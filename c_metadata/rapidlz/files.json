{
    "src/rapidlz.c": {
        "includes": [],
        "macros": [
            "#define RAPIDLZ_STREAM_HASH_SIZE (1 << 12)",
            "#define RAPIDLZ_MAX_BYTE_VALUE 255",
            "#define RAPIDLZ_MAX_4BIT_VALUE 15",
            "#define RAPIDLZ_MIN_MATCH 4",
            "#define RAPIDLZ_HASH_TYPE_4 4",
            "#define RAPIDLZ_HASH_TYPE_5 5",
            "#define RAPIDLZ_STEP_FORWARD_BASE 6",
            "#define RAPIDLZ_MAX_OFFSET 65535",
            "#define RAPIDLZ_EIGHT_BYTE 8",
            "#define RAPIDLZ_SIXTEEN_BYTE 16",
            "#define RAPIDLZ_COPY_PROTECT_SIZE 16",
            "#define RAPIDLZ_INPUT_INVALID (size_t)(-100)",
            "#define RAPIDLZ_MALLOC_FAILED (size_t)(-99)",
            "#define RAPIDLZ_DST_SIZE_SMALL (size_t)(-98)",
            "#define RAPIDLZ_SECUREC_ERROR (size_t)(-97)",
            "#define RAPIDLZ_FORMAT_INVALID (size_t)(-96)",
            "#define LOG_BUF_SIZE 1024",
            "#define RAPIDLZFILENAME (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)",
            "#define RAPIDLZ_MAX_INPUT_SIZE 0x7E000000U",
            "#define RAPIDLZ_MAX_4BIT_MATCH 19",
            "#define RAPIDLZ_ACCELERATION_MAX 10",
            "#define RAPIDLZ_SRC_SIZE_THRESHOLD 65536",
            "#define RAPIDLZ_LAST_LITERALS 6",
            "#define RAPIDLZ_MIN_COMPRESS_SIZE 16",
            "#define RAPIDLZ_MIN_HASH_BIT 6",
            "#define RAPIDLZ_MAX_HASH_BIT 12"
        ],
        "macro_functions": [
            "#define RAPIDLZ_LOG(error_code, fmt, ...)                                                                              \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        RapidlzLogWrite((size_t)(error_code), RAPIDLZFILENAME, __LINE__, fmt, __VA_ARGS__);                            \\\n    } while (0)",
            "#define RAPIDLZ_LIKELY(x) (__builtin_expect(!!(x), 1))",
            "#define RAPIDLZ_UNLIKELY(x) (__builtin_expect(!!(x), 0))",
            "#define RAPIDLZ_READ16BIT(ptr) (((const RapidlzUnalignU16 *)(ptr))->v)",
            "#define RAPIDLZ_READ32BIT(ptr) (((const RapidlzUnalignU32 *)(ptr))->v)",
            "#define RAPIDLZ_READ64BIT(ptr) (((const RapidlzUnalignU64 *)(ptr))->v)",
            "#define RAPIDLZ_WRITE64BIT(ptr, val) (((RapidlzUnalignU64 *)(ptr))->v = (val))",
            "#define RAPIDLZ_ASSERT(x) assert(x)",
            "#define RAPIDLZ_EXPAND_FORWARD(srcBegin, matchBegin, srcCurr, srcAnchor)                                               \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        while ((srcBegin) < (matchBegin) && (srcCurr) > (srcAnchor) &&                                                 \\\n               RAPIDLZ_UNLIKELY((matchBegin)[-1] == (srcCurr)[-1]))                                                    \\\n        {                                                                                                              \\\n            (matchBegin)--;                                                                                            \\\n            (srcCurr)--;                                                                                               \\\n        }                                                                                                              \\\n    } while (0)",
            "#define RAPIDLZ_READ_OPTIONAL_LENGTH(len, srcCurr, srcEnd, temp)                                                       \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if (RAPIDLZ_LIKELY((srcCurr) < (srcEnd)))                                                                      \\\n        {                                                                                                              \\\n            (temp) = *(srcCurr)++;                                                                                     \\\n            (len) += (temp);                                                                                           \\\n        }                                                                                                              \\\n        while (((temp) == RAPIDLZ_MAX_BYTE_VALUE) && (srcCurr) < (srcEnd))                                             \\\n        {                                                                                                              \\\n            (temp) = *(srcCurr)++;                                                                                     \\\n            (len) += (temp);                                                                                           \\\n        }                                                                                                              \\\n    } while (0)",
            "#define SAFE_COPY_MATCH(dstCurr, matchSrc, matchLength)                                                                \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        while ((matchLength)-- > 0)                                                                                    \\\n        {                                                                                                              \\\n            *(dstCurr)++ = *(matchSrc)++;                                                                              \\\n        }                                                                                                              \\\n    } while (0)",
            "#define RAPIDLZ_COMPRESSBOUND(size) ((uint32_t)(size) > RAPIDLZ_MAX_INPUT_SIZE ? 0 : (size) + ((size) / 255) + 16)"
        ],
        "types": {
            "": [],
            "RapidlzLogFunc": "typedef void (*RapidlzLogFunc)(const char *message, size_t size);",
            "RapidlzStreamCtx": "typedef struct TagRapidlzStreamCtx RapidlzStreamCtx;",
            "TagRapidlzStreamCtx": "struct TagRapidlzStreamCtx\n{\n    uint32_t hashTable[RAPIDLZ_STREAM_HASH_SIZE];\n    const uint8_t *dict;\n    uint32_t dictSize;\n    uint32_t currentOffset;\n    int acceleration;\n    RapidlzStreamCtx *strmCtxSpecific;\n};",
            "RapidlzUnalignU16": "typedef struct\n{\n    uint16_t v;\n} __attribute__((packed)) RapidlzUnalignU16;",
            "RapidlzUnalignU32": "typedef struct\n{\n    uint32_t v;\n} __attribute__((packed)) RapidlzUnalignU32;",
            "RapidlzUnalignU64": "typedef struct\n{\n    uint64_t v;\n} __attribute__((packed)) RapidlzUnalignU64;",
            "RapidlzCCtx": "typedef struct\n{\n    uint8_t *hashTable;\n    uint8_t hashType;\n    uint8_t hashBits;\n    uint8_t step;\n    uint8_t bufferLimit;\n} RapidlzCCtx;"
        },
        "global_variables": {
            "g_overlapOffAddVal": "static uint8_t g_overlapOffAddVal[] = {0, 1, 2, 2, 4, 3, 2, 1};",
            "g_rapidlzLogFunc": "static RapidlzLogFunc g_rapidlzLogFunc = NULL;",
            "g_rapidlzVersion": "static const char *g_rapidlzVersion = \"rapidlz 3.24.10.B201\";"
        },
        "declarations": [
            "TagRapidlzStreamCtx"
        ],
        "functions": {
            "RapidlzIsLE": "static int RapidlzIsLE(void)\n{\n    int n = 1;\n    return *(char *)(&n);\n}",
            "RapidlzReadLE16Bit": "static uint16_t RapidlzReadLE16Bit(const void *addr)\n{\n    if (RapidlzIsLE() != 0)\n    {\n        return *(const uint16_t *)addr;\n    }\n    uint8_t tmp1 = ((const uint8_t *)addr)[0];\n    uint8_t tmp2 = ((const uint8_t *)addr)[1];\n    return (uint16_t)(tmp1 + (tmp2 << 8));\n}",
            "RapidlzCountTailZero64": "static uint8_t RapidlzCountTailZero64(uint64_t x)\n{\n    if (x == 0)\n    {\n        return 0;\n    }\n    uint64_t val = x;\n    uint8_t num = 0;\n    while ((val & 1) == 0)\n    {\n        val >>= 1;\n        num++;\n    }\n    return num;\n}",
            "RapidlzCountLeadZero64": "static uint8_t RapidlzCountLeadZero64(uint64_t x)\n{\n    if (x == 0)\n    {\n        return 0;\n    }\n    uint8_t num = 0;\n    uint64_t val = x;\n    while ((val & 0x8000000000000000ULL) == 0)\n    {\n        val <<= 1;\n        num++;\n    }\n    return num;\n}",
            "RapidlzHighBit64": "static uint8_t RapidlzHighBit64(uint64_t x)\n{\n    RAPIDLZ_ASSERT(x != 0);\n    uint8_t pos = 64;\n    uint64_t value = x;\n    if (value == 0)\n    {\n        return 0;\n    }\n    if ((value & 0xFFFFFFFF00000000) == 0)\n    {\n        value <<= 32;\n        pos -= 32;\n    }\n    if ((value & 0xFFFF000000000000) == 0)\n    {\n        value <<= 16;\n        pos -= 16;\n    }\n    if ((value & 0xFF00000000000000) == 0)\n    {\n        value <<= 8;\n        pos -= 8;\n    }\n    if ((value & 0xF000000000000000) == 0)\n    {\n        value <<= 4;\n        pos -= 4;\n    }\n    if ((value & 0xC000000000000000) == 0)\n    {\n        value <<= 2;\n        pos -= 2;\n    }\n    if ((value & 0x8000000000000000) == 0)\n    {\n        value <<= 1;\n        pos -= 1;\n    }\n    return pos - 1;\n}",
            "RapidlzWriteLE16": "static void RapidlzWriteLE16(void *addr, uint16_t val)\n{\n    if (RapidlzIsLE() != 0)\n    {\n        *(uint16_t *)addr = val;\n    }\n    else\n    {\n        uint8_t *tmp = (uint8_t *)addr;\n        tmp[0] = (uint8_t)val;\n        tmp[1] = (uint8_t)(val >> 8);\n    }\n}",
            "RapidlzCopy16Byte": "static void RapidlzCopy16Byte(void *dst, const void *src)\n{\n    RAPIDLZ_WRITE64BIT(dst, RAPIDLZ_READ64BIT(src));\n    RAPIDLZ_WRITE64BIT((uint8_t *)dst + 8, RAPIDLZ_READ64BIT((uint8_t *)src + 8));\n}",
            "RapidlzCopy8Byte": "static void RapidlzCopy8Byte(void *dst, const void *src)\n{\n    RAPIDLZ_WRITE64BIT(dst, RAPIDLZ_READ64BIT(src));\n}",
            "RapidlzWildCopy16": "static void RapidlzWildCopy16(const uint8_t *srcPtr, uint8_t *dstPtr, uint8_t *dstEnd)\n{\n    uint8_t *tmpDstPtr = dstPtr;\n    const uint8_t *tmpSrcPtr = srcPtr;\n    do\n    {\n        RapidlzCopy16Byte(tmpDstPtr, tmpSrcPtr);\n        tmpDstPtr += 16;\n        tmpSrcPtr += 16;\n    } while (tmpDstPtr < dstEnd);\n}",
            "RapidlzCopyLiteralsFast": "static void RapidlzCopyLiteralsFast(const uint8_t *src, uint8_t *dst, uint32_t length)\n{\n    if (RAPIDLZ_LIKELY(length <= RAPIDLZ_SIXTEEN_BYTE))\n    {\n        RapidlzCopy16Byte(dst, src);\n        return;\n    }\n    RapidlzWildCopy16(src, dst, dst + length);\n}",
            "RapidlzCompressExpandBackward": "static const uint8_t *RapidlzCompressExpandBackward(const uint8_t *matchLimit, const uint8_t *matchPtr,\n                                                    const uint8_t *srcCurr)\n{\n    uint64_t xorVal;\n    const uint8_t *loopEnd = matchLimit - 7;\n    const uint8_t *srcCurrMatchEnd = srcCurr;\n    const uint8_t *matchBegin = matchPtr;\n    while (srcCurrMatchEnd < loopEnd)\n    {\n        xorVal = RAPIDLZ_READ64BIT(matchBegin) ^ RAPIDLZ_READ64BIT(srcCurrMatchEnd);\n        if (RAPIDLZ_UNLIKELY(xorVal == 0))\n        {\n            srcCurrMatchEnd += sizeof(uint64_t);\n            matchBegin += sizeof(uint64_t);\n            continue;\n        }\n        srcCurrMatchEnd +=\n            RapidlzIsLE() ? (RapidlzCountTailZero64(xorVal) >> 3) : (RapidlzCountLeadZero64(xorVal) >> 3);\n        return srcCurrMatchEnd;\n    }\n    if (((srcCurrMatchEnd + 3) < matchLimit) && (RAPIDLZ_READ32BIT(srcCurrMatchEnd) == RAPIDLZ_READ32BIT(matchBegin)))\n    {\n        srcCurrMatchEnd += sizeof(uint32_t);\n        matchBegin += sizeof(uint32_t);\n    }\n    if (((srcCurrMatchEnd + 1) < matchLimit) && (RAPIDLZ_READ16BIT(srcCurrMatchEnd) == RAPIDLZ_READ16BIT(matchBegin)))\n    {\n        srcCurrMatchEnd += sizeof(uint16_t);\n        matchBegin += sizeof(uint16_t);\n    }\n    if ((srcCurrMatchEnd < matchLimit) && (srcCurrMatchEnd[0] == matchBegin[0]))\n    {\n        srcCurrMatchEnd++;\n    }\n    return srcCurrMatchEnd;\n}",
            "RapidlzCopyMatchFast": "static void RapidlzCopyMatchFast(uint8_t *dst, uint8_t *match, uint16_t offset, uint32_t length)\n{\n    uint8_t *dstCurr = dst;\n    uint8_t *matchPtr = match;\n    if (offset >= RAPIDLZ_SIXTEEN_BYTE)\n    {\n        RapidlzCopyLiteralsFast(matchPtr, dstCurr, length);\n        return;\n    }\n    for (int i = 0; i < RAPIDLZ_EIGHT_BYTE; ++i)\n    {\n        dstCurr[i] = matchPtr[i];\n    }\n    if (length <= RAPIDLZ_EIGHT_BYTE)\n    {\n        return;\n    }\n    uint8_t *dstEnd = dstCurr + length;\n    if (offset < RAPIDLZ_EIGHT_BYTE)\n    {\n        matchPtr += g_overlapOffAddVal[offset];\n        dstCurr += RAPIDLZ_EIGHT_BYTE;\n    }\n    do\n    {\n        RapidlzCopy8Byte(dstCurr, matchPtr);\n        dstCurr += RAPIDLZ_EIGHT_BYTE;\n        matchPtr += RAPIDLZ_EIGHT_BYTE;\n    } while (dstCurr < dstEnd);\n}",
            "RapidlzLogWrite": "void RapidlzLogWrite(size_t error_code, const char *file_name, unsigned short line, const char *fmt, ...)\n{\n    va_list alist;\n    char output[LOG_BUF_SIZE];\n    int retVal, len;\n    RapidlzLogFunc func = g_rapidlzLogFunc;\n    char *filename;\n    if (func == NULL)\n    {\n        return;\n    }\n    filename = strdup(file_name);\n    if (filename == NULL)\n    {\n        return;\n    }\n    retVal = snprintf_s(output, LOG_BUF_SIZE, LOG_BUF_SIZE - 1, \"\\n[Rapidlz-Log] File=%s, Line=%u, Error=%zu\\n\",\n                        basename(filename), line, error_code);\n    if (retVal < 0)\n    {\n        free(filename);\n        return;\n    }\n    len = retVal;\n    free(filename);\n    va_start(alist, fmt);\n    retVal = vsnprintf_s(output + len, LOG_BUF_SIZE - len, LOG_BUF_SIZE - len - 1, fmt, alist);\n    va_end(alist);\n    if (retVal < 0)\n    {\n        return;\n    }\n    func(output, strlen(output) + 1);\n}",
            "RapidlzLogRegister": "void RapidlzLogRegister(RapidlzLogFunc func)\n{\n    g_rapidlzLogFunc = func;\n}",
            "RapidlzVersionGet": "const char *RapidlzVersionGet(void)\n{\n    return g_rapidlzVersion;\n}",
            "RapidlzCompressBound": "size_t RapidlzCompressBound(size_t srcSize)\n{\n    return RAPIDLZ_COMPRESSBOUND(srcSize);\n}",
            "RapidlzPutPosOnTable": "static void RapidlzPutPosOnTable(uint32_t pos, uint32_t hashValue, uint8_t *hashTable, uint8_t hashType)\n{\n    if (hashType == 4)\n    {\n        *(((uint16_t *)hashTable) + hashValue) = (uint16_t)pos;\n    }\n    else if (hashType == 5)\n    {\n        *(((uint32_t *)hashTable) + hashValue) = (uint32_t)pos;\n    }\n}",
            "RapidlzGetPosOnTable": "static uint32_t RapidlzGetPosOnTable(uint32_t hashValue, uint8_t *hashTable, uint8_t hashType)\n{\n    if (hashType == 4)\n    {\n        return (uint32_t)(*(((uint16_t *)hashTable) + hashValue));\n    }\n    else if (hashType == 5)\n    {\n        return (*(((uint32_t *)hashTable) + hashValue));\n    }\n    return 0;\n}",
            "RapidlzCalcHashValue": "static uint32_t RapidlzCalcHashValue(const uint8_t *srcCurr, uint8_t hashType, uint8_t hashBits)\n{\n    if (hashType == 5)\n    {\n        return (uint32_t)((((RAPIDLZ_READ64BIT(srcCurr)) << 24) * 11400714819323198485ULL) >> (64 - hashBits));\n    }\n    else\n    {\n        return (RAPIDLZ_READ32BIT(srcCurr) * 2654435769U) >> (32 - hashBits);\n    }\n}",
            "RapidlzCompressStoreOptionalLength": "static uint8_t *RapidlzCompressStoreOptionalLength(uint8_t *dst, uint32_t litLength)\n{\n    uint8_t *dstCurr = dst;\n    uint32_t length = litLength;\n    if (length < RAPIDLZ_MAX_BYTE_VALUE)\n    {\n        *dstCurr = (uint8_t)length;\n        dstCurr++;\n        return dstCurr;\n    }\n    do\n    {\n        *dstCurr = RAPIDLZ_MAX_BYTE_VALUE;\n        dstCurr++;\n        length -= RAPIDLZ_MAX_BYTE_VALUE;\n    } while (length >= RAPIDLZ_MAX_BYTE_VALUE);\n    *dstCurr = (uint8_t)length;\n    dstCurr++;\n    return dstCurr;\n}",
            "RapidlzStoreLastLiterals": "static uint8_t *RapidlzStoreLastLiterals(uint8_t *dst, uint8_t *dstEnd, const uint8_t *srcCurr, uint32_t litLength,\n                                         uint8_t bufferLimit)\n{\n    uint8_t *dstCurr = dst;\n    if (bufferLimit != 0)\n    {\n        const uint32_t litTokSize = 1 + litLength + (litLength / RAPIDLZ_MAX_BYTE_VALUE);\n        if (dstCurr + litTokSize > dstEnd)\n        {\n            RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCur:%zu litTokSize:%u\\n\", dstEnd - dstCurr, litTokSize);\n            return NULL;\n        }\n    }\n    uint8_t token = (uint8_t)(((litLength < RAPIDLZ_MAX_4BIT_VALUE) ? (litLength) : (RAPIDLZ_MAX_4BIT_VALUE)) << 4);\n    *dstCurr = token;\n    dstCurr++;\n    if (litLength >= RAPIDLZ_MAX_4BIT_VALUE)\n    {\n        dstCurr = RapidlzCompressStoreOptionalLength(dstCurr, litLength - RAPIDLZ_MAX_4BIT_VALUE);\n    }\n    if (memcpy_s(dstCurr, dstEnd - dstCurr, srcCurr, litLength) != EOK)\n    {\n        RAPIDLZ_LOG(RAPIDLZ_SECUREC_ERROR, \"dstEnd - dstCurr:%zu litLength%u\\n\", dstEnd - dstCurr, litLength);\n        return NULL;\n    }\n    return dstCurr + litLength;\n}",
            "RapidlzStoreOffMatch": "static uint8_t *RapidlzStoreOffMatch(uint8_t *dst, uint8_t *token, uint32_t matchLength, uint16_t offset)\n{\n    uint8_t *dstCurr = dst;\n    RapidlzWriteLE16(dstCurr, offset);\n    dstCurr += 2;\n    if (matchLength >= RAPIDLZ_MAX_4BIT_VALUE)\n    {\n        uint32_t optionalLen = matchLength - RAPIDLZ_MAX_4BIT_VALUE;\n        *token += RAPIDLZ_MAX_4BIT_VALUE;\n        for (; optionalLen >= RAPIDLZ_MAX_BYTE_VALUE; optionalLen -= RAPIDLZ_MAX_BYTE_VALUE)\n        {\n            *dstCurr++ = RAPIDLZ_MAX_BYTE_VALUE;\n        }\n        *dstCurr++ = (uint8_t)optionalLen;\n    }\n    else\n    {\n        *token += (uint8_t)matchLength;\n    }\n    return dstCurr;\n}",
            "RapidlzStoreSequence": "static uint8_t *RapidlzStoreSequence(uint8_t *dst, const uint8_t *srcAnchor, uint32_t literalLength,\n                                     uint32_t matchLength, uint16_t offset)\n{\n    uint8_t *dstCurr = dst;\n    uint8_t *token = dstCurr++;\n    if (literalLength >= RAPIDLZ_MAX_4BIT_VALUE)\n    {\n        *token = (RAPIDLZ_MAX_4BIT_VALUE << 4);\n        uint32_t optionalLen = literalLength - RAPIDLZ_MAX_4BIT_VALUE;\n        for (; optionalLen >= RAPIDLZ_MAX_BYTE_VALUE; optionalLen -= RAPIDLZ_MAX_BYTE_VALUE)\n        {\n            *dstCurr++ = (uint8_t)RAPIDLZ_MAX_BYTE_VALUE;\n        }\n        *dstCurr++ = (uint8_t)optionalLen;\n        RapidlzCopy16Byte(dstCurr, srcAnchor);\n        if (literalLength > 16)\n        {\n            RapidlzWildCopy16(srcAnchor + 16, dstCurr + 16, dstCurr + literalLength);\n        }\n        dstCurr += literalLength;\n    }\n    else if (literalLength > 0)\n    {\n        *token = (uint8_t)(literalLength << 4);\n        RapidlzCopy16Byte(dstCurr, srcAnchor);\n        dstCurr += literalLength;\n    }\n    else\n    {\n        *token = 0;\n    }\n    return RapidlzStoreOffMatch(dstCurr, token, matchLength, offset);\n}",
            "RapidlzCompressProcess": "static size_t RapidlzCompressProcess(void *dst, size_t dstSize, const void *src, size_t srcSize, RapidlzCCtx *cCtx)\n{\n    uint32_t hashValue, matchLength, literalLength;\n    uint32_t step = 1;\n    uint16_t offset;\n    uint8_t *hashTable = cCtx->hashTable;\n    const uint8_t *srcBegin = (const uint8_t *)src;\n    const uint8_t *srcEnd = (const uint8_t *)src + srcSize;\n    const uint8_t *srcCurr = srcBegin + 1;\n    const uint8_t *srcCurrMatchEnd;\n    const uint8_t *srcAnchor = srcBegin;\n    const uint8_t *matchBegin;\n    const uint8_t *matchLimit = srcEnd - RAPIDLZ_LAST_LITERALS;\n    const uint8_t *srcLimit = srcEnd - RAPIDLZ_MIN_COMPRESS_SIZE;\n    uint8_t *dstBegin = (uint8_t *)dst;\n    uint8_t *dstEnd = (uint8_t *)dst + dstSize;\n    uint8_t *dstCurr = dstBegin;\n    uint8_t hashType = cCtx->hashType;\n    uint8_t hashBits = cCtx->hashBits;\n    uint32_t searchMatchNb = cCtx->step << RAPIDLZ_STEP_FORWARD_BASE;\n    uint32_t searchMatchNbTmp = searchMatchNb;\n    uint8_t bufferLimit = cCtx->bufferLimit;\n    while (RAPIDLZ_LIKELY(srcCurr <= srcLimit))\n    {\n        for (;;)\n        {\n            hashValue = RapidlzCalcHashValue(srcCurr, hashType, hashBits);\n            matchBegin = srcBegin + RapidlzGetPosOnTable(hashValue, hashTable, hashType);\n            RapidlzPutPosOnTable(srcCurr - srcBegin, hashValue, hashTable, hashType);\n            if ((RAPIDLZ_READ32BIT(srcCurr) == RAPIDLZ_READ32BIT(matchBegin)) &&\n                RAPIDLZ_LIKELY((srcCurr - matchBegin) <= RAPIDLZ_MAX_OFFSET))\n            {\n                break;\n            }\n            srcCurr += step;\n            step = (searchMatchNbTmp++ >> RAPIDLZ_STEP_FORWARD_BASE);\n            if (srcCurr > srcLimit)\n            {\n                dstCurr = RapidlzStoreLastLiterals(dstCurr, dstEnd, srcAnchor, srcEnd - srcAnchor, bufferLimit);\n                if (dstCurr == NULL)\n                {\n                    return 0;\n                }\n                return dstCurr - dstBegin;\n            }\n        }\n        step = 1;\n        searchMatchNbTmp = searchMatchNb;\n        srcCurrMatchEnd =\n            RapidlzCompressExpandBackward(matchLimit, matchBegin + RAPIDLZ_MIN_MATCH, srcCurr + RAPIDLZ_MIN_MATCH);\n        RAPIDLZ_EXPAND_FORWARD(srcBegin, matchBegin, srcCurr, srcAnchor);\n        matchLength = srcCurrMatchEnd - srcCurr - RAPIDLZ_MIN_MATCH;\n        offset = (uint16_t)(srcCurr - matchBegin);\n        literalLength = srcCurr - srcAnchor;\n        if (bufferLimit != 0)\n        {\n            uint32_t writeSize = literalLength + 8 + (literalLength + matchLength / RAPIDLZ_MAX_BYTE_VALUE);\n            if (RAPIDLZ_UNLIKELY(dstCurr + writeSize > dstEnd))\n            {\n                RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCur:%zu writeSize:%u\\n\", dstEnd - dstCurr, writeSize);\n                return 0;\n            }\n        }\n        dstCurr = RapidlzStoreSequence(dstCurr, srcAnchor, literalLength, matchLength, offset);\n        srcCurr = srcCurrMatchEnd;\n        srcAnchor = srcCurr;\n        hashValue = RapidlzCalcHashValue(srcCurr - 2, hashType, hashBits);\n        RapidlzPutPosOnTable(srcCurr - 2 - srcBegin, hashValue, hashTable, hashType);\n        if (RAPIDLZ_UNLIKELY(srcCurr > srcLimit))\n        {\n            break;\n        }\n        hashValue = RapidlzCalcHashValue(srcCurr, hashType, hashBits);\n        matchBegin = srcBegin + RapidlzGetPosOnTable(hashValue, hashTable, hashType);\n        RapidlzPutPosOnTable(srcCurr - srcBegin, hashValue, hashTable, hashType);\n        if ((RAPIDLZ_READ32BIT(srcCurr) != RAPIDLZ_READ32BIT(matchBegin)) ||\n            RAPIDLZ_UNLIKELY((srcCurr - matchBegin) > RAPIDLZ_MAX_OFFSET))\n        {\n            srcCurr++;\n            continue;\n        }\n        srcCurrMatchEnd =\n            RapidlzCompressExpandBackward(matchLimit, matchBegin + RAPIDLZ_MIN_MATCH, srcCurr + RAPIDLZ_MIN_MATCH);\n        matchLength = srcCurrMatchEnd - srcCurr - RAPIDLZ_MIN_MATCH;\n        offset = (uint16_t)(srcCurr - matchBegin);\n        if (bufferLimit != 0)\n        {\n            const uint32_t writeSize = 8 + matchLength / RAPIDLZ_MAX_BYTE_VALUE;\n            if (RAPIDLZ_UNLIKELY(dstCurr + writeSize > dstEnd))\n            {\n                RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCur:%zu writeSize:%u\\n\", dstEnd - dstCurr, writeSize);\n                return 0;\n            }\n        }\n        *dstCurr = 0;\n        dstCurr = RapidlzStoreOffMatch(dstCurr + 1, dstCurr, matchLength, offset);\n        srcCurr = srcCurrMatchEnd;\n        srcAnchor = srcCurr;\n        hashValue = RapidlzCalcHashValue(srcCurr - 2, hashType, hashBits);\n        RapidlzPutPosOnTable(srcCurr - 2 - srcBegin, hashValue, hashTable, hashType);\n    }\n    if (srcAnchor < srcEnd)\n    {\n        dstCurr = RapidlzStoreLastLiterals(dstCurr, dstEnd, srcAnchor, srcEnd - srcAnchor, bufferLimit);\n        if (dstCurr == NULL)\n        {\n            return 0;\n        }\n    }\n    return dstCurr - dstBegin;\n}",
            "RapidlzCCtxFree": "static void RapidlzCCtxFree(RapidlzCCtx *cCtx)\n{\n    if (cCtx != NULL)\n    {\n        if (cCtx->hashTable != NULL)\n        {\n            free(cCtx->hashTable);\n            cCtx->hashTable = NULL;\n        }\n        free(cCtx);\n    }\n}",
            "RapidlzCompress": "size_t RapidlzCompress(const void *src, void *dst, size_t srcSize, size_t dstSize, int acceleration)\n{\n    if (src == NULL || dst == NULL || srcSize == 0 || dstSize == 0)\n    {\n        RAPIDLZ_LOG(RAPIDLZ_INPUT_INVALID, \"input invalid\\n\");\n        return 0;\n    }\n    if (acceleration < 1 || acceleration > RAPIDLZ_ACCELERATION_MAX)\n    {\n        RAPIDLZ_LOG(RAPIDLZ_INPUT_INVALID, \"acceleration:%d\\n\", acceleration);\n        return 0;\n    }\n    RapidlzCCtx *cCtx = (RapidlzCCtx *)malloc(sizeof(RapidlzCCtx));\n    if (cCtx == NULL)\n    {\n        RAPIDLZ_LOG(RAPIDLZ_MALLOC_FAILED, \"cCtx malloc failed\\n\");\n        return 0;\n    }\n    cCtx->hashBits = RAPIDLZ_MIN_HASH_BIT;\n    size_t totalHashSize;\n    if (srcSize <= RAPIDLZ_SRC_SIZE_THRESHOLD)\n    {\n        cCtx->hashType = RAPIDLZ_HASH_TYPE_4;\n        if (srcSize >= 64)\n        {\n            cCtx->hashBits = (RapidlzHighBit64(srcSize) > RAPIDLZ_MAX_HASH_BIT) ? (RAPIDLZ_MAX_HASH_BIT + 1)\n                                                                                : RapidlzHighBit64(srcSize);\n        }\n        totalHashSize = sizeof(uint16_t) * (uint32_t)(1 << cCtx->hashBits);\n    }\n    else\n    {\n        cCtx->hashType = RAPIDLZ_HASH_TYPE_5;\n        cCtx->hashBits = RAPIDLZ_MAX_HASH_BIT;\n        totalHashSize = sizeof(uint32_t) * (uint32_t)(1 << cCtx->hashBits);\n    }\n    uint8_t *table = (uint8_t *)malloc(totalHashSize);\n    if (table == NULL)\n    {\n        RAPIDLZ_LOG(RAPIDLZ_MALLOC_FAILED, \"hash table malloc failed\\n\");\n        free(cCtx);\n        return 0;\n    }\n    (void)memset_s(table, totalHashSize, 0, totalHashSize);\n    cCtx->hashTable = table;\n    cCtx->step = (uint8_t)acceleration;\n    cCtx->bufferLimit = dstSize < RapidlzCompressBound(srcSize);\n    size_t cSize = RapidlzCompressProcess(dst, dstSize, src, srcSize, cCtx);\n    RapidlzCCtxFree(cCtx);\n    return cSize;\n}",
            "RapidlzCompressDefault": "size_t RapidlzCompressDefault(const void *src, void *dst, size_t srcSize, size_t dstSize)\n{\n    return RapidlzCompress(src, dst, srcSize, dstSize, 1);\n}",
            "RapidlzDecompress": "size_t RapidlzDecompress(const void *src, void *dst, size_t srcSize, size_t dstSize)\n{\n    if (src == NULL || dst == NULL || srcSize == 0 || dstSize == 0)\n    {\n        RAPIDLZ_LOG(RAPIDLZ_INPUT_INVALID, \"input invalid\\n\");\n        return 0;\n    }\n    uint8_t token, temp = 0;\n    register uint16_t offset;\n    register uint32_t litLen, matchLen;\n    uint8_t *matchSrc;\n    const uint8_t *srcEnd = (const uint8_t *)src + srcSize;\n    const uint8_t *srcCurr = (const uint8_t *)src;\n    const uint8_t *srcEndFast = srcEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n    uint8_t *dstEnd = (uint8_t *)dst + dstSize;\n    uint8_t *dstCurr = (uint8_t *)dst;\n    uint8_t *dstEndFast = dstEnd - RAPIDLZ_COPY_PROTECT_SIZE;\n    while (srcCurr < srcEnd)\n    {\n        token = *srcCurr++;\n        litLen = (token >> 4);\n        if (RAPIDLZ_LIKELY(litLen < RAPIDLZ_MAX_4BIT_VALUE))\n        {\n            if (RAPIDLZ_LIKELY(srcCurr + litLen <= srcEndFast && dstCurr + litLen <= dstEndFast))\n            {\n                RapidlzCopy16Byte(dstCurr, srcCurr);\n                dstCurr += litLen;\n                srcCurr += litLen;\n                goto READ_MATCH;\n            }\n        }\n        else\n        {\n            RAPIDLZ_READ_OPTIONAL_LENGTH(litLen, srcCurr, srcEnd, temp);\n            if (RAPIDLZ_LIKELY(srcCurr + litLen <= srcEndFast && dstCurr + litLen <= dstEndFast))\n            {\n                RapidlzWildCopy16(srcCurr, dstCurr, dstCurr + litLen);\n                dstCurr += litLen;\n                srcCurr += litLen;\n                goto READ_MATCH;\n            }\n        }\n        size_t leftSrcSize = srcEnd - srcCurr;\n        if (RAPIDLZ_UNLIKELY(litLen > leftSrcSize || memmove_s(dstCurr, dstEnd - dstCurr, srcCurr, litLen) != EOK))\n        {\n            RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"litLen:%u dstEnd - dst:%zu\\n\", litLen, leftSrcSize);\n            return 0;\n        }\n        dstCurr += litLen;\n        srcCurr += litLen;\n        if (leftSrcSize == litLen)\n        {\n            return dstCurr - (uint8_t *)(dst);\n        }\n    READ_MATCH:\n        if (RAPIDLZ_UNLIKELY(srcCurr > srcEnd - 2))\n        {\n            RAPIDLZ_LOG(RAPIDLZ_FORMAT_INVALID, \"rapidlz format invalid\\n\");\n            return 0;\n        }\n        offset = RapidlzReadLE16Bit(srcCurr);\n        srcCurr += 2;\n        matchSrc = dstCurr - offset;\n        if (RAPIDLZ_UNLIKELY((void *)matchSrc < dst))\n        {\n            RAPIDLZ_LOG(RAPIDLZ_FORMAT_INVALID, \"rapidlz format invalid\\n\");\n            return 0;\n        }\n        matchLen = (token & RAPIDLZ_MAX_4BIT_VALUE) + RAPIDLZ_MIN_MATCH;\n        if (matchLen == RAPIDLZ_MAX_4BIT_MATCH)\n        {\n            RAPIDLZ_READ_OPTIONAL_LENGTH(matchLen, srcCurr, srcEnd, temp);\n        }\n        if (RAPIDLZ_LIKELY(dstCurr + matchLen <= dstEndFast))\n        {\n            RapidlzCopyMatchFast(dstCurr, matchSrc, offset, matchLen);\n            dstCurr += matchLen;\n        }\n        else\n        {\n            if (dstCurr + matchLen > dstEnd)\n            {\n                RAPIDLZ_LOG(RAPIDLZ_DST_SIZE_SMALL, \"dstEnd - dstCurr:%zu matchLen:%u\\n\", dstEnd - dstCurr, matchLen);\n                return 0;\n            }\n            SAFE_COPY_MATCH(dstCurr, matchSrc, matchLen);\n        }\n    }\n    return dstCurr - (uint8_t *)dst;\n}"
        }
    }
}