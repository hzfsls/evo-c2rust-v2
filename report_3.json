{
    "macro": {
        "all_cnt": 85,
        "passed_cnt": 85,
        "pass_rate": 1.0,
        "messages": []
    },
    "macro_function": {
        "all_cnt": 7,
        "passed_cnt": 7,
        "pass_rate": 1.0,
        "messages": []
    },
    "definition": {
        "all_cnt": 15,
        "passed_cnt": 15,
        "pass_rate": 1.0,
        "messages": []
    },
    "dummy_function": {
        "all_cnt": 92,
        "passed_cnt": 92,
        "pass_rate": 1.0,
        "messages": []
    },
    "function": {
        "all_cnt": 92,
        "passed_cnt": 84,
        "pass_rate": 0.9130434782608695,
        "messages": [
            {
                "c_code": "void BzpHeapInit(BzpHuffmanInfo *huffman)\n    {\n        int32_t i = 0;\n        for (i = 0; i < huffman->alphaSize; i++)\n        {\n            huffman->nHeap++;\n            huffman->heap[huffman->nHeap] = i;\n            BzpHeapAdjustUp(huffman->heap, huffman->weight, huffman->nHeap);\n        }\n    }",
                "original_rust_code": "pub fn BzpHeapInit(mut huffman: Ptr<BzpHuffmanInfo>) {\n    let mut i: i32 = 0;\n    c_for!(i = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        huffman.nHeap += 1;\n        let tmp0 = huffman.nHeap;\n        huffman.heap[tmp0] = i;\n        BzpHeapAdjustUp(huffman.heap, huffman.weight.cast(), huffman.nHeap);\n    });\n}\n",
                "optimized_rust_code": "pub fn BzpHeapInit(mut huffman: Ptr<BzpHuffmanInfo>) {\n    let mut i: i32 = 0;\n    c_for!(i = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        huffman.nHeap += 1;\n        let tmp0 = huffman.nHeap;\n        huffman.heap[tmp0] = i;\n        BzpHeapAdjustUp(huffman.heap.as_ptr(), huffman.weight.cast(), huffman.nHeap);\n    });\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007357323)\nerror[E0308]: mismatched types\n  --> src/src/compress/bzp_huffman_encode_c.rs:63:25\n   |\n63 |         BzpHeapAdjustUp(huffman.heap, huffman.weight.cast(), huffman.nHeap);\n   |         --------------- ^^^^^^^^^^^^ expected `Ptr<i32>`, found `Array<i32, 259>`\n   |         |\n   |         arguments to this function are incorrect\n   |\n   = note: expected struct `memory::ptr::Ptr<i32>`\n              found struct `types::array::Array<i32, 259>`\nnote: function defined here\n  --> src/src/compress/bzp_huffman_encode_c.rs:22:8\n   |\n22 | pub fn BzpHeapAdjustUp(mut heap: Ptr<i32>, mut weight: Ptr<i32>, mut pos: i32) {\n   |        ^^^^^^^^^^^^^^^ ------------------\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007405869)\nerror[E0599]: no method named `as_ptr` found for struct `types::array::Array` in the current scope\n  --> src/src/compress/bzp_huffman_encode_c.rs:63:38\n   |\n63 |         BzpHeapAdjustUp(huffman.heap.as_ptr(), huffman.weight.cast(), huffman.nHeap);\n   |                                      ^^^^^^ method not found in `Array<i32, 259>`\n   |\n  ::: src/translation_utils/types/array.rs:5:1\n   |\n5  | pub struct Array<T, const N: usize>(pub [T; N]);\n   | ----------------------------------- method `as_ptr` not found for this struct\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void BzpBuildHuffmanTree(BzpHuffmanInfo *huffman)\n    {\n        BzpHuffmanInitArray(huffman);\n        BzpHeapInit(huffman);\n        int32_t idx1, idx2;\n        while (huffman->nHeap > 1)\n        {\n            idx1 = huffman->heap[1];\n            huffman->heap[1] = huffman->heap[huffman->nHeap--];\n            BzpHeapAdjustDown(huffman->heap, huffman->weight, huffman->nHeap);\n            idx2 = huffman->heap[1];\n            huffman->heap[1] = huffman->heap[huffman->nHeap--];\n            BzpHeapAdjustDown(huffman->heap, huffman->weight, huffman->nHeap);\n            huffman->weight[huffman->nWeight] = BzpHuffmanWeightAdd(huffman->weight[idx1], huffman->weight[idx2]);\n            huffman->parent[idx1] = huffman->nWeight;\n            huffman->parent[idx2] = huffman->nWeight;\n            huffman->parent[huffman->nWeight] = -1;\n            huffman->nHeap++;\n            huffman->heap[huffman->nHeap] = huffman->nWeight;\n            huffman->nWeight++;\n            BzpHeapAdjustUp(huffman->heap, huffman->weight, huffman->nHeap);\n        }\n    }",
                "original_rust_code": "pub fn BzpBuildHuffmanTree(mut huffman: Ptr<BzpHuffmanInfo>) {\n    BzpHuffmanInitArray(huffman);\n    BzpHeapInit(huffman);\n    let mut idx1: i32;\n    let mut idx2: i32;\n    while (huffman.nHeap > 1) {\n        idx1 = huffman.heap[1];\n        let tmp0 = 1;\n        huffman.heap[tmp0];\n        huffman.nHeap -= 1;\n        BzpHeapAdjustDown(huffman.heap, huffman.weight.cast(), huffman.nHeap);\n        idx2 = huffman.heap[1];\n        huffman.heap[1] = huffman.heap[huffman.nHeap];\n        huffman.nHeap -= 1;\n        BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap);\n        huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1], huffman.weight[idx2]);\n        huffman.parent[idx1] = huffman.nWeight;\n        huffman.parent[idx2] = huffman.nWeight;\n        huffman.parent[huffman.nWeight] = -1;\n        huffman.nHeap += 1;\n        huffman.heap[huffman.nHeap] = huffman.nWeight;\n        huffman.nWeight += 1;\n        BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap);\n    }\n}\n",
                "optimized_rust_code": "pub fn BzpBuildHuffmanTree(mut huffman: Ptr<BzpHuffmanInfo>) {\n    BzpHuffmanInitArray(huffman);\n    BzpHeapInit(huffman);\n    let mut idx1: i32;\n    let mut idx2: i32;\n    while (huffman.nHeap > 1) {\n        idx1 = huffman.heap[1];\n        let tmp0 = 1;\n        huffman.heap[tmp0];\n        huffman.nHeap -= 1;\n        BzpHeapAdjustDown(huffman.heap, huffman.weight.cast(), huffman.nHeap);\n        idx2 = huffman.heap[1];\n        huffman.heap[1] = huffman.heap[huffman.nHeap];\n        huffman.nHeap -= 1;\n        BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap);\n        huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1], huffman.weight[idx2]);\n        huffman.parent[idx1] = huffman.nWeight;\n        huffman.parent[idx2] = huffman.nWeight;\n        huffman.parent[huffman.nWeight] = -1;\n        huffman.nHeap += 1;\n        huffman.heap[huffman.nHeap] = huffman.nWeight;\n        huffman.nWeight += 1;\n        BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap);\n    }\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007406294)\nerror[E0308]: mismatched types\n  --> src/src/compress/bzp_huffman_encode_c.rs:77:27\n   |\n77 |         BzpHeapAdjustDown(huffman.heap, huffman.weight.cast(), huffman.nHeap);\n   |         ----------------- ^^^^^^^^^^^^ expected `Ptr<i32>`, found `Array<i32, 259>`\n   |         |\n   |         arguments to this function are incorrect\n   |\n   = note: expected struct `memory::ptr::Ptr<i32>`\n              found struct `types::array::Array<i32, 259>`\nnote: function defined here\n  --> src/src/compress/bzp_huffman_encode_c.rs:37:8\n   |\n37 | pub fn BzpHeapAdjustDown(mut heap: Ptr<i32>, mut weight: Ptr<i32>, mut nHeap: i32) {\n   |        ^^^^^^^^^^^^^^^^^ ------------------\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007450793)\nerror[E0308]: mismatched types\n  --> src/src/compress/bzp_huffman_encode_c.rs:77:27\n   |\n77 |         BzpHeapAdjustDown(huffman.heap, huffman.weight.cast(), huffman.nHeap);\n   |         ----------------- ^^^^^^^^^^^^ expected `Ptr<i32>`, found `Array<i32, 259>`\n   |         |\n   |         arguments to this function are incorrect\n   |\n   = note: expected struct `memory::ptr::Ptr<i32>`\n              found struct `types::array::Array<i32, 259>`\nnote: function defined here\n  --> src/src/compress/bzp_huffman_encode_c.rs:37:8\n   |\n37 | pub fn BzpHeapAdjustDown(mut heap: Ptr<i32>, mut weight: Ptr<i32>, mut nHeap: i32) {\n   |        ^^^^^^^^^^^^^^^^^ ------------------\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int32_t BzpSelectTree(BzpHuffmanGroups *huffman)\n    {\n        int32_t id = 0;\n        int32_t nGroups = huffman->nGroups;\n        for (int32_t k = 0; k < nGroups; k++)\n        {\n            if (huffman->cost[k] < huffman->cost[id])\n            {\n                id = k;\n            }\n        }\n        huffman->select[huffman->nSelect++] = id;\n        return id;\n    }",
                "original_rust_code": "pub fn BzpSelectTree(mut huffman: Ptr<BzpHuffmanGroups>) -> i32 {\n    let mut id: i32 = 0;\n    let mut nGroups: i32 = huffman.nGroups;\n    c_for!(let mut k: i32 = 0; k < nGroups; k.suffix_plus_plus(); {\n        let tmp0 = k;\n        if (huffman.cost[tmp0]) {\n            id = k;\n        }\n    });\n    huffman.select[huffman.nSelect] = id;\n    huffman.nSelect += 1;\n    return id;\n}\n",
                "optimized_rust_code": "pub fn BzpSelectTree(mut huffman: Ptr<BzpHuffmanGroups>) -> i32 {\n    let mut id: i32 = 0;\n    let mut nGroups: i32 = huffman.nGroups;\n    c_for!(let mut k: i32 = 0; k < nGroups; k.suffix_plus_plus(); {\n        let tmp0 = k;\n        if (huffman.cost[tmp0]) {\n            id = k;\n        }\n    });\n    huffman.select[huffman.nSelect] = id;\n    huffman.nSelect += 1;\n    return id;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007474042)\nerror[E0308]: mismatched types\n   --> src/src/compress/bzp_huffman_encode_c.rs:285:12\n    |\n285 |         if (huffman.cost[tmp0]) {\n    |            ^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007505046)\nerror[E0308]: mismatched types\n   --> src/src/compress/bzp_huffman_encode_c.rs:285:12\n    |\n285 |         if (huffman.cost[tmp0]) {\n    |            ^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void BzpNumEncode(BzpMtfInfo *mtf, int32_t num)\n    {\n        num <<= 1;\n\n        do\n        {\n            num >>= 1;\n            num--;\n            if (num & 1)\n            {\n                mtf->mtfV[mtf->nMtf++] = BZP_MTF_ENCODE1;\n                mtf->mtfFreq[BZP_MTF_ENCODE1]++;\n            }\n            else\n            {\n                mtf->mtfV[mtf->nMtf++] = BZP_MTF_ENCODE0;\n                mtf->mtfFreq[BZP_MTF_ENCODE0]++;\n            }\n        } while (num >= BZP_MTF_ENCODE_BASE);\n    }",
                "original_rust_code": "pub fn BzpNumEncode(mut mtf: Ptr<BzpMtfInfo>, mut num: i32) {\n    num <<= 1;\n    c_do!({\n        num >>= 1;\n        num -= 1;\n        if (num & 1) {\n            let tmp0 = mtf.nMtf;\n            mtf.mtfV[tmp0] = BZP_MTF_ENCODE1!();\n            mtf.nMtf += 1;\n            mtf.mtfFreq[BZP_MTF_ENCODE1!()] += 1;\n        } else {\n            mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE0!();\n            mtf.nMtf += 1;\n            mtf.mtfFreq[BZP_MTF_ENCODE0!()] += 1;\n        }\n    } while num >= BZP_MTF_ENCODE_BASE!());\n}\n",
                "optimized_rust_code": "pub fn BzpNumEncode(mut mtf: Ptr<BzpMtfInfo>, mut num: i32) {\n    num <<= 1;\n    c_do!({\n        num >>= 1;\n        num -= 1;\n        if (num & 1) {\n            let tmp0 = mtf.nMtf;\n            mtf.mtfV[tmp0] = BZP_MTF_ENCODE1!();\n            mtf.nMtf += 1;\n            mtf.mtfFreq[BZP_MTF_ENCODE1!()] += 1;\n        } else {\n            mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE0!();\n            mtf.nMtf += 1;\n            mtf.mtfFreq[BZP_MTF_ENCODE0!()] += 1;\n        }\n    } while num >= BZP_MTF_ENCODE_BASE!());\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007565043)\nerror[E0308]: mismatched types\n  --> src/src/compress/bzp_mtf_encode_c.rs:55:12\n   |\n55 |         if (num & 1) {\n   |            ^^^^^^^^^ expected `bool`, found `i32`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007601988)\nerror[E0308]: mismatched types\n  --> src/src/compress/bzp_mtf_encode_c.rs:55:12\n   |\n55 |         if (num & 1) {\n   |            ^^^^^^^^^ expected `bool`, found `i32`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void BzpMtfMain(BzpMtfInfo *mtf)\n    {\n        uint8_t list[BZP_MAX_ALPHA_SIZE];\n        int32_t EOB;\n        int32_t num = 0;\n        BzpMapInputChar(mtf, list, BZP_MAX_ALPHA_SIZE);\n        EOB = mtf->nUse + 1;\n        for (int32_t i = 0; i <= EOB; i++)\n        {\n            mtf->mtfFreq[i] = 0;\n        }\n        for (int32_t i = 0; i < mtf->nBlock; i++)\n        {\n            int32_t pos = mtf->map[i] - 1;\n            if (pos < 0)\n            {\n                pos += mtf->nBlock;\n            }\n            uint8_t ch = mtf->block[pos];\n            if (ch == list[0])\n            {\n                num++;\n            }\n            else\n            {\n                if (num > 0)\n                {\n                    BzpNumEncode(mtf, num);\n                    num = 0;\n                }\n                int32_t pos_ = 1;\n                while (ch != list[pos_] && pos_ < mtf->nUse)\n                {\n                    pos_++;\n                }\n\n                for (int32_t j = pos_; j > 0; j--)\n                {\n                    list[j] = list[j - 1];\n                }\n                list[0] = ch;\n\n                mtf->mtfV[mtf->nMtf] = pos_ + 1;\n                mtf->mtfFreq[pos_ + 1]++;\n                mtf->nMtf++;\n            }\n        }\n        if (num > 0)\n        {\n            BzpNumEncode(mtf, num);\n        }\n\n        mtf->mtfV[mtf->nMtf] = EOB;\n        mtf->mtfFreq[EOB]++;\n        mtf->nMtf++;\n    }",
                "original_rust_code": "pub fn BzpMtfMain(mut mtf: Ptr<BzpMtfInfo>) {\n    let mut list: Array<u8, { BZP_MAX_ALPHA_SIZE!() }> = Default::default();\n    let mut EOB: i32 = Default::default();\n    let mut num: i32 = 0;\n    BzpMapInputChar(mtf, list, BZP_MAX_ALPHA_SIZE!());\n    EOB = (mtf.nUse + 1);\n    c_for!(let mut i: i32 = 0; i <= EOB; i.suffix_plus_plus(); {\n        mtf.mtfFreq[i] = 0;\n    });\n    c_for!(let mut i: i32 = 0; i < mtf.nBlock; i.suffix_plus_plus(); {\n        let mut pos: i32 = (mtf.map[i] - 1);\n        if (pos < 0) {\n            pos += mtf.nBlock;\n        }\n        let mut ch: u8 = mtf.block[pos];\n        if (ch == list[0]) {\n            num += 1;\n        } else {\n            if (num > 0) {\n                BzpNumEncode(mtf, num);\n                num = 0;\n            }\n            let mut pos_: i32 = 1;\n            while (ch != list[pos_]) && (pos_ < mtf.nUse) {\n                pos_ += 1;\n            }\n            c_for!(let mut j: i32 = pos_; j > 0; j.suffix_minus_minus(); {\n                list[j] = list[j - 1];\n            });\n            list[0] = ch;\n            let tmp0 = mtf.nMtf;\n            mtf.mtfV[tmp0] = (pos_ + 1);\n            mtf.mtfFreq[pos_ + 1] += 1;\n            mtf.nMtf += 1;\n        }\n    });\n    if (num > 0) {\n        BzpNumEncode(mtf, num);\n    }\n    mtf.mtfV[mtf.nMtf] = EOB;\n    mtf.mtfFreq[EOB] += 1;\n    mtf.nMtf += 1;\n}\n",
                "optimized_rust_code": "pub fn BzpMtfMain(mut mtf: Ptr<BzpMtfInfo>) {\n    let mut list: Array<u8, { BZP_MAX_ALPHA_SIZE!() }> = Default::default();\n    let mut EOB: i32 = Default::default();\n    let mut num: i32 = 0;\n    BzpMapInputChar(mtf, list.as_mut_ptr(), BZP_MAX_ALPHA_SIZE!());\n    EOB = (mtf.nUse + 1);\n    c_for!(let mut i: i32 = 0; i <= EOB; i.suffix_plus_plus(); {\n        mtf.mtfFreq[i] = 0;\n    });\n    c_for!(let mut i: i32 = 0; i < mtf.nBlock; i.suffix_plus_plus(); {\n        let mut pos: i32 = (mtf.map[i] - 1);\n        if (pos < 0) {\n            pos += mtf.nBlock;\n        }\n        let mut ch: u8 = mtf.block[pos];\n        if (ch == list[0]) {\n            num += 1;\n        } else {\n            if (num > 0) {\n                BzpNumEncode(mtf, num);\n                num = 0;\n            }\n            let mut pos_: i32 = 1;\n            while (ch != list[pos_]) && (pos_ < mtf.nUse) {\n                pos_ += 1;\n            }\n            c_for!(let mut j: i32 = pos_; j > 0; j.suffix_minus_minus(); {\n                list[j] = list[j - 1];\n            });\n            list[0] = ch;\n            let tmp0 = mtf.nMtf;\n            mtf.mtfV[tmp0] = (pos_ + 1);\n            mtf.mtfFreq[pos_ + 1] += 1;\n            mtf.nMtf += 1;\n        }\n    });\n    if (num > 0) {\n        BzpNumEncode(mtf, num);\n    }\n    mtf.mtfV[mtf.nMtf] = EOB;\n    mtf.mtfFreq[EOB] += 1;\n    mtf.nMtf += 1;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007602221)\nerror[E0308]: mismatched types\n  --> src/src/compress/bzp_mtf_encode_c.rs:59:26\n   |\n59 |     BzpMapInputChar(mtf, list, BZP_MAX_ALPHA_SIZE!());\n   |     ---------------      ^^^^ expected `Ptr<u8>`, found `Array<u8, 258>`\n   |     |\n   |     arguments to this function are incorrect\n   |\n   = note: expected struct `memory::ptr::Ptr<u8>`\n              found struct `types::array::Array<u8, 258>`\nnote: function defined here\n  --> src/src/compress/bzp_mtf_encode_c.rs:37:8\n   |\n37 | pub fn BzpMapInputChar(mut mtf: Ptr<BzpMtfInfo>, mut list: Ptr<u8>, mut lenList: i32) {\n   |        ^^^^^^^^^^^^^^^                           -----------------\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007661944)\nerror[E0599]: no method named `as_mut_ptr` found for struct `types::array::Array` in the current scope\n  --> src/src/compress/bzp_mtf_encode_c.rs:59:31\n   |\n59 |     BzpMapInputChar(mtf, list.as_mut_ptr(), BZP_MAX_ALPHA_SIZE!());\n   |                               ^^^^^^^^^^ method not found in `Array<u8, 258>`\n   |\n  ::: src/translation_utils/types/array.rs:5:1\n   |\n5  | pub struct Array<T, const N: usize>(pub [T; N]);\n   | ----------------------------------- method `as_mut_ptr` not found for this struct\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int32_t BzpMTFDeCode(InDeComdata *inData, BzpHuffmanDecode *huffman, BzpBwtDecodeInfo *debwt)\n    {\n        debwt->nBlock = 0;\n        uint8_t ch;\n        int32_t ninUse = huffman->alphaSize - BZP_EXTRA_CHARS_NUM;\n        int32_t eob = ninUse + 1;\n        int32_t val = BzpHuffmanDecodeStep(huffman, inData);\n        while (val != eob && val != -1)\n        {\n            if (val == 0 || val == 1)\n            {\n                int32_t res = 0, basenum = 1;\n                while (val == 0 || val == 1)\n                {\n                    res = res + (val + 1) * basenum;\n                    basenum <<= 1;\n                    val = BzpHuffmanDecodeStep(huffman, inData);\n                }\n                for (int32_t j = 0; j < res; j++)\n                {\n                    debwt->block[debwt->nBlock++] = inData->list[0];\n                }\n            }\n            else\n            {\n                int32_t pos = val - 1;\n                ch = inData->list[pos];\n                debwt->block[debwt->nBlock++] = ch;\n\n                for (int32_t j = pos; j > 0; j--)\n                {\n                    inData->list[j] = inData->list[j - 1];\n                }\n                inData->list[0] = ch;\n                val = BzpHuffmanDecodeStep(huffman, inData);\n            }\n        }\n        if (val == -1)\n        {\n            return BZP_ERROR_DATA;\n        }\n        return BZP_OK;\n    }",
                "original_rust_code": "pub fn BzpMTFDeCode(mut inData: Ptr<InDeComdata>, mut huffman: Ptr<BzpHuffmanDecode>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    debwt.nBlock = 0;\n    let mut ch: u8 = Default::default();\n    let mut ninUse: i32 = huffman.alphaSize - BZP_EXTRA_CHARS_NUM!();\n    let mut eob: i32 = ninUse + 1;\n    let mut val: i32 = BzpHuffmanDecodeStep(huffman, inData);\n    while (val != eob) && (val != -1) {\n        if (val == 0) || (val == 1) {\n            let mut res: i32 = 0;\n            let mut basenum: i32 = 1;\n            while (val == 0) || (val == 1) {\n                res = res + (val + 1) * basenum;\n                basenum <<= 1;\n                val = BzpHuffmanDecodeStep(huffman, inData);\n            }\n            c_for!(let mut j: i32 = 0; j < res; j.suffix_plus_plus(); {\n                let tmp0 = debwt.nBlock.suffix_plus_plus();\n                debwt.block[tmp0] = inData.list[0];\n            });\n        } else {\n            let mut pos: i32 = val - 1;\n            ch = inData.list[pos].cast();\n            debwt.block[debwt.nBlock.suffix_plus_plus()] = ch;\n            c_for!(let mut j: i32 = pos; j > 0; j.suffix_minus_minus(); {\n                inData.list[j] = inData.list[j - 1];\n            });\n            inData.list[0] = ch.cast();\n            val = BzpHuffmanDecodeStep(huffman, inData);\n        }\n    }\n    if (val == -1) {\n        return BZP_ERROR_DATA!();\n    }\n    return BZP_OK!();\n}\n",
                "optimized_rust_code": "pub fn BzpMTFDeCode(mut inData: Ptr<InDeComdata>, mut huffman: Ptr<BzpHuffmanDecode>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    debwt.nBlock = 0;\n    let mut ch: u8 = Default::default();\n    let mut ninUse: i32 = huffman.alphaSize - BZP_EXTRA_CHARS_NUM!();\n    let mut eob: i32 = ninUse + 1;\n    let mut val: i32 = BzpHuffmanDecodeStep(huffman, inData);\n    while (val != eob) && (val != -1) {\n        if (val == 0) || (val == 1) {\n            let mut res: i32 = 0;\n            let mut basenum: i32 = 1;\n            while (val == 0) || (val == 1) {\n                res = res + (val + 1) * basenum;\n                basenum <<= 1;\n                val = BzpHuffmanDecodeStep(huffman, inData);\n            }\n            c_for!(let mut j: i32 = 0; j < res; j.suffix_plus_plus(); {\n                let tmp0 = debwt.nBlock.suffix_plus_plus();\n                debwt.block[tmp0] = inData.list[0];\n            });\n        } else {\n            let mut pos: i32 = val - 1;\n            ch = inData.list[pos].cast();\n            debwt.block[debwt.nBlock.suffix_plus_plus()] = ch;\n            c_for!(let mut j: i32 = pos; j > 0; j.suffix_minus_minus(); {\n                inData.list[j] = inData.list[j - 1];\n            });\n            inData.list[0] = ch.cast();\n            val = BzpHuffmanDecodeStep(huffman, inData);\n        }\n    }\n    if (val == -1) {\n        return BZP_ERROR_DATA!();\n    }\n    return BZP_OK!();\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007723554)\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_decompress_stream_c.rs:214:37\n    |\n214 |                 debwt.block[tmp0] = inData.list[0];\n    |                 -----------------   ^^^^^^^^^^^^^^ expected `u8`, found `i32`\n    |                 |\n    |                 expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007777498)\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_decompress_stream_c.rs:214:37\n    |\n214 |                 debwt.block[tmp0] = inData.list[0];\n    |                 -----------------   ^^^^^^^^^^^^^^ expected `u8`, found `i32`\n    |                 |\n    |                 expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int32_t BzpDeCodeToStream(InDeComdata *inData, BzpBwtDecodeInfo *debwt)\n    {\n        uint8_t ch;\n        int32_t ret = BZP_OK;\n        for (int32_t i = 0; i < debwt->nBlock; i++)\n        {\n            ch = debwt->deCode[i];\n            if (inData->num == BZP_RLC_NUM_4)\n            {\n                for (int32_t j = 0; j < ((int32_t)ch); j++)\n                {\n                    BZP_UPDATE_CRC(inData->blockCRC, (uint8_t)inData->lasChar);\n                    ret |= BzpWriteChar(inData->lasChar, inData);\n                }\n                inData->lasChar = BZP_ASCII_SIZE;\n                inData->num = 0;\n            }\n            else if (ch == inData->lasChar)\n            {\n                BZP_UPDATE_CRC(inData->blockCRC, ch);\n                ret = BzpWriteChar(ch, inData);\n                inData->num++;\n            }\n            else\n            {\n                BZP_UPDATE_CRC(inData->blockCRC, ch);\n                ret = BzpWriteChar(ch, inData);\n                inData->lasChar = ch;\n                inData->num = 1;\n            }\n            if (ret != BZP_OK)\n                break;\n        }\n        return ret;\n    }",
                "original_rust_code": "pub fn BzpDeCodeToStream(mut inData: Ptr<InDeComdata>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    let mut ch: u8 = Default::default();\n    let mut ret: i32 = BZP_OK!();\n    c_for!(let mut i: i32 = 0; i < debwt.nBlock; i.suffix_plus_plus(); {\n        ch = debwt.deCode[i];\n        if (inData.num == BZP_RLC_NUM_4!()) {\n            c_for!(let mut j: i32 = 0; j < ch.cast::<i32>(); j.suffix_plus_plus(); {\n                BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n                ret |= BzpWriteChar(inData.lasChar.cast(), inData);\n            });\n            inData.lasChar = BZP_ASCII_SIZE!();\n            inData.num = 0;\n        } else if (ch == inData.lasChar) {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch);\n            ret = BzpWriteChar(ch, inData);\n            inData.num += 1;\n        } else {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch);\n            ret = BzpWriteChar(ch, inData);\n            inData.lasChar = ch.cast();\n            inData.num = 1;\n        }\n        if (ret != BZP_OK!()) {\n            break;\n        }\n    });\n    return ret;\n}\n",
                "optimized_rust_code": "pub fn BzpDeCodeToStream(mut inData: Ptr<InDeComdata>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    let mut ch: u8 = Default::default();\n    let mut ret: i32 = BZP_OK!();\n    c_for!(let mut i: i32 = 0; i < debwt.nBlock; i.suffix_plus_plus(); {\n        ch = debwt.deCode[i];\n        if (inData.num == BZP_RLC_NUM_4!()) {\n            c_for!(let mut j: i32 = 0; j < ch.cast::<i32>(); j.suffix_plus_plus(); {\n                BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u32>());\n                ret |= BzpWriteChar(inData.lasChar.cast(), inData);\n            });\n            inData.lasChar = BZP_ASCII_SIZE!();\n            inData.num = 0;\n        } else if (i32::from(ch) == inData.lasChar) {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch.cast::<u32>());\n            ret = BzpWriteChar(ch, inData);\n            inData.num += 1;\n        } else {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch.cast::<u32>());\n            ret = BzpWriteChar(ch, inData);\n            inData.lasChar = ch.cast::<i32>();\n            inData.num = 1;\n        }\n        if (ret != BZP_OK!()) {\n            break;\n        }\n    });\n    return ret;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007777756)\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:74\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                          ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:209:17\n    |\n209 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]: cannot index into a value of type `types::global::Global<types::array::Array<i32, 256>>`\n   --> src/src/public/bzp_stream_utils_h.rs:186:53\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:209:17\n    |\n209 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:72\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                        ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:209:17\n    |\n209 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_decompress_stream_c.rs:214:26\n    |\n214 |         } else if (ch == inData.lasChar) {\n    |                    --    ^^^^^^^^^^^^^^ expected `u8`, found `i32`\n    |                    |\n    |                    expected because this is `u8`\n    |\nhelp: you can convert `ch` from `u8` to `i32`, matching the type of `inData.lasChar`\n    |\n214 |         } else if (i32::from(ch) == inData.lasChar) {\n    |                    ++++++++++  +\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:74\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                          ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:215:13\n    |\n215 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]: cannot index into a value of type `types::global::Global<types::array::Array<i32, 256>>`\n   --> src/src/public/bzp_stream_utils_h.rs:186:53\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:215:13\n    |\n215 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:72\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                        ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:215:13\n    |\n215 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:74\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                          ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:219:13\n    |\n219 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]: cannot index into a value of type `types::global::Global<types::array::Array<i32, 256>>`\n   --> src/src/public/bzp_stream_utils_h.rs:186:53\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:219:13\n    |\n219 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:72\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                        ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:219:13\n    |\n219 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0608.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 10 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007828695)\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:74\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                          ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:209:17\n    |\n209 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u32>());\n    |                 -------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]: cannot index into a value of type `types::global::Global<types::array::Array<i32, 256>>`\n   --> src/src/public/bzp_stream_utils_h.rs:186:53\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:209:17\n    |\n209 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u32>());\n    |                 -------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:72\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                        ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:209:17\n    |\n209 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u32>());\n    |                 -------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:74\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                          ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:215:13\n    |\n215 |             BZP_UPDATE_CRC!(inData.blockCRC, ch.cast::<u32>());\n    |             -------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]: cannot index into a value of type `types::global::Global<types::array::Array<i32, 256>>`\n   --> src/src/public/bzp_stream_utils_h.rs:186:53\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:215:13\n    |\n215 |             BZP_UPDATE_CRC!(inData.blockCRC, ch.cast::<u32>());\n    |             -------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:72\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                        ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:215:13\n    |\n215 |             BZP_UPDATE_CRC!(inData.blockCRC, ch.cast::<u32>());\n    |             -------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:74\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                          ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:219:13\n    |\n219 |             BZP_UPDATE_CRC!(inData.blockCRC, ch.cast::<u32>());\n    |             -------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]: cannot index into a value of type `types::global::Global<types::array::Array<i32, 256>>`\n   --> src/src/public/bzp_stream_utils_h.rs:186:53\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:219:13\n    |\n219 |             BZP_UPDATE_CRC!(inData.blockCRC, ch.cast::<u32>());\n    |             -------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:72\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                        ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:219:13\n    |\n219 |             BZP_UPDATE_CRC!(inData.blockCRC, ch.cast::<u32>());\n    |             -------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0608.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 9 previous errors\n"
            },
            {
                "c_code": "void BzpAddCharToBlock(uint8_t lasch, int32_t num, BzpBwtInfo *bwt)\n    {\n        if (num < BZP_RLC_NUM_LOWER_LIMIT || num > BZP_RLC_NUM_UPPER_LIMIT)\n        {\n            return;\n        }\n        for (int32_t i = 0; i < num; i++)\n        {\n            BZP_UPDATE_CRC(bwt->blockCRC, lasch);\n        }\n\n        int32_t val = BZP_MIN_FUN(num, (int32_t)BZP_RLC_NUM_4);\n        switch (val)\n        {\n        case BZP_RLC_NUM_4:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_3:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_2:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_1:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        default:\n            break;\n        }\n        if (num >= BZP_RLC_NUM_4)\n        {\n            bwt->block[bwt->nBlock++] = ((char)(num - BZP_RLC_NUM_4));\n            bwt->inUse[num - BZP_RLC_NUM_4] = true;\n        }\n\n        bwt->inUse[lasch] = true;\n    }",
                "original_rust_code": "pub fn BzpAddCharToBlock(mut lasch: u8, mut num: i32, mut bwt: Ptr<BzpBwtInfo>) {\n    if (num < BZP_RLC_NUM_LOWER_LIMIT!()) || (num > BZP_RLC_NUM_UPPER_LIMIT!()) {\n        return;\n    }\n    c_for!(let mut i: i32 = 0; i < num; i.suffix_plus_plus(); {\n        BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    });\n\n    let mut val: i32 = BZP_MIN_FUN!(num, BZP_RLC_NUM_4!());\n    c_switch!(val, {\n        BZP_RLC_NUM_4!() => {\n            let tmp0 = bwt.nBlock.suffix_plus_plus();\n            bwt.block[tmp0] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_3!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_2!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_1!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        _ => {\n            break;\n        },\n    });\n    if (num >= BZP_RLC_NUM_4!()) {\n        bwt.block[bwt.nBlock.suffix_plus_plus()] = (num - BZP_RLC_NUM_4!()).cast::<u8>();\n        bwt.inUse[num - BZP_RLC_NUM_4!()] = true;\n    }\n\n    bwt.inUse[lasch] = true;\n}\n",
                "optimized_rust_code": "pub fn BzpAddCharToBlock(mut lasch: u8, mut num: i32, mut bwt: Ptr<BzpBwtInfo>) {\n    if (num < BZP_RLC_NUM_LOWER_LIMIT!()) || (num > BZP_RLC_NUM_UPPER_LIMIT!()) {\n        return;\n    }\n    c_for!(let mut i: i32 = 0; i < num; i.suffix_plus_plus(); {\n        BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    });\n\n    let mut val: i32 = BZP_MIN_FUN!(num, BZP_RLC_NUM_4!());\n    c_switch!(val, {\n        BZP_RLC_NUM_4!() => {\n            let tmp0 = bwt.nBlock.suffix_plus_plus();\n            bwt.block[tmp0] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_3!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_2!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_1!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        _ => {\n            break;\n        },\n    });\n    if (num >= BZP_RLC_NUM_4!()) {\n        bwt.block[bwt.nBlock.suffix_plus_plus()] = (num - BZP_RLC_NUM_4!()).cast::<u8>();\n        bwt.inUse[num - BZP_RLC_NUM_4!()] = true;\n    }\n\n    bwt.inUse[lasch] = true;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007919395)\nerror: no rules expected `,`\n   --> src/src/public/bzp_compress_stream_c.rs:348:18\n    |\n348 |     c_switch!(val, {\n    |                  ^ no rules expected this token in macro call\n    |\n   ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n    |\n3   | macro_rules! c_switch {\n    | --------------------- when calling this macro\n    |\nnote: while trying to match `;`\n   --> src/translation_utils/c_alignment/c_switch.rs:5:17\n    |\n5   |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n    |                 ^\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:74\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                          ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:344:9\n    |\n344 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]: cannot index into a value of type `types::global::Global<types::array::Array<i32, 256>>`\n   --> src/src/public/bzp_stream_utils_h.rs:186:53\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:344:9\n    |\n344 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:72\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                        ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:344:9\n    |\n344 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0608.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007978902)\nerror: no rules expected `,`\n   --> src/src/public/bzp_compress_stream_c.rs:348:18\n    |\n348 |     c_switch!(val, {\n    |                  ^ no rules expected this token in macro call\n    |\n   ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n    |\n3   | macro_rules! c_switch {\n    | --------------------- when calling this macro\n    |\nnote: while trying to match `;`\n   --> src/translation_utils/c_alignment/c_switch.rs:5:17\n    |\n5   |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n    |                 ^\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:74\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                          ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:344:9\n    |\n344 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]: cannot index into a value of type `types::global::Global<types::array::Array<i32, 256>>`\n   --> src/src/public/bzp_stream_utils_h.rs:186:53\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:344:9\n    |\n344 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:72\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                        ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:344:9\n    |\n344 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0608.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
            }
        ]
    }
}