{
    "macro": {
        "all_cnt": 85,
        "passed_cnt": 85,
        "pass_rate": 1.0,
        "messages": []
    },
    "macro_function": {
        "all_cnt": 7,
        "passed_cnt": 7,
        "pass_rate": 1.0,
        "messages": []
    },
    "definition": {
        "all_cnt": 15,
        "passed_cnt": 15,
        "pass_rate": 1.0,
        "messages": []
    },
    "dummy_function": {
        "all_cnt": 92,
        "passed_cnt": 92,
        "pass_rate": 1.0,
        "messages": []
    },
    "function": {
        "all_cnt": 92,
        "passed_cnt": 78,
        "pass_rate": 0.8478260869565217,
        "messages": [
            {
                "c_code": "void BzpHeapInit(BzpHuffmanInfo *huffman)\n    {\n        int32_t i = 0;\n        for (i = 0; i < huffman->alphaSize; i++)\n        {\n            huffman->nHeap++;\n            huffman->heap[huffman->nHeap] = i;\n            BzpHeapAdjustUp(huffman->heap, huffman->weight, huffman->nHeap);\n        }\n    }",
                "original_rust_code": "pub fn BzpHeapInit(mut huffman: Ptr<BzpHuffmanInfo>) {\n    let mut i: i32 = 0;\n    c_for!(i = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        huffman.nHeap += 1;\n        huffman.heap[huffman.nHeap] = i.cast();\n        BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n    });\n}\n",
                "optimized_rust_code": "pub fn BzpHeapInit(mut huffman: Ptr<BzpHuffmanInfo>) {\n    let mut i: i32 = 0;\n    c_for!(i = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        huffman.nHeap += 1;\n        let tmp0 = huffman.nHeap;\n        huffman.heap[tmp0] = i;\n        BzpHeapAdjustUp(huffman.heap, huffman.weight.cast(), huffman.nHeap);\n    });\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007160623)\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:61:22\n   |\n61 |         huffman.heap[huffman.nHeap] = i.cast();\n   |         -------     -^^^^^^^-------\n   |         |           ||\n   |         |           |immutable borrow occurs here\n   |         |           mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:61:22\n   |\n61 |         huffman.heap[huffman.nHeap] = i.cast();\n   |                      ^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:61:21\n   |\n61 |         huffman.heap[huffman.nHeap] = i.cast();\n   |                     ^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007163192)\nerror[E0308]: mismatched types\n  --> src/src/compress/bzp_huffman_encode_c.rs:63:25\n   |\n63 |         BzpHeapAdjustUp(huffman.heap, huffman.weight.cast(), huffman.nHeap);\n   |         --------------- ^^^^^^^^^^^^ expected `Ptr<i32>`, found `Array<i32, 259>`\n   |         |\n   |         arguments to this function are incorrect\n   |\n   = note: expected struct `memory::ptr::Ptr<i32>`\n              found struct `types::array::Array<i32, 259>`\nnote: function defined here\n  --> src/src/compress/bzp_huffman_encode_c.rs:22:8\n   |\n22 | pub fn BzpHeapAdjustUp(mut heap: Ptr<i32>, mut weight: Ptr<i32>, mut pos: i32) {\n   |        ^^^^^^^^^^^^^^^ ------------------\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void BzpBuildHuffmanTree(BzpHuffmanInfo *huffman)\n    {\n        BzpHuffmanInitArray(huffman);\n        BzpHeapInit(huffman);\n        int32_t idx1, idx2;\n        while (huffman->nHeap > 1)\n        {\n            idx1 = huffman->heap[1];\n            huffman->heap[1] = huffman->heap[huffman->nHeap--];\n            BzpHeapAdjustDown(huffman->heap, huffman->weight, huffman->nHeap);\n            idx2 = huffman->heap[1];\n            huffman->heap[1] = huffman->heap[huffman->nHeap--];\n            BzpHeapAdjustDown(huffman->heap, huffman->weight, huffman->nHeap);\n            huffman->weight[huffman->nWeight] = BzpHuffmanWeightAdd(huffman->weight[idx1], huffman->weight[idx2]);\n            huffman->parent[idx1] = huffman->nWeight;\n            huffman->parent[idx2] = huffman->nWeight;\n            huffman->parent[huffman->nWeight] = -1;\n            huffman->nHeap++;\n            huffman->heap[huffman->nHeap] = huffman->nWeight;\n            huffman->nWeight++;\n            BzpHeapAdjustUp(huffman->heap, huffman->weight, huffman->nHeap);\n        }\n    }",
                "original_rust_code": "pub fn BzpBuildHuffmanTree(mut huffman: Ptr<BzpHuffmanInfo>) {\n    BzpHuffmanInitArray(huffman.cast());\n    BzpHeapInit(huffman.cast());\n    let mut idx1: i32;\n    let mut idx2: i32;\n    while (huffman.nHeap > 1).as_bool() {\n        idx1 = huffman.heap[1].cast();\n        huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n        huffman.nHeap -= 1;\n        BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n        idx2 = huffman.heap[1].cast();\n        huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n        huffman.nHeap -= 1;\n        BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n        huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n        huffman.parent[idx1] = huffman.nWeight.cast();\n        huffman.parent[idx2] = huffman.nWeight.cast();\n        huffman.parent[huffman.nWeight] = -1;\n        huffman.nHeap += 1;\n        huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n        huffman.nWeight += 1;\n        BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n    }\n}\n",
                "optimized_rust_code": "pub fn BzpBuildHuffmanTree(mut huffman: Ptr<BzpHuffmanInfo>) {\n    BzpHuffmanInitArray(huffman);\n    BzpHeapInit(huffman);\n    let mut idx1: i32;\n    let mut idx2: i32;\n    while (huffman.nHeap > 1) {\n        idx1 = huffman.heap[1];\n        let tmp0 = 1;\n        huffman.heap[tmp0];\n        huffman.nHeap -= 1;\n        BzpHeapAdjustDown(huffman.heap, huffman.weight.cast(), huffman.nHeap);\n        idx2 = huffman.heap[1];\n        huffman.heap[1] = huffman.heap[huffman.nHeap];\n        huffman.nHeap -= 1;\n        BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap);\n        huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1], huffman.weight[idx2]);\n        huffman.parent[idx1] = huffman.nWeight;\n        huffman.parent[idx2] = huffman.nWeight;\n        huffman.parent[huffman.nWeight] = -1;\n        huffman.nHeap += 1;\n        huffman.heap[huffman.nHeap] = huffman.nWeight;\n        huffman.nWeight += 1;\n        BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap);\n    }\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007163628)\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:74:40\n   |\n74 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                           -------     -^^^^^^^-------\n   |                           |           ||\n   |                           |           |immutable borrow occurs here\n   |                           |           mutable borrow later used here\n   |                           mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:74:40\n   |\n74 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                                        ^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:74:39\n   |\n74 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                                       ^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:78:40\n   |\n78 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                           -------     -^^^^^^^-------\n   |                           |           ||\n   |                           |           |immutable borrow occurs here\n   |                           |           mutable borrow later used here\n   |                           mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:78:40\n   |\n78 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                                        ^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:78:39\n   |\n78 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                                       ^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:81:24\n   |\n81 |         huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n   |         -------       -^^^^^^^---------\n   |         |             ||\n   |         |             |immutable borrow occurs here\n   |         |             mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:81:24\n   |\n81 |         huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n   |                        ^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:81:23\n   |\n81 |         huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n   |                       ^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:84:24\n   |\n84 |         huffman.parent[huffman.nWeight] = -1;\n   |         -------       -^^^^^^^---------\n   |         |             ||\n   |         |             |immutable borrow occurs here\n   |         |             mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:84:24\n   |\n84 |         huffman.parent[huffman.nWeight] = -1;\n   |                        ^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:84:23\n   |\n84 |         huffman.parent[huffman.nWeight] = -1;\n   |                       ^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_huffman_encode_c.rs:86:22\n   |\n86 |         huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n   |         -------     -^^^^^^^-------\n   |         |           ||\n   |         |           |immutable borrow occurs here\n   |         |           mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_huffman_encode_c.rs:86:22\n   |\n86 |         huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n   |                      ^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_huffman_encode_c.rs:86:21\n   |\n86 |         huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n   |                     ^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007175844)\nerror[E0308]: mismatched types\n  --> src/src/compress/bzp_huffman_encode_c.rs:77:27\n   |\n77 |         BzpHeapAdjustDown(huffman.heap, huffman.weight.cast(), huffman.nHeap);\n   |         ----------------- ^^^^^^^^^^^^ expected `Ptr<i32>`, found `Array<i32, 259>`\n   |         |\n   |         arguments to this function are incorrect\n   |\n   = note: expected struct `memory::ptr::Ptr<i32>`\n              found struct `types::array::Array<i32, 259>`\nnote: function defined here\n  --> src/src/compress/bzp_huffman_encode_c.rs:37:8\n   |\n37 | pub fn BzpHeapAdjustDown(mut heap: Ptr<i32>, mut weight: Ptr<i32>, mut nHeap: i32) {\n   |        ^^^^^^^^^^^^^^^^^ ------------------\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void BzpGenerateSelectMTF(BzpHuffmanGroups *huffman)\n    {\n        int32_t nGroups = huffman->nGroups;\n        int32_t list[nGroups];\n        for (int32_t i = 0; i < nGroups; i++)\n        {\n            list[i] = i;\n        }\n        for (int32_t i = 0; i < huffman->nSelect; i++)\n        {\n            int32_t pos = 0;\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                if (huffman->select[i] == list[j])\n                {\n                    pos = j;\n                    break;\n                }\n            }\n            for (int32_t j = pos; j > 0; j--)\n            {\n                list[j] = list[j - 1];\n            }\n            list[0] = huffman->select[i];\n            huffman->selectMTF[i] = pos;\n        }\n    }",
                "original_rust_code": "pub fn BzpGenerateSelectMTF(mut huffman: Ptr<BzpHuffmanGroups>) {\n    let mut nGroups: i32 = huffman.nGroups.cast();\n    let mut list: Array<i32, { nGroups }> = arr![0; nGroups];\n    c_for!(let mut i: i32 = 0; i < nGroups; i.suffix_plus_plus(); {\n        list[i] = i.cast();\n    });\n    c_for!(let mut i: i32 = 0; i < huffman.nSelect; i.suffix_plus_plus(); {\n        let mut pos: i32 = 0;\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            if (huffman.select[i] == list[j]).as_bool() {\n                pos = j.cast();\n                break;\n            }\n        });\n        c_for!(let mut j: i32 = pos; j > 0; j.suffix_minus_minus(); {\n            list[j] = list[j - 1].cast();\n        });\n        list[0] = huffman.select[i].cast();\n        huffman.selectMTF[i] = pos.cast();\n    });\n}\n",
                "optimized_rust_code": "pub fn BzpGenerateSelectMTF(mut huffman: Ptr<BzpHuffmanGroups>) {\n    let mut nGroups: i32 = huffman.nGroups;\n    let mut list: Array<i32, { nGroups }> = arr![0; nGroups];\n    c_for!(let mut i: i32 = 0; i < nGroups; i.suffix_plus_plus(); {\n        list[i] = i;\n    });\n    c_for!(let mut i: i32 = 0; i < huffman.nSelect; i.suffix_plus_plus(); {\n        let mut pos: i32 = 0;\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            if (huffman.select[i] == list[j]) {\n                pos = j;\n                break;\n            }\n        });\n        c_for!(let mut j: i32 = pos; j > 0; j.suffix_minus_minus(); {\n            list[j] = list[j - 1];\n        });\n        let tmp0 = 0;\n        list[tmp0];\n        huffman.selectMTF[i] = pos;\n    });\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007177596)\nerror[E0435]: attempt to use a non-constant value in a constant\n   --> src/src/compress/bzp_huffman_encode_c.rs:215:32\n    |\n215 |     let mut list: Array<i32, { nGroups }> = arr![0; nGroups];\n    |                                ^^^^^^^ non-constant value\n    |\nhelp: consider using `const` instead of `let`\n    |\n214 -     let mut nGroups: i32 = huffman.nGroups.cast();\n214 +     const nGroups: i32 = huffman.nGroups.cast();\n    |\n\nerror[E0435]: attempt to use a non-constant value in a constant\n   --> src/src/compress/bzp_huffman_encode_c.rs:215:53\n    |\n215 |     let mut list: Array<i32, { nGroups }> = arr![0; nGroups];\n    |                                                     ^^^^^^^ non-constant value\n    |\nhelp: consider using `const` instead of `let`\n    |\n214 -     let mut nGroups: i32 = huffman.nGroups.cast();\n214 +     const nGroups: i32 = huffman.nGroups.cast();\n    |\n\nFor more information about this error, try `rustc --explain E0435`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007180497)\nerror[E0435]: attempt to use a non-constant value in a constant\n   --> src/src/compress/bzp_huffman_encode_c.rs:215:32\n    |\n215 |     let mut list: Array<i32, { nGroups }> = arr![0; nGroups];\n    |                                ^^^^^^^ non-constant value\n    |\nhelp: consider using `const` instead of `let`\n    |\n214 -     let mut nGroups: i32 = huffman.nGroups;\n214 +     const nGroups: i32 = huffman.nGroups;\n    |\n\nerror[E0435]: attempt to use a non-constant value in a constant\n   --> src/src/compress/bzp_huffman_encode_c.rs:215:53\n    |\n215 |     let mut list: Array<i32, { nGroups }> = arr![0; nGroups];\n    |                                                     ^^^^^^^ non-constant value\n    |\nhelp: consider using `const` instead of `let`\n    |\n214 -     let mut nGroups: i32 = huffman.nGroups;\n214 +     const nGroups: i32 = huffman.nGroups;\n    |\n\nFor more information about this error, try `rustc --explain E0435`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "int32_t BzpSelectTree(BzpHuffmanGroups *huffman)\n    {\n        int32_t id = 0;\n        int32_t nGroups = huffman->nGroups;\n        for (int32_t k = 0; k < nGroups; k++)\n        {\n            if (huffman->cost[k] < huffman->cost[id])\n            {\n                id = k;\n            }\n        }\n        huffman->select[huffman->nSelect++] = id;\n        return id;\n    }",
                "original_rust_code": "pub fn BzpSelectTree(mut huffman: Ptr<BzpHuffmanGroups>) -> i32 {\n    let mut id: i32 = 0;\n    let mut nGroups: i32 = huffman.nGroups.cast();\n    c_for!(let mut k: i32 = 0; k < nGroups; k.suffix_plus_plus(); {\n        if (huffman.cost[k] < huffman.cost[id]).as_bool() {\n            id = k.cast();\n        }\n    });\n    huffman.select[huffman.nSelect] = id.cast();\n    huffman.nSelect += 1;\n    return id.cast();\n}\n",
                "optimized_rust_code": "pub fn BzpSelectTree(mut huffman: Ptr<BzpHuffmanGroups>) -> i32 {\n    let mut id: i32 = 0;\n    let mut nGroups: i32 = huffman.nGroups;\n    c_for!(let mut k: i32 = 0; k < nGroups; k.suffix_plus_plus(); {\n        let tmp0 = k;\n        if (huffman.cost[tmp0]) {\n            id = k;\n        }\n    });\n    huffman.select[huffman.nSelect] = id;\n    huffman.nSelect += 1;\n    return id;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007188388)\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n   --> src/src/compress/bzp_huffman_encode_c.rs:269:20\n    |\n269 |     huffman.select[huffman.nSelect] = id.cast();\n    |     -------       -^^^^^^^---------\n    |     |             ||\n    |     |             |immutable borrow occurs here\n    |     |             mutable borrow later used here\n    |     mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/compress/bzp_huffman_encode_c.rs:269:20\n    |\n269 |     huffman.select[huffman.nSelect] = id.cast();\n    |                    ^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/compress/bzp_huffman_encode_c.rs:269:19\n    |\n269 |     huffman.select[huffman.nSelect] = id.cast();\n    |                   ^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007191171)\nerror[E0308]: mismatched types\n   --> src/src/compress/bzp_huffman_encode_c.rs:266:12\n    |\n266 |         if (huffman.cost[tmp0]) {\n    |            ^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void BzpHuffmanMain(BzpHuffmanGroups *huffman)\n    {\n        int32_t nGroups = BzpGetHuffmanGroups(huffman->nBlock);\n        huffman->nGroups = nGroups;\n\n        BzpInitLenArray(huffman);\n        int32_t st = 0, ed;\n\n        for (int32_t i = 0; i < BZP_MAX_ITER_NUM; i++)\n        {\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                (void)memset_s(huffman->huffmanGroups[j].weight, sizeof(huffman->huffmanGroups[j].weight), 0,\n                               sizeof(huffman->huffmanGroups[j].weight));\n            }\n\n            st = 0;\n            huffman->nSelect = 0;\n            while (st < huffman->nBlock)\n            {\n                ed = BZP_MIN_FUN(huffman->nBlock, st + (int32_t)BZP_ELEMS_NUM_IN_ONE_GROUP) - 1;\n\n                BzpCalculateCost(huffman, st, ed);\n\n                int32_t id = BzpSelectTree(huffman);\n\n                for (int32_t k = st; k <= ed; k++)\n                {\n                    huffman->huffmanGroups[id].weight[huffman->block[k]]++;\n                }\n                st = ed + 1;\n            }\n\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                BzpBuildTreeBalanceHeight(&huffman->huffmanGroups[j]);\n            }\n        }\n\n        BzpGenerateSelectMTF(huffman);\n\n        for (int32_t i = 0; i < nGroups; i++)\n        {\n            BzpGetHuffmanTable(&huffman->huffmanGroups[i]);\n        }\n    }",
                "original_rust_code": "pub fn BzpHuffmanMain(mut huffman: Ptr<BzpHuffmanGroups>) {\n    let mut nGroups: i32 = BzpGetHuffmanGroups(huffman.nBlock.cast()).cast();\n    huffman.nGroups = nGroups.cast();\n\n    BzpInitLenArray(huffman.cast());\n    let mut st: i32 = 0;\n    let mut ed: i32 = Default::default();\n\n    c_for!(let mut i: i32 = 0; i < BZP_MAX_ITER_NUM!().cast(); i.suffix_plus_plus(); {\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            c_memset_s!(huffman.huffmanGroups[j].weight, c_sizeofval!(huffman.huffmanGroups[j].weight), 0,\n                       c_sizeofval!(huffman.huffmanGroups[j].weight)).cast::<Void>();\n        });\n\n        st = 0;\n        huffman.nSelect = 0;\n        while (st < huffman.nBlock).as_bool() {\n            ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast()).cast::<i32>() - 1;\n\n            BzpCalculateCost(huffman.cast(), st.cast(), ed.cast());\n\n            let mut id: i32 = BzpSelectTree(huffman.cast()).cast();\n\n            c_for!(let mut k: i32 = st; k <= ed; k.suffix_plus_plus(); {\n                huffman.huffmanGroups[id].weight[huffman.block[k]] += 1;\n            });\n            st = ed + 1;\n        }\n\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            BzpBuildTreeBalanceHeight(c_ref!(huffman.huffmanGroups[j]).cast());\n        });\n    });\n\n    BzpGenerateSelectMTF(huffman.cast());\n\n    c_for!(let mut i: i32 = 0; i < nGroups; i.suffix_plus_plus(); {\n        BzpGetHuffmanTable(c_ref!(huffman.huffmanGroups[i]).cast());\n    });\n}\n",
                "optimized_rust_code": "pub fn BzpHuffmanMain(mut huffman: Ptr<BzpHuffmanGroups>) {\n    let mut nGroups: i32 = BzpGetHuffmanGroups(huffman.nBlock);\n    huffman.nGroups = nGroups;\n\n    BzpInitLenArray(huffman);\n    let mut st: i32 = 0;\n    let mut ed: i32 = Default::default();\n\n    c_for!(let mut i: i32 = 0; i < BZP_MAX_ITER_NUM!(); i.suffix_plus_plus(); {\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            c_memset_s!(huffman.huffmanGroups[j].weight, c_sizeofval!(huffman.huffmanGroups[j].weight), 0,\n                       c_sizeofval!(huffman.huffmanGroups[j].weight)).cast::<Void>();\n        });\n\n        st = 0;\n        huffman.nSelect = 0;\n        while (st < huffman.nBlock) {\n            ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!()).cast::<i32>() - 1;\n\n            BzpCalculateCost(huffman, st, ed);\n\n            let mut id: i32 = BzpSelectTree(huffman);\n\n            c_for!(let mut k: i32 = st; k <= ed; k.suffix_plus_plus(); {\n                huffman.huffmanGroups[id].weight[huffman.block[k]] += 1;\n            });\n            st = ed + 1;\n        }\n\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            BzpBuildTreeBalanceHeight(c_ref!(huffman.huffmanGroups[j]));\n        });\n    });\n\n    BzpGenerateSelectMTF(huffman);\n\n    c_for!(let mut i: i32 = 0; i < nGroups; i.suffix_plus_plus(); {\n        BzpGetHuffmanTable(c_ref!(huffman.huffmanGroups[i]));\n    });\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007191396)\nerror[E0284]: type annotations needed\n   --> src/src/compress/bzp_huffman_encode_c.rs:283:82\n    |\n283 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast()).cast::<i32>() - 1;\n    |                                                  -                               ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |                                                  |\n    |                                                  type must be known at this point\n    |\n    = note: cannot satisfy `<i32 as std::ops::Add<_>>::Output == i32`\nhelp: consider specifying the generic argument\n    |\n283 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast::<T>()).cast::<i32>() - 1;\n    |                                                                                      +++++\n\nerror[E0283]: type annotations needed\n   --> src/src/compress/bzp_huffman_encode_c.rs:283:82\n    |\n283 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast()).cast::<i32>() - 1;\n    |                                                  -                               ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |                                                  |\n    |                                                  type must be known at this point\n    |\nnote: multiple `impl`s satisfying `i32: std::ops::Add<_>` found\n   --> src/translation_utils/types/num.rs:112:1\n    |\n112 | impl Add<Num> for i32 {\n    | ^^^^^^^^^^^^^^^^^^^^^\n    = note: and more `impl`s found in the following crates: `core`:\n            - impl std::ops::Add for i32;\n            - impl std::ops::Add<&i32> for i32;\nhelp: consider specifying the generic argument\n    |\n283 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast::<T>()).cast::<i32>() - 1;\n    |                                                                                      +++++\n\nSome errors have detailed explanations: E0283, E0284.\nFor more information about an error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007196080)\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n   --> src/src/compress/bzp_huffman_encode_c.rs:290:50\n    |\n290 |                 huffman.huffmanGroups[id].weight[huffman.block[k]] += 1;\n    |                 -------                         -^^^^^^^----------\n    |                 |                               ||\n    |                 |                               |immutable borrow occurs here\n    |                 |                               mutable borrow later used here\n    |                 mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/compress/bzp_huffman_encode_c.rs:290:50\n    |\n290 |                 huffman.huffmanGroups[id].weight[huffman.block[k]] += 1;\n    |                                                  ^^^^^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/compress/bzp_huffman_encode_c.rs:290:49\n    |\n290 |                 huffman.huffmanGroups[id].weight[huffman.block[k]] += 1;\n    |                                                 ^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void BzpNumEncode(BzpMtfInfo *mtf, int32_t num)\n    {\n        num <<= 1;\n\n        do\n        {\n            num >>= 1;\n            num--;\n            if (num & 1)\n            {\n                mtf->mtfV[mtf->nMtf++] = BZP_MTF_ENCODE1;\n                mtf->mtfFreq[BZP_MTF_ENCODE1]++;\n            }\n            else\n            {\n                mtf->mtfV[mtf->nMtf++] = BZP_MTF_ENCODE0;\n                mtf->mtfFreq[BZP_MTF_ENCODE0]++;\n            }\n        } while (num >= BZP_MTF_ENCODE_BASE);\n    }",
                "original_rust_code": "pub fn BzpNumEncode(mut mtf: Ptr<BzpMtfInfo>, mut num: i32) {\n    num <<= 1;\n    c_do!({\n        num >>= 1;\n        num -= 1;\n        if (num & 1).as_bool() {\n            mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE1!();\n            mtf.nMtf += 1;\n            mtf.mtfFreq[BZP_MTF_ENCODE1!()] += 1;\n        } else {\n            mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE0!();\n            mtf.nMtf += 1;\n            mtf.mtfFreq[BZP_MTF_ENCODE0!()] += 1;\n        }\n    } while num >= BZP_MTF_ENCODE_BASE!());\n}\n",
                "optimized_rust_code": "pub fn BzpNumEncode(mut mtf: Ptr<BzpMtfInfo>, mut num: i32) {\n    num <<= 1;\n    c_do!({\n        num >>= 1;\n        num -= 1;\n        if (num & 1) {\n            let tmp0 = mtf.nMtf;\n            mtf.mtfV[tmp0] = BZP_MTF_ENCODE1!();\n            mtf.nMtf += 1;\n            mtf.mtfFreq[BZP_MTF_ENCODE1!()] += 1;\n        } else {\n            mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE0!();\n            mtf.nMtf += 1;\n            mtf.mtfFreq[BZP_MTF_ENCODE0!()] += 1;\n        }\n    } while num >= BZP_MTF_ENCODE_BASE!());\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007210997)\nerror[E0502]: cannot borrow `mtf` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_mtf_encode_c.rs:56:22\n   |\n56 |             mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE1!();\n   |             ---     -^^^------\n   |             |       ||\n   |             |       |immutable borrow occurs here\n   |             |       mutable borrow later used here\n   |             mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_mtf_encode_c.rs:56:22\n   |\n56 |             mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE1!();\n   |                      ^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_mtf_encode_c.rs:56:21\n   |\n56 |             mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE1!();\n   |                     ^^^^^^^^^^\n\nerror[E0502]: cannot borrow `mtf` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_mtf_encode_c.rs:60:22\n   |\n60 |             mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE0!();\n   |             ---     -^^^------\n   |             |       ||\n   |             |       |immutable borrow occurs here\n   |             |       mutable borrow later used here\n   |             mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_mtf_encode_c.rs:60:22\n   |\n60 |             mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE0!();\n   |                      ^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_mtf_encode_c.rs:60:21\n   |\n60 |             mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE0!();\n   |                     ^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007212755)\nerror[E0308]: mismatched types\n  --> src/src/compress/bzp_mtf_encode_c.rs:55:12\n   |\n55 |         if (num & 1) {\n   |            ^^^^^^^^^ expected `bool`, found `i32`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void BzpMtfMain(BzpMtfInfo *mtf)\n    {\n        uint8_t list[BZP_MAX_ALPHA_SIZE];\n        int32_t EOB;\n        int32_t num = 0;\n        BzpMapInputChar(mtf, list, BZP_MAX_ALPHA_SIZE);\n        EOB = mtf->nUse + 1;\n        for (int32_t i = 0; i <= EOB; i++)\n        {\n            mtf->mtfFreq[i] = 0;\n        }\n        for (int32_t i = 0; i < mtf->nBlock; i++)\n        {\n            int32_t pos = mtf->map[i] - 1;\n            if (pos < 0)\n            {\n                pos += mtf->nBlock;\n            }\n            uint8_t ch = mtf->block[pos];\n            if (ch == list[0])\n            {\n                num++;\n            }\n            else\n            {\n                if (num > 0)\n                {\n                    BzpNumEncode(mtf, num);\n                    num = 0;\n                }\n                int32_t pos_ = 1;\n                while (ch != list[pos_] && pos_ < mtf->nUse)\n                {\n                    pos_++;\n                }\n\n                for (int32_t j = pos_; j > 0; j--)\n                {\n                    list[j] = list[j - 1];\n                }\n                list[0] = ch;\n\n                mtf->mtfV[mtf->nMtf] = pos_ + 1;\n                mtf->mtfFreq[pos_ + 1]++;\n                mtf->nMtf++;\n            }\n        }\n        if (num > 0)\n        {\n            BzpNumEncode(mtf, num);\n        }\n\n        mtf->mtfV[mtf->nMtf] = EOB;\n        mtf->mtfFreq[EOB]++;\n        mtf->nMtf++;\n    }",
                "original_rust_code": "pub fn BzpMtfMain(mut mtf: Ptr<BzpMtfInfo>) {\n    let mut list: Array<u8, { BZP_MAX_ALPHA_SIZE!() }> = Default::default();\n    let mut EOB: i32 = Default::default();\n    let mut num: i32 = 0;\n    BzpMapInputChar(mtf.cast(), list.cast(), BZP_MAX_ALPHA_SIZE!().cast());\n    EOB = (mtf.nUse + 1).cast();\n    c_for!(let mut i: i32 = 0; i <= EOB; i.suffix_plus_plus(); {\n        mtf.mtfFreq[i] = 0;\n    });\n    c_for!(let mut i: i32 = 0; i < mtf.nBlock; i.suffix_plus_plus(); {\n        let mut pos: i32 = (mtf.map[i] - 1).cast();\n        if (pos < 0).as_bool() {\n            pos += mtf.nBlock;\n        }\n        let mut ch: u8 = mtf.block[pos].cast();\n        if (ch == list[0]).as_bool() {\n            num += 1;\n        } else {\n            if (num > 0).as_bool() {\n                BzpNumEncode(mtf.cast(), num.cast());\n                num = 0;\n            }\n            let mut pos_: i32 = 1;\n            while (ch != list[pos_]).as_bool() && (pos_ < mtf.nUse).as_bool() {\n                pos_ += 1;\n            }\n            c_for!(let mut j: i32 = pos_; j > 0; j.suffix_minus_minus(); {\n                list[j] = list[j - 1].cast();\n            });\n            list[0] = ch.cast();\n            mtf.mtfV[mtf.nMtf] = (pos_ + 1).cast();\n            mtf.mtfFreq[pos_ + 1] += 1;\n            mtf.nMtf += 1;\n        }\n    });\n    if (num > 0).as_bool() {\n        BzpNumEncode(mtf.cast(), num.cast());\n    }\n    mtf.mtfV[mtf.nMtf] = EOB.cast();\n    mtf.mtfFreq[EOB] += 1;\n    mtf.nMtf += 1;\n}\n",
                "optimized_rust_code": "pub fn BzpMtfMain(mut mtf: Ptr<BzpMtfInfo>) {\n    let mut list: Array<u8, { BZP_MAX_ALPHA_SIZE!() }> = Default::default();\n    let mut EOB: i32 = Default::default();\n    let mut num: i32 = 0;\n    BzpMapInputChar(mtf, list, BZP_MAX_ALPHA_SIZE!());\n    EOB = (mtf.nUse + 1);\n    c_for!(let mut i: i32 = 0; i <= EOB; i.suffix_plus_plus(); {\n        mtf.mtfFreq[i] = 0;\n    });\n    c_for!(let mut i: i32 = 0; i < mtf.nBlock; i.suffix_plus_plus(); {\n        let mut pos: i32 = (mtf.map[i] - 1);\n        if (pos < 0) {\n            pos += mtf.nBlock;\n        }\n        let mut ch: u8 = mtf.block[pos];\n        if (ch == list[0]) {\n            num += 1;\n        } else {\n            if (num > 0) {\n                BzpNumEncode(mtf, num);\n                num = 0;\n            }\n            let mut pos_: i32 = 1;\n            while (ch != list[pos_]) && (pos_ < mtf.nUse) {\n                pos_ += 1;\n            }\n            c_for!(let mut j: i32 = pos_; j > 0; j.suffix_minus_minus(); {\n                list[j] = list[j - 1];\n            });\n            list[0] = ch;\n            let tmp0 = mtf.nMtf;\n            mtf.mtfV[tmp0] = (pos_ + 1);\n            mtf.mtfFreq[pos_ + 1] += 1;\n            mtf.nMtf += 1;\n        }\n    });\n    if (num > 0) {\n        BzpNumEncode(mtf, num);\n    }\n    mtf.mtfV[mtf.nMtf] = EOB;\n    mtf.mtfFreq[EOB] += 1;\n    mtf.nMtf += 1;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007212983)\nerror[E0502]: cannot borrow `mtf` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_mtf_encode_c.rs:85:22\n   |\n85 |             mtf.mtfV[mtf.nMtf] = (pos_ + 1).cast();\n   |             ---     -^^^------\n   |             |       ||\n   |             |       |immutable borrow occurs here\n   |             |       mutable borrow later used here\n   |             mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_mtf_encode_c.rs:85:22\n   |\n85 |             mtf.mtfV[mtf.nMtf] = (pos_ + 1).cast();\n   |                      ^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_mtf_encode_c.rs:85:21\n   |\n85 |             mtf.mtfV[mtf.nMtf] = (pos_ + 1).cast();\n   |                     ^^^^^^^^^^\n\nerror[E0502]: cannot borrow `mtf` as immutable because it is also borrowed as mutable\n  --> src/src/compress/bzp_mtf_encode_c.rs:93:14\n   |\n93 |     mtf.mtfV[mtf.nMtf] = EOB.cast();\n   |     ---     -^^^------\n   |     |       ||\n   |     |       |immutable borrow occurs here\n   |     |       mutable borrow later used here\n   |     mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/compress/bzp_mtf_encode_c.rs:93:14\n   |\n93 |     mtf.mtfV[mtf.nMtf] = EOB.cast();\n   |              ^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/compress/bzp_mtf_encode_c.rs:93:13\n   |\n93 |     mtf.mtfV[mtf.nMtf] = EOB.cast();\n   |             ^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007219248)\nerror[E0308]: mismatched types\n  --> src/src/compress/bzp_mtf_encode_c.rs:59:26\n   |\n59 |     BzpMapInputChar(mtf, list, BZP_MAX_ALPHA_SIZE!());\n   |     ---------------      ^^^^ expected `Ptr<u8>`, found `Array<u8, 258>`\n   |     |\n   |     arguments to this function are incorrect\n   |\n   = note: expected struct `memory::ptr::Ptr<u8>`\n              found struct `types::array::Array<u8, 258>`\nnote: function defined here\n  --> src/src/compress/bzp_mtf_encode_c.rs:37:8\n   |\n37 | pub fn BzpMapInputChar(mut mtf: Ptr<BzpMtfInfo>, mut list: Ptr<u8>, mut lenList: i32) {\n   |        ^^^^^^^^^^^^^^^                           -----------------\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void BzpGetOneTable(BzpHuffmanDecode *huffman, int32_t t)\n    {\n        int32_t vec = 0, cnt = 0;\n        int32_t mi = huffman->len[t][0], mx = huffman->len[t][0];\n        for (int32_t i = 0; i < huffman->alphaSize; i++)\n        {\n            mi = BZP_MIN_FUN(mi, huffman->len[t][i]);\n            mx = BZP_MAX_FUN(mx, huffman->len[t][i]);\n        }\n        huffman->minLens[t] = mi;\n        for (int32_t i = mi; i <= mx; i++)\n        {\n            for (int32_t j = 0; j < huffman->alphaSize; j++)\n            {\n                if (huffman->len[t][j] == i)\n                {\n                    huffman->perm[t][cnt++] = j;\n                }\n            }\n        }\n        for (int32_t i = 0; i < huffman->alphaSize; i++)\n        {\n            huffman->base[t][huffman->len[t][i] + 1]++;\n        }\n\n        for (int32_t i = 1; i <= mx + 1; i++)\n        {\n            huffman->base[t][i] += huffman->base[t][i - 1];\n        }\n\n        for (int32_t i = mi; i <= mx; i++)\n        {\n\n            vec += (huffman->base[t][i + 1] - huffman->base[t][i]);\n\n            huffman->limit[t][i] = vec - 1;\n            vec <<= 1;\n        }\n        for (int32_t i = mi + 1; i <= mx; i++)\n        {\n            huffman->base[t][i] = ((huffman->limit[t][i - 1] + 1) << 1) - huffman->base[t][i];\n        }\n    }",
                "original_rust_code": "pub fn BzpGetOneTable(mut huffman: Ptr<BzpHuffmanDecode>, mut t: i32) {\n    let mut vec: i32 = 0;\n    let mut cnt: i32 = 0;\n    let mut mi: i32 = huffman.len[t][0];\n    let mut mx: i32 = huffman.len[t][0];\n    c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        mi = BZP_MIN_FUN!(mi, huffman.len[t][i]);\n        mx = BZP_MAX_FUN!(mx, huffman.len[t][i]);\n    });\n    huffman.minLens[t] = mi;\n    c_for!(let mut i: i32 = mi; i <= mx; i.suffix_plus_plus(); {\n        c_for!(let mut j: i32 = 0; j < huffman.alphaSize; j.suffix_plus_plus(); {\n            if (huffman.len[t][j] == i).as_bool() {\n                huffman.perm[t][cnt] = j;\n                cnt += 1;\n            }\n        });\n    });\n    c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        huffman.base[t][huffman.len[t][i] + 1] += 1;\n    });\n    c_for!(let mut i: i32 = 1; i <= mx + 1; i.suffix_plus_plus(); {\n        huffman.base[t][i] += huffman.base[t][i - 1];\n    });\n    c_for!(let mut i: i32 = mi; i <= mx; i.suffix_plus_plus(); {\n        vec += (huffman.base[t][i + 1] - huffman.base[t][i]);\n        huffman.limit[t][i] = vec - 1;\n        vec <<= 1;\n    });\n    c_for!(let mut i: i32 = mi + 1; i <= mx; i.suffix_plus_plus(); {\n        huffman.base[t][i] = ((huffman.limit[t][i - 1] + 1) << 1) - huffman.base[t][i];\n    });\n}\n",
                "optimized_rust_code": "pub fn BzpGetOneTable(mut huffman: Ptr<BzpHuffmanDecode>, mut t: i32) {\n    let mut vec: i32 = 0;\n    let mut cnt: i32 = 0;\n    let mut mi: i32 = huffman.len[t][0];\n    let mut mx: i32 = huffman.len[t][0];\n    c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        mi = BZP_MIN_FUN!(mi, huffman.len[t][i]);\n        mx = BZP_MAX_FUN!(mx, huffman.len[t][i]);\n    });\n    huffman.minLens[t] = mi;\n    c_for!(let mut i: i32 = mi; i <= mx; i.suffix_plus_plus(); {\n        c_for!(let mut j: i32 = 0; j < huffman.alphaSize; j.suffix_plus_plus(); {\n            if (huffman.len[t][j] == i) {\n                huffman.perm[t][cnt] = j;\n                cnt += 1;\n            }\n        });\n    });\n    c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        huffman.base[t][huffman.len[t][i] + 1] += 1;\n    });\n    c_for!(let mut i: i32 = 1; i <= mx + 1; i.suffix_plus_plus(); {\n        let tmp0 = t;\n        huffman.base[tmp0][i - 1];\n    });\n    c_for!(let mut i: i32 = mi; i <= mx; i.suffix_plus_plus(); {\n        vec += (huffman.base[t][i + 1] - huffman.base[t][i]);\n        huffman.limit[t][i] = vec - 1;\n        vec <<= 1;\n    });\n    c_for!(let mut i: i32 = mi + 1; i <= mx; i.suffix_plus_plus(); {\n        huffman.base[t][i] = ((huffman.limit[t][i - 1] + 1) << 1) - huffman.base[t][i];\n    });\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007220935)\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/decompress/bzp_huffman_decode_c.rs:54:25\n   |\n54 |         huffman.base[t][huffman.len[t][i] + 1] += 1;\n   |         -------        -^^^^^^^---------------\n   |         |              ||\n   |         |              |immutable borrow occurs here\n   |         |              mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/decompress/bzp_huffman_decode_c.rs:54:25\n   |\n54 |         huffman.base[t][huffman.len[t][i] + 1] += 1;\n   |                         ^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/decompress/bzp_huffman_decode_c.rs:54:24\n   |\n54 |         huffman.base[t][huffman.len[t][i] + 1] += 1;\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007222896)\nerror[E0502]: cannot borrow `huffman` as immutable because it is also borrowed as mutable\n  --> src/src/decompress/bzp_huffman_decode_c.rs:54:25\n   |\n54 |         huffman.base[t][huffman.len[t][i] + 1] += 1;\n   |         -------        -^^^^^^^---------------\n   |         |              ||\n   |         |              |immutable borrow occurs here\n   |         |              mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/decompress/bzp_huffman_decode_c.rs:54:25\n   |\n54 |         huffman.base[t][huffman.len[t][i] + 1] += 1;\n   |                         ^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/decompress/bzp_huffman_decode_c.rs:54:24\n   |\n54 |         huffman.base[t][huffman.len[t][i] + 1] += 1;\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "uint32_t BzpReadBits(int32_t nBit, InDeComdata *inData)\n    {\n        uint32_t res = 0;\n\n        while (inData->nBuf < nBit)\n        {\n            if (inData->input->nBuf == inData->input->pos)\n            {\n                inData->input->nBuf =\n                    fread(inData->input->buf, sizeof(char), sizeof(inData->input->buf), inData->input->filePtr);\n                inData->input->pos = 0;\n            }\n            int32_t data = ((uint32_t)(inData->input->buf[inData->input->pos]));\n\n            inData->buf = (inData->buf << BZP_BITS8) | data;\n            inData->input->pos++;\n            inData->nBuf += BZP_BITS8;\n        }\n        res = inData->buf >> (inData->nBuf - nBit);\n        res = res & ((1 << nBit) - 1);\n        inData->nBuf -= nBit;\n        return res;\n    }",
                "original_rust_code": "pub fn BzpReadBits(mut nBit: i32, mut inData: Ptr<InDeComdata>) -> u32 {\n    let mut res: u32 = 0;\n    while (inData.nBuf < nBit).as_bool() {\n        if (inData.input.nBuf == inData.input.pos).as_bool() {\n            inData.input.nBuf = c_fread!(inData.input.buf, c_sizeof!(char), c_sizeofval!(inData.input.buf), inData.input.filePtr).cast();\n            inData.input.pos = 0;\n        }\n        let mut data: i32 = (inData.input.buf[inData.input.pos]).cast::<u32>();\n        inData.buf = (inData.buf << BZP_BITS8!()) | data.cast::<u32>();\n        inData.input.pos += 1;\n        inData.nBuf += BZP_BITS8!();\n    }\n    res = (inData.buf >> (inData.nBuf - nBit)).cast();\n    res = (res & ((1 << nBit) - 1)).cast();\n    inData.nBuf -= nBit;\n    return res.cast();\n}\n",
                "optimized_rust_code": "pub fn BzpReadBits(mut nBit: i32, mut inData: Ptr<InDeComdata>) -> u32 {\n    let mut res: u32 = 0;\n    while (inData.nBuf < nBit) {\n        if (inData.input.nBuf == inData.input.pos) {\n            inData.input.nBuf = c_fread!(inData.input.buf, c_sizeof!(char), c_sizeofval!(inData.input.buf), inData.input.filePtr);\n            inData.input.pos = 0;\n        }\n        let tmp0 = inData.input.pos;\n        let mut data: i32 = (inData.input.buf[tmp0]).cast::<u32>();\n        inData.buf = (inData.buf << BZP_BITS8!()) | data.cast::<u32>();\n        inData.input.pos += 1;\n        inData.nBuf += BZP_BITS8!();\n    }\n    res = (inData.buf >> (inData.nBuf - nBit));\n    res = (res & ((1 << nBit) - 1));\n    inData.nBuf -= nBit;\n    return res;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007224679)\nerror[E0282]: type annotations needed\n   --> src/translation_utils/memory/file_ptr.rs:368:9\n    |\n368 |         fread($ptr.cast(), $size.cast(), $count.cast(), &mut $file).cast()\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:33:33\n    |\n33  |             inData.input.nBuf = c_fread!(inData.input.buf, c_sizeof!(char), c_sizeofval!(inData.input.buf), inData.input.filePtr).cast();\n    |                                 ------------------------------------------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `c_fread` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> src/src/public/bzp_decompress_stream_c.rs:36:29\n   |\n36 |         let mut data: i32 = (inData.input.buf[inData.input.pos]).cast::<u32>();\n   |                       ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `u32`\n   |                       |\n   |                       expected due to this\n   |\nhelp: you can convert a `u32` to an `i32` and panic if the converted value doesn't fit\n   |\n36 |         let mut data: i32 = (inData.input.buf[inData.input.pos]).cast::<u32>().try_into().unwrap();\n   |                                                                               ++++++++++++++++++++\n\nSome errors have detailed explanations: E0282, E0308.\nFor more information about an error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007227800)\nerror[E0308]: mismatched types\n  --> src/src/public/bzp_decompress_stream_c.rs:37:29\n   |\n37 |         let mut data: i32 = (inData.input.buf[tmp0]).cast::<u32>();\n   |                       ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `u32`\n   |                       |\n   |                       expected due to this\n   |\nhelp: you can convert a `u32` to an `i32` and panic if the converted value doesn't fit\n   |\n37 |         let mut data: i32 = (inData.input.buf[tmp0]).cast::<u32>().try_into().unwrap();\n   |                                                                   ++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int32_t BzpMTFDeCode(InDeComdata *inData, BzpHuffmanDecode *huffman, BzpBwtDecodeInfo *debwt)\n    {\n        debwt->nBlock = 0;\n        uint8_t ch;\n        int32_t ninUse = huffman->alphaSize - BZP_EXTRA_CHARS_NUM;\n        int32_t eob = ninUse + 1;\n        int32_t val = BzpHuffmanDecodeStep(huffman, inData);\n        while (val != eob && val != -1)\n        {\n            if (val == 0 || val == 1)\n            {\n                int32_t res = 0, basenum = 1;\n                while (val == 0 || val == 1)\n                {\n                    res = res + (val + 1) * basenum;\n                    basenum <<= 1;\n                    val = BzpHuffmanDecodeStep(huffman, inData);\n                }\n                for (int32_t j = 0; j < res; j++)\n                {\n                    debwt->block[debwt->nBlock++] = inData->list[0];\n                }\n            }\n            else\n            {\n                int32_t pos = val - 1;\n                ch = inData->list[pos];\n                debwt->block[debwt->nBlock++] = ch;\n\n                for (int32_t j = pos; j > 0; j--)\n                {\n                    inData->list[j] = inData->list[j - 1];\n                }\n                inData->list[0] = ch;\n                val = BzpHuffmanDecodeStep(huffman, inData);\n            }\n        }\n        if (val == -1)\n        {\n            return BZP_ERROR_DATA;\n        }\n        return BZP_OK;\n    }",
                "original_rust_code": "pub fn BzpMTFDeCode(mut inData: Ptr<InDeComdata>, mut huffman: Ptr<BzpHuffmanDecode>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    debwt.nBlock = 0;\n    let mut ch: u8 = Default::default();\n    let mut ninUse: i32 = huffman.alphaSize - BZP_EXTRA_CHARS_NUM!();\n    let mut eob: i32 = ninUse + 1;\n    let mut val: i32 = BzpHuffmanDecodeStep(huffman.cast(), inData.cast()).cast();\n    while (val != eob).as_bool() && (val != -1).as_bool() {\n        if (val == 0).as_bool() || (val == 1).as_bool() {\n            let mut res: i32 = 0;\n            let mut basenum: i32 = 1;\n            while (val == 0).as_bool() || (val == 1).as_bool() {\n                res = res + (val + 1) * basenum;\n                basenum <<= 1;\n                val = BzpHuffmanDecodeStep(huffman.cast(), inData.cast()).cast();\n            }\n            c_for!(let mut j: i32 = 0; j < res; j.suffix_plus_plus(); {\n                debwt.block[debwt.nBlock.suffix_plus_plus()] = inData.list[0].cast();\n            });\n        } else {\n            let mut pos: i32 = val - 1;\n            ch = inData.list[pos].cast();\n            debwt.block[debwt.nBlock.suffix_plus_plus()] = ch.cast();\n            c_for!(let mut j: i32 = pos; j > 0; j.suffix_minus_minus(); {\n                inData.list[j] = inData.list[j - 1].cast();\n            });\n            inData.list[0] = ch.cast();\n            val = BzpHuffmanDecodeStep(huffman.cast(), inData.cast()).cast();\n        }\n    }\n    if (val == -1).as_bool() {\n        return BZP_ERROR_DATA!();\n    }\n    return BZP_OK!();\n}\n",
                "optimized_rust_code": "pub fn BzpMTFDeCode(mut inData: Ptr<InDeComdata>, mut huffman: Ptr<BzpHuffmanDecode>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    debwt.nBlock = 0;\n    let mut ch: u8 = Default::default();\n    let mut ninUse: i32 = huffman.alphaSize - BZP_EXTRA_CHARS_NUM!();\n    let mut eob: i32 = ninUse + 1;\n    let mut val: i32 = BzpHuffmanDecodeStep(huffman, inData);\n    while (val != eob) && (val != -1) {\n        if (val == 0) || (val == 1) {\n            let mut res: i32 = 0;\n            let mut basenum: i32 = 1;\n            while (val == 0) || (val == 1) {\n                res = res + (val + 1) * basenum;\n                basenum <<= 1;\n                val = BzpHuffmanDecodeStep(huffman, inData);\n            }\n            c_for!(let mut j: i32 = 0; j < res; j.suffix_plus_plus(); {\n                let tmp0 = debwt.nBlock.suffix_plus_plus();\n                debwt.block[tmp0] = inData.list[0];\n            });\n        } else {\n            let mut pos: i32 = val - 1;\n            ch = inData.list[pos].cast();\n            debwt.block[debwt.nBlock.suffix_plus_plus()] = ch;\n            c_for!(let mut j: i32 = pos; j > 0; j.suffix_minus_minus(); {\n                inData.list[j] = inData.list[j - 1];\n            });\n            inData.list[0] = ch.cast();\n            val = BzpHuffmanDecodeStep(huffman, inData);\n        }\n    }\n    if (val == -1) {\n        return BZP_ERROR_DATA!();\n    }\n    return BZP_OK!();\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007239129)\nerror[E0499]: cannot borrow `debwt` as mutable more than once at a time\n   --> src/src/public/bzp_decompress_stream_c.rs:198:29\n    |\n198 |                 debwt.block[debwt.nBlock.suffix_plus_plus()] = inData.list[0].cast();\n    |                 -----      -^^^^^---------------------------\n    |                 |          ||\n    |                 |          |second mutable borrow occurs here\n    |                 |          first borrow later used here\n    |                 first mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/public/bzp_decompress_stream_c.rs:198:29\n    |\n198 |                 debwt.block[debwt.nBlock.suffix_plus_plus()] = inData.list[0].cast();\n    |                             ^^^^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/public/bzp_decompress_stream_c.rs:198:28\n    |\n198 |                 debwt.block[debwt.nBlock.suffix_plus_plus()] = inData.list[0].cast();\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0499]: cannot borrow `debwt` as mutable more than once at a time\n   --> src/src/public/bzp_decompress_stream_c.rs:203:25\n    |\n203 |             debwt.block[debwt.nBlock.suffix_plus_plus()] = ch.cast();\n    |             -----      -^^^^^---------------------------\n    |             |          ||\n    |             |          |second mutable borrow occurs here\n    |             |          first borrow later used here\n    |             first mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/public/bzp_decompress_stream_c.rs:203:25\n    |\n203 |             debwt.block[debwt.nBlock.suffix_plus_plus()] = ch.cast();\n    |                         ^^^^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/public/bzp_decompress_stream_c.rs:203:24\n    |\n203 |             debwt.block[debwt.nBlock.suffix_plus_plus()] = ch.cast();\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007247804)\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_decompress_stream_c.rs:199:37\n    |\n199 |                 debwt.block[tmp0] = inData.list[0];\n    |                 -----------------   ^^^^^^^^^^^^^^ expected `u8`, found `i32`\n    |                 |\n    |                 expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int32_t BzpDeCodeToStream(InDeComdata *inData, BzpBwtDecodeInfo *debwt)\n    {\n        uint8_t ch;\n        int32_t ret = BZP_OK;\n        for (int32_t i = 0; i < debwt->nBlock; i++)\n        {\n            ch = debwt->deCode[i];\n            if (inData->num == BZP_RLC_NUM_4)\n            {\n                for (int32_t j = 0; j < ((int32_t)ch); j++)\n                {\n                    BZP_UPDATE_CRC(inData->blockCRC, (uint8_t)inData->lasChar);\n                    ret |= BzpWriteChar(inData->lasChar, inData);\n                }\n                inData->lasChar = BZP_ASCII_SIZE;\n                inData->num = 0;\n            }\n            else if (ch == inData->lasChar)\n            {\n                BZP_UPDATE_CRC(inData->blockCRC, ch);\n                ret = BzpWriteChar(ch, inData);\n                inData->num++;\n            }\n            else\n            {\n                BZP_UPDATE_CRC(inData->blockCRC, ch);\n                ret = BzpWriteChar(ch, inData);\n                inData->lasChar = ch;\n                inData->num = 1;\n            }\n            if (ret != BZP_OK)\n                break;\n        }\n        return ret;\n    }",
                "original_rust_code": "pub fn BzpDeCodeToStream(mut inData: Ptr<InDeComdata>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    let mut ch: u8 = Default::default();\n    let mut ret: i32 = BZP_OK!();\n    c_for!(let mut i: i32 = 0; i < debwt.nBlock; i.suffix_plus_plus(); {\n        ch = debwt.deCode[i].cast();\n        if (inData.num == BZP_RLC_NUM_4!()).as_bool() {\n            c_for!(let mut j: i32 = 0; j < ch.cast::<i32>(); j.suffix_plus_plus(); {\n                BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n                ret |= BzpWriteChar(inData.lasChar.cast(), inData.cast()).cast();\n            });\n            inData.lasChar = BZP_ASCII_SIZE!().cast();\n            inData.num = 0;\n        } else if (ch == inData.lasChar).as_bool() {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch);\n            ret = BzpWriteChar(ch.cast(), inData.cast()).cast();\n            inData.num += 1;\n        } else {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch);\n            ret = BzpWriteChar(ch.cast(), inData.cast()).cast();\n            inData.lasChar = ch.cast();\n            inData.num = 1;\n        }\n        if (ret != BZP_OK!()).as_bool() {\n            break;\n        }\n    });\n    return ret.cast();\n}\n",
                "optimized_rust_code": "pub fn BzpDeCodeToStream(mut inData: Ptr<InDeComdata>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    let mut ch: u8 = Default::default();\n    let mut ret: i32 = BZP_OK!();\n    c_for!(let mut i: i32 = 0; i < debwt.nBlock; i.suffix_plus_plus(); {\n        ch = debwt.deCode[i];\n        if (inData.num == BZP_RLC_NUM_4!()) {\n            c_for!(let mut j: i32 = 0; j < ch.cast::<i32>(); j.suffix_plus_plus(); {\n                BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n                ret |= BzpWriteChar(inData.lasChar.cast(), inData);\n            });\n            inData.lasChar = BZP_ASCII_SIZE!();\n            inData.num = 0;\n        } else if (ch == inData.lasChar) {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch);\n            ret = BzpWriteChar(ch, inData);\n            inData.num += 1;\n        } else {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch);\n            ret = BzpWriteChar(ch, inData);\n            inData.lasChar = ch.cast();\n            inData.num = 1;\n        }\n        if (ret != BZP_OK!()) {\n            break;\n        }\n    });\n    return ret;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007248042)\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:74\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                          ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:194:17\n    |\n194 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]: cannot index into a value of type `types::global::Global<types::array::Array<i32, 256>>`\n   --> src/src/public/bzp_stream_utils_h.rs:186:53\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:194:17\n    |\n194 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:72\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                        ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:194:17\n    |\n194 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_decompress_stream_c.rs:199:26\n    |\n199 |         } else if (ch == inData.lasChar).as_bool() {\n    |                    --    ^^^^^^^^^^^^^^ expected `u8`, found `i32`\n    |                    |\n    |                    expected because this is `u8`\n    |\nhelp: you can convert `ch` from `u8` to `i32`, matching the type of `inData.lasChar`\n    |\n199 |         } else if (i32::from(ch) == inData.lasChar).as_bool() {\n    |                    ++++++++++  +\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:74\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                          ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:200:13\n    |\n200 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]: cannot index into a value of type `types::global::Global<types::array::Array<i32, 256>>`\n   --> src/src/public/bzp_stream_utils_h.rs:186:53\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:200:13\n    |\n200 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:72\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                        ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:200:13\n    |\n200 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:74\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                          ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:204:13\n    |\n204 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]: cannot index into a value of type `types::global::Global<types::array::Array<i32, 256>>`\n   --> src/src/public/bzp_stream_utils_h.rs:186:53\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:204:13\n    |\n204 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:72\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                        ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:204:13\n    |\n204 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0608.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 10 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007256297)\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:74\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                          ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:194:17\n    |\n194 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]: cannot index into a value of type `types::global::Global<types::array::Array<i32, 256>>`\n   --> src/src/public/bzp_stream_utils_h.rs:186:53\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:194:17\n    |\n194 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:72\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                        ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:194:17\n    |\n194 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                 ------------------------------------------------------------- in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_decompress_stream_c.rs:199:26\n    |\n199 |         } else if (ch == inData.lasChar) {\n    |                    --    ^^^^^^^^^^^^^^ expected `u8`, found `i32`\n    |                    |\n    |                    expected because this is `u8`\n    |\nhelp: you can convert `ch` from `u8` to `i32`, matching the type of `inData.lasChar`\n    |\n199 |         } else if (i32::from(ch) == inData.lasChar) {\n    |                    ++++++++++  +\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:74\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                          ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:200:13\n    |\n200 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]: cannot index into a value of type `types::global::Global<types::array::Array<i32, 256>>`\n   --> src/src/public/bzp_stream_utils_h.rs:186:53\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:200:13\n    |\n200 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:72\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                        ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:200:13\n    |\n200 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:74\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                          ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:204:13\n    |\n204 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]: cannot index into a value of type `types::global::Global<types::array::Array<i32, 256>>`\n   --> src/src/public/bzp_stream_utils_h.rs:186:53\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:204:13\n    |\n204 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:72\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                        ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:204:13\n    |\n204 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |             ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0608.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 10 previous errors\n"
            },
            {
                "c_code": "int32_t BzpDeCompressOneBlock(InDeComdata *inData, BzpHuffmanDecode *huffman, BzpBwtDecodeInfo *debwt)\n    {\n\n        int32_t ret = BZP_OK;\n        BzpCheckFileHead(inData);\n        uint32_t blockCRC = BzpReadUInt32(inData);\n\n        (void)BzpReadBits(BZP_BIT, inData);\n\n        int32_t oriPtr = BzpReadUInt24(inData);\n        if (oriPtr < 0 || oriPtr > BZP_BASE_BLOCK_SIZE * inData->blockSize)\n        {\n            return BZP_ERROR_DATA;\n        }\n\n        int32_t ninUse = BzpGetDictionaryList(inData);\n        huffman->alphaSize = ninUse + BZP_EXTRA_CHARS_NUM;\n        huffman->nGroups = BzpReadBits(BZP_BITS3, inData);\n        if (huffman->nGroups < BZP_NGROUPS_NUM_0 || huffman->nGroups > BZP_NGROUPS_NUM_4)\n        {\n            return BZP_ERROR_DATA;\n        }\n        huffman->nSelect = BzpReadBits(BZP_BITS15, inData);\n\n        int32_t nSelectUpperLimit = (inData->blockSize * BZP_BASE_BLOCK_SIZE / BZP_ELEMS_NUM_IN_ONE_GROUP + 1);\n        if (huffman->nSelect < 1 || huffman->nSelect > nSelectUpperLimit)\n        {\n            return BZP_ERROR_DATA;\n        }\n\n        ret |= BzpDeHuffmanSelect(inData, huffman);\n\n        ret |= BzpDeHuffmanLen(inData, huffman);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n\n        BzpGenerateDecodeTable(huffman);\n\n        debwt->oriPtr = oriPtr;\n        ret = BzpMTFDeCode(inData, huffman, debwt);\n        if (ret != BZP_OK || debwt->nBlock >= BZP_BASE_BLOCK_SIZE * inData->blockSize)\n        {\n            return BZP_ERROR_DATA;\n        }\n\n        BzpBwtDecode(debwt);\n\n        ret = BzpDeCodeToStream(inData, debwt);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n        inData->blockCRC = ~(inData->blockCRC);\n\n        if (blockCRC != inData->blockCRC)\n        {\n            ret = BZP_ERROR_DATA;\n        }\n\n        return ret;\n    }",
                "original_rust_code": "pub fn BzpDeCompressOneBlock(mut inData: Ptr<InDeComdata>, mut huffman: Ptr<BzpHuffmanDecode>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    let mut ret: i32 = BZP_OK!();\n    BzpCheckFileHead(inData.cast());\n    let mut blockCRC: u32 = BzpReadUInt32(inData.cast()).cast();\n    BzpReadBits(BZP_BIT!(), inData.cast()).cast::<Void>();\n    let mut oriPtr: i32 = BzpReadUInt24(inData.cast()).cast();\n    if (oriPtr < 0 || oriPtr > BZP_BASE_BLOCK_SIZE!() * inData.blockSize).as_bool() {\n        return BZP_ERROR_DATA!();\n    }\n    let mut ninUse: i32 = BzpGetDictionaryList(inData.cast()).cast();\n    huffman.alphaSize = (ninUse + BZP_EXTRA_CHARS_NUM!()).cast();\n    huffman.nGroups = BzpReadBits(BZP_BITS3!(), inData.cast()).cast();\n    if (huffman.nGroups < BZP_NGROUPS_NUM_0!() || huffman.nGroups > BZP_NGROUPS_NUM_4!()).as_bool() {\n        return BZP_ERROR_DATA!();\n    }\n    huffman.nSelect = BzpReadBits(BZP_BITS15!(), inData.cast()).cast();\n    let mut nSelectUpperLimit: i32 = (inData.blockSize * BZP_BASE_BLOCK_SIZE!() / BZP_ELEMS_NUM_IN_ONE_GROUP!() + 1).cast();\n    if (huffman.nSelect < 1 || huffman.nSelect > nSelectUpperLimit).as_bool() {\n        return BZP_ERROR_DATA!();\n    }\n    ret |= BzpDeHuffmanSelect(inData.cast(), huffman.cast()).cast();\n    ret |= BzpDeHuffmanLen(inData.cast(), huffman.cast()).cast();\n    if (ret != BZP_OK!()).as_bool() {\n        return ret;\n    }\n    BzpGenerateDecodeTable(huffman.cast());\n    debwt.oriPtr = oriPtr.cast();\n    ret = BzpMTFDeCode(inData.cast(), huffman.cast(), debwt.cast()).cast();\n    if (ret != BZP_OK!() || debwt.nBlock >= BZP_BASE_BLOCK_SIZE!() * inData.blockSize).as_bool() {\n        return BZP_ERROR_DATA!();\n    }\n    BzpBwtDecode(debwt.cast());\n    ret = BzpDeCodeToStream(inData.cast(), debwt.cast()).cast();\n    if (ret != BZP_OK!()).as_bool() {\n        return ret;\n    }\n    inData.blockCRC = !(inData.blockCRC).cast();\n    if (blockCRC != inData.blockCRC).as_bool() {\n        ret = BZP_ERROR_DATA!();\n    }\n    return ret.cast();\n}\n",
                "optimized_rust_code": "pub fn BzpDeCompressOneBlock(mut inData: Ptr<InDeComdata>, mut huffman: Ptr<BzpHuffmanDecode>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    let mut ret: i32 = BZP_OK!();\n    BzpCheckFileHead(inData);\n    let mut blockCRC: u32 = BzpReadUInt32(inData);\n    BzpReadBits(BZP_BIT!(), inData).cast::<Void>();\n    let mut oriPtr: i32 = BzpReadUInt24(inData).cast();\n    if (oriPtr < 0 || oriPtr > BZP_BASE_BLOCK_SIZE!() * inData.blockSize) {\n        return BZP_ERROR_DATA!();\n    }\n    let mut ninUse: i32 = BzpGetDictionaryList(inData);\n    huffman.alphaSize = (ninUse + BZP_EXTRA_CHARS_NUM!());\n    huffman.nGroups = BzpReadBits(BZP_BITS3!(), inData);\n    if (huffman.nGroups < BZP_NGROUPS_NUM_0!() || huffman.nGroups > BZP_NGROUPS_NUM_4!()) {\n        return BZP_ERROR_DATA!();\n    }\n    huffman.nSelect = BzpReadBits(BZP_BITS15!(), inData).cast();\n    let mut nSelectUpperLimit: i32 = (inData.blockSize * BZP_BASE_BLOCK_SIZE!() / BZP_ELEMS_NUM_IN_ONE_GROUP!() + 1);\n    if (huffman.nSelect < 1 || huffman.nSelect > nSelectUpperLimit) {\n        return BZP_ERROR_DATA!();\n    }\n    ret |= BzpDeHuffmanSelect(inData, huffman);\n    ret |= BzpDeHuffmanLen(inData, huffman);\n    if (ret != BZP_OK!()) {\n        return ret;\n    }\n    BzpGenerateDecodeTable(huffman);\n    debwt.oriPtr = oriPtr;\n    ret = BzpMTFDeCode(inData, huffman, debwt);\n    if (ret != BZP_OK!() || debwt.nBlock >= BZP_BASE_BLOCK_SIZE!() * inData.blockSize) {\n        return BZP_ERROR_DATA!();\n    }\n    BzpBwtDecode(debwt);\n    ret = BzpDeCodeToStream(inData, debwt);\n    if (ret != BZP_OK!()) {\n        return ret;\n    }\n    inData.blockCRC = !(inData.blockCRC);\n    if (blockCRC != inData.blockCRC) {\n        ret = BZP_ERROR_DATA!();\n    }\n    return ret;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007256806)\nerror[E0282]: type annotations needed\n   --> src/src/public/bzp_decompress_stream_c.rs:251:42\n    |\n251 |     inData.blockCRC = !(inData.blockCRC).cast();\n    |                                          ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n251 |     inData.blockCRC = !(inData.blockCRC).cast::<T>();\n    |                                              +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007278597)\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_decompress_stream_c.rs:226:23\n    |\n226 |     huffman.nGroups = BzpReadBits(BZP_BITS3!(), inData);\n    |     ---------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `u32`\n    |     |\n    |     expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int32_t BZPDeCompressData(InDeComdata *inData)\n    {\n        int32_t ret = BZP_OK;\n        uint32_t caltotalCRC = 0;\n        uint8_t ch;\n        ret = BzpReadFileHead(inData);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n        BzpHuffmanDecode *huffman = BzpHuffmanDecodeInit(inData->blockSize);\n        BzpBwtDecodeInfo *debwt = BzpBwtDecodeInit(inData->blockSize);\n\n        while ((ch = BzpReadBits(BZP_BITS8, inData)) != BZP_FILE_END_0)\n        {\n            if (ch != BZP_BLOCK_HEAD_0)\n            {\n                ret = BZP_ERROR_DATA;\n                break;\n            }\n            BzpHuffmanDecodeReset(huffman);\n            inData->blockCRC = BZP_INIT_BLOCK_CRC;\n\n            ret = BzpDeCompressOneBlock(inData, huffman, debwt);\n            if (ret != BZP_OK)\n            {\n                break;\n            }\n\n            caltotalCRC = (caltotalCRC << 1) | (caltotalCRC >> BZP_CRC_MOVE_RIGHT_VAL);\n            caltotalCRC ^= inData->blockCRC;\n        }\n        if (ret == BZP_OK)\n        {\n            ret = BZPReadFileEnd(inData, caltotalCRC);\n        }\n        BzpHuffmanDecodeFinish(huffman);\n        BzpBwtDecodeFinish(debwt);\n        return ret;\n    }",
                "original_rust_code": "pub fn BZPDeCompressData(mut inData: Ptr<InDeComdata>) -> i32 {\n    let mut ret: i32 = BZP_OK!();\n    let mut caltotalCRC: u32 = 0;\n    let mut ch: u8;\n    ret = BzpReadFileHead(inData.cast()).cast();\n    if (ret != BZP_OK!()).as_bool() {\n        return ret;\n    }\n    let mut huffman: Ptr<BzpHuffmanDecode> = BzpHuffmanDecodeInit(inData.blockSize.cast());\n    let mut debwt: Ptr<BzpBwtDecodeInfo> = BzpBwtDecodeInit(inData.blockSize.cast());\n\n    while {\n        ch = BzpReadBits(BZP_BITS8!(), inData.cast()).cast();\n        ch != BZP_FILE_END_0!()\n    } {\n        if (ch != BZP_BLOCK_HEAD_0!()).as_bool() {\n            ret = BZP_ERROR_DATA!();\n            break;\n        }\n        BzpHuffmanDecodeReset(huffman.cast());\n        inData.blockCRC = BZP_INIT_BLOCK_CRC!();\n\n        ret = BzpDeCompressOneBlock(inData.cast(), huffman.cast(), debwt.cast()).cast();\n        if (ret != BZP_OK!()).as_bool() {\n            break;\n        }\n\n        caltotalCRC = (caltotalCRC << 1) | (caltotalCRC >> BZP_CRC_MOVE_RIGHT_VAL!());\n        caltotalCRC ^= inData.blockCRC.cast();\n    }\n    if (ret == BZP_OK!()).as_bool() {\n        ret = BZPReadFileEnd(inData.cast(), caltotalCRC.cast()).cast();\n    }\n    BzpHuffmanDecodeFinish(huffman.cast());\n    BzpBwtDecodeFinish(debwt.cast());\n    return ret.cast();\n}\n",
                "optimized_rust_code": "pub fn BZPDeCompressData(mut inData: Ptr<InDeComdata>) -> i32 {\n    let mut ret: i32 = BZP_OK!();\n    let mut caltotalCRC: u32 = 0;\n    let mut ch: u8;\n    ret = BzpReadFileHead(inData);\n    if (ret != BZP_OK!()) {\n        return ret;\n    }\n    let mut huffman: Ptr<BzpHuffmanDecode> = BzpHuffmanDecodeInit(inData.blockSize);\n    let mut debwt: Ptr<BzpBwtDecodeInfo> = BzpBwtDecodeInit(inData.blockSize);\n\n    while {\n        ch = BzpReadBits(BZP_BITS8!(), inData);\n        ch != BZP_FILE_END_0!()\n    } {\n        if (ch != BZP_BLOCK_HEAD_0!()) {\n            ret = BZP_ERROR_DATA!();\n            break;\n        }\n        BzpHuffmanDecodeReset(huffman);\n        inData.blockCRC = BZP_INIT_BLOCK_CRC!();\n\n        ret = BzpDeCompressOneBlock(inData, huffman, debwt);\n        if (ret != BZP_OK!()) {\n            break;\n        }\n\n        caltotalCRC = (caltotalCRC << 1) | (caltotalCRC >> BZP_CRC_MOVE_RIGHT_VAL!());\n        caltotalCRC ^= inData.blockCRC;\n    }\n    if (ret == BZP_OK!()) {\n        ret = BZPReadFileEnd(inData, caltotalCRC);\n    }\n    BzpHuffmanDecodeFinish(huffman);\n    BzpBwtDecodeFinish(debwt);\n    return ret;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007279330)\nerror[E0283]: type annotations needed\n   --> src/src/public/bzp_decompress_stream_c.rs:300:40\n    |\n300 |         caltotalCRC ^= inData.blockCRC.cast();\n    |                     --                 ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |                     |\n    |                     type must be known at this point\n    |\n    = note: multiple `impl`s satisfying `u32: BitXorAssign<_>` found in the `core` crate:\n            - impl BitXorAssign for u32;\n            - impl BitXorAssign<&u32> for u32;\nhelp: consider specifying the generic argument\n    |\n300 |         caltotalCRC ^= inData.blockCRC.cast::<T>();\n    |                                            +++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007286175)\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_decompress_stream_c.rs:284:14\n    |\n275 |     let mut ch: u8;\n    |                 -- expected due to this type\n...\n284 |         ch = BzpReadBits(BZP_BITS8!(), inData);\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`, found `u32`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void BzpAddCharToBlock(uint8_t lasch, int32_t num, BzpBwtInfo *bwt)\n    {\n        if (num < BZP_RLC_NUM_LOWER_LIMIT || num > BZP_RLC_NUM_UPPER_LIMIT)\n        {\n            return;\n        }\n        for (int32_t i = 0; i < num; i++)\n        {\n            BZP_UPDATE_CRC(bwt->blockCRC, lasch);\n        }\n\n        int32_t val = BZP_MIN_FUN(num, (int32_t)BZP_RLC_NUM_4);\n        switch (val)\n        {\n        case BZP_RLC_NUM_4:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_3:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_2:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_1:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        default:\n            break;\n        }\n        if (num >= BZP_RLC_NUM_4)\n        {\n            bwt->block[bwt->nBlock++] = ((char)(num - BZP_RLC_NUM_4));\n            bwt->inUse[num - BZP_RLC_NUM_4] = true;\n        }\n\n        bwt->inUse[lasch] = true;\n    }",
                "original_rust_code": "pub fn BzpAddCharToBlock(mut lasch: u8, mut num: i32, mut bwt: Ptr<BzpBwtInfo>) {\n    if (num < BZP_RLC_NUM_LOWER_LIMIT!()).as_bool() || (num > BZP_RLC_NUM_UPPER_LIMIT!()).as_bool() {\n        return;\n    }\n    c_for!(let mut i: i32 = 0; i < num; i.suffix_plus_plus(); {\n        BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    });\n\n    let mut val: i32 = BZP_MIN_FUN!(num, BZP_RLC_NUM_4!().cast()).cast();\n    c_switch!(val, {\n        BZP_RLC_NUM_4!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch.cast();\n            break;\n        },\n        BZP_RLC_NUM_3!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch.cast();\n            break;\n        },\n        BZP_RLC_NUM_2!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch.cast();\n            break;\n        },\n        BZP_RLC_NUM_1!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch.cast();\n            break;\n        },\n        _ => {\n            break;\n        },\n    });\n    if (num >= BZP_RLC_NUM_4!()).as_bool() {\n        bwt.block[bwt.nBlock.suffix_plus_plus()] = (num - BZP_RLC_NUM_4!()).cast::<u8>();\n        bwt.inUse[num - BZP_RLC_NUM_4!()] = true;\n    }\n\n    bwt.inUse[lasch] = true;\n}\n",
                "optimized_rust_code": "pub fn BzpAddCharToBlock(mut lasch: u8, mut num: i32, mut bwt: Ptr<BzpBwtInfo>) {\n    if (num < BZP_RLC_NUM_LOWER_LIMIT!()) || (num > BZP_RLC_NUM_UPPER_LIMIT!()) {\n        return;\n    }\n    c_for!(let mut i: i32 = 0; i < num; i.suffix_plus_plus(); {\n        BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    });\n\n    let mut val: i32 = BZP_MIN_FUN!(num, BZP_RLC_NUM_4!());\n    c_switch!(val, {\n        BZP_RLC_NUM_4!() => {\n            let tmp0 = bwt.nBlock.suffix_plus_plus();\n            bwt.block[tmp0] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_3!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_2!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        BZP_RLC_NUM_1!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch;\n            break;\n        },\n        _ => {\n            break;\n        },\n    });\n    if (num >= BZP_RLC_NUM_4!()) {\n        bwt.block[bwt.nBlock.suffix_plus_plus()] = (num - BZP_RLC_NUM_4!()).cast::<u8>();\n        bwt.inUse[num - BZP_RLC_NUM_4!()] = true;\n    }\n\n    bwt.inUse[lasch] = true;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007300013)\nerror: no rules expected `,`\n   --> src/src/public/bzp_compress_stream_c.rs:348:18\n    |\n348 |     c_switch!(val, {\n    |                  ^ no rules expected this token in macro call\n    |\n   ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n    |\n3   | macro_rules! c_switch {\n    | --------------------- when calling this macro\n    |\nnote: while trying to match `;`\n   --> src/translation_utils/c_alignment/c_switch.rs:5:17\n    |\n5   |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n    |                 ^\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:74\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                          ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:344:9\n    |\n344 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]: cannot index into a value of type `types::global::Global<types::array::Array<i32, 256>>`\n   --> src/src/public/bzp_stream_utils_h.rs:186:53\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:344:9\n    |\n344 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:72\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                        ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:344:9\n    |\n344 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0608.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007304269)\nerror: no rules expected `,`\n   --> src/src/public/bzp_compress_stream_c.rs:348:18\n    |\n348 |     c_switch!(val, {\n    |                  ^ no rules expected this token in macro call\n    |\n   ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n    |\n3   | macro_rules! c_switch {\n    | --------------------- when calling this macro\n    |\nnote: while trying to match `;`\n   --> src/translation_utils/c_alignment/c_switch.rs:5:17\n    |\n5   |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n    |                 ^\n\nerror[E0308]: mismatched types\n   --> src/src/public/bzp_stream_utils_h.rs:186:74\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                          ^^^^^^^^^^^^^^ expected `u32`, found `u8`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:344:9\n    |\n344 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0608]: cannot index into a value of type `types::global::Global<types::array::Array<i32, 256>>`\n   --> src/src/public/bzp_stream_utils_h.rs:186:53\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:344:9\n    |\n344 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n   --> src/src/public/bzp_stream_utils_h.rs:186:72\n    |\n186 |         $crcVar = (($crcVar) << 8) ^ g_bzpCRC32Table[(($crcVar) >> 24) ^ (($cha) as u8)];\n    |                                                                        ^ no implementation for `u32 ^ u8`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:344:9\n    |\n344 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |         ------------------------------------ in this macro invocation\n    |\n    = help: the trait `BitXor<u8>` is not implemented for `u32`\n    = help: the following other types implement trait `BitXor<Rhs>`:\n              `&u32` implements `BitXor<u32>`\n              `&u32` implements `BitXor`\n              `u32` implements `BitXor<&u32>`\n              `u32` implements `BitXor`\n    = note: this error originates in the macro `BZP_UPDATE_CRC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0608.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
            }
        ]
    }
}