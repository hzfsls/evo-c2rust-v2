{
    "macro": {
        "all_cnt": 29,
        "passed_cnt": 29,
        "pass_rate": 1.0,
        "messages": []
    },
    "macro_function": {
        "all_cnt": 0,
        "passed_cnt": 0,
        "pass_rate": 100.0,
        "messages": []
    },
    "definition": {
        "all_cnt": 95,
        "passed_cnt": 95,
        "pass_rate": 1.0,
        "messages": []
    },
    "dummy_function": {
        "all_cnt": 200,
        "passed_cnt": 200,
        "pass_rate": 1.0,
        "messages": []
    },
    "function": {
        "all_cnt": 200,
        "passed_cnt": 188,
        "pass_rate": 0.94,
        "messages": [
            {
                "c_code": "void sortedarray_remove_range(SortedArray *sortedarray, unsigned int index, unsigned int length)\n{\n\n    if (index > sortedarray->length || index + length > sortedarray->length)\n    {\n        return;\n    }\n\n    memmove(&sortedarray->data[index], &sortedarray->data[index + length],\n            (sortedarray->length - (index + length)) * sizeof(SortedArrayValue));\n\n    sortedarray->length -= length;\n}",
                "original_rust_code": "pub fn sortedarray_remove_range(mut sortedarray: Ptr<SortedArray>, mut index: u32, mut length: u32) {\n    if (index > sortedarray.length).as_bool() || (index + length > sortedarray.length).as_bool() {\n        return;\n    }\n    c_memmove_s!(\n        c_ref!(sortedarray.data[index]).cast(),\n        c_ref!(sortedarray.data[index + length]).cast(),\n        (sortedarray.length - (index + length)) * c_sizeof!(SortedArrayValue)\n    );\n    sortedarray.length -= length;\n}\n",
                "optimized_rust_code": "pub fn sortedarray_remove_range(mut sortedarray: Ptr<SortedArray>, mut index: u32, mut length: u32) {\n    if (index > sortedarray.length) || (index + length > sortedarray.length) {\n        return;\n    }\n    c_memmove_s!(\n        c_ref!(sortedarray.data[index]),\n        c_ref!(sortedarray.data[index + length]),\n        (sortedarray.length - (index + length)) * c_sizeof!(SortedArrayValue)\n    );\n    sortedarray.length -= length;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003750158)\nerror: unexpected end of macro invocation\n   --> src/src/sortedarray_c.rs:109:78\n    |\n109 |         (sortedarray.length - (index + length)) * c_sizeof!(SortedArrayValue)\n    |                                                - help: missing comma here    ^ missing tokens in macro arguments\n    |\n   ::: src/translation_utils/c_alignment/libraries/safelib/c_memmove_s.rs:45:1\n    |\n45  | macro_rules! c_memmove_s {\n    | ------------------------ when calling this macro\n    |\nnote: while trying to match `,`\n   --> src/translation_utils/c_alignment/libraries/safelib/c_memmove_s.rs:46:42\n    |\n46  |     ($dst:expr, $dst_size:expr, $src:expr, $count:expr) => {\n    |                                          ^\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003752701)\nerror: unexpected end of macro invocation\n   --> src/src/sortedarray_c.rs:109:78\n    |\n109 |         (sortedarray.length - (index + length)) * c_sizeof!(SortedArrayValue)\n    |                                                - help: missing comma here    ^ missing tokens in macro arguments\n    |\n   ::: src/translation_utils/c_alignment/libraries/safelib/c_memmove_s.rs:45:1\n    |\n45  | macro_rules! c_memmove_s {\n    | ------------------------ when calling this macro\n    |\nnote: while trying to match `,`\n   --> src/translation_utils/c_alignment/libraries/safelib/c_memmove_s.rs:46:42\n    |\n46  |     ($dst:expr, $dst_size:expr, $src:expr, $count:expr) => {\n    |                                          ^\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "AVLTreeNode *avl_tree_insert(AVLTree *tree, AVLTreeKey key, AVLTreeValue value)\n{\n    AVLTreeNode **rover;\n    AVLTreeNode *new_node;\n    AVLTreeNode *previous_node;\n\n    rover = &tree->root_node;\n    previous_node = NULL;\n\n    while (*rover != NULL)\n    {\n        previous_node = *rover;\n        if (tree->compare_func(key, (*rover)->key) < 0)\n        {\n            rover = &((*rover)->children[AVL_TREE_NODE_LEFT]);\n        }\n        else\n        {\n            rover = &((*rover)->children[AVL_TREE_NODE_RIGHT]);\n        }\n    }\n\n    new_node = (AVLTreeNode *)malloc(sizeof(AVLTreeNode));\n\n    if (new_node == NULL)\n    {\n        return NULL;\n    }\n\n    new_node->children[AVL_TREE_NODE_LEFT] = NULL;\n    new_node->children[AVL_TREE_NODE_RIGHT] = NULL;\n    new_node->parent = previous_node;\n    new_node->key = key;\n    new_node->value = value;\n    new_node->height = 1;\n\n    *rover = new_node;\n\n    avl_tree_balance_to_root(tree, previous_node);\n\n    ++tree->num_nodes;\n\n    return new_node;\n}",
                "original_rust_code": "pub fn avl_tree_insert(mut tree: Ptr<AVLTree>, mut key: AVLTreeKey, mut value: AVLTreeValue) -> Ptr<AVLTreeNode> {\n    let mut rover: Ptr<Ptr<AVLTreeNode>> = Default::default();\n    let mut new_node: Ptr<AVLTreeNode> = Default::default();\n    let mut previous_node: Ptr<AVLTreeNode> = Default::default();\n\n    rover = c_ref!(tree.root_node).cast();\n    previous_node = NULL!();\n\n    while (*rover != NULL!()).as_bool() {\n        previous_node = *rover.cast();\n        if (tree.compare_func(key.cast(), (*rover).key.cast()) < 0) {\n            rover = c_ref!((*rover).children[AVL_TREE_NODE_LEFT!()]).cast();\n        } else {\n            rover = c_ref!((*rover).children[AVL_TREE_NODE_RIGHT!()]).cast();\n        }\n    }\n\n    new_node = c_malloc!(c_sizeof!(AVLTreeNode));\n\n    if (new_node == NULL!()).as_bool() {\n        return NULL!();\n    }\n\n    new_node.children[AVL_TREE_NODE_LEFT!()] = NULL!();\n    new_node.children[AVL_TREE_NODE_RIGHT!()] = NULL!();\n    new_node.parent = previous_node.cast();\n    new_node.key = key.cast();\n    new_node.value = value.cast();\n    new_node.height = 1;\n\n    *rover = new_node.cast();\n\n    avl_tree_balance_to_root(tree.cast(), previous_node.cast());\n\n    tree.num_nodes.prefix_plus_plus();\n\n    return new_node.cast();\n}\n",
                "optimized_rust_code": "pub fn avl_tree_insert(mut tree: Ptr<AVLTree>, mut key: AVLTreeKey, mut value: AVLTreeValue) -> Ptr<AVLTreeNode> {\n    let mut rover: Ptr<Ptr<AVLTreeNode>> = Default::default();\n    let mut new_node: Ptr<AVLTreeNode> = Default::default();\n    let mut previous_node: Ptr<AVLTreeNode> = Default::default();\n\n    rover = c_ref!(tree.root_node);\n    previous_node = NULL!();\n\n    while (*rover != NULL!()) {\n        previous_node = *rover;\n        if (tree.compare_func(key, (*rover).key) < 0) {\n            rover = c_ref!((*rover).children[AVL_TREE_NODE_LEFT!()]);\n        } else {\n            rover = c_ref!((*rover).children[AVL_TREE_NODE_RIGHT!()]);\n        }\n    }\n\n    new_node = c_malloc!(c_sizeof!(AVLTreeNode));\n\n    if (new_node == NULL!()) {\n        return NULL!();\n    }\n\n    new_node.children[AVL_TREE_NODE_LEFT!()] = NULL!();\n    new_node.children[AVL_TREE_NODE_RIGHT!()] = NULL!();\n    new_node.parent = previous_node;\n    new_node.key = key;\n    new_node.value = value;\n    new_node.height = 1;\n\n    *rover = new_node;\n\n    avl_tree_balance_to_root(tree, previous_node);\n\n    tree.num_nodes.prefix_plus_plus();\n\n    return new_node;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003762146)\nerror[E0282]: type annotations needed\n   --> src/src/avl_tree_c.rs:180:32\n    |\n180 |         previous_node = *rover.cast();\n    |                                ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n180 |         previous_node = *rover.cast::<T>();\n    |                                    +++++\n\nerror[E0599]: no method named `compare_func` found for struct `memory::ptr::Ptr<_AVLTree>` in the current scope\n   --> src/src/avl_tree_c.rs:181:18\n    |\n181 |         if (tree.compare_func(key.cast(), (*rover).key.cast()) < 0) {\n    |                  ^^^^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `compare_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `compare_func`, surround the field access with parentheses\n    |\n181 |         if ((tree.compare_func)(key.cast(), (*rover).key.cast()) < 0) {\n    |             +                 +\n\nSome errors have detailed explanations: E0282, E0599.\nFor more information about an error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003767352)\nerror[E0599]: no method named `compare_func` found for struct `memory::ptr::Ptr<_AVLTree>` in the current scope\n   --> src/src/avl_tree_c.rs:181:18\n    |\n181 |         if (tree.compare_func(key, (*rover).key) < 0) {\n    |                  ^^^^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `compare_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `compare_func`, surround the field access with parentheses\n    |\n181 |         if ((tree.compare_func)(key, (*rover).key) < 0) {\n    |             +                 +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "BloomFilter *bloom_filter_new(unsigned int table_size, BloomFilterHashFunc hash_func, unsigned int num_functions)\n{\n    BloomFilter *filter;\n\n    if (num_functions > sizeof(salts) / sizeof(*salts))\n    {\n        return NULL;\n    }\n\n    filter = malloc(sizeof(BloomFilter));\n\n    if (filter == NULL)\n    {\n        return NULL;\n    }\n\n    filter->table = calloc((table_size + 7) / 8, 1);\n\n    if (filter->table == NULL)\n    {\n        free(filter);\n        return NULL;\n    }\n\n    filter->hash_func = hash_func;\n    filter->num_functions = num_functions;\n    filter->table_size = table_size;\n\n    return filter;\n}",
                "original_rust_code": "pub fn bloom_filter_new(mut table_size: u32, mut hash_func: BloomFilterHashFunc, mut num_functions: u32) -> Ptr<BloomFilter> {\n    let mut filter: Ptr<BloomFilter>;\n\n    if (num_functions > (c_sizeofval!(salts) / c_sizeofval!(*salts))).as_bool() {\n        return NULL!();\n    }\n\n    filter = c_malloc!(c_sizeof!(BloomFilter));\n\n    if (filter == NULL!()).as_bool() {\n        return NULL!();\n    }\n\n    filter.table = c_calloc!((table_size + 7) / 8, 1);\n\n    if (filter.table == NULL!()).as_bool() {\n        c_free!(filter);\n        return NULL!();\n    }\n\n    filter.hash_func = hash_func.cast();\n    filter.num_functions = num_functions.cast();\n    filter.table_size = table_size.cast();\n\n    return filter.cast();\n}\n",
                "optimized_rust_code": "pub fn bloom_filter_new(mut table_size: u32, mut hash_func: BloomFilterHashFunc, mut num_functions: u32) -> Ptr<BloomFilter> {\n    let mut filter: Ptr<BloomFilter>;\n\n    if (num_functions > (c_sizeofval!(salts) / c_sizeofval!(*salts))) {\n        return NULL!();\n    }\n\n    filter = c_malloc!(c_sizeof!(BloomFilter));\n\n    if (filter == NULL!()) {\n        return NULL!();\n    }\n\n    filter.table = c_calloc!((table_size + 7) / 8, 1);\n\n    if (filter.table == NULL!()) {\n        c_free!(filter);\n        return NULL!();\n    }\n\n    filter.hash_func = hash_func;\n    filter.num_functions = num_functions;\n    filter.table_size = table_size;\n\n    return filter;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003777727)\nerror[E0614]: type `types::array::Array<u32, 64>` cannot be dereferenced\n  --> src/src/bloom_filter_c.rs:29:61\n   |\n29 |     if (num_functions > (c_sizeofval!(salts) / c_sizeofval!(*salts))).as_bool() {\n   |                                                             ^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src/src/bloom_filter_c.rs:29:25\n   |\n29 |     if (num_functions > (c_sizeofval!(salts) / c_sizeofval!(*salts))).as_bool() {\n   |         -------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `Num`\n   |         |\n   |         expected because this is `u32`\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003780932)\nerror[E0614]: type `types::array::Array<u32, 64>` cannot be dereferenced\n  --> src/src/bloom_filter_c.rs:29:61\n   |\n29 |     if (num_functions > (c_sizeofval!(salts) / c_sizeofval!(*salts))) {\n   |                                                             ^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src/src/bloom_filter_c.rs:29:25\n   |\n29 |     if (num_functions > (c_sizeofval!(salts) / c_sizeofval!(*salts))) {\n   |         -------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `Num`\n   |         |\n   |         expected because this is `u32`\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "void bloom_filter_insert(BloomFilter *bloomfilter, BloomFilterValue value)\n{\n    unsigned int hash;\n    unsigned int subhash;\n    unsigned int index;\n    unsigned int i;\n    unsigned char b;\n\n    hash = bloomfilter->hash_func(value);\n\n    for (i = 0; i < bloomfilter->num_functions; ++i)\n    {\n\n        subhash = hash ^ salts[i];\n\n        index = subhash % bloomfilter->table_size;\n\n        b = (unsigned char)(1 << (index % 8));\n        bloomfilter->table[index / 8] |= b;\n    }\n}",
                "original_rust_code": "pub fn bloom_filter_insert(mut bloomfilter: Ptr<BloomFilter>, mut value: BloomFilterValue) {\n    let mut hash: u32;\n    let mut subhash: u32;\n    let mut index: u32;\n    let mut i: u32;\n    let mut b: u8;\n\n    hash = bloomfilter.hash_func(value.cast());\n\n    c_for!(i = 0; i < bloomfilter.num_functions; i.prefix_plus_plus(); {\n        subhash = hash ^ salts[i];\n        index = subhash % bloomfilter.table_size;\n        b = (1 << (index % 8)).cast::<u8>();\n        bloomfilter.table[index / 8] |= b;\n    });\n}\n",
                "optimized_rust_code": "pub fn bloom_filter_insert(mut bloomfilter: Ptr<BloomFilter>, mut value: BloomFilterValue) {\n    let mut hash: u32;\n    let mut subhash: u32;\n    let mut index: u32;\n    let mut i: u32;\n    let mut b: u8;\n\n    hash = bloomfilter.hash_func(value);\n\n    c_for!(i = 0; i < bloomfilter.num_functions; i.prefix_plus_plus(); {\n        subhash = hash ^ salts[i];\n        index = subhash % bloomfilter.table_size;\n        b = (1 << (index % 8)).cast::<u8>();\n        bloomfilter.table[index / 8] |= b;\n    });\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003781435)\nerror[E0599]: no method named `hash_func` found for struct `memory::ptr::Ptr<_BloomFilter>` in the current scope\n  --> src/src/bloom_filter_c.rs:44:24\n   |\n44 |     hash = bloomfilter.hash_func(value.cast());\n   |                        ^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `hash_func` not found for this struct\n   |\nhelp: to call the function pointer stored in `hash_func`, surround the field access with parentheses\n   |\n44 |     hash = (bloomfilter.hash_func)(value.cast());\n   |            +                     +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003783189)\nerror[E0599]: no method named `hash_func` found for struct `memory::ptr::Ptr<_BloomFilter>` in the current scope\n  --> src/src/bloom_filter_c.rs:44:24\n   |\n44 |     hash = bloomfilter.hash_func(value);\n   |                        ^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `hash_func` not found for this struct\n   |\nhelp: to call the function pointer stored in `hash_func`, surround the field access with parentheses\n   |\n44 |     hash = (bloomfilter.hash_func)(value);\n   |            +                     +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int bloom_filter_query(BloomFilter *bloomfilter, BloomFilterValue value)\n{\n    unsigned int hash;\n    unsigned int subhash;\n    unsigned int index;\n    unsigned int i;\n    unsigned char b;\n    int bit;\n\n    hash = bloomfilter->hash_func(value);\n\n    for (i = 0; i < bloomfilter->num_functions; ++i)\n    {\n\n        subhash = hash ^ salts[i];\n\n        index = subhash % bloomfilter->table_size;\n\n        b = bloomfilter->table[index / 8];\n        bit = 1 << (index % 8);\n\n        if ((b & bit) == 0)\n        {\n            return 0;\n        }\n    }\n\n    return 1;\n}",
                "original_rust_code": "pub fn bloom_filter_query(mut bloomfilter: Ptr<BloomFilter>, mut value: BloomFilterValue) -> i32 {\n    let mut hash: u32;\n    let mut subhash: u32;\n    let mut index: u32;\n    let mut i: u32;\n    let mut b: u8;\n    let mut bit: i32;\n\n    hash = bloomfilter.hash_func(value).cast();\n\n    c_for!(i = 0; i < bloomfilter.num_functions; i.prefix_plus_plus(); {\n        subhash = (hash ^ salts[i]).cast();\n\n        index = (subhash % bloomfilter.table_size).cast();\n\n        b = bloomfilter.table[index / 8].cast();\n        bit = (1 << (index % 8)).cast();\n\n        if ((b & bit) == 0).as_bool() {\n            return 0;\n        }\n    });\n\n    return 1;\n}\n",
                "optimized_rust_code": "pub fn bloom_filter_query(mut bloomfilter: Ptr<BloomFilter>, mut value: BloomFilterValue) -> i32 {\n    let mut hash: u32;\n    let mut subhash: u32;\n    let mut index: u32;\n    let mut i: u32;\n    let mut b: u8;\n    let mut bit: i32;\n\n    hash = bloomfilter.hash_func(value);\n\n    c_for!(i = 0; i < bloomfilter.num_functions; i.prefix_plus_plus(); {\n        subhash = (hash ^ salts[i]);\n\n        index = (subhash % bloomfilter.table_size);\n\n        b = bloomfilter.table[index / 8];\n        bit = (1 << (index % 8));\n\n        if ((b & bit) == 0) {\n            return 0;\n        }\n    });\n\n    return 1;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003783435)\nerror[E0599]: no method named `hash_func` found for struct `memory::ptr::Ptr<_BloomFilter>` in the current scope\n  --> src/src/bloom_filter_c.rs:50:24\n   |\n50 |     hash = bloomfilter.hash_func(value).cast();\n   |                        ^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `hash_func` not found for this struct\n   |\nhelp: to call the function pointer stored in `hash_func`, surround the field access with parentheses\n   |\n50 |     hash = (bloomfilter.hash_func)(value).cast();\n   |            +                     +\n\nerror[E0308]: mismatched types\n  --> src/src/bloom_filter_c.rs:60:18\n   |\n60 |         if ((b & bit) == 0).as_bool() {\n   |                  ^^^ expected `u8`, found `i32`\n\nerror[E0277]: no implementation for `u8 & i32`\n  --> src/src/bloom_filter_c.rs:60:16\n   |\n60 |         if ((b & bit) == 0).as_bool() {\n   |                ^ no implementation for `u8 & i32`\n   |\n   = help: the trait `BitAnd<i32>` is not implemented for `u8`\n   = help: the following other types implement trait `BitAnd<Rhs>`:\n             `&u8` implements `BitAnd<u8>`\n             `&u8` implements `BitAnd`\n             `u8` implements `BitAnd<&u8>`\n             `u8` implements `BitAnd`\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003786504)\nerror[E0599]: no method named `hash_func` found for struct `memory::ptr::Ptr<_BloomFilter>` in the current scope\n  --> src/src/bloom_filter_c.rs:50:24\n   |\n50 |     hash = bloomfilter.hash_func(value);\n   |                        ^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `hash_func` not found for this struct\n   |\nhelp: to call the function pointer stored in `hash_func`, surround the field access with parentheses\n   |\n50 |     hash = (bloomfilter.hash_func)(value);\n   |            +                     +\n\nerror[E0308]: mismatched types\n  --> src/src/bloom_filter_c.rs:60:18\n   |\n60 |         if ((b & bit) == 0) {\n   |                  ^^^ expected `u8`, found `i32`\n\nerror[E0277]: no implementation for `u8 & i32`\n  --> src/src/bloom_filter_c.rs:60:16\n   |\n60 |         if ((b & bit) == 0) {\n   |                ^ no implementation for `u8 & i32`\n   |\n   = help: the trait `BitAnd<i32>` is not implemented for `u8`\n   = help: the following other types implement trait `BitAnd<Rhs>`:\n             `&u8` implements `BitAnd<u8>`\n             `&u8` implements `BitAnd`\n             `u8` implements `BitAnd<&u8>`\n             `u8` implements `BitAnd`\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "static int hash_table_allocate_table(HashTable *hash_table)\n{\n    unsigned int new_table_size;\n\n    if (hash_table->prime_index < hash_table_num_primes)\n    {\n        new_table_size = hash_table_primes[hash_table->prime_index];\n    }\n    else\n    {\n        new_table_size = hash_table->entries * 10;\n    }\n\n    hash_table->table_size = new_table_size;\n\n    hash_table->table = calloc(hash_table->table_size, sizeof(HashTableEntry *));\n\n    return hash_table->table != NULL;\n}",
                "original_rust_code": "pub fn hash_table_allocate_table(mut hash_table: Ptr<HashTable>) -> i32 {\n    let mut new_table_size: u32 = Default::default();\n\n    if (hash_table.prime_index < hash_table_num_primes!()).as_bool() {\n        new_table_size = hash_table_primes[hash_table.prime_index].cast();\n    } else {\n        new_table_size = (hash_table.entries * 10).cast();\n    }\n\n    hash_table.table_size = new_table_size.cast();\n\n    hash_table.table = c_calloc!(hash_table.table_size, c_sizeof!(Ptr<HashTableEntry>));\n\n    return (hash_table.table != NULL!()).cast::<i32>();\n}\n",
                "optimized_rust_code": "pub fn hash_table_allocate_table(mut hash_table: Ptr<HashTable>) -> i32 {\n    let mut new_table_size: u32 = Default::default();\n\n    if (hash_table.prime_index < hash_table_num_primes!()) {\n        let tmp0 = hash_table.prime_index;\n        new_table_size = hash_table_primes[tmp0];\n    } else {\n        new_table_size = (hash_table.entries * 10);\n    }\n\n    hash_table.table_size = new_table_size;\n\n    hash_table.table = c_calloc!(hash_table.table_size, c_sizeof!(Ptr<HashTableEntry>));\n\n    return (hash_table.table != NULL!()).cast::<i32>();\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003789422)\nerror: cannot find macro `hash_table_num_primes` in this scope\n  --> src/src/hash_table_c.rs:39:34\n   |\n39 |     if (hash_table.prime_index < hash_table_num_primes!()).as_bool() {\n   |                                  ^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `hash_table_num_primes` is in scope, but it is a constant, not a macro\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003792278)\nerror: cannot find macro `hash_table_num_primes` in this scope\n  --> src/src/hash_table_c.rs:39:34\n   |\n39 |     if (hash_table.prime_index < hash_table_num_primes!()) {\n   |                                  ^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `hash_table_num_primes` is in scope, but it is a constant, not a macro\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static int set_allocate_table(Set *set)\n{\n\n    if (set->prime_index < set_num_primes)\n    {\n        set->table_size = set_primes[set->prime_index];\n    }\n    else\n    {\n        set->table_size = set->entries * 10;\n    }\n\n    set->table = calloc(set->table_size, sizeof(SetEntry *));\n\n    return set->table != NULL;\n}",
                "original_rust_code": "pub fn set_allocate_table(mut set: Ptr<Set>) -> i32 {\n    if (set.prime_index < set_num_primes!()).as_bool() {\n        set.table_size = set_primes[set.prime_index].cast();\n    } else {\n        set.table_size = (set.entries * 10).cast();\n    }\n    set.table = c_calloc!(set.table_size, c_sizeof!(Ptr<SetEntry>));\n    return (set.table != NULL!()).cast::<i32>();\n}\n",
                "optimized_rust_code": "pub fn set_allocate_table(mut set: Ptr<Set>) -> i32 {\n    if (set.prime_index < set_num_primes!()) {\n        let tmp0 = set.prime_index;\n        set.table_size = set_primes[tmp0];\n    } else {\n        set.table_size = (set.entries * 10);\n    }\n    set.table = c_calloc!(set.table_size, c_sizeof!(Ptr<SetEntry>));\n    return (set.table != NULL!()).cast::<i32>();\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003795784)\nerror: cannot find macro `set_num_primes` in this scope\n  --> src/src/set_c.rs:36:27\n   |\n36 |     if (set.prime_index < set_num_primes!()).as_bool() {\n   |                           ^^^^^^^^^^^^^^\n   |\n   = note: `set_num_primes` is in scope, but it is a constant, not a macro\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003798455)\nerror: cannot find macro `set_num_primes` in this scope\n  --> src/src/set_c.rs:36:27\n   |\n36 |     if (set.prime_index < set_num_primes!()) {\n   |                           ^^^^^^^^^^^^^^\n   |\n   = note: `set_num_primes` is in scope, but it is a constant, not a macro\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int trie_insert(Trie *trie, char *key, TrieValue value)\n{\n    TrieNode **rover;\n    TrieNode *node;\n    char *p;\n    int c;\n\n    if (value == TRIE_NULL)\n    {\n        return 0;\n    }\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = value;\n        return 1;\n    }\n\n    rover = &trie->root_node;\n    p = key;\n\n    for (;;)\n    {\n\n        node = *rover;\n\n        if (node == NULL)\n        {\n\n            node = (TrieNode *)calloc(1, sizeof(TrieNode));\n\n            if (node == NULL)\n            {\n\n                trie_insert_rollback(trie, (unsigned char *)key);\n\n                return 0;\n            }\n\n            node->data = TRIE_NULL;\n\n            *rover = node;\n        }\n\n        ++node->use_count;\n\n        c = (unsigned char)*p;\n\n        if (c == '\\0')\n        {\n\n            node->data = value;\n\n            break;\n        }\n\n        rover = &node->next[c];\n        ++p;\n    }\n\n    return 1;\n}",
                "original_rust_code": "pub fn trie_insert(mut trie: Ptr<Trie>, mut key: Ptr<u8>, mut value: TrieValue) -> i32 {\n    let mut rover: Ptr<Ptr<TrieNode>> = Default::default();\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut p: Ptr<u8> = Default::default();\n    let mut c: i32 = Default::default();\n\n    if (value == TRIE_NULL!()).as_bool() {\n        return 0;\n    }\n\n    node = trie_find_end(trie.cast(), key.cast()).cast();\n\n    if (node != NULL!()).as_bool() && (node.data != TRIE_NULL!()).as_bool() {\n        node.data = value.cast();\n        return 1;\n    }\n\n    rover = c_ref!(trie.root_node).cast();\n    p = key.cast();\n\n    loop {\n        node = *rover;\n\n        if (node == NULL!()).as_bool() {\n            node = c_calloc!(1, c_sizeof!(TrieNode));\n\n            if (node == NULL!()).as_bool() {\n                trie_insert_rollback(trie.cast(), key.cast::<Ptr<u8>>());\n\n                return 0;\n            }\n\n            node.data = TRIE_NULL!();\n\n            *rover = node.cast();\n        }\n\n        node.use_count.prefix_plus_plus();\n\n        c = (*p).cast::<u8>().cast::<i32>();\n\n        if (c == '\\0').as_bool() {\n            node.data = value.cast();\n\n            break;\n        }\n\n        rover = c_ref!(node.next[c]).cast();\n        p.prefix_plus_plus();\n    }\n\n    return 1;\n}\n",
                "optimized_rust_code": "pub fn trie_insert(mut trie: Ptr<Trie>, mut key: Ptr<u8>, mut value: TrieValue) -> i32 {\n    let mut rover: Ptr<Ptr<TrieNode>> = Default::default();\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut p: Ptr<u8> = Default::default();\n    let mut c: i32 = Default::default();\n\n    if (value == TRIE_NULL!()) {\n        return 0;\n    }\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL!()) && (node.data != TRIE_NULL!()) {\n        node.data = value;\n        return 1;\n    }\n\n    rover = c_ref!(trie.root_node);\n    p = key;\n\n    loop {\n        node = *rover;\n\n        if (node == NULL!()) {\n            node = c_calloc!(1, c_sizeof!(TrieNode));\n\n            if (node == NULL!()) {\n                trie_insert_rollback(trie, key.cast::<Ptr<u8>>());\n\n                return 0;\n            }\n\n            node.data = TRIE_NULL!();\n\n            *rover = node;\n        }\n\n        node.use_count.prefix_plus_plus();\n\n        c = (*p).cast::<u8>().cast::<i32>();\n\n        if (c == '\\0') {\n            node.data = value;\n\n            break;\n        }\n\n        rover = c_ref!(node.next[c]);\n        p.prefix_plus_plus();\n    }\n\n    return 1;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003818434)\nerror[E0308]: mismatched types\n   --> src/src/trie_c.rs:186:18\n    |\n186 |         if (c == '\\0').as_bool() {\n    |             -    ^^^^ expected `i32`, found `char`\n    |             |\n    |             expected because this is `i32`\n    |\nhelp: you can cast a `char` to an `i32`, since a `char` always occupies 4 bytes\n    |\n186 |         if (c == '\\0' as i32).as_bool() {\n    |                       ++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003824862)\nerror[E0308]: mismatched types\n   --> src/src/trie_c.rs:186:18\n    |\n186 |         if (c == '\\0') {\n    |             -    ^^^^ expected `i32`, found `char`\n    |             |\n    |             expected because this is `i32`\n    |\nhelp: you can cast a `char` to an `i32`, since a `char` always occupies 4 bytes\n    |\n186 |         if (c == '\\0' as i32) {\n    |                       ++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int trie_insert_binary(Trie *trie, unsigned char *key, int key_length, TrieValue value)\n{\n    TrieNode **rover;\n    TrieNode *node;\n    int p, c;\n\n    if (value == TRIE_NULL)\n    {\n        return 0;\n    }\n\n    node = trie_find_end_binary(trie, key, key_length);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = value;\n        return 1;\n    }\n\n    rover = &trie->root_node;\n    p = 0;\n\n    for (;;)\n    {\n\n        node = *rover;\n\n        if (node == NULL)\n        {\n\n            node = (TrieNode *)calloc(1, sizeof(TrieNode));\n\n            if (node == NULL)\n            {\n\n                trie_insert_rollback(trie, key);\n\n                return 0;\n            }\n\n            node->data = TRIE_NULL;\n\n            *rover = node;\n        }\n\n        ++node->use_count;\n\n        c = (unsigned char)key[p];\n\n        if (p == key_length)\n        {\n\n            node->data = value;\n\n            break;\n        }\n\n        rover = &node->next[c];\n        ++p;\n    }\n\n    return 1;\n}",
                "original_rust_code": "pub fn trie_insert_binary(mut trie: Ptr<Trie>, mut key: Ptr<u8>, mut key_length: i32, mut value: TrieValue) -> i32 {\n    let mut rover: Ptr<Ptr<TrieNode>> = Default::default();\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut p: i32 = Default::default();\n    let mut c: i32 = Default::default();\n\n    if (value == TRIE_NULL!()).as_bool() {\n        return 0;\n    }\n\n    node = trie_find_end_binary(trie.cast(), key.cast(), key_length.cast()).cast();\n\n    if (node != NULL!()).as_bool() && (node.data != TRIE_NULL!()).as_bool() {\n        node.data = value.cast();\n        return 1;\n    }\n\n    rover = c_ref!(trie.root_node).cast();\n    p = 0;\n\n    loop {\n        node = *rover;\n\n        if (node == NULL!()).as_bool() {\n            node = c_calloc!(1, c_sizeof!(TrieNode));\n\n            if (node == NULL!()).as_bool() {\n                trie_insert_rollback(trie.cast(), key.cast()).cast();\n\n                return 0;\n            }\n\n            node.data = TRIE_NULL!();\n\n            *rover = node.cast();\n        }\n\n        node.use_count.prefix_plus_plus();\n\n        c = key[p].cast::<u8>();\n\n        if (p == key_length).as_bool() {\n            node.data = value.cast();\n\n            break;\n        }\n\n        rover = c_ref!(node.next[c]).cast();\n        p.prefix_plus_plus();\n    }\n\n    return 1;\n}\n",
                "optimized_rust_code": "pub fn trie_insert_binary(mut trie: Ptr<Trie>, mut key: Ptr<u8>, mut key_length: i32, mut value: TrieValue) -> i32 {\n    let mut rover: Ptr<Ptr<TrieNode>> = Default::default();\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut p: i32 = Default::default();\n    let mut c: i32 = Default::default();\n\n    if (value == TRIE_NULL!()) {\n        return 0;\n    }\n\n    node = trie_find_end_binary(trie, key, key_length);\n\n    if (node != NULL!()) && (node.data != TRIE_NULL!()) {\n        node.data = value;\n        return 1;\n    }\n\n    rover = c_ref!(trie.root_node);\n    p = 0;\n\n    loop {\n        node = *rover;\n\n        if (node == NULL!()) {\n            node = c_calloc!(1, c_sizeof!(TrieNode));\n\n            if (node == NULL!()) {\n                trie_insert_rollback(trie, key);\n\n                return 0;\n            }\n\n            node.data = TRIE_NULL!();\n\n            *rover = node;\n        }\n\n        node.use_count.prefix_plus_plus();\n\n        c = key[p].cast::<u8>();\n\n        if (p == key_length) {\n            node.data = value;\n\n            break;\n        }\n\n        rover = c_ref!(node.next[c]);\n        p.prefix_plus_plus();\n    }\n\n    return 1;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003825156)\nerror[E0308]: mismatched types\n   --> src/src/trie_c.rs:189:13\n    |\n154 |     let mut c: i32 = Default::default();\n    |                --- expected due to this type\n...\n189 |         c = key[p].cast::<u8>();\n    |             ^^^^^^^^^^^^^^^^^^^ expected `i32`, found `u8`\n\nerror[E0277]: the trait bound `(): cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/src/trie_c.rs:177:63\n    |\n177 |                 trie_insert_rollback(trie.cast(), key.cast()).cast();\n    |                                                               ^^^^ the trait `integer::Integer` is not implemented for `()`\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<()>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `()` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003832129)\nerror[E0308]: mismatched types\n   --> src/src/trie_c.rs:189:13\n    |\n154 |     let mut c: i32 = Default::default();\n    |                --- expected due to this type\n...\n189 |         c = key[p].cast::<u8>();\n    |             ^^^^^^^^^^^^^^^^^^^ expected `i32`, found `u8`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static void binomial_tree_unref(BinomialTree *tree)\n{\n    int i;\n\n    if (tree == NULL)\n    {\n        return;\n    }\n\n    --tree->refcount;\n\n    if (tree->refcount == 0)\n    {\n\n        for (i = 0; i < tree->order; ++i)\n        {\n            binomial_tree_unref(tree->subtrees[i]);\n        }\n\n        free(tree->subtrees);\n        free(tree);\n    }\n}",
                "original_rust_code": "pub fn binomial_tree_unref(mut tree: Ptr<BinomialTree>) {\n    let mut i: i32 = Default::default();\n    if (tree == NULL!()).as_bool() {\n        return;\n    }\n    tree.refcount.suffix_minus_minus();\n    if (tree.refcount == 0).as_bool() {\n        c_for!(i = 0; i < tree.order; i.suffix_plus_plus(); {\n            binomial_tree_unref(tree.subtrees[i].cast());\n        });\n        c_free!(tree.subtrees);\n        c_free!(tree);\n    }\n}\n",
                "optimized_rust_code": "pub fn binomial_tree_unref(mut tree: Ptr<BinomialTree>) {\n    let mut i: i32 = Default::default();\n    if (tree == NULL!()) {\n        return;\n    }\n    tree.refcount.suffix_minus_minus();\n    if (tree.refcount == 0) {\n        c_for!(i = 0; i < tree.order; i.suffix_plus_plus(); {\n            binomial_tree_unref(tree.subtrees[i]);\n        });\n        c_free!(tree.subtrees);\n        c_free!(tree);\n    }\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003845105)\nerror[E0308]: mismatched types\n  --> src/src/binomial_heap_c.rs:51:27\n   |\n51 |         c_for!(i = 0; i < tree.order; i.suffix_plus_plus(); {\n   |                       -   ^^^^^^^^^^ expected `i32`, found `u16`\n   |                       |\n   |                       expected because this is `i32`\n   |\nhelp: you can convert a `u16` to an `i32`\n   |\n51 |         c_for!(i = 0; i < tree.order.into(); i.suffix_plus_plus(); {\n   |                                     +++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003847724)\nerror[E0308]: mismatched types\n  --> src/src/binomial_heap_c.rs:51:27\n   |\n51 |         c_for!(i = 0; i < tree.order; i.suffix_plus_plus(); {\n   |                       -   ^^^^^^^^^^ expected `i32`, found `u16`\n   |                       |\n   |                       expected because this is `i32`\n   |\nhelp: you can convert a `u16` to an `i32`\n   |\n51 |         c_for!(i = 0; i < tree.order.into(); i.suffix_plus_plus(); {\n   |                                     +++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static BinomialTree *binomial_tree_merge(BinomialHeap *heap, BinomialTree *tree1, BinomialTree *tree2)\n{\n    BinomialTree *new_tree;\n    BinomialTree *tmp;\n    int i;\n\n    if (binomial_heap_cmp(heap, tree1->value, tree2->value) > 0)\n    {\n\n        tmp = tree1;\n        tree1 = tree2;\n        tree2 = tmp;\n    }\n\n    new_tree = malloc(sizeof(BinomialTree));\n\n    if (new_tree == NULL)\n    {\n        return NULL;\n    }\n\n    new_tree->refcount = 0;\n    new_tree->order = (unsigned short)(tree1->order + 1);\n\n    new_tree->value = tree1->value;\n\n    new_tree->subtrees = malloc(sizeof(BinomialTree *) * new_tree->order);\n\n    if (new_tree->subtrees == NULL)\n    {\n        free(new_tree);\n        return NULL;\n    }\n\n    memcpy(new_tree->subtrees, tree1->subtrees, sizeof(BinomialTree *) * tree1->order);\n    new_tree->subtrees[new_tree->order - 1] = tree2;\n\n    for (i = 0; i < new_tree->order; ++i)\n    {\n        binomial_tree_ref(new_tree->subtrees[i]);\n    }\n\n    return new_tree;\n}",
                "original_rust_code": "pub fn binomial_tree_merge(mut heap: Ptr<BinomialHeap>, mut tree1: Ptr<BinomialTree>, mut tree2: Ptr<BinomialTree>) -> Ptr<BinomialTree> {\n    let mut new_tree: Ptr<BinomialTree>;\n    let mut tmp: Ptr<BinomialTree>;\n    let mut i: i32;\n\n    if (binomial_heap_cmp(heap.cast(), tree1.value.cast(), tree2.value.cast()) > 0).as_bool() {\n        tmp = tree1.cast();\n        tree1 = tree2.cast();\n        tree2 = tmp.cast();\n    }\n\n    new_tree = c_malloc!(c_sizeof!(BinomialTree));\n\n    if (new_tree == NULL!()).as_bool() {\n        return NULL!();\n    }\n\n    new_tree.refcount = 0;\n    new_tree.order = (tree1.order + 1).cast();\n\n    new_tree.value = tree1.value.cast();\n\n    new_tree.subtrees = c_malloc!(c_sizeof!(Ptr<BinomialTree>) * new_tree.order);\n\n    if (new_tree.subtrees == NULL!()).as_bool() {\n        c_free!(new_tree);\n        return NULL!();\n    }\n\n    c_memcpy!(new_tree.subtrees, tree1.subtrees, c_sizeof!(Ptr<BinomialTree>) * tree1.order);\n    new_tree.subtrees[new_tree.order - 1] = tree2.cast();\n\n    c_for!(i = 0; i < new_tree.order; i.prefix_plus_plus(); {\n        binomial_tree_ref(new_tree.subtrees[i].cast());\n    });\n\n    return new_tree.cast();\n}\n",
                "optimized_rust_code": "pub fn binomial_tree_merge(mut heap: Ptr<BinomialHeap>, mut tree1: Ptr<BinomialTree>, mut tree2: Ptr<BinomialTree>) -> Ptr<BinomialTree> {\n    let mut new_tree: Ptr<BinomialTree>;\n    let mut tmp: Ptr<BinomialTree>;\n    let mut i: i32;\n\n    if (binomial_heap_cmp(heap, tree1.value, tree2.value) > 0) {\n        tmp = tree1;\n        tree1 = tree2;\n        tree2 = tmp;\n    }\n\n    new_tree = c_malloc!(c_sizeof!(BinomialTree));\n\n    if (new_tree == NULL!()) {\n        return NULL!();\n    }\n\n    new_tree.refcount = 0;\n    new_tree.order = (tree1.order + 1);\n\n    new_tree.value = tree1.value;\n\n    new_tree.subtrees = c_malloc!(c_sizeof!(Ptr<BinomialTree>) * new_tree.order);\n\n    if (new_tree.subtrees == NULL!()) {\n        c_free!(new_tree);\n        return NULL!();\n    }\n\n    c_memcpy!(new_tree.subtrees, tree1.subtrees, c_sizeof!(Ptr<BinomialTree>) * tree1.order);\n    let tmp0 = new_tree.order - 1;\n    new_tree.subtrees[tmp0] = tree2;\n\n    c_for!(i = 0; i < new_tree.order; i.prefix_plus_plus(); {\n        binomial_tree_ref(new_tree.subtrees[i]);\n    });\n\n    return new_tree;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003848020)\nerror[E0308]: mismatched types\n  --> src/src/binomial_heap_c.rs:81:23\n   |\n81 |     c_for!(i = 0; i < new_tree.order; i.prefix_plus_plus(); {\n   |                   -   ^^^^^^^^^^^^^^ expected `i32`, found `u16`\n   |                   |\n   |                   expected because this is `i32`\n   |\nhelp: you can convert a `u16` to an `i32`\n   |\n81 |     c_for!(i = 0; i < new_tree.order.into(); i.prefix_plus_plus(); {\n   |                                     +++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003854160)\nerror[E0308]: mismatched types\n  --> src/src/binomial_heap_c.rs:82:23\n   |\n82 |     c_for!(i = 0; i < new_tree.order; i.prefix_plus_plus(); {\n   |                   -   ^^^^^^^^^^^^^^ expected `i32`, found `u16`\n   |                   |\n   |                   expected because this is `i32`\n   |\nhelp: you can convert a `u16` to an `i32`\n   |\n82 |     c_for!(i = 0; i < new_tree.order.into(); i.prefix_plus_plus(); {\n   |                                     +++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "RBTreeNode *rb_tree_insert(RBTree *tree, RBTreeKey key, RBTreeValue value)\n{\n    RBTreeNode *node;\n    RBTreeNode **rover;\n    RBTreeNode *parent;\n    RBTreeNodeSide side;\n\n    node = malloc(sizeof(RBTreeNode));\n\n    if (node == NULL)\n    {\n        return NULL;\n    }\n\n    node->key = key;\n    node->value = value;\n    node->color = RB_TREE_NODE_RED;\n    node->children[RB_TREE_NODE_LEFT] = NULL;\n    node->children[RB_TREE_NODE_RIGHT] = NULL;\n\n    parent = NULL;\n    rover = &tree->root_node;\n\n    while (*rover != NULL)\n    {\n\n        parent = *rover;\n\n        if (tree->compare_func(value, (*rover)->value) < 0)\n        {\n            side = RB_TREE_NODE_LEFT;\n        }\n        else\n        {\n            side = RB_TREE_NODE_RIGHT;\n        }\n\n        rover = &(*rover)->children[side];\n    }\n\n    *rover = node;\n    node->parent = parent;\n\n    rb_tree_insert_case1(tree, node);\n\n    ++tree->num_nodes;\n\n    return node;\n}",
                "original_rust_code": "pub fn rb_tree_insert(mut tree: Ptr<RBTree>, mut key: RBTreeKey, mut value: RBTreeValue) -> Ptr<RBTreeNode> {\n    let mut node: Ptr<RBTreeNode>;\n    let mut rover: Ptr<Ptr<RBTreeNode>>;\n    let mut parent: Ptr<RBTreeNode>;\n    let mut side: RBTreeNodeSide;\n\n    node = c_malloc!(c_sizeof!(RBTreeNode));\n\n    if (node == NULL!()).as_bool() {\n        return NULL!();\n    }\n\n    node.key = key.cast();\n    node.value = value.cast();\n    node.color = RB_TREE_NODE_RED!();\n    node.children[RB_TREE_NODE_LEFT!()] = NULL!();\n    node.children[RB_TREE_NODE_RIGHT!()] = NULL!();\n\n    parent = NULL!();\n    rover = c_ref!(tree.root_node).cast();\n\n    while (*rover != NULL!()).as_bool() {\n        parent = *rover.cast();\n\n        if (tree.compare_func(value.cast(), (*rover).value.cast()) < 0) {\n            side = RB_TREE_NODE_LEFT!();\n        } else {\n            side = RB_TREE_NODE_RIGHT!();\n        }\n\n        rover = c_ref!((*rover).children[side]).cast();\n    }\n\n    *rover = node.cast();\n    node.parent = parent.cast();\n\n    rb_tree_insert_case1(tree.cast(), node.cast());\n\n    tree.num_nodes.prefix_plus_plus();\n\n    return node.cast();\n}\n",
                "optimized_rust_code": "pub fn rb_tree_insert(mut tree: Ptr<RBTree>, mut key: RBTreeKey, mut value: RBTreeValue) -> Ptr<RBTreeNode> {\n    let mut node: Ptr<RBTreeNode>;\n    let mut rover: Ptr<Ptr<RBTreeNode>>;\n    let mut parent: Ptr<RBTreeNode>;\n    let mut side: RBTreeNodeSide;\n\n    node = c_malloc!(c_sizeof!(RBTreeNode));\n\n    if (node == NULL!()) {\n        return NULL!();\n    }\n\n    node.key = key;\n    node.value = value;\n    node.color = RB_TREE_NODE_RED!();\n    node.children[RB_TREE_NODE_LEFT!()] = NULL!();\n    node.children[RB_TREE_NODE_RIGHT!()] = NULL!();\n\n    parent = NULL!();\n    rover = c_ref!(tree.root_node);\n\n    while (*rover != NULL!()) {\n        parent = *rover;\n\n        if (tree.compare_func(value, (*rover).value) < 0) {\n            side = RB_TREE_NODE_LEFT!();\n        } else {\n            side = RB_TREE_NODE_RIGHT!();\n        }\n\n        rover = c_ref!((*rover).children[side]);\n    }\n\n    *rover = node;\n    node.parent = parent;\n\n    rb_tree_insert_case1(tree, node);\n\n    tree.num_nodes.prefix_plus_plus();\n\n    return node;\n}\n",
                "original_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003872889)\nerror[E0282]: type annotations needed\n   --> src/src/rb_tree_c.rs:195:25\n    |\n195 |         parent = *rover.cast();\n    |                         ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n195 |         parent = *rover.cast::<T>();\n    |                             +++++\n\nerror[E0599]: no method named `compare_func` found for struct `memory::ptr::Ptr<_RBTree>` in the current scope\n   --> src/src/rb_tree_c.rs:197:18\n    |\n197 |         if (tree.compare_func(value.cast(), (*rover).value.cast()) < 0) {\n    |                  ^^^^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `compare_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `compare_func`, surround the field access with parentheses\n    |\n197 |         if ((tree.compare_func)(value.cast(), (*rover).value.cast()) < 0) {\n    |             +                 +\n\nSome errors have detailed explanations: E0282, E0599.\nFor more information about an error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n",
                "optimized_error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003879358)\nerror[E0599]: no method named `compare_func` found for struct `memory::ptr::Ptr<_RBTree>` in the current scope\n   --> src/src/rb_tree_c.rs:197:18\n    |\n197 |         if (tree.compare_func(value, (*rover).value) < 0) {\n    |                  ^^^^^^^^^^^^ field, not a method\n    |\n   ::: src/translation_utils/memory/ptr.rs:8:1\n    |\n8   | pub struct Ptr<T>(pub Option<NonNull<T>>);\n    | ----------------- method `compare_func` not found for this struct\n    |\nhelp: to call the function pointer stored in `compare_func`, surround the field access with parentheses\n    |\n197 |         if ((tree.compare_func)(value, (*rover).value) < 0) {\n    |             +                 +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            }
        ]
    }
}