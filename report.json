{
    "macro": {
        "all_cnt": 114,
        "passed_cnt": 114,
        "pass_rate": 1.0,
        "messages": []
    },
    "macro_function": {
        "all_cnt": 52,
        "passed_cnt": 31,
        "pass_rate": 0.5961538461538461,
        "messages": [
            {
                "c_code": "#define CMPTLZ_ERROR_CONVERT(x) (int32_t)((CMPTLZ_MODULE << 16) | (uint32_t)(x))",
                "rust_code": "macro_rules! CMPTLZ_ERROR_CONVERT { ($x:expr) => { ((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32 } }\npub(crate) use CMPTLZ_ERROR_CONVERT;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450637799)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:669:52\n     |\n669  | macro_rules! CMPTLZ_ERROR_CONVERT { ($x:expr) => { ((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32 } }\n     |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n1546 | pub fn CmptLzDecByDistAndLen(mut decCtx: Ptr<CmptLzDecCtx>, mut matchDist: usize, mut matchLen: u32, mut dicPosLimit: usize) -> u32 {\n     |                                                                                                                                 --- expected `u32` because of return type\n...\n1553 |         return CMPT_ERROR_DATA!();\n     |                ------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_ERROR_CONVERT` which comes from the expansion of the macro `CMPT_ERROR_DATA` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you can convert an `i32` to a `u32` and panic if the converted value doesn't fit\n     |\n669  | macro_rules! CMPTLZ_ERROR_CONVERT { ($x:expr) => { (((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32).try_into().unwrap() } }\n     |                                                    +                                               +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:669:52\n     |\n669  | ...TLZ_ERROR_CONVERT { ($x:expr) => { ((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32 } }\n     |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n1655 | ...chDec(mut decCtx: Ptr<CmptLzDecCtx>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut dicPosLimit: usize, mut posState: u32) -> u32 {\n     |                                                                                                                                                                  --- expected `u32` because of return type\n...\n1669 | ...rn CMPT_ERROR_DATA!();\n     |       ------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_ERROR_CONVERT` which comes from the expansion of the macro `CMPT_ERROR_DATA` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you can convert an `i32` to a `u32` and panic if the converted value doesn't fit\n     |\n669  | macro_rules! CMPTLZ_ERROR_CONVERT { ($x:expr) => { (((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32).try_into().unwrap() } }\n     |                                                    +                                               +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "#define CMPTLZ_HANDLE_CONVERT(x) (int32_t)((CMPTLZ_MODULE << 16) | ((uint32_t)(x) << 8))",
                "rust_code": "macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\npub(crate) use CMPTLZ_HANDLE_CONVERT;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450638227)\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n1279 |         CmptLzDecMemFree(memHook, CMPTLZ_PROB_HANDLE!(), decCtx.probs.cast());\n     |                                   --------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_PROB_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n1287 |         decCtx.probs = CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE!(), (numProbs as u32 * c_sizeof!(CmptLzDecProb)).cast()).cast();\n     |                                                   --------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_PROB_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n1291 |             decCtx.probs = CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE!(), (numProbs as u32 * c_sizeof!(CmptLzDecProb)).cast()).cast();\n     |                                                       --------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_PROB_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n2902 |     let mut handle: VoidPtr = (alloc.CmptLzAlloc)(CMPTLZ_ENC_CCTX_HANDLE!(), c_sizeof!(CmptLzEncCtx).cast());\n     |                                                   ------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_ENC_CCTX_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n2986 |     let mut mf: Ptr<CmptMfCtx> = (alloc.CmptLzAlloc)(CMPTLZ_MF_CCTX_HANDLE!(), c_sizeof!(CmptMfCtx).cast()).cast();\n     |                                                      ------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_MF_CCTX_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3003 |     mf.hash = (alloc.CmptLzAlloc)(CMPTLZ_MF_HASH_HANDLE!(),(mf.hashCount as u32 * c_sizeof!(u32)).cast()).cast();\n     |                                   ------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_MF_HASH_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3008 |     mf.son = (alloc.CmptLzAlloc)(CMPTLZ_MF_SON_HANDLE!(), (mf.sonsCount as u32 * c_sizeof!(u32)).cast()).cast();\n     |                                  ----------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_MF_SON_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3501 |     let mut rc: Ptr<CmptRcCtx> = (alloc.CmptLzAlloc)(CMPTLZ_RC_CCTX_HANDLE!(), c_sizeof!(CmptRcCtx).cast()).cast();\n     |                                                      ------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_RC_CCTX_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3507 |     rc.bufBase = (alloc.CmptLzAlloc)(CMPTLZ_RC_BUF_HANDLE!(), CMPTLZ_RC_BUFFER_SIZE!());\n     |                                      ----------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_RC_BUF_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3902 |             (alloc.CmptLzFree)(CMPTLZ_MF_HASH_HANDLE!(), encCtx.mfCtx.hash.cast());\n     |                                ------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_MF_HASH_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3906 |             (alloc.CmptLzFree)(CMPTLZ_MF_SON_HANDLE!(), encCtx.mfCtx.son.cast());\n     |                                ----------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_MF_SON_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3909 |         (alloc.CmptLzFree)(CMPTLZ_MF_CCTX_HANDLE!(), encCtx.mfCtx.cast());\n     |                            ------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_MF_CCTX_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3914 |             (alloc.CmptLzFree)(CMPTLZ_RC_BUF_HANDLE!(), encCtx.rcCtx.bufBase.cast());\n     |                                ----------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_RC_BUF_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3917 |         (alloc.CmptLzFree)(CMPTLZ_RC_CCTX_HANDLE!(), encCtx.rcCtx.cast());\n     |                            ------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_RC_CCTX_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3920 |     (alloc.CmptLzFree)(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx.cast());\n     |                        ------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_ENC_CCTX_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3970 |         (alloc.CmptLzFree)(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx.cast());\n     |                            ------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_ENC_CCTX_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: could not compile `my_proj` (lib) due to 16 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 16 previous errors\n"
            },
            {
                "c_code": "#define CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec)                                                             \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if ((range) < CMPTLZ_RANGE_DOWN_LIMIT)                                                                         \\\n        {                                                                                                              \\\n            (range) <<= CMPTLZ_ONE_BYTE_WIDTH;                                                                         \\\n            (rangeCode) <<= CMPTLZ_ONE_BYTE_WIDTH;                                                                     \\\n            (rangeCode) |= (*(bufToDec)++);                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
                "rust_code": "macro_rules! CMPTLZ_RANGE_NORMALIZE {\n    ($range:expr, $rangeCode:expr, $bufToDec:expr) => {\n        if $range < CMPTLZ_RANGE_DOWN_LIMIT!() {\n            $range <<= CMPTLZ_ONE_BYTE_WIDTH!();\n            $rangeCode <<= CMPTLZ_ONE_BYTE_WIDTH!();\n            $rangeCode |= $bufToDec.plus_plus();\n        }\n    }\n}\npub(crate) use CMPTLZ_RANGE_NORMALIZE;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450658984)\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1420 |         CMPTLZ_POSSLOT_BIT_DEC!(probPosSlot + posSlot, range, rangeCode, rangeBound, posSlot, bufToDec);\n     |         ----------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_POSSLOT_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1442 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |                 --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1447 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |                 --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1460 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1477 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1481 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |         --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1490 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |         --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1511 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |         --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1514 |             CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |             --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1519 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |         --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1523 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1526 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                 --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1530 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1533 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                 --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1602 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |         --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1606 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1615 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1620 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |         --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1624 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1628 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1632 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |                 --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1636 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |                 --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1711 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1720 |             CMPTLZ_MATCH_BIT_DEC!(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n     |             ------------------------------------------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_MATCH_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1751 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n     |         ----------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1754 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n     |             ----------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1758 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n     |             ----------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1762 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n     |                 ----------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1766 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n     |                 ----------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 29 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 29 previous errors\n"
            },
            {
                "c_code": "#define CMPTLZ_IS_THE_BIT_0(probSlot, range, rangeCode, rangeBound)                                                    \\\n    (rangeBound) = (range >> CMPTLZ_PROB_LG_BIT) * (*(probSlot));                                                      \\\n    if ((rangeCode) < (rangeBound))",
                "rust_code": "macro_rules! CMPTLZ_IS_THE_BIT_0 { ($probSlot:expr, $range:expr, $rangeCode:expr, $rangeBound:expr) =>\n    {\n        $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n        if $rangeCode < $rangeBound\n    }\n}\npub(crate) use CMPTLZ_IS_THE_BIT_0;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450659411)\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1438 |             if CMPTLZ_IS_THE_BIT_0!(probPosSlot + distDec, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------------------- caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1438 |             if CMPTLZ_IS_THE_BIT_0!(probPosSlot + distDec, range, rangeCode, rangeBound); {\n     |                                                                                         +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1507 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |        ----------------------------------------------------------- caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1507 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound); {\n     |                                                                   +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1519 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |            ----------------------------------------------------------- caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1519 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound); {\n     |                                                                       +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1598 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |        ------------------------------------------------------------ caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1598 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound); {\n     |                                                                    +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1602 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1602 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound); {\n     |                                                                        +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1620 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1620 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound); {\n     |                                                                        +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1628 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------ caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1628 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound); {\n     |                                                                            +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1750 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1750 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound); {\n     |                                                                        +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1758 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------ caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1758 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound); {\n     |                                                                            +\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1438 |             if CMPTLZ_IS_THE_BIT_0!(probPosSlot + distDec, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1438 |             if CMPTLZ_IS_THE_BIT_0!(probPosSlot + distDec, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1438 |             if CMPTLZ_IS_THE_BIT_0!(probPosSlot + distDec, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1507 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |        ----------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1507 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |        ----------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1507 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |        ----------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1519 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |            ----------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1519 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |            ----------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1519 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |            ----------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1598 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |        ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1598 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |        ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1598 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |        ------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1602 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1602 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1602 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1620 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1620 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1620 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1628 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1628 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1628 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1750 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1750 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1750 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1758 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1758 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1758 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 36 previous errors; 9 warnings emitted\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 36 previous errors; 9 warnings emitted\n"
            },
            {
                "c_code": "#define CMPTLZ_NORMAL_BIT_DEC(probLit, range, rangeCode, rangeBound, decSym)                                           \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probLit));                                                 \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_0(probLit, range, rangeBound);                                                         \\\n            (decSym) = ((decSym) << 1);                                                                                \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_1(probLit, range, rangeCode, rangeBound);                                              \\\n            (decSym) = ((decSym) << 1) + 1;                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
                "rust_code": "macro_rules! CMPTLZ_NORMAL_BIT_DEC {\n    ($probLit:expr, $range:expr, $rangeCode:expr, $rangeBound:expr, $decSym:expr) => {\n        $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n        if $rangeCode < $rangeBound {\n            CMPTLZ_RANGE_UPDATE_0!($probLit, $range, $rangeBound);\n            $decSym = $decSym << 1;\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!($probLit, $range, $rangeCode, $rangeBound);\n            $decSym = ($decSym << 1) + 1;\n        }\n    };\n}\npub(crate) use CMPTLZ_NORMAL_BIT_DEC;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450670083)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:738:59\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1418 |         CMPTLZ_POSSLOT_BIT_DEC!(probPosSlot + posSlot, range, rangeCode, rangeBound, posSlot, bufToDec);\n     |         ----------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_POSSLOT_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:738:57\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1418 |         CMPTLZ_POSSLOT_BIT_DEC!(probPosSlot + posSlot, range, rangeCode, rangeBound, posSlot, bufToDec);\n     |         ----------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_POSSLOT_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:738:59\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1512 |             CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |             --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:738:57\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1512 |             CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |             --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:738:59\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1524 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                 --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:738:57\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1524 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                 --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:738:59\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1531 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                 --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:738:57\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1531 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                 --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:738:59\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1708 |             CMPTLZ_NORMAL_BIT_DEC!(probSlot + decSym, range, rangeCode, rangeBound, decSym);\n     |             ------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:738:57\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1708 |             CMPTLZ_NORMAL_BIT_DEC!(probSlot + decSym, range, rangeCode, rangeBound, decSym);\n     |             ------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 10 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 10 previous errors\n"
            },
            {
                "c_code": "#define CMPTLZ_MATCH_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec)          \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (matchSym) <<= 1;                                                                                              \\\n        (bit) = (offset);                                                                                              \\\n        (offset) &= (matchSym);                                                                                        \\\n        (probLit) = (probSlot) + ((offset) + (bit) + (decSym));                                                        \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probLit));                                                 \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_0(probLit, range, rangeBound);                                                         \\\n            (decSym) = ((decSym) << 1);                                                                                \\\n            (offset) ^= (bit);                                                                                         \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_1(probLit, range, rangeCode, rangeBound);                                              \\\n            (decSym) = ((decSym) << 1) + 1;                                                                            \\\n        }                                                                                                              \\\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);                                                            \\\n    } while (0)",
                "rust_code": "macro_rules! CMPTLZ_MATCH_BIT_DEC {\n    ($probSlot:expr, $range:expr, $rangeCode:expr, $rangeBound:expr, $decSym:expr, $matchSym:expr, $offset:expr, $bit:expr, $bufToDec:expr) => {\n        $matchSym <<= 1;\n        $bit = $offset;\n        $offset &= $matchSym;\n        $probLit = $probSlot + ($offset + $bit + $decSym);\n        $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n        if $rangeCode < $rangeBound {\n            CMPTLZ_RANGE_UPDATE_0!($probLit, $range, $rangeBound);\n            $decSym = $decSym << 1;\n            $offset ^= $bit;\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!($probLit, $range, $rangeCode, $rangeBound);\n            $decSym = ($decSym << 1) + 1;\n        }\n        CMPTLZ_RANGE_NORMALIZE!($range, $rangeCode, $bufToDec);\n    };\n}\npub(crate) use CMPTLZ_MATCH_BIT_DEC;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450670519)\nerror: expected expression, found `$`\n    --> src/src/cmptlz_c.rs:757:9\n     |\n757  |         $probLit = $probSlot + ($offset + $bit + $decSym);\n     |         ^^^^^^^^ expected expression\n...\n1720 |             CMPTLZ_MATCH_BIT_DEC!(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n     |             ------------------------------------------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_MATCH_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "#define CMPTLZ_DIST_BIT_DEC(probDist, probSlot, range, rangeCode, rangeBound, decDist, decBit)                         \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (probDist) = (probSlot) + (decDist);                                                                           \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probDist));                                                \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_0(probDist, range, rangeBound);                                                        \\\n            (decDist) += (decBit);                                                                                     \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_1(probDist, range, rangeCode, rangeBound);                                             \\\n            (decDist) += (decBit) * 2;                                                                                 \\\n        }                                                                                                              \\\n    } while (0)",
                "rust_code": "macro_rules! CMPTLZ_DIST_BIT_DEC {\n    ($probDist:expr, $probSlot:expr, $range:expr, $rangeCode:expr, $rangeBound:expr, $decDist:expr, $decBit:expr) => {\n        $probDist = $probSlot + $decDist;\n        $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probDist);\n        if $rangeCode < $rangeBound {\n            CMPTLZ_RANGE_UPDATE_0!($probDist, $range, $rangeBound);\n            $decDist += $decBit;\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!($probDist, $range, $rangeCode, $rangeBound);\n            $decDist += $decBit * 2;\n        }\n    };\n}\npub(crate) use CMPTLZ_DIST_BIT_DEC;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450670947)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:775:59\n     |\n775  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probDist);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1476 |             CMPTLZ_DIST_BIT_DEC!(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n     |             ----------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_DIST_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:775:57\n     |\n775  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probDist);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1476 |             CMPTLZ_DIST_BIT_DEC!(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n     |             ----------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_DIST_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "#define CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit)                                              \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if ((range) < CMPTLZ_RANGE_DOWN_LIMIT)                                                                         \\\n        {                                                                                                              \\\n            if ((bufTryDec) >= (bufLimit))                                                                             \\\n            {                                                                                                          \\\n                return CMPTLZ_DEC_INPUT_EOF;                                                                           \\\n            }                                                                                                          \\\n            (range) <<= CMPTLZ_ONE_BYTE_WIDTH;                                                                         \\\n            (rangeCode) <<= CMPTLZ_ONE_BYTE_WIDTH;                                                                     \\\n            (rangeCode) |= (*(bufTryDec)++);                                                                           \\\n        }                                                                                                              \\\n    } while (0)",
                "rust_code": "macro_rules! CMPTLZ_RANGE_TRY_NORMALIZE { ($range:expr, $rangeCode:expr, $bufTryDec:expr, $bufLimit:expr) =>\n    {\n        if $range < CMPTLZ_RANGE_DOWN_LIMIT!()\n        {\n            if $bufTryDec >= $bufLimit\n            {\n                return CMPTLZ_DEC_INPUT_EOF!();\n            }\n            $range <<= CMPTLZ_ONE_BYTE_WIDTH!();\n            $rangeCode <<= CMPTLZ_ONE_BYTE_WIDTH!();\n            $rangeCode |= *$bufTryDec.plus_plus();\n        }\n    }\n}\npub(crate) use CMPTLZ_RANGE_TRY_NORMALIZE;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450691572)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1793 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1793 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1803 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1803 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1818 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1818 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1823 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1823 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1839 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1839 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1852 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |                 ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1852 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |                 ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1866 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1866 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1884 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1884 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1912 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1912 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1927 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1927 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1933 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1933 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1954 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1954 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1958 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1958 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1970 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1970 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1975 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1975 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1980 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |                 ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1980 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |                 ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1988 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1988 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1995 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |                 ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1995 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |                 ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 36 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 36 previous errors\n"
            },
            {
                "c_code": "#define CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probSym)                                       \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probSym));                                                 \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);                                                     \\\n            (decSym) = ((decSym) << 1);                                                                                \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);                                          \\\n            (decSym) = ((decSym) << 1) + 1;                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
                "rust_code": "macro_rules! CMPTLZ_SINGLE_BIT_TRY_DEC {\n    ($range:expr, $rangeCode:expr, $rangeBound:expr, $decSym:expr, $probSym:expr) => {\n        $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n        if $rangeCode < $rangeBound {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!($range, $rangeBound);\n            $decSym = $decSym << 1;\n        } else {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!($range, $rangeCode, $rangeBound);\n            $decSym = ($decSym << 1) + 1;\n        }\n    };\n}\npub(crate) use CMPTLZ_SINGLE_BIT_TRY_DEC;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450692003)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:841:59\n     |\n841  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n     |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1819 |         CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n     |         ------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:841:57\n     |\n841  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1819 |         CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n     |         ------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:841:59\n     |\n841  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n     |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1835 |         CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n     |         ------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:841:57\n     |\n841  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1835 |         CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n     |         ------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:841:59\n     |\n841  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n     |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1908 |             CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n     |             ------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:841:57\n     |\n841  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1908 |             CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n     |             ------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 6 previous errors\n"
            },
            {
                "c_code": "#define CMPTLZ_MATCH_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probSym)                                        \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probSym));                                                 \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);                                                     \\\n            (decSym) = ((decSym) << 1);                                                                                \\\n            (offset) ^= (bit);                                                                                         \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);                                          \\\n            (decSym) = ((decSym) << 1) + 1;                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
                "rust_code": "macro_rules! CMPTLZ_MATCH_BIT_TRY_DEC {\n    ($range:expr, $rangeCode:expr, $rangeBound:expr, $decSym:expr, $probSym:expr) => {\n        $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n        if $rangeCode < $rangeBound {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!($range, $rangeBound);\n            $decSym = $decSym << 1;\n            $offset ^= $bit;\n        } else {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!($range, $rangeCode, $rangeBound);\n            $decSym = ($decSym << 1) + 1;\n        }\n    };\n}\npub(crate) use CMPTLZ_MATCH_BIT_TRY_DEC;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450692431)\nerror: no rules expected `,`\n    --> src/src/cmptlz_c.rs:1923:84\n     |\n855  | macro_rules! CMPTLZ_MATCH_BIT_TRY_DEC {\n     | ------------------------------------- when calling this macro\n...\n1923 |             CMPTLZ_MATCH_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit, offset, bit);\n     |                                                                                    ^ no rules expected this token in macro call\n     |\nnote: while trying to match meta-variable `$probSym:expr`\n    --> src/src/cmptlz_c.rs:856:68\n     |\n856  |     ($range:expr, $rangeCode:expr, $rangeBound:expr, $decSym:expr, $probSym:expr) => {\n     |                                                                    ^^^^^^^^^^^^^\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "#define CMPT_STATE_UPDATE_WHEN_LIT(state)                                                                              \\\n    (state) = (((state) <= SHORTREP_LIT_LIT) ? LIT_LIT : (((state) <= LIT_SHORTREP) ? (state) - 3 : (state) - 6))",
                "rust_code": "macro_rules! CMPT_STATE_UPDATE_WHEN_LIT { ($state:expr) => \n    {\n        $state = if $state <= SHORTREP_LIT_LIT {\n            LIT_LIT\n        } else if $state <= LIT_SHORTREP {\n            $state - 3\n        } else {\n            $state - 6\n        }\n    }\n}\npub(crate) use CMPT_STATE_UPDATE_WHEN_LIT;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450728091)\nerror[E0423]: expected value, found macro `SHORTREP_LIT_LIT`\n    --> src/src/cmptlz_c.rs:935:31\n     |\n935  |         $state = if $state <= SHORTREP_LIT_LIT {\n     |                               ^^^^^^^^^^^^^^^^ not a value\n...\n2570 |             CMPT_STATE_UPDATE_WHEN_LIT!(state);\n     |             ---------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LIT` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `LIT_LIT`\n    --> src/src/cmptlz_c.rs:936:13\n     |\n936  |             LIT_LIT\n     |             ^^^^^^^ not a value\n...\n2570 |             CMPT_STATE_UPDATE_WHEN_LIT!(state);\n     |             ---------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LIT` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `LIT_SHORTREP`\n    --> src/src/cmptlz_c.rs:937:29\n     |\n937  |         } else if $state <= LIT_SHORTREP {\n     |                             ^^^^^^^^^^^^ not a value\n...\n2570 |             CMPT_STATE_UPDATE_WHEN_LIT!(state);\n     |             ---------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LIT` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `SHORTREP_LIT_LIT`\n    --> src/src/cmptlz_c.rs:935:31\n     |\n935  |         $state = if $state <= SHORTREP_LIT_LIT {\n     |                               ^^^^^^^^^^^^^^^^ not a value\n...\n3720 |     CMPT_STATE_UPDATE_WHEN_LIT!(encCtx.state);\n     |     ----------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LIT` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `LIT_LIT`\n    --> src/src/cmptlz_c.rs:936:13\n     |\n936  |             LIT_LIT\n     |             ^^^^^^^ not a value\n...\n3720 |     CMPT_STATE_UPDATE_WHEN_LIT!(encCtx.state);\n     |     ----------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LIT` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `LIT_SHORTREP`\n    --> src/src/cmptlz_c.rs:937:29\n     |\n937  |         } else if $state <= LIT_SHORTREP {\n     |                             ^^^^^^^^^^^^ not a value\n...\n3720 |     CMPT_STATE_UPDATE_WHEN_LIT!(encCtx.state);\n     |     ----------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LIT` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 6 previous errors\n"
            },
            {
                "c_code": "#define CMPT_STATE_UPDATE_WHEN_MATCH(state) (state) = (((state) < 7) ? LIT_MATCH : NOTLIT_MATCH)",
                "rust_code": "macro_rules! CMPT_STATE_UPDATE_WHEN_MATCH { ($state:expr) => { $state = if $state < 7 { LIT_MATCH!() } else { NOTLIT_MATCH!() } } }\npub(crate) use CMPT_STATE_UPDATE_WHEN_MATCH;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450728528)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:946:64\n     |\n946  | macro_rules! CMPT_STATE_UPDATE_WHEN_MATCH { ($state:expr) => { $state = if $state < 7 { LIT_MATCH!() } else { NOTLIT_MATCH!() } } }\n     |                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n...\n3778 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_MATCH!(state);\n     |     ------------   ------------------------------------ in this macro invocation\n     |     |\n     |     expected due to the type of this binding\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_MATCH` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "#define CMPT_STATE_UPDATE_WHEN_LONGREP(state) (state) = (((state) < 7) ? LIT_LONGREP : NOTLIT_REP)",
                "rust_code": "macro_rules! CMPT_STATE_UPDATE_WHEN_LONGREP { ($state:expr) => { $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP } } }\npub(crate) use CMPT_STATE_UPDATE_WHEN_LONGREP;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450728958)\nerror[E0423]: expected value, found macro `LIT_LONGREP`\n    --> src/src/cmptlz_c.rs:955:91\n     |\n955  | macro_rules! CMPT_STATE_UPDATE_WHEN_LONGREP { ($state:expr) => { $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP } } }\n     |                                                                                           ^^^^^^^^^^^ not a value\n...\n2569 |             CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n     |             -------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LONGREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `NOTLIT_REP`\n    --> src/src/cmptlz_c.rs:955:112\n     |\n955  | macro_rules! CMPT_STATE_UPDATE_WHEN_LONGREP { ($state:expr) => { $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP } } }\n     |                                                                                                                ^^^^^^^^^^ not a value\n...\n2569 |             CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n     |             -------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LONGREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `LIT_LONGREP`\n    --> src/src/cmptlz_c.rs:955:91\n     |\n955  | macro_rules! CMPT_STATE_UPDATE_WHEN_LONGREP { ($state:expr) => { $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP } } }\n     |                                                                                           ^^^^^^^^^^^ not a value\n...\n3885 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n     |                    -------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LONGREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `NOTLIT_REP`\n    --> src/src/cmptlz_c.rs:955:112\n     |\n955  | macro_rules! CMPT_STATE_UPDATE_WHEN_LONGREP { ($state:expr) => { $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP } } }\n     |                                                                                                                ^^^^^^^^^^ not a value\n...\n3885 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n     |                    -------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LONGREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 4 previous errors\n"
            },
            {
                "c_code": "#define CMPT_STATE_UPDATE_WHEN_SHORTREP(state) (state) = (((state) < 7) ? LIT_SHORTREP : NOTLIT_REP)",
                "rust_code": "macro_rules! CMPT_STATE_UPDATE_WHEN_SHORTREP { ($state:expr) => { $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP } } }\npub(crate) use CMPT_STATE_UPDATE_WHEN_SHORTREP;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450729386)\nerror[E0423]: expected value, found macro `LIT_SHORTREP`\n    --> src/src/cmptlz_c.rs:965:92\n     |\n965  | macro_rules! CMPT_STATE_UPDATE_WHEN_SHORTREP { ($state:expr) => { $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP } } }\n     |                                                                                            ^^^^^^^^^^^^ not a value\n...\n2561 |             CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n     |             --------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_SHORTREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `NOTLIT_REP`\n    --> src/src/cmptlz_c.rs:965:114\n     |\n965  | macro_rules! CMPT_STATE_UPDATE_WHEN_SHORTREP { ($state:expr) => { $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP } } }\n     |                                                                                                                  ^^^^^^^^^^ not a value\n...\n2561 |             CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n     |             --------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_SHORTREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `LIT_SHORTREP`\n    --> src/src/cmptlz_c.rs:965:92\n     |\n965  | macro_rules! CMPT_STATE_UPDATE_WHEN_SHORTREP { ($state:expr) => { $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP } } }\n     |                                                                                            ^^^^^^^^^^^^ not a value\n...\n3754 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n     |                    --------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_SHORTREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `NOTLIT_REP`\n    --> src/src/cmptlz_c.rs:965:114\n     |\n965  | macro_rules! CMPT_STATE_UPDATE_WHEN_SHORTREP { ($state:expr) => { $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP } } }\n     |                                                                                                                  ^^^^^^^^^^ not a value\n...\n3754 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n     |                    --------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_SHORTREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 4 previous errors\n"
            },
            {
                "c_code": "#define CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue)                                             \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        temp = mf->hashRootTable[cur[0]] ^ cur[1];                                                                     \\\n        hash2Value = temp & CMPTLZ_HASH_2_MASK;                                                                        \\\n        hash3Value = (temp ^ ((uint32_t)(cur[2]) << 8)) & CMPTLZ_HASH_3_MASK;                                          \\\n        hashValue = (temp ^ ((uint32_t)(cur[2]) << 8) ^ (mf->hashRootTable[cur[3]] << 5)) & mf->hashMask;              \\\n    } while (0)",
                "rust_code": "macro_rules! CMPT_HASH_4_CALC {\n    ($mf:expr, $cur:expr, $temp:expr, $hash2Value:expr, $hash3Value:expr, $hashValue:expr) => {\n        $temp = $mf.hashRootTable[$cur[0]] ^ $cur[1];\n        $hash2Value = $temp & CMPTLZ_HASH_2_MASK!();\n        $hash3Value = ($temp ^ (($cur[2] as u32) << 8)) & CMPTLZ_HASH_3_MASK!();\n        $hashValue = ($temp ^ (($cur[2] as u32) << 8) ^ ($mf.hashRootTable[$cur[3]] << 5)) & $mf.hashMask;\n    }\n}\npub(crate) use CMPT_HASH_4_CALC;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450734978)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:992:46\n     |\n992  |         $temp = $mf.hashRootTable[$cur[0]] ^ $cur[1];\n     |                                              ^^^^^^^ expected `u32`, found `u8`\n...\n3131 |     CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n     |     ------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n    --> src/src/cmptlz_c.rs:992:44\n     |\n992  |         $temp = $mf.hashRootTable[$cur[0]] ^ $cur[1];\n     |                                            ^ no implementation for `u32 ^ u8`\n...\n3131 |     CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n     |     ------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitXor<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitXor<Rhs>`:\n               `&u32` implements `BitXor<u32>`\n               `&u32` implements `BitXor`\n               `u32` implements `BitXor<&u32>`\n               `u32` implements `BitXor`\n     = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:992:46\n     |\n992  |         $temp = $mf.hashRootTable[$cur[0]] ^ $cur[1];\n     |                                              ^^^^^^^ expected `u32`, found `u8`\n...\n3179 |         CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n     |         ------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n    --> src/src/cmptlz_c.rs:992:44\n     |\n992  |         $temp = $mf.hashRootTable[$cur[0]] ^ $cur[1];\n     |                                            ^ no implementation for `u32 ^ u8`\n...\n3179 |         CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n     |         ------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitXor<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitXor<Rhs>`:\n               `&u32` implements `BitXor<u32>`\n               `&u32` implements `BitXor`\n               `u32` implements `BitXor<&u32>`\n               `u32` implements `BitXor`\n     = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 4 previous errors\n"
            },
            {
                "c_code": "#define GET_LEN_TO_POS_STATE(len) (((len) < CMPT_NUM_LEN_POS_STATE + 1) ? (len) - 2 : CMPT_NUM_LEN_POS_STATE - 1)",
                "rust_code": "macro_rules! GET_LEN_TO_POS_STATE { ($len:expr) => { if $len < CMPT_NUM_LEN_POS_STATE + 1 { $len - 2 } else { CMPT_NUM_LEN_POS_STATE - 1 } } }\npub(crate) use GET_LEN_TO_POS_STATE;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450770482)\nerror[E0423]: expected value, found macro `CMPT_NUM_LEN_POS_STATE`\n    --> src/src/cmptlz_c.rs:1076:64\n     |\n1076 | macro_rules! GET_LEN_TO_POS_STATE { ($len:expr) => { if $len < CMPT_NUM_LEN_POS_STATE + 1 { $len - 2 } else { CMPT_NUM_LEN_POS_STATE - 1 ...\n     |                                                                ^^^^^^^^^^^^^^^^^^^^^^ not a value\n...\n3617 |     let mut probs: Ptr<CmptlzProb> = encCtx.probDistSlot[GET_LEN_TO_POS_STATE!(len)].cast();\n     |                                                          -------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `GET_LEN_TO_POS_STATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPT_NUM_LEN_POS_STATE`\n    --> src/src/cmptlz_c.rs:1076:111\n     |\n1076 | ...{ ($len:expr) => { if $len < CMPT_NUM_LEN_POS_STATE + 1 { $len - 2 } else { CMPT_NUM_LEN_POS_STATE - 1 } } }\n     |                                                                                ^^^^^^^^^^^^^^^^^^^^^^ not a value\n...\n3617 | ... = encCtx.probDistSlot[GET_LEN_TO_POS_STATE!(len)].cast();\n     |                           -------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `GET_LEN_TO_POS_STATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "#define CMPT_RC_GET_NEWBOUND(prob, bit0Prob, range, newBound)                                                          \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (bit0Prob) = *(prob);                                                                                          \\\n        newBound = ((range) >> 11) * (bit0Prob);                                                                       \\\n    } while (0)",
                "rust_code": "macro_rules! CMPT_RC_GET_NEWBOUND { ($prob:expr, $bit0Prob:expr, $range:expr, $newBound:expr) =>\n    {\n        $bit0Prob = *$prob;\n        $newBound = ($range >> 11) * $bit0Prob;\n    }\n}\npub(crate) use CMPT_RC_GET_NEWBOUND;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450785945)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n2386 |         let mut bit0Prob: u32;\n     |                           --- expected due to this type\n...\n2391 |         CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |         ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3463 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3470 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3481 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3491 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3577 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3580 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3577 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3585 |         CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |         ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3577 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3602 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3577 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3606 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3577 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3610 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3620 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3628 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3641 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3648 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3682 |         let mut bit0Prob: u32;\n     |                           --- expected due to this type\n...\n3688 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>()  + m, bit, bit0Prob, range, newBound, shiftRes);\n     |             ---------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3682 |         let mut bit0Prob: u32;\n     |                           --- expected due to this type\n...\n3693 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>() + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3705 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3710 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3734 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3739 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3734 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3744 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3734 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3749 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3734 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3754 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3767 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3772 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3767 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3777 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3811 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3816 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3821 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3828 |             CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |             ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3837 |             CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |             ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3849 |             CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |             ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3854 |             CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |             ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3867 |             CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |             ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3872 |             CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |             ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 28 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 28 previous errors\n"
            },
            {
                "c_code": "#define CMPT_RC_BIT_PROCESS(rcCtx, prob, bit, bit0Prob, range, newBound, shiftRes)                                     \\\n    {                                                                                                                  \\\n        do                                                                                                             \\\n        {                                                                                                              \\\n            uint32_t mask = 0 - (uint32_t)(bit);                                                                       \\\n            CMPT_RC_GET_NEWBOUND(prob, bit0Prob, range, newBound);                                                     \\\n            (range) &= mask;                                                                                           \\\n            mask &= (newBound);                                                                                        \\\n            (range) -= mask;                                                                                           \\\n            (rcCtx)->low += mask;                                                                                      \\\n            mask = (uint32_t)(bit) - 1;                                                                                \\\n            (range) += (newBound) & mask;                                                                              \\\n            mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));                                                            \\\n            mask += ((1 << 5) - 1);                                                                                    \\\n            (bit0Prob) += (int)(mask - (bit0Prob)) >> 5;                                                               \\\n            *(prob) = (CmptlzProb)(bit0Prob);                                                                          \\\n            CMPT_RC_NORMALIZE(rcCtx, range, shiftRes);                                                                 \\\n        } while (0);                                                                                                   \\\n    }",
                "rust_code": "macro_rules! CMPT_RC_BIT_PROCESS {\n    ($rcCtx:expr, $prob:expr, $bit:expr, $bit0Prob:expr, $range:expr, $newBound:expr, $shiftRes:expr) => {\n        {\n            let mut mask = 0 - ($bit as u32);\n            CMPT_RC_GET_NEWBOUND!($prob, $bit0Prob, $range, $newBound);\n            $range &= mask;\n            mask &= $newBound;\n            $range -= mask;\n            $rcCtx.low += mask;\n            mask = ($bit as u32) - 1;\n            $range += $newBound & mask;\n            mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n            mask += (1 << 5) - 1;\n            $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n            *$prob = $bit0Prob as CmptlzProb;\n            CMPT_RC_NORMALIZE!($rcCtx, $range, $shiftRes);\n        }\n    };\n}\npub(crate) use CMPT_RC_BIT_PROCESS;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450786374)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3472 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3493 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3604 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3608 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3612 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3630 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3650 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3690 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>()  + m, bit, bit0Prob, range, newBound, shiftRes);\n     |             ---------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3695 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>() + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3472 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3472 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3472 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3472 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3493 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3493 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3493 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3493 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3604 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3604 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3604 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3604 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3608 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3608 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3608 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3608 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3612 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3612 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3612 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3612 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3630 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3630 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3630 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3630 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3650 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3650 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3650 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3650 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3690 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>()  + m, bit, bit0Prob, range, newBound, shiftRes);\n     |             ---------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3690 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>()  + m, bit, bit0Prob, range, newBound, shiftRes);\n     |             ---------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3690 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>()  + m, bit, bit0Prob, range, newBound, shiftRes);\n     |             ---------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3690 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>()  + m, bit, bit0Prob, range, newBound, shiftRes);\n     |             ---------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3695 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>() + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3695 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>() + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3695 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>() + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3695 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>() + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 45 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 45 previous errors\n"
            },
            {
                "c_code": "#define CMPT_RC_BIT_0(prob, newBound, range, bit0Prob)                                                                 \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (range) = (newBound);                                                                                          \\\n        *(prob) = (CmptlzProb)((bit0Prob) + ((CMPTLZ_PROB_MAX_NUM - (bit0Prob)) >> 5));                                \\\n    } while (0)",
                "rust_code": "macro_rules! CMPT_RC_BIT_0 { ($prob:expr, $newBound:expr, $range:expr, $bit0Prob:expr) =>\n    {\n        $range = $newBound;\n        *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n    }\n}\npub(crate) use CMPT_RC_BIT_0;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450786829)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n2395 |         CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n     |         ---------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3600 |     CMPT_RC_BIT_0_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     ------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3713 |     CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n     |     ---------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3752 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3757 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3780 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3826 |             CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |             -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3840 |             CMPT_RC_BIT_0!(probs, newBound, range, bit0Prob);\n     |             ------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3857 |             CMPT_RC_BIT_0!(probs, newBound, range, bit0Prob);\n     |             ------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 9 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 9 previous errors\n"
            },
            {
                "c_code": "#define CMPT_RC_BIT_1(rcCtx, prob, newBound, range, bit0Prob)                                                          \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (range) -= (newBound);                                                                                         \\\n        (rcCtx)->low += (newBound);                                                                                    \\\n        *(prob) = (CmptlzProb)((bit0Prob) - ((bit0Prob) >> 5));                                                        \\\n    } while (0)",
                "rust_code": "macro_rules! CMPT_RC_BIT_1 { ($rcCtx:expr, $prob:expr, $newBound:expr, $range:expr, $bit0Prob:expr) =>\n    {\n        $range -= $newBound;\n        $rcCtx.low += $newBound;\n        *$prob = ($bit0Prob - ($bit0Prob >> 5)) as CmptlzProb;\n    }\n}\npub(crate) use CMPT_RC_BIT_1;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450787256)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3584:46\n     |\n3584 |         CMPT_RC_BIT_1_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                              ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3584 |         CMPT_RC_BIT_1_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |         ------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3589:50\n     |\n3589 |             CMPT_RC_BIT_1_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                  ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3589 |             CMPT_RC_BIT_1_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |             ------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3742:49\n     |\n3742 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                 ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3742 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3747:49\n     |\n3747 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                 ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3747 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3775:49\n     |\n3775 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                 ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3775 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3814:49\n     |\n3814 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                 ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3814 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3819:49\n     |\n3819 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                 ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3819 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3831:49\n     |\n3831 |             CMPT_RC_BIT_1!(encCtx.rcCtx, probs, newBound, range, bit0Prob);\n     |                                                 ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3831 |             CMPT_RC_BIT_1!(encCtx.rcCtx, probs, newBound, range, bit0Prob);\n     |             -------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3835:57\n     |\n3835 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                         ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3835 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |             -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3847:57\n     |\n3847 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                         ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3847 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |             -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3852:57\n     |\n3852 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                         ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3852 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |             -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3865:57\n     |\n3865 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                         ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3865 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |             -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3870:57\n     |\n3870 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                         ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3870 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |             -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3875:49\n     |\n3875 |             CMPT_RC_BIT_1!(encCtx.rcCtx, probs, newBound, range, bit0Prob);\n     |                                                 ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3875 |             CMPT_RC_BIT_1!(encCtx.rcCtx, probs, newBound, range, bit0Prob);\n     |             -------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 28 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 28 previous errors\n"
            },
            {
                "c_code": "#define CMPT_LIT_PROB_GET(encCtx, litProb, pos, prevByte)                                                              \\\n    (litProb + (uint32_t)3 * (((((pos) << 8) + (prevByte)) & encCtx->lpMask) << encCtx->litMarcov.lcBits))",
                "rust_code": "macro_rules! CMPT_LIT_PROB_GET {\n    ($encCtx:expr, $litProb:expr, $pos:expr, $prevByte:expr) => {\n        $litProb + (3 as u32) * (((($pos << 8) + $prevByte) & $encCtx.lpMask) << $encCtx.litMarcov.lcBits)\n    }\n}\npub(crate) use CMPT_LIT_PROB_GET;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450797739)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1189:63\n     |\n1189 |         $litProb + (3 as u32) * (((($pos << 8) + $prevByte) & $encCtx.lpMask) << $encCtx.litMarcov.lcBits)\n     |                                                               ^^^^^^^^^^^^^^ expected `u32`, found `u64`\n...\n3718 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1] as u32);\n     |             ------------------------------------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_LIT_PROB_GET` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 & u64`\n    --> src/src/cmptlz_c.rs:1189:61\n     |\n1189 |         $litProb + (3 as u32) * (((($pos << 8) + $prevByte) & $encCtx.lpMask) << $encCtx.litMarcov.lcBits)\n     |                                                             ^ no implementation for `u32 & u64`\n...\n3718 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1] as u32);\n     |             ------------------------------------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitAnd<u64>` is not implemented for `u32`\n     = help: the following other types implement trait `BitAnd<Rhs>`:\n               `&u32` implements `BitAnd<u32>`\n               `&u32` implements `BitAnd`\n               `u32` implements `BitAnd<&u32>`\n               `u32` implements `BitAnd`\n     = note: this error originates in the macro `CMPT_LIT_PROB_GET` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            }
        ]
    },
    "definition": {
        "all_cnt": 27,
        "passed_cnt": 27,
        "pass_rate": 1.0,
        "messages": []
    },
    "function": {
        "all_cnt": 122,
        "passed_cnt": 78,
        "pass_rate": 0.639344262295082,
        "messages": [
            {
                "c_code": "static int CmptLzPropsDecode(const unsigned char *protData, unsigned protSize, CmptLzDecProt *decProt)\n{\n    uint32_t dictSize;\n    if (protSize < CMPTLZ_PROPS_SIZE)\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n    else\n    {\n        dictSize =\n            protData[1] | ((uint32_t)protData[2] << 8) | ((uint32_t)protData[3] << 16) | ((uint32_t)protData[4] << 24);\n    }\n    if (dictSize < CMPTLZ_DICT_MIN_LEN)\n    {\n        dictSize = CMPTLZ_DICT_MIN_LEN;\n    }\n    decProt->dicSize = dictSize;\n    unsigned char firstData = protData[0];\n    if (firstData >= (CMPTLZ_LIT_CTX_MAX * CMPTLZ_POS_STATE_MAX * CMPTLZ_LIT_POS_MAX))\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n    decProt->litCtx = (unsigned char)(firstData % CMPTLZ_LIT_CTX_MAX);\n    firstData /= CMPTLZ_LIT_CTX_MAX;\n    decProt->posBits = (unsigned char)(firstData / CMPTLZ_POS_STATE_MAX);\n    decProt->litPos = (unsigned char)(firstData % CMPTLZ_LIT_POS_MAX);\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptLzPropsDecode(mut protData: Ptr<u8>, mut protSize: u8, mut decProt: Ptr<CmptLzDecProt>) -> i32 {\n    let mut dictSize: u32;\n    if (protSize < CMPTLZ_PROPS_SIZE!()) {\n        return CMPT_ERROR_UNSUPPORTED!();\n    } else {\n        dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n    }\n    if (dictSize < CMPTLZ_DICT_MIN_LEN!()) {\n        dictSize = CMPTLZ_DICT_MIN_LEN!();\n    }\n    decProt.dicSize = dictSize;\n    let mut firstData: u8 = protData[0];\n    if (firstData >= (CMPTLZ_LIT_CTX_MAX!() * CMPTLZ_POS_STATE_MAX!() * CMPTLZ_LIT_POS_MAX!())) {\n        return CMPT_ERROR_UNSUPPORTED!();\n    }\n    decProt.litCtx = (firstData % CMPTLZ_LIT_CTX_MAX!());\n    firstData /= CMPTLZ_LIT_CTX_MAX!();\n    decProt.posBits = (firstData / CMPTLZ_POS_STATE_MAX!());\n    decProt.litPos = (firstData % CMPTLZ_LIT_POS_MAX!());\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450958960)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1243:35\n     |\n1243 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n     |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`, found `u32`\n\nerror[E0277]: no implementation for `u8 | u32`\n    --> src/src/cmptlz_c.rs:1243:33\n     |\n1243 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n     |                                 ^ no implementation for `u8 | u32`\n     |\n     = help: the trait `BitOr<u32>` is not implemented for `u8`\n     = help: the following other types implement trait `BitOr<Rhs>`:\n               `&u8` implements `BitOr<u8>`\n               `&u8` implements `BitOr`\n               `u8` implements `BitOr<&u8>`\n               `u8` implements `BitOr`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1243:65\n     |\n1243 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n     |                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`, found `u32`\n\nerror[E0277]: no implementation for `u8 | u32`\n    --> src/src/cmptlz_c.rs:1243:63\n     |\n1243 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n     |                                                               ^ no implementation for `u8 | u32`\n     |\n     = help: the trait `BitOr<u32>` is not implemented for `u8`\n     = help: the following other types implement trait `BitOr<Rhs>`:\n               `&u8` implements `BitOr<u8>`\n               `&u8` implements `BitOr`\n               `u8` implements `BitOr<&u8>`\n               `u8` implements `BitOr`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1243:96\n     |\n1243 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n     |                                                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`, found `u32`\n\nerror[E0277]: no implementation for `u8 | u32`\n    --> src/src/cmptlz_c.rs:1243:94\n     |\n1243 |         dictSize = (protData[1] | ((protData[2] as u32) << 8) | ((protData[3] as u32) << 16) | ((protData[4] as u32) << 24)).cast();\n     |                                                                                              ^ no implementation for `u8 | u32`\n     |\n     = help: the trait `BitOr<u32>` is not implemented for `u8`\n     = help: the following other types implement trait `BitOr<Rhs>`:\n               `&u8` implements `BitOr<u8>`\n               `&u8` implements `BitOr`\n               `u8` implements `BitOr<&u8>`\n               `u8` implements `BitOr`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 6 previous errors\n"
            },
            {
                "c_code": "static void *CmptLzDecMemAlloc(CmptLzMemHook *memHook, int32_t memHandle, size_t allocSize)\n{\n    return memHook->CmptLzAlloc(memHandle, allocSize);\n}",
                "rust_code": "pub fn CmptLzDecMemAlloc(mut memHook: Ptr<CmptLzMemHook>, mut memHandle: i32, mut allocSize: usize) -> Ptr<Void> {\n    return memHook.CmptLzAlloc(memHandle, allocSize);\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450964428)\nerror[E0599]: no method named `CmptLzAlloc` found for struct `memory::ptr::Ptr<CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:1269:20\n     |\n1269 |     return memHook.CmptLzAlloc(memHandle, allocSize);\n     |                    ^^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzAlloc` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzAlloc`, surround the field access with parentheses\n     |\n1269 |     return (memHook.CmptLzAlloc)(memHandle, allocSize);\n     |            +                   +\n\nerror[E0599]: no method named `CmptLzAlloc` found for struct `memory::ptr::Ptr<cmptlz_c::CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:1269:20\n     |\n1269 |     return memHook.CmptLzAlloc(memHandle, allocSize);\n     |                    ^^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzAlloc` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzAlloc`, surround the field access with parentheses\n     |\n1269 |     return (memHook.CmptLzAlloc)(memHandle, allocSize);\n     |            +                   +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "static void CmptLzDecMemFree(CmptLzMemHook *memHook, int32_t memHandle, void *freeAddress)\n{\n    memHook->CmptLzFree(memHandle, freeAddress);\n}",
                "rust_code": "pub fn CmptLzDecMemFree(mut memHook: Ptr<CmptLzMemHook>, mut memHandle: i32, mut freeAddress: Ptr<Void>) {\n    memHook.CmptLzFree(memHandle, freeAddress);\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450964867)\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:1273:13\n     |\n1273 |     memHook.CmptLzFree(memHandle, freeAddress);\n     |             ^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzFree` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n     |\n1273 |     (memHook.CmptLzFree)(memHandle, freeAddress);\n     |     +                  +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_c::CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:1273:13\n     |\n1273 |     memHook.CmptLzFree(memHandle, freeAddress);\n     |             ^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzFree` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n     |\n1273 |     (memHook.CmptLzFree)(memHandle, freeAddress);\n     |     +                  +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "static int CmptLzDecAllocateProbs(CmptLzDecCtx *decCtx, CmptLzDecProt *decProt, CmptLzMemHook *memHook)\n{\n    uint32_t numProbs = CmptLzGetNumProbs(decProt);\n    if (decCtx->probs == NULL)\n    {\n        decCtx->probs =\n            (CmptLzDecProb *)CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE, numProbs * sizeof(CmptLzDecProb));\n    }\n    else\n    {\n        if (numProbs != decCtx->numProbs)\n        {\n            CmptLzDecFreeProbs(decCtx, memHook);\n            decCtx->probs =\n                (CmptLzDecProb *)CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE, numProbs * sizeof(CmptLzDecProb));\n        }\n    }\n    if (decCtx->probs == NULL)\n    {\n        return CMPT_ERROR_MEM;\n    }\n    decCtx->probsPlus1664 = decCtx->probs + 1664;\n    decCtx->numProbs = numProbs;\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptLzDecAllocateProbs(mut decCtx: Ptr<CmptLzDecCtx>, mut decProt: Ptr<CmptLzDecProt>, mut memHook: Ptr<CmptLzMemHook>) -> i32 {\n    let mut numProbs: u32 = CmptLzGetNumProbs(decProt);\n    if (decCtx.probs == NULL!()) {\n        decCtx.probs = CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE!(), numProbs * c_sizeof!(CmptLzDecProb)).cast::<Ptr<CmptLzDecProb>>();\n    } else {\n        if (numProbs != decCtx.numProbs) {\n            CmptLzDecFreeProbs(decCtx, memHook);\n            decCtx.probs = CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE!(), numProbs * c_sizeof!(CmptLzDecProb)).cast::<Ptr<CmptLzDecProb>>();\n        }\n    }\n    if (decCtx.probs == NULL!()) {\n        return CMPT_ERROR_MEM!();\n    }\n    decCtx.probsPlus1664 = (decCtx.probs + 1664);\n    decCtx.numProbs = numProbs;\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750450970320)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1286:74\n     |\n1286 |         decCtx.probs = CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE!(), numProbs * c_sizeof!(CmptLzDecProb)).cast::<Ptr<CmptLzDecProb>>();\n     |                        -----------------                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n     |                        |\n     |                        arguments to this function are incorrect\n     |\nnote: function defined here\n    --> src/src/cmptlz_c.rs:1268:8\n     |\n1268 | pub fn CmptLzDecMemAlloc(mut memHook: Ptr<CmptLzMemHook>, mut memHandle: i32, mut allocSize: usize) -> VoidPtr {\n     |        ^^^^^^^^^^^^^^^^^                                                      --------------------\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n     |\n1286 |         decCtx.probs = CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE!(), (numProbs * c_sizeof!(CmptLzDecProb)).try_into().unwrap()).cast::<Ptr<CmptLzDecProb>>();\n     |                                                                          +                                   +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1290:78\n     |\n1290 | ....probs = CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE!(), numProbs * c_sizeof!(CmptLzDecProb)).cast::<Ptr<CmptLzDecProb>>();\n     |             -----------------                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n     |             |\n     |             arguments to this function are incorrect\n     |\nnote: function defined here\n    --> src/src/cmptlz_c.rs:1268:8\n     |\n1268 | pub fn CmptLzDecMemAlloc(mut memHook: Ptr<CmptLzMemHook>, mut memHandle: i32, mut allocSize: usize) -> VoidPtr {\n     |        ^^^^^^^^^^^^^^^^^                                                      --------------------\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n     |\n1290 |             decCtx.probs = CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE!(), (numProbs * c_sizeof!(CmptLzDecProb)).try_into().unwrap()).cast::<Ptr<CmptLzDecProb>>();\n     |                                                                              +                                   +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "static size_t CmptLzDistDec(CmptLzDecCtx *decCtx, CmptLzDecProb *probsMatrix, uint32_t *pRange, uint32_t *pRangeCode,\n                            uint32_t *pRangeBound, uint32_t decLen)\n{\n    uint32_t assistBits;\n    uint32_t posSlot = 1;\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    const unsigned char *bufToDec = decCtx->buf;\n    uint32_t distDec;\n    CmptLzDecProb *probPosSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decLen);\n    int i = 0;\n    for (i = 0; i < CMPTLZ_POS_SLOT_BITS; i++)\n    {\n        CMPTLZ_POSSLOT_BIT_DEC((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    }\n    posSlot -= 64;\n    if (posSlot < CMPTLZ_LOW_POSSLOT)\n    {\n        distDec = posSlot;\n        CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n        if (distDec == (size_t)0xFFFFFFFF)\n        {\n            return distDec;\n        }\n        else\n        {\n            return (distDec + 1);\n        }\n    }\n    uint32_t directBitNum = ((posSlot >> 1) - 1);\n    distDec = CmptLzGetBaseDistByPosSlot(posSlot);\n    if (posSlot < CMPTLZ_HIGH_POSSLOT)\n    {\n        assistBits = 1;\n        distDec <<= directBitNum;\n        distDec += assistBits;\n        probPosSlot = CmptLzGetSpecPosProb(probsMatrix);\n        do\n        {\n            if CMPTLZ_IS_THE_BIT_0 ((probPosSlot + distDec), range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0((probPosSlot + distDec), range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                distDec += assistBits;\n                assistBits <<= 1;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1((probPosSlot + distDec), range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                assistBits <<= 1;\n                distDec += assistBits;\n            }\n        } while (--directBitNum);\n        distDec -= assistBits;\n    }\n    else\n    {\n        directBitNum -= CMPTLZ_REP4;\n        do\n        {\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            range >>= 1;\n            rangeCode -= range;\n            assistBits = (0 - ((uint32_t)rangeCode >> 31));\n            distDec = (distDec << 1) + (assistBits + 1);\n            rangeCode += range & assistBits;\n        } while (--directBitNum);\n        CmptLzDecProb *probDist;\n        probPosSlot = CmptLzGetAilgnProb(probsMatrix);\n        distDec <<= CMPTLZ_LARGE_DIST_LOW_BITS;\n        assistBits = 1;\n        uint32_t cycleSym = 1;\n        for (i = 0; i < 3; i++)\n        {\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            CMPTLZ_DIST_BIT_DEC(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n            cycleSym <<= 1;\n        }\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probDist = probPosSlot + assistBits;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probDist);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probDist, range, rangeBound);\n            assistBits -= 8;\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probDist, range, rangeCode, rangeBound);\n        }\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        distDec |= assistBits;\n    }\n    CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n    if (distDec == (size_t)0xFFFFFFFF)\n    {\n        return distDec;\n    }\n    else\n    {\n        return (distDec + 1);\n    }\n}",
                "rust_code": "pub fn CmptLzDistDec(mut decCtx: Ptr<CmptLzDecCtx>, mut probsMatrix: Ptr<CmptLzDecProb>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut decLen: u32) -> usize {\n    let mut assistBits: u32;\n    let mut posSlot: u32 = 1;\n    let mut range: u32 = *pRange;\n    let mut rangeCode: u32 = *pRangeCode;\n    let mut rangeBound: u32 = *pRangeBound;\n    let mut bufToDec: Ptr<u8> = decCtx.buf;\n    let mut distDec: u32;\n    let mut probPosSlot: Ptr<CmptLzDecProb> = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decLen);\n    let mut i: i32 = 0;\n    c_for!(i = 0; i < CMPTLZ_POS_SLOT_BITS!(); i.suffix_plus_plus(); {\n        CMPTLZ_POSSLOT_BIT_DEC!((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    });\n    posSlot -= 64;\n    if (posSlot < CMPTLZ_LOW_POSSLOT!()) {\n        distDec = posSlot;\n        CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n        if (distDec == 0xFFFFFFFF.cast::<usize>()) {\n            return distDec.cast();\n        } else {\n            return (distDec + 1).cast();\n        }\n    }\n    let mut directBitNum: u32 = ((posSlot >> 1) - 1);\n    distDec = CmptLzGetBaseDistByPosSlot(posSlot);\n    if (posSlot < CMPTLZ_HIGH_POSSLOT!()) {\n        assistBits = 1;\n        distDec <<= directBitNum;\n        distDec += assistBits;\n        probPosSlot = CmptLzGetSpecPosProb(probsMatrix);\n        c_do!({\n            if CMPTLZ_IS_THE_BIT_0!((probPosSlot + distDec), range, rangeCode, rangeBound).as_bool() {\n                CMPTLZ_RANGE_UPDATE_0!((probPosSlot + distDec), range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n                distDec += assistBits;\n                assistBits <<= 1;\n            } else {\n                CMPTLZ_RANGE_UPDATE_1!((probPosSlot + distDec), range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n                assistBits <<= 1;\n                distDec += assistBits;\n            }\n        } while directBitNum.prefix_minus_minus());\n        distDec -= assistBits;\n    } else {\n        directBitNum -= CMPTLZ_REP4!();\n        c_do!({\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            range >>= 1;\n            rangeCode -= range;\n            assistBits = (0 - ((rangeCode >> 31).cast::<u32>()));\n            distDec = (distDec << 1) + (assistBits + 1);\n            rangeCode += range & assistBits;\n        } while directBitNum.prefix_minus_minus());\n        let mut probDist: Ptr<CmptLzDecProb>;\n        probPosSlot = CmptLzGetAilgnProb(probsMatrix);\n        distDec <<= CMPTLZ_LARGE_DIST_LOW_BITS!();\n        assistBits = 1;\n        let mut cycleSym: u32 = 1;\n        c_for!(i = 0; i < 3; i.suffix_plus_plus(); {\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            CMPTLZ_DIST_BIT_DEC!(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n            cycleSym <<= 1;\n        });\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        probDist = (probPosSlot + assistBits);\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probDist);\n        if (rangeCode < rangeBound) {\n            CMPTLZ_RANGE_UPDATE_0!(probDist, range, rangeBound);\n            assistBits -= 8;\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probDist, range, rangeCode, rangeBound);\n        }\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        distDec |= assistBits;\n    }\n    CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n    if (distDec == 0xFFFFFFFF.cast::<usize>()) {\n        return distDec.cast();\n    } else {\n        return (distDec + 1).cast();\n    }\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451067263)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1425:24\n     |\n1425 |         if (distDec == 0xFFFFFFFF.cast::<usize>()) {\n     |             -------    ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `usize`\n     |             |\n     |             expected because this is `u32`\n     |\nhelp: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit\n     |\n1425 |         if (distDec == 0xFFFFFFFF.cast::<usize>().try_into().unwrap()) {\n     |                                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1450:17\n     |\n1450 |         } while directBitNum.prefix_minus_minus());\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `u32`\n     |\n    ::: src/translation_utils/c_alignment/c_do_while.rs:7:15\n     |\n7    |         while core::mem::replace(&mut __first, false) || $cond\n     |               --------------------------------------- expected because this is `bool`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1461:17\n     |\n1461 |         } while directBitNum.prefix_minus_minus());\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `u32`\n     |\n    ::: src/translation_utils/c_alignment/c_do_while.rs:7:15\n     |\n7    |         while core::mem::replace(&mut __first, false) || $cond\n     |               --------------------------------------- expected because this is `bool`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1474:57\n     |\n1474 |         rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probDist);\n     |                                                         ^^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:1474:55\n     |\n1474 |         rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probDist);\n     |                                                       ^ no implementation for `u32 * u16`\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1485:20\n     |\n1485 |     if (distDec == 0xFFFFFFFF.cast::<usize>()) {\n     |         -------    ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `usize`\n     |         |\n     |         expected because this is `u32`\n     |\nhelp: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit\n     |\n1485 |     if (distDec == 0xFFFFFFFF.cast::<usize>().try_into().unwrap()) {\n     |                                              ++++++++++++++++++++\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 6 previous errors\n"
            },
            {
                "c_code": "static uint32_t CmptLzDecByDistAndLen(CmptLzDecCtx *decCtx, size_t matchDist, uint32_t matchLen, size_t dicPosLimit)\n{\n    size_t dicCopyPos;\n    size_t dicPos = decCtx->dictPos;\n    size_t dictBufSize = decCtx->dictBufSize;\n    uint32_t remainDicLen = (uint32_t)(dicPosLimit - dicPos);\n    unsigned char *dict = decCtx->dict;\n    if (remainDicLen == 0)\n    {\n        return CMPT_ERROR_DATA;\n    }\n    uint32_t decDicLen = ((remainDicLen < matchLen) ? remainDicLen : matchLen);\n    decCtx->processedPos += decDicLen;\n    decCtx->dictPos += decDicLen;\n    decCtx->remainLen = matchLen - decDicLen;\n    if (dicPos < matchDist)\n    {\n        dicCopyPos = dictBufSize - matchDist + dicPos;\n    }\n    else\n    {\n        dicCopyPos = dicPos - matchDist;\n    }\n    do\n    {\n        dict[dicPos++] = dict[dicCopyPos];\n        if (++dicCopyPos == dictBufSize)\n        {\n            dicCopyPos = 0;\n        }\n    } while (--decDicLen != 0);\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptLzDecByDistAndLen(mut decCtx: Ptr<CmptLzDecCtx>, mut matchDist: usize, mut matchLen: u32, mut dicPosLimit: usize) -> u32 {\n    let mut dicCopyPos: usize;\n    let mut dicPos: usize = decCtx.dictPos;\n    let mut dictBufSize: usize = decCtx.dictBufSize;\n    let mut remainDicLen: u32 = (dicPosLimit - dicPos).cast();\n    let mut dict: Ptr<u8> = decCtx.dict;\n    if (remainDicLen == 0) {\n        return CMPT_ERROR_DATA!();\n    }\n    let mut decDicLen: u32 = if remainDicLen < matchLen { remainDicLen } else { matchLen };\n    decCtx.processedPos += decDicLen;\n    decCtx.dictPos += decDicLen.cast();\n    decCtx.remainLen = (matchLen - decDicLen);\n    if (dicPos < matchDist) {\n        dicCopyPos = (dictBufSize - matchDist + dicPos);\n    } else {\n        dicCopyPos = (dicPos - matchDist);\n    }\n    c_do!({\n        dict[dicPos] = dict[dicCopyPos];\n        dicPos += 1;\n        if (dicCopyPos.prefix_plus_plus() == dictBufSize) {\n            dicCopyPos = 0;\n        }\n    } while (decDicLen.suffix_minus_minus() != 0));\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451072677)\nerror[E0283]: type annotations needed\n    --> src/src/cmptlz_c.rs:1556:33\n     |\n1556 |     decCtx.dictPos += decDicLen.cast();\n     |                    --           ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n     |                    |\n     |                    type must be known at this point\n     |\n     = note: multiple `impl`s satisfying `usize: std::ops::AddAssign<_>` found in the `core` crate:\n             - impl std::ops::AddAssign for usize;\n             - impl std::ops::AddAssign<&usize> for usize;\nhelp: consider specifying the generic argument\n     |\n1556 |     decCtx.dictPos += decDicLen.cast::<T>();\n     |                                     +++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "static void CmptLzShortRepDec(CmptLzDecCtx *decCtx)\n{\n    uint32_t rep0 = decCtx->reps[0];\n    unsigned char *dict = decCtx->dict;\n    size_t dictPos = decCtx->dictPos;\n    size_t dictBufSize = decCtx->dictBufSize;\n    dict[dictPos] = dict[dictPos - rep0 + (dictPos < rep0 ? dictBufSize : 0)];\n    decCtx->dictPos++;\n    decCtx->processedPos++;\n    if (decCtx->state < CMPTLZ_LIT_STATES)\n    {\n        decCtx->state = 9;\n    }\n    else\n    {\n        decCtx->state = 11;\n    }\n}",
                "rust_code": "pub fn CmptLzShortRepDec(mut decCtx: Ptr<CmptLzDecCtx>) {\n    let mut rep0: u32 = decCtx.reps[0];\n    let mut dict: Ptr<u8> = decCtx.dict;\n    let mut dictPos: usize = decCtx.dictPos;\n    let mut dictBufSize: usize = decCtx.dictBufSize;\n    dict[dictPos] = dict[dictPos - rep0 + if dictPos < rep0 { dictBufSize } else { 0 }];\n    decCtx.dictPos += 1;\n    decCtx.processedPos += 1;\n    if (decCtx.state < CMPTLZ_LIT_STATES!()) {\n        decCtx.state = 9;\n    } else {\n        decCtx.state = 11;\n    }\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451073102)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1577:36\n     |\n1577 |     dict[dictPos] = dict[dictPos - rep0 + if dictPos < rep0 { dictBufSize } else { 0 }];\n     |                                    ^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n    --> src/src/cmptlz_c.rs:1577:34\n     |\n1577 |     dict[dictPos] = dict[dictPos - rep0 + if dictPos < rep0 { dictBufSize } else { 0 }];\n     |                                  ^ no implementation for `usize - u32`\n     |\n     = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n     = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n               `&usize` implements `std::ops::Sub<usize>`\n               `&usize` implements `std::ops::Sub`\n               `usize` implements `std::ops::Sub<&usize>`\n               `usize` implements `std::ops::Sub<types::num::Num>`\n               `usize` implements `std::ops::Sub`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1577:56\n     |\n1577 |     dict[dictPos] = dict[dictPos - rep0 + if dictPos < rep0 { dictBufSize } else { 0 }];\n     |                                              -------   ^^^^ expected `usize`, found `u32`\n     |                                              |\n     |                                              expected because this is `usize`\n     |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n     |\n1577 |     dict[dictPos] = dict[dictPos - rep0 + if dictPos < rep0.try_into().unwrap() { dictBufSize } else { 0 }];\n     |                                                            ++++++++++++++++++++\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 3 previous errors\n"
            },
            {
                "c_code": "static uint32_t CmptLzRepDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound,\n                             size_t dicPosLimit, uint32_t posState)\n{\n    uint32_t repLen;\n    uint32_t repDist;\n    uint32_t mkState = decCtx->state;\n    const unsigned char *bufToDec = decCtx->buf;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    probSlot = CmptLzGetIsRepG0Prob(probsMatrix) + mkState;\n    if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probSlot = CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState;\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            *pRange = range;\n            *pRangeCode = rangeCode;\n            *pRangeBound = rangeBound;\n            decCtx->buf = bufToDec;\n            CmptLzShortRepDec(decCtx);\n            return CMPT_OK;\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            repDist = decCtx->reps[0];\n        }\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probSlot = CmptLzGetIsRepG1Prob(probsMatrix) + mkState;\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            repDist = decCtx->reps[1];\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            probSlot = CmptLzGetIsRepG2Prob(probsMatrix) + mkState;\n            if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                repDist = decCtx->reps[CMPTLZ_REP2];\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                repDist = decCtx->reps[CMPTLZ_REP3];\n                decCtx->reps[CMPTLZ_REP3] = decCtx->reps[CMPTLZ_REP2];\n            }\n            decCtx->reps[CMPTLZ_REP2] = decCtx->reps[1];\n        }\n        decCtx->reps[1] = decCtx->reps[0];\n        decCtx->reps[0] = repDist;\n    }\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx->buf = bufToDec;\n    decCtx->state = (mkState < CMPTLZ_LIT_STATES) ? 8 : 11;\n    probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n    repLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n    return CmptLzDecByDistAndLen(decCtx, repDist, repLen + 2, dicPosLimit);\n}",
                "rust_code": "pub fn CmptLzRepDec(mut decCtx: Ptr<CmptLzDecCtx>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut dicPosLimit: usize, mut posState: u32) -> u32 {\n    let mut repLen: u32;\n    let mut repDist: u32;\n    let mut mkState: u32 = decCtx.state;\n    let mut bufToDec: Ptr<u8> = decCtx.buf;\n    let mut probSlot: Ptr<CmptLzDecProb>;\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx);\n    let mut range: u32 = *pRange;\n    let mut rangeCode: u32 = *pRangeCode;\n    let mut rangeBound: u32 = *pRangeBound;\n    probSlot = (CmptLzGetIsRepG0Prob(probsMatrix) + mkState);\n    if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n        CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        probSlot = (CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState);\n        if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n            CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            *pRange = range;\n            *pRangeCode = rangeCode;\n            *pRangeBound = rangeBound;\n            decCtx.buf = bufToDec;\n            CmptLzShortRepDec(decCtx);\n            return CMPT_OK!();\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            repDist = decCtx.reps[0];\n        }\n    } else {\n        CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        probSlot = (CmptLzGetIsRepG1Prob(probsMatrix) + mkState);\n        if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n            CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            repDist = decCtx.reps[1];\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            probSlot = (CmptLzGetIsRepG2Prob(probsMatrix) + mkState);\n            if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n                CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n                repDist = decCtx.reps[CMPTLZ_REP2!()];\n            } else {\n                CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n                repDist = decCtx.reps[CMPTLZ_REP3!()];\n                let tmp0 = CMPTLZ_REP3!();\n                decCtx.reps[tmp0];\n            }\n            decCtx.reps[CMPTLZ_REP2!()] = decCtx.reps[1];\n        }\n        decCtx.reps[1] = decCtx.reps[0];\n        decCtx.reps[0] = repDist;\n    }\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx.buf = bufToDec;\n    decCtx.state = if mkState < CMPTLZ_LIT_STATES!() { 8 } else { 11 };\n    probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n    repLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n    return CmptLzDecByDistAndLen(decCtx, repDist.cast(), (repLen + 2), dicPosLimit);\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451073533)\n    Finished `test` profile [optimized + debuginfo] target(s) in 2.61s\n     Running unittests src/lib.rs (target/debug/deps/my_proj-baa1ee44ab22c9ed)\nerror: test failed, to rerun pass `--lib`\n"
            },
            {
                "c_code": "static uint32_t CmptLzLitDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound)\n{\n    uint32_t decSym = 1;\n    uint32_t mkState = decCtx->state;\n    uint32_t procPos = decCtx->processedPos;\n    uint32_t checkDicSize = decCtx->checkDicSize;\n    uint32_t litCtx = decCtx->prop.litCtx;\n    uint32_t litPosMask = ((uint32_t)0x100 << decCtx->prop.litPos) - ((uint32_t)0x100 >> litCtx);\n    CmptLzDecProb *probLit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    const unsigned char *bufToDec = decCtx->buf;\n    unsigned char *dict = decCtx->dict;\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t dictPos = decCtx->dictPos;\n    uint32_t range = *pRange;\n    uint32_t rangeBound = *pRangeBound;\n    uint32_t rangeCode = *pRangeCode;\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0 || checkDicSize != 0)\n    {\n        probSlot += (uint32_t)CMPTLZ_REP3 *\n                    ((((procPos << 8) + dict[(dictPos == 0 ? dictBufSize : dictPos) - 1]) & litPosMask) << litCtx);\n    }\n    int i = 0;\n    if (mkState < CMPTLZ_LIT_STATES)\n    {\n        mkState -= (mkState < 4) ? mkState : 3;\n        for (i = 0; i < 8; i++)\n        {\n            CMPTLZ_NORMAL_BIT_DEC((probSlot + decSym), range, rangeCode, rangeBound, decSym);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        }\n    }\n    else\n    {\n        uint32_t bit;\n        uint32_t offset = 0x100;\n        uint32_t rep0 = decCtx->reps[0];\n        uint32_t matchSym = dict[dictPos - rep0 + ((dictPos < rep0) ? dictBufSize : 0)];\n        mkState -= (mkState < 10) ? CMPTLZ_REP3 : 6;\n        for (i = 0; i < 8; i++)\n        {\n            CMPTLZ_MATCH_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n        }\n    }\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    dict[dictPos++] = (uint8_t)decSym;\n    decCtx->processedPos += 1;\n    decCtx->state = mkState;\n    decCtx->dictPos = dictPos;\n    decCtx->buf = bufToDec;\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptLzLitDec(mut decCtx: Ptr<CmptLzDecCtx>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>) -> u32 {\n    let mut decSym: u32 = 1;\n    let mut mkState: u32 = decCtx.state;\n    let mut procPos: u32 = decCtx.processedPos;\n    let mut checkDicSize: u32 = decCtx.checkDicSize;\n    let mut litCtx: u32 = decCtx.prop.litCtx.cast();\n    let mut litPosMask: u32 = ((0x100 as u32) << decCtx.prop.litPos) - ((0x100 as u32) >> litCtx);\n    let mut probLit: Ptr<CmptLzDecProb> = Default::default();\n    let mut probSlot: Ptr<CmptLzDecProb> = Default::default();\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx);\n    let mut bufToDec: Ptr<u8> = decCtx.buf;\n    let mut dict: Ptr<u8> = decCtx.dict;\n    let mut dictBufSize: usize = decCtx.dictBufSize;\n    let mut dictPos: usize = decCtx.dictPos;\n    let mut range: u32 = *pRange;\n    let mut rangeBound: u32 = *pRangeBound;\n    let mut rangeCode: u32 = *pRangeCode;\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0) || (checkDicSize != 0) {\n        probSlot += (CMPTLZ_REP3!() as u32) *\n                    ((((procPos << 8) + dict[(if dictPos == 0 { dictBufSize } else { dictPos }) - 1]) & litPosMask) << litCtx);\n    }\n    let mut i: i32 = 0;\n    if (mkState < CMPTLZ_LIT_STATES!()) {\n        mkState -= if (mkState < 4) { mkState } else { 3 };\n        c_for!(; i < 8; i.suffix_plus_plus(); {\n            CMPTLZ_NORMAL_BIT_DEC!((probSlot + decSym), range, rangeCode, rangeBound, decSym);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        });\n    } else {\n        let mut bit: u32 = Default::default();\n        let mut offset: u32 = 0x100;\n        let mut rep0: u32 = decCtx.reps[0];\n        let mut matchSym: u32 = dict[dictPos - rep0 + (if (dictPos < rep0) { dictBufSize } else { 0 })].cast();\n        mkState -= if (mkState < 10) { CMPTLZ_REP3!() } else { 6 };\n        c_for!(; i < 8; i.suffix_plus_plus(); {\n            CMPTLZ_MATCH_BIT_DEC!(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n        });\n    }\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    dict[dictPos] = decSym.cast::<u8>();\n    dictPos += 1;\n    decCtx.processedPos += 1;\n    decCtx.state = mkState;\n    decCtx.dictPos = dictPos;\n    decCtx.buf = bufToDec;\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451082048)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1694:41\n     |\n1694 |                     ((((procPos << 8) + dict[(if dictPos == 0 { dictBufSize } else { dictPos }) - 1]) & litPosMask) << litCtx);\n     |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n\nerror[E0277]: cannot add `u8` to `u32`\n    --> src/src/cmptlz_c.rs:1694:39\n     |\n1694 |                     ((((procPos << 8) + dict[(if dictPos == 0 { dictBufSize } else { dictPos }) - 1]) & litPosMask) << litCtx);\n     |                                       ^ no implementation for `u32 + u8`\n     |\n     = help: the trait `std::ops::Add<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Add<Rhs>`:\n               `&u32` implements `std::ops::Add<u32>`\n               `&u32` implements `std::ops::Add`\n               `u32` implements `std::ops::Add<&u32>`\n               `u32` implements `std::ops::Add<types::num::Num>`\n               `u32` implements `std::ops::Add`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1707:48\n     |\n1707 |         let mut matchSym: u32 = dict[dictPos - rep0 + (if (dictPos < rep0) { dictBufSize } else { 0 })].cast();\n     |                                                ^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n    --> src/src/cmptlz_c.rs:1707:46\n     |\n1707 |         let mut matchSym: u32 = dict[dictPos - rep0 + (if (dictPos < rep0) { dictBufSize } else { 0 })].cast();\n     |                                              ^ no implementation for `usize - u32`\n     |\n     = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n     = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n               `&usize` implements `std::ops::Sub<usize>`\n               `&usize` implements `std::ops::Sub`\n               `usize` implements `std::ops::Sub<&usize>`\n               `usize` implements `std::ops::Sub<types::num::Num>`\n               `usize` implements `std::ops::Sub`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1707:70\n     |\n1707 |         let mut matchSym: u32 = dict[dictPos - rep0 + (if (dictPos < rep0) { dictBufSize } else { 0 })].cast();\n     |                                                            -------   ^^^^ expected `usize`, found `u32`\n     |                                                            |\n     |                                                            expected because this is `usize`\n     |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n     |\n1707 |         let mut matchSym: u32 = dict[dictPos - rep0 + (if (dictPos < rep0.try_into().unwrap()) { dictBufSize } else { 0 })].cast();\n     |                                                                          ++++++++++++++++++++\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 5 previous errors\n"
            },
            {
                "c_code": "int CmptLzDecDirectProcess(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *bufLimit)\n{\n    uint32_t decRes;\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t procPos;\n    uint32_t mkState;\n    uint32_t posState;\n    uint32_t range = decCtx->range;\n    uint32_t rangeCode = decCtx->code;\n    uint32_t rangeBound = 0;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    do\n    {\n        procPos = decCtx->processedPos;\n        mkState = decCtx->state;\n        posState = CMPTLZ_CALC_POS_STATE(procPos, pbMask);\n        probSlot = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n            decRes = CmptLzLitDec(decCtx, &range, &rangeCode, &rangeBound);\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n            probSlot = CmptLzGetIsRepProb(probsMatrix) + mkState;\n            if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n                decRes = CmptLzMatchDec(decCtx, &range, &rangeCode, &rangeBound, dicPosLimit, posState);\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n                decRes = CmptLzRepDec(decCtx, &range, &rangeCode, &rangeBound, dicPosLimit, posState);\n            }\n            if (decRes != CMPT_OK)\n            {\n                break;\n            }\n        }\n    } while (decCtx->dictPos < dicPosLimit && decCtx->buf < bufLimit && decCtx->remainLen < CMPTLZ_MATCH_MAX_LEN);\n    decCtx->range = range;\n    decCtx->code = rangeCode;\n    return (int)decRes;\n}",
                "rust_code": "pub fn CmptLzDecDirectProcess(mut decCtx: Ptr<CmptLzDecCtx>, mut dicPosLimit: usize, mut bufLimit: Ptr<u8>) -> i32 {\n    let mut decRes: u32;\n    let mut pbMask: u32 = ((1 as u32) << decCtx.prop.posBits) - 1;\n    let mut procPos: u32;\n    let mut mkState: u32;\n    let mut posState: u32;\n    let mut range: u32 = decCtx.range;\n    let mut rangeCode: u32 = decCtx.code;\n    let mut rangeBound: u32 = 0;\n    let mut probSlot: Ptr<CmptLzDecProb>;\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx);\n    c_do!({\n        procPos = decCtx.processedPos;\n        mkState = decCtx.state;\n        posState = CMPTLZ_CALC_POS_STATE!(procPos, pbMask);\n        probSlot = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n        if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n            CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n            decRes = CmptLzLitDec(decCtx, c_ref!(range), c_ref!(rangeCode), c_ref!(rangeBound));\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n            probSlot = CmptLzGetIsRepProb(probsMatrix) + mkState;\n            if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n                CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n                decRes = CmptLzMatchDec(decCtx, c_ref!(range), c_ref!(rangeCode), c_ref!(rangeBound), dicPosLimit, posState);\n            } else {\n                CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n                decRes = CmptLzRepDec(decCtx, c_ref!(range), c_ref!(rangeCode), c_ref!(rangeBound), dicPosLimit, posState);\n            }\n            if (decRes != CMPT_OK!()) {\n                break;\n            }\n        }\n    } while (decCtx.dictPos < dicPosLimit) && (decCtx.buf < bufLimit) && (decCtx.remainLen < CMPTLZ_MATCH_MAX_LEN!()));\n    decCtx.range = range;\n    decCtx.code = rangeCode;\n    return decRes.cast::<i32>();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451082544)\nerror[E0381]: used binding `decRes` is possibly-uninitialized\n    --> src/src/cmptlz_c.rs:1775:12\n     |\n1735 |     let mut decRes: u32;\n     |         ---------- binding declared here but left uninitialized\n...\n1755 |         } else {\n     |          ------ if the `if` condition is `false` and this `else` arm is executed, `decRes` is not initialized\n...\n1775 |     return decRes.cast::<i32>();\n     |            ^^^^^^ `decRes` used here but it is possibly-uninitialized\n     |\n    ::: src/translation_utils/c_alignment/c_do_while.rs:7:15\n     |\n7    |         while core::mem::replace(&mut __first, false) || $cond\n     |               ------------------------------------------------ if this condition isn't met and the `while` loop runs 0 times, `decRes` is not initialized\n\nFor more information about this error, try `rustc --explain E0381`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "static int CmptLzTryDecLenAndDist(CmptLzDecCtx *decCtx, uint32_t mkState, uint32_t range, uint32_t rangeCode,\n                                  uint32_t rangeBound, CmptLzDecProb *probSlot, const unsigned char *bufTryDec,\n                                  const unsigned char **pbufLimit)\n{\n    uint32_t offset;\n    uint32_t bits2BeDec;\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t posState = CMPTLZ_CALC_POS_STATE(decCtx->processedPos, pbMask);\n    const unsigned char *bufLimit = *pbufLimit;\n    CmptLzDecProb *probBit;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    CmptLzDecProb *probLen = probSlot + CMPTLZ_LEN_CHOICE;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probLen);\n    if (rangeCode < rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET + posState;\n        bits2BeDec = 3;\n        offset = 0;\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probLen);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            probLen = probSlot + CMPTLZ_LEN_CHOICE + CMPTLZ_LEN_CHOICE2 + posState;\n            bits2BeDec = 3;\n            offset = (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET;\n            bits2BeDec = 8;\n            offset = (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n    }\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    uint32_t decSym = 1;\n    do\n    {\n        probBit = probLen + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    } while (decSym < ((uint32_t)1 << bits2BeDec));\n    decSym -= ((uint32_t)1 << bits2BeDec);\n    decSym += offset;\n    if (mkState >= 4)\n    {\n        *pbufLimit = bufTryDec;\n        return CMPT_OK;\n    }\n    probSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decSym);\n    decSym = 1;\n    do\n    {\n        probBit = probSlot + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    } while (decSym < (1 << CMPTLZ_POS_SLOT_BITS));\n    decSym -= (1 << CMPTLZ_POS_SLOT_BITS);\n    bits2BeDec = ((decSym >> 1) - 1);\n    if (decSym >= CMPTLZ_LOW_POSSLOT)\n    {\n        if (decSym < CMPTLZ_HIGH_POSSLOT)\n        {\n            probSlot = CmptLzGetSpecPosProb(probsMatrix) + (CmptLzGetBaseDistByPosSlot(decSym) << bits2BeDec);\n        }\n        else\n        {\n            bits2BeDec -= CMPTLZ_LARGE_DIST_LOW_BITS;\n            do\n            {\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n                range >>= 1;\n                rangeCode -= range & (((rangeCode - range) >> 31) - 1);\n            } while (--bits2BeDec);\n            probSlot = CmptLzGetAilgnProb(probsMatrix);\n            bits2BeDec = CMPTLZ_LARGE_DIST_LOW_BITS;\n        }\n        decSym = 1;\n        offset = 1;\n        do\n        {\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n            probBit = probSlot + decSym;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probBit);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                decSym += offset;\n                offset <<= 1;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                offset <<= 1;\n                decSym += offset;\n            }\n        } while (--bits2BeDec);\n    }\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptLzTryDecLenAndDist(mut decCtx: Ptr<CmptLzDecCtx>, mut mkState: u32, mut range: u32, mut rangeCode: u32, mut rangeBound: u32, mut probSlot: Ptr<CmptLzDecProb>, mut bufTryDec: Ptr<u8>, mut pbufLimit: Ptr<Ptr<u8>>) -> i32 {\n    let mut offset: u32;\n    let mut bits2BeDec: u32;\n    let mut pbMask: u32 = ((1 as u32) << decCtx.prop.posBits) - 1;\n    let mut posState: u32 = CMPTLZ_CALC_POS_STATE!(decCtx.processedPos, pbMask);\n    let mut bufLimit: Ptr<u8> = *pbufLimit;\n    let mut probBit: Ptr<CmptLzDecProb>;\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx);\n    CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    probLen = probSlot + CMPTLZ_LEN_CHOICE!();\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probLen);\n    if (rangeCode < rangeBound) {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET!() + posState;\n        bits2BeDec = 3;\n        offset = 0;\n    } else {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2!();\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probLen);\n        if (rangeCode < rangeBound) {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n            probLen = probSlot + CMPTLZ_LEN_CHOICE!() + CMPTLZ_LEN_CHOICE2!() + posState;\n            bits2BeDec = 3;\n            offset = (CMPTLZ_LOW_LEN_CLASS!() << 1);\n        } else {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET!();\n            bits2BeDec = 8;\n            offset = (CMPTLZ_LOW_LEN_CLASS!() << 1);\n        }\n    }\n    CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    let mut decSym: u32 = 1;\n    c_do!({\n        probBit = probLen + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    } while decSym < ((1 as u32) << bits2BeDec));\n    decSym -= ((1 as u32) << bits2BeDec);\n    decSym += offset;\n    if (mkState >= 4) {\n        *pbufLimit = bufTryDec;\n        return CMPT_OK!();\n    }\n    probSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decSym);\n    decSym = 1;\n    c_do!({\n        probBit = probSlot + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    } while decSym < (1 << CMPTLZ_POS_SLOT_BITS!()));\n    decSym -= (1 << CMPTLZ_POS_SLOT_BITS!());\n    bits2BeDec = ((decSym >> 1) - 1);\n    if (decSym >= CMPTLZ_LOW_POSSLOT!()) {\n        if (decSym < CMPTLZ_HIGH_POSSLOT!()) {\n            probSlot = CmptLzGetSpecPosProb(probsMatrix) + (CmptLzGetBaseDistByPosSlot(decSym) << bits2BeDec);\n        } else {\n            bits2BeDec -= CMPTLZ_LARGE_DIST_LOW_BITS!();\n            c_do!({\n                CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n                range >>= 1;\n                rangeCode -= range & (((rangeCode - range) >> 31) - 1);\n            } while bits2BeDec.prefix_minus_minus() > 0);\n            probSlot = CmptLzGetAilgnProb(probsMatrix);\n            bits2BeDec = CMPTLZ_LARGE_DIST_LOW_BITS!();\n        }\n        decSym = 1;\n        offset = 1;\n        c_do!({\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n            probBit = probSlot + decSym;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probBit);\n            if (rangeCode < rangeBound) {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n                decSym += offset;\n                offset <<= 1;\n            } else {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n                offset <<= 1;\n                decSym += offset;\n            }\n        } while bits2BeDec.prefix_minus_minus() > 0);\n    }\n    CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451082994)\nerror[E0425]: cannot find value `probLen` in this scope\n    --> src/src/cmptlz_c.rs:1790:5\n     |\n1790 |     probLen = probSlot + CMPTLZ_LEN_CHOICE!();\n     |     ^^^^^^^\n     |\nhelp: you might have meant to introduce a new binding\n     |\n1790 |     let probLen = probSlot + CMPTLZ_LEN_CHOICE!();\n     |     +++\n\nerror[E0425]: cannot find value `probLen` in this scope\n    --> src/src/cmptlz_c.rs:1791:55\n     |\n1791 |     rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probLen);\n     |                                                       ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `probLen` in this scope\n    --> src/src/cmptlz_c.rs:1794:9\n     |\n1794 |         probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET!() + posState;\n     |         ^^^^^^^\n     |\nhelp: you might have meant to introduce a new binding\n     |\n1794 |         let probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET!() + posState;\n     |         +++\n\nerror[E0425]: cannot find value `probLen` in this scope\n    --> src/src/cmptlz_c.rs:1800:9\n     |\n1800 |         probLen = probSlot + CMPTLZ_LEN_CHOICE2!();\n     |         ^^^^^^^\n     |\nhelp: you might have meant to introduce a new binding\n     |\n1800 |         let probLen = probSlot + CMPTLZ_LEN_CHOICE2!();\n     |         +++\n\nerror[E0425]: cannot find value `probLen` in this scope\n    --> src/src/cmptlz_c.rs:1801:59\n     |\n1801 |         rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probLen);\n     |                                                           ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `probLen` in this scope\n    --> src/src/cmptlz_c.rs:1804:13\n     |\n1804 |             probLen = probSlot + CMPTLZ_LEN_CHOICE!() + CMPTLZ_LEN_CHOICE2!() + posState;\n     |             ^^^^^^^\n     |\nhelp: you might have meant to introduce a new binding\n     |\n1804 |             let probLen = probSlot + CMPTLZ_LEN_CHOICE!() + CMPTLZ_LEN_CHOICE2!() + posState;\n     |             +++\n\nerror[E0425]: cannot find value `probLen` in this scope\n    --> src/src/cmptlz_c.rs:1809:13\n     |\n1809 |             probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET!();\n     |             ^^^^^^^\n     |\nhelp: you might have meant to introduce a new binding\n     |\n1809 |             let probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET!();\n     |             +++\n\nerror[E0425]: cannot find value `probLen` in this scope\n    --> src/src/cmptlz_c.rs:1817:19\n     |\n1817 |         probBit = probLen + decSym;\n     |                   ^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1854:61\n     |\n1854 |             rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probBit);\n     |                                                             ^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:1854:59\n     |\n1854 |             rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probBit);\n     |                                                           ^ no implementation for `u32 * u16`\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n\nSome errors have detailed explanations: E0277, E0308, E0425.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 10 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 10 previous errors\n"
            },
            {
                "c_code": "static int CmptLzTryDecLitPacket(CmptLzDecCtx *decCtx, uint32_t range, uint32_t rangeCode, uint32_t rangeBound,\n                                 const unsigned char *bufTryDec, const unsigned char **pbufLimit)\n{\n    CmptLzDecProb *probBit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    uint32_t procPos = decCtx->processedPos;\n    uint32_t litPosMask = ((uint32_t)0x100 << decCtx->prop.litPos) - ((uint32_t)0x100 >> decCtx->prop.litCtx);\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t dicPos = decCtx->dictPos;\n    const unsigned char *dict = decCtx->dict;\n    const unsigned char *bufLimit = *pbufLimit;\n    if (decCtx->dictPos >= decCtx->dictBufSize)\n    {\n        return CMPT_ERROR_DATA;\n    }\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0 || decCtx->checkDicSize != 0)\n    {\n        probSlot += (uint32_t)3 * ((((procPos << 8) + dict[(dicPos == 0 ? dictBufSize : dicPos) - 1]) & litPosMask)\n                                   << decCtx->prop.litCtx);\n    }\n    uint32_t decSym = 1;\n    if (decCtx->state < CMPTLZ_LIT_STATES)\n    {\n        do\n        {\n            probBit = probSlot + decSym;\n            CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        } while (decSym < 0x100);\n    }\n    else\n    {\n        uint32_t bit;\n        uint32_t matchSym = dict[dicPos - decCtx->reps[0] + ((dicPos < decCtx->reps[0]) ? dictBufSize : 0)];\n        uint32_t offset = 0x100;\n        do\n        {\n            matchSym <<= 1;\n            bit = offset;\n            offset &= matchSym;\n            probBit = probSlot + (offset + bit + decSym);\n            CMPTLZ_MATCH_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        } while (decSym < 0x100);\n    }\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptLzTryDecLitPacket(mut decCtx: Ptr<CmptLzDecCtx>, mut range: u32, mut rangeCode: u32, mut rangeBound: u32, mut bufTryDec: Ptr<u8>, mut pbufLimit: Ptr<Ptr<u8>>) -> i32 {\n    let mut probBit: Ptr<CmptLzDecProb> = Default::default();\n    let mut probSlot: Ptr<CmptLzDecProb> = Default::default();\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx);\n    let mut procPos: u32 = decCtx.processedPos;\n    let mut litPosMask: u32 = ((0x100 as u32) << decCtx.prop.litPos) - ((0x100 as u32) >> decCtx.prop.litCtx);\n    let mut dictBufSize: usize = decCtx.dictBufSize;\n    let mut dicPos: usize = decCtx.dictPos;\n    let mut dict: Ptr<u8> = decCtx.dict;\n    let mut bufLimit: Ptr<u8> = *pbufLimit;\n    if (decCtx.dictPos >= decCtx.dictBufSize) {\n        return CMPT_ERROR_DATA!();\n    }\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0) || (decCtx.checkDicSize != 0) {\n        probSlot += (3 as u32) * ((((procPos << 8) + dict[(if dicPos == 0 { dictBufSize } else { dicPos }) - 1]) & litPosMask) << decCtx.prop.litCtx);\n    }\n    let mut decSym: u32 = 1;\n    if (decCtx.state < CMPTLZ_LIT_STATES!()) {\n        c_do!({\n            probBit = (probSlot + decSym);\n            CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n        } while decSym < 0x100);\n    } else {\n        let mut bit: u32 = Default::default();\n        let tmp0 = dicPos - decCtx.reps[0;\n        let mut matchSym: u32 = dict[tmp0] + (if dicPos < decCtx.reps[0] { dictBufSize } else { 0 })];\n        let mut offset: u32 = 0x100;\n        c_do!({\n            matchSym <<= 1;\n            bit = offset;\n            offset &= matchSym;\n            probBit = (probSlot + (offset + bit + decSym));\n            CMPTLZ_MATCH_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n        } while decSym < 0x100);\n    }\n    CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451083436)\nerror: expected one of `.`, `?`, `]`, or an operator, found `;`\n    --> src/src/cmptlz_c.rs:1913:42\n     |\n1913 |         let tmp0 = dicPos - decCtx.reps[0;\n     |                                          ^ expected one of `.`, `?`, `]`, or an operator\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1902:54\n     |\n1902 | ...) * ((((procPos << 8) + dict[(if dicPos == 0 { dictBufSize } else { dicPos }) - 1]) & litPosMask) << decCtx.prop.litCtx);\n     |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n\nerror[E0277]: cannot add `u8` to `u32`\n    --> src/src/cmptlz_c.rs:1902:52\n     |\n1902 | ...   probSlot += (3 as u32) * ((((procPos << 8) + dict[(if dicPos == 0 { dictBufSize } else { dicPos }) - 1]) & litPosMask) << decCtx.pr...\n     |                                                  ^ no implementation for `u32 + u8`\n     |\n     = help: the trait `std::ops::Add<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Add<Rhs>`:\n               `&u32` implements `std::ops::Add<u32>`\n               `&u32` implements `std::ops::Add`\n               `u32` implements `std::ops::Add<&u32>`\n               `u32` implements `std::ops::Add<types::num::Num>`\n               `u32` implements `std::ops::Add`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 3 previous errors\n"
            },
            {
                "c_code": "int CmptLzTryDecOnePacket(CmptLzDecCtx *decCtx, const unsigned char *bufTryDec, const unsigned char **pbufLimit)\n{\n    uint32_t rangeBound = 0;\n    uint32_t range = decCtx->range;\n    uint32_t rangeCode = decCtx->code;\n    uint32_t mkState = decCtx->state;\n    const unsigned char *bufLimit = *pbufLimit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probSlot1;\n    CmptLzDecProb *probSlot2;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t posState = CMPTLZ_CALC_POS_STATE(decCtx->processedPos, pbMask);\n    probSlot1 = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot1);\n    if (rangeCode < rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        return CmptLzTryDecLitPacket(decCtx, range, rangeCode, rangeBound, bufTryDec, pbufLimit);\n    }\n    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    probSlot2 = CmptLzGetIsRepProb(probsMatrix) + mkState;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot2);\n    if (rangeCode < rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        probSlot = CmptLzGetMatchLenCoderProb(probsMatrix);\n        mkState = 0;\n    }\n    else\n    {\n        if (decCtx->dictPos >= decCtx->dictBufSize)\n        {\n            return CMPT_ERROR_DATA;\n        }\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        probSlot = CmptLzGetIsRepG0Prob(probsMatrix) + mkState;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n            probSlot = CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n                *pbufLimit = bufTryDec;\n                return CMPT_OK;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            }\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n            probSlot = CmptLzGetIsRepG1Prob(probsMatrix) + mkState;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n                probSlot = CmptLzGetIsRepG2Prob(probsMatrix) + mkState;\n                rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n                if (rangeCode < rangeBound)\n                {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                }\n                else\n                {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                }\n            }\n        }\n        probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n        mkState = CMPTLZ_MKSTATE_NUM;\n    }\n    return CmptLzTryDecLenAndDist(decCtx, mkState, range, rangeCode, rangeBound, probSlot, bufTryDec, pbufLimit);\n}",
                "rust_code": "pub fn CmptLzTryDecOnePacket(mut decCtx: Ptr<CmptLzDecCtx>, mut bufTryDec: Ptr<u8>, mut pbufLimit: Ptr<Ptr<u8>>) -> i32 {\n    let mut rangeBound: u32 = 0;\n    let mut range: u32 = decCtx.range;\n    let mut rangeCode: u32 = decCtx.code;\n    let mut mkState: u32 = decCtx.state;\n    let mut bufLimit: Ptr<u8> = *pbufLimit;\n    let mut probSlot: Ptr<CmptLzDecProb> = Default::default();\n    let mut probSlot1: Ptr<CmptLzDecProb> = Default::default();\n    let mut probSlot2: Ptr<CmptLzDecProb> = Default::default();\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx);\n    let mut pbMask: u32 = ((1).cast::<u32>() << decCtx.prop.posBits) - 1;\n    let mut posState: u32 = CMPTLZ_CALC_POS_STATE!(decCtx.processedPos, pbMask);\n    probSlot1 = (CmptLzGetIsMatchProb(probsMatrix) + posState + mkState);\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot1);\n    if (rangeCode < rangeBound) {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n        return CmptLzTryDecLitPacket(decCtx, range, rangeCode, rangeBound, bufTryDec, pbufLimit);\n    }\n    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n    CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    probSlot2 = (CmptLzGetIsRepProb(probsMatrix) + mkState);\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot2);\n    if (rangeCode < rangeBound) {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n        probSlot = CmptLzGetMatchLenCoderProb(probsMatrix);\n        mkState = 0;\n    } else {\n        if (decCtx.dictPos >= decCtx.dictBufSize) {\n            return CMPT_ERROR_DATA!();\n        }\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n        probSlot = (CmptLzGetIsRepG0Prob(probsMatrix) + mkState);\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n        if (rangeCode < rangeBound) {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n            probSlot = (CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState);\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n            if (rangeCode < rangeBound) {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n                *pbufLimit = bufTryDec;\n                return CMPT_OK!();\n            } else {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n            }\n        } else {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n            probSlot = (CmptLzGetIsRepG1Prob(probsMatrix) + mkState);\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n            if (rangeCode < rangeBound) {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n            } else {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n                probSlot = (CmptLzGetIsRepG2Prob(probsMatrix) + mkState);\n                rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n                if (rangeCode < rangeBound) {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!(range, rangeBound);\n                } else {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!(range, rangeCode, rangeBound);\n                }\n            }\n        }\n        probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n        mkState = CMPTLZ_MKSTATE_NUM!();\n    }\n    return CmptLzTryDecLenAndDist(decCtx, mkState, range, rangeCode, rangeBound, probSlot, bufTryDec, pbufLimit);\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451083873)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1949:53\n     |\n1949 |     rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot1);\n     |                                                     ^^^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:1949:51\n     |\n1949 |     rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot1);\n     |                                                   ^ no implementation for `u32 * u16`\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1958:53\n     |\n1958 |     rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot2);\n     |                                                     ^^^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:1958:51\n     |\n1958 |     rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot2);\n     |                                                   ^ no implementation for `u32 * u16`\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1970:57\n     |\n1970 |         rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n     |                                                         ^^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:1970:55\n     |\n1970 |         rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n     |                                                       ^ no implementation for `u32 * u16`\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1975:61\n     |\n1975 |             rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n     |                                                             ^^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:1975:59\n     |\n1975 |             rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n     |                                                           ^ no implementation for `u32 * u16`\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1988:61\n     |\n1988 |             rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n     |                                                             ^^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:1988:59\n     |\n1988 |             rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n     |                                                           ^ no implementation for `u32 * u16`\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1995:65\n     |\n1995 |                 rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n     |                                                                 ^^^^^^^^^^^ expected `u32`, found `u16`\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:1995:63\n     |\n1995 |                 rangeBound = (range >> CMPTLZ_PROB_LG_BIT!()) * (*probSlot);\n     |                                                               ^ no implementation for `u32 * u16`\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 12 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 12 previous errors\n"
            },
            {
                "c_code": "static int CmptLzDecCtxPrepare(CmptLzDecCtx *decCtx, const unsigned char *pSrcIn, size_t srcInLen,\n                               EnCmptLzStatus *finStatus)\n{\n    size_t readCodeLen = CMPTLZ_RANGE_CODE_SIZE - decCtx->tempBufSize;\n    readCodeLen = (srcInLen < readCodeLen) ? srcInLen : readCodeLen;\n    while (readCodeLen-- > 0)\n    {\n        decCtx->tempBuf[decCtx->tempBufSize++] = *pSrcIn++;\n    }\n    if (decCtx->tempBufSize != 0 && decCtx->tempBuf[0] != 0)\n    {\n        decCtx->tempBufSize = 0;\n        *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n        return CMPT_ERROR_DATA;\n    }\n    if (decCtx->tempBufSize < CMPTLZ_RANGE_CODE_SIZE)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    CmptLzRangeCodeInit(decCtx);\n    if (decCtx->remainLen > CMPTLZ_MATCH_MAX_LEN + 1)\n    {\n        CmptLzDecGetProbsInit(decCtx);\n        decCtx->reps[0] = 1;\n        decCtx->reps[1] = 1;\n        decCtx->reps[2] = 1;\n        decCtx->reps[3] = 1;\n    }\n    decCtx->remainLen = 0;\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptLzDecCtxPrepare(mut decCtx: Ptr<CmptLzDecCtx>, mut pSrcIn: Ptr<u8>, mut srcInLen: usize, mut finStatus: Ptr<EnCmptLzStatus>) -> i32 {\n    let mut readCodeLen: usize = CMPTLZ_RANGE_CODE_SIZE!() - decCtx.tempBufSize;\n    readCodeLen = if srcInLen < readCodeLen { srcInLen } else { readCodeLen };\n    while (readCodeLen.suffix_minus_minus() > 0) {\n        let tmp0 = decCtx.tempBufSize;\n        decCtx.tempBuf[tmp0] = *pSrcIn;\n        decCtx.tempBufSize += 1;\n        pSrcIn += 1;\n    }\n    if (decCtx.tempBufSize != 0) && (decCtx.tempBuf[0] != 0) {\n        decCtx.tempBufSize = 0;\n        *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED!();\n        return CMPT_ERROR_DATA!();\n    }\n    if (decCtx.tempBufSize < CMPTLZ_RANGE_CODE_SIZE!()) {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT!();\n        return CMPT_OK!();\n    }\n    CmptLzRangeCodeInit(decCtx);\n    if (decCtx.remainLen > CMPTLZ_MATCH_MAX_LEN!() + 1) {\n        CmptLzDecGetProbsInit(decCtx);\n        decCtx.reps[0] = 1;\n        decCtx.reps[1] = 1;\n        decCtx.reps[2] = 1;\n        decCtx.reps[3] = 1;\n    }\n    decCtx.remainLen = 0;\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451114495)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:2123:34\n     |\n2123 |     let mut readCodeLen: usize = CMPTLZ_RANGE_CODE_SIZE!() - decCtx.tempBufSize;\n     |                          -----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n     |                          |\n     |                          expected due to this\n     |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n     |\n2123 |     let mut readCodeLen: usize = (CMPTLZ_RANGE_CODE_SIZE!() - decCtx.tempBufSize).try_into().unwrap();\n     |                                  +                                              +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "int CmptLzDecDecodeToDic(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *pSrcIn, size_t *pStrInLen,\n                         EnCmptLzFinMode finMode, EnCmptLzStatus *finStatus)\n{\n    int res;\n    bool carefulDecDone = false;\n    size_t srcDecLenTmp;\n    size_t srcDecLen = 0;\n    size_t srcInLen = *pStrInLen;\n    if (decCtx->remainLen > CMPTLZ_MATCH_MAX_LEN)\n    {\n        size_t oldTempBufSize = decCtx->tempBufSize;\n        res = CmptLzDecCtxPrepare(decCtx, pSrcIn, srcInLen, finStatus);\n        srcDecLenTmp = (decCtx->tempBufSize - oldTempBufSize);\n        if ((res != CMPT_OK) || (*finStatus == CMPTLZ_STATUS_NEEDS_MORE_INPUT))\n        {\n            *pStrInLen = srcDecLenTmp;\n            return res;\n        }\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n        decCtx->tempBufSize = 0;\n    }\n    if (decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN)\n    {\n        if (decCtx->code != 0)\n        {\n            return CMPT_ERROR_DATA;\n        }\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n    if (decCtx->remainLen != 0)\n    {\n        CmptLzDecRemWriteInDict(decCtx, dicPosLimit);\n    }\n    if (decCtx->tempBufSize != 0)\n    {\n        res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, &srcDecLenTmp);\n        *pStrInLen = srcDecLenTmp;\n        if (res == CMPT_ERROR_DATA)\n        {\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n            return CMPT_ERROR_DATA;\n        }\n        else if (res == CMPTLZ_DEC_INPUT_EOF)\n        {\n            *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n            return CMPT_OK;\n        }\n        else\n        {\n            srcDecLen += srcDecLenTmp;\n            pSrcIn += srcDecLenTmp;\n            srcInLen -= srcDecLenTmp;\n        }\n    }\n    while ((decCtx->dictPos < dicPosLimit) && (carefulDecDone == false))\n    {\n        decCtx->buf = pSrcIn;\n        if (srcInLen <= CMPTLZ_REQUIRED_INPUT_MAX)\n        {\n            res = CmptLzDecCarefulProcess(decCtx, dicPosLimit, pSrcIn + srcInLen);\n            carefulDecDone = true;\n        }\n        else\n        {\n            res = CmptLzDecDirectProcess(decCtx, dicPosLimit, pSrcIn + srcInLen - CMPTLZ_REQUIRED_INPUT_MAX);\n        }\n        srcDecLenTmp = (size_t)(decCtx->buf - pSrcIn) + decCtx->tempBufSize;\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n        if (res == CMPT_ERROR_DATA)\n        {\n            *pStrInLen = srcDecLen;\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n            return CMPT_ERROR_DATA;\n        }\n    }\n    *pStrInLen = srcDecLen;\n    if ((decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n    if (decCtx->dictPos < dicPosLimit)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    if ((decCtx->remainLen == 0) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_MAYBE_FINISHED_WITHOUT_MARK;\n        return CMPT_OK;\n    }\n    if (finMode == CMPTLZ_FINISH_ANY)\n    {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n        return CMPT_OK;\n    }\n    if (decCtx->remainLen != 0)\n    {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n        return CMPT_ERROR_DATA;\n    }\n    srcDecLenTmp = 0;\n    res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, &srcDecLenTmp);\n    srcDecLen += srcDecLenTmp;\n    *pStrInLen = srcDecLen;\n    if (res == CMPTLZ_DEC_INPUT_EOF)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    if ((decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n    *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n    return CMPT_ERROR_DATA;\n}",
                "rust_code": "pub fn CmptLzDecDecodeToDic(mut decCtx: Ptr<CmptLzDecCtx>, mut dicPosLimit: usize, mut pSrcIn: Ptr<u8>, mut pStrInLen: Ptr<usize>, mut finMode: EnCmptLzFinMode, mut finStatus: Ptr<EnCmptLzStatus>) -> i32 {\n    let mut res: i32;\n    let mut carefulDecDone: bool = false;\n    let mut srcDecLenTmp: usize = Default::default();\n    let mut srcDecLen: usize = 0;\n    let mut srcInLen: usize = *pStrInLen;\n    if (decCtx.remainLen > CMPTLZ_MATCH_MAX_LEN!()) {\n        let mut oldTempBufSize: usize = decCtx.tempBufSize.cast();\n        res = CmptLzDecCtxPrepare(decCtx, pSrcIn, srcInLen, finStatus);\n        srcDecLenTmp = (decCtx.tempBufSize - oldTempBufSize).cast();\n        if (res != CMPT_OK!()) || (*finStatus == CMPTLZ_STATUS_NEEDS_MORE_INPUT!()) {\n            *pStrInLen = srcDecLenTmp;\n            return res;\n        }\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n        decCtx.tempBufSize = 0;\n    }\n    if (decCtx.remainLen == CMPTLZ_MATCH_MAX_LEN!()) {\n        if (decCtx.code != 0) {\n            return CMPT_ERROR_DATA!();\n        }\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK!();\n        return CMPT_OK!();\n    }\n    if (decCtx.remainLen != 0) {\n        CmptLzDecRemWriteInDict(decCtx, dicPosLimit);\n    }\n    if (decCtx.tempBufSize != 0) {\n        res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, c_ref!(srcDecLenTmp));\n        *pStrInLen = srcDecLenTmp;\n        if (res == CMPT_ERROR_DATA!()) {\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED!();\n            return CMPT_ERROR_DATA!();\n        } else if (res == CMPTLZ_DEC_INPUT_EOF!()) {\n            *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT!();\n            return CMPT_OK!();\n        } else {\n            srcDecLen += srcDecLenTmp;\n            pSrcIn += srcDecLenTmp;\n            srcInLen -= srcDecLenTmp;\n        }\n    }\n    while (decCtx.dictPos < dicPosLimit) && (carefulDecDone == false) {\n        decCtx.buf = pSrcIn;\n        if (srcInLen <= CMPTLZ_REQUIRED_INPUT_MAX!()) {\n            res = CmptLzDecCarefulProcess(decCtx, dicPosLimit, (pSrcIn + srcInLen));\n            carefulDecDone = true;\n        } else {\n            res = CmptLzDecDirectProcess(decCtx, dicPosLimit, (pSrcIn + srcInLen - CMPTLZ_REQUIRED_INPUT_MAX!()));\n        }\n        srcDecLenTmp = (decCtx.buf - pSrcIn).cast::<usize>() + decCtx.tempBufSize;\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n        if (res == CMPT_ERROR_DATA!()) {\n            *pStrInLen = srcDecLen;\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED!();\n            return CMPT_ERROR_DATA!();\n        }\n    }\n    *pStrInLen = srcDecLen;\n    if (decCtx.remainLen == CMPTLZ_MATCH_MAX_LEN!()) && (decCtx.code == 0) {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK!();\n        return CMPT_OK!();\n    }\n    if (decCtx.dictPos < dicPosLimit) {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT!();\n        return CMPT_OK!();\n    }\n    if (decCtx.remainLen == 0) && (decCtx.code == 0) {\n        *finStatus = CMPTLZ_STATUS_MAYBE_FINISHED_WITHOUT_MARK!();\n        return CMPT_OK!();\n    }\n    if (finMode == CMPTLZ_FINISH_ANY!()) {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED!();\n        return CMPT_OK!();\n    }\n    if (decCtx.remainLen != 0) {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED!();\n        return CMPT_ERROR_DATA!();\n    }\n    srcDecLenTmp = 0;\n    res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, c_ref!(srcDecLenTmp));\n    srcDecLen += srcDecLenTmp;\n    *pStrInLen = srcDecLen;\n    if (res == CMPTLZ_DEC_INPUT_EOF!()) {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT!();\n        return CMPT_OK!();\n    }\n    if (decCtx.remainLen == CMPTLZ_MATCH_MAX_LEN!()) && (decCtx.code == 0) {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK!();\n        return CMPT_OK!();\n    }\n    *finStatus = CMPTLZ_STATUS_NOT_FINISHED!();\n    return CMPT_ERROR_DATA!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451114933)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:2162:46\n     |\n2162 |         srcDecLenTmp = (decCtx.tempBufSize - oldTempBufSize).cast();\n     |                                              ^^^^^^^^^^^^^^ expected `u32`, found `usize`\n\nerror[E0277]: cannot subtract `usize` from `u32`\n    --> src/src/cmptlz_c.rs:2162:44\n     |\n2162 |         srcDecLenTmp = (decCtx.tempBufSize - oldTempBufSize).cast();\n     |                                            ^ no implementation for `u32 - usize`\n     |\n     = help: the trait `std::ops::Sub<usize>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n               `&u32` implements `std::ops::Sub<u32>`\n               `&u32` implements `std::ops::Sub`\n               `u32` implements `std::ops::Sub<&u32>`\n               `u32` implements `std::ops::Sub<types::num::Num>`\n               `u32` implements `std::ops::Sub`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:2205:64\n     |\n2205 |         srcDecLenTmp = (decCtx.buf - pSrcIn).cast::<usize>() + decCtx.tempBufSize;\n     |                                                                ^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot add `u32` to `usize`\n    --> src/src/cmptlz_c.rs:2205:62\n     |\n2205 |         srcDecLenTmp = (decCtx.buf - pSrcIn).cast::<usize>() + decCtx.tempBufSize;\n     |                                                              ^ no implementation for `usize + u32`\n     |\n     = help: the trait `std::ops::Add<u32>` is not implemented for `usize`\n     = help: the following other types implement trait `std::ops::Add<Rhs>`:\n               `&usize` implements `std::ops::Add<usize>`\n               `&usize` implements `std::ops::Add`\n               `usize` implements `std::ops::Add<&usize>`\n               `usize` implements `std::ops::Add<types::num::Num>`\n               `usize` implements `std::ops::Add`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 4 previous errors\n"
            },
            {
                "c_code": "int CmptEncodeOneBlock(CmptLzEncCtx *encCtx)\n{\n    CmptMfCtx *mf = encCtx->mfCtx;\n    uint32_t nowpos32 = encCtx->nowpos64;\n    uint32_t startpos = nowpos32;\n    uint32_t backRes, lenRes;\n    int shiftRes = CMPT_OK;\n    while (true)\n    {\n        CmptlzDp(encCtx, mf, nowpos32);\n        backRes = encCtx->backRes;\n        lenRes = encCtx->lenRes;\n        switch (backRes)\n        {\n        case CMPTLZ_UINT32_MAX:\n            shiftRes = CmptlzEncLit(encCtx, mf, nowpos32);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 0:\n            shiftRes = CmptEncShortOrRep0(encCtx, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 1:\n            shiftRes = CmptlzEncLongRep(encCtx, 1, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 2:\n            shiftRes = CmptlzEncLongRep(encCtx, 2, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 3:\n            shiftRes = CmptlzEncLongRep(encCtx, 3, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        default:\n            shiftRes = CmptlzEncNormalMatch(encCtx, nowpos32, backRes, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        }\n        nowpos32 += lenRes;\n        mf->mfStart += lenRes;\n        mf->readAhead -= lenRes;\n        if (mf->readAhead == 0)\n        {\n            CmptPriceCheck(encCtx);\n            if (mf->srcLen <= mf->mfStart)\n            {\n                break;\n            }\n            if (nowpos32 - startpos >= CMPT_ONE_BLOCK_MAX_SIZE)\n            {\n                encCtx->nowpos64 += nowpos32 - startpos;\n                return 0;\n            }\n        }\n    }\n    encCtx->nowpos64 += nowpos32 - startpos;\n    return CmptlzFlush(encCtx);\n}",
                "rust_code": "pub fn CmptEncodeOneBlock(mut encCtx: Ptr<CmptLzEncCtx>) -> i32 {\n    let mut mf: Ptr<CmptMfCtx> = encCtx.mfCtx;\n    let mut nowpos32: u32 = encCtx.nowpos64.cast();\n    let mut startpos: u32 = nowpos32;\n    let mut backRes: u32 = Default::default();\n    let mut lenRes: u32 = Default::default();\n    let mut shiftRes: i32 = CMPT_OK!();\n    loop {\n        CmptlzDp(encCtx, mf, nowpos32);\n        backRes = encCtx.backRes;\n        lenRes = encCtx.lenRes;\n        c_switch!(backRes, {\n            CMPTLZ_UINT32_MAX!() => {\n                shiftRes = CmptlzEncLit(encCtx, mf, nowpos32);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n            0 => {\n                shiftRes = CmptEncShortOrRep0(encCtx, nowpos32, lenRes);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n            1 => {\n                shiftRes = CmptlzEncLongRep(encCtx, 1, nowpos32, lenRes);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n            2 => {\n                shiftRes = CmptlzEncLongRep(encCtx, 2, nowpos32, lenRes);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n            3 => {\n                shiftRes = CmptlzEncLongRep(encCtx, 3, nowpos32, lenRes);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n            _ => {\n                shiftRes = CmptlzEncNormalMatch(encCtx, nowpos32, backRes, lenRes);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n        });\n        nowpos32 += lenRes;\n        mf.mfStart += lenRes;\n        mf.readAhead -= lenRes;\n        if (mf.readAhead == 0) {\n            CmptPriceCheck(encCtx);\n            if (mf.srcLen <= mf.mfStart) {\n                break;\n            }\n            if (nowpos32 - startpos >= CMPT_ONE_BLOCK_MAX_SIZE!()) {\n                encCtx.nowpos64 += (nowpos32 - startpos).cast();\n                return 0;\n            }\n        }\n    }\n    encCtx.nowpos64 += (nowpos32 - startpos).cast();\n    return CmptlzFlush(encCtx);\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451140668)\nerror: no rules expected `,`\n    --> src/src/cmptlz_c.rs:2329:26\n     |\n2329 |         c_switch!(backRes, {\n     |                          ^ no rules expected this token in macro call\n     |\n    ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n     |\n3    | macro_rules! c_switch {\n     | --------------------- when calling this macro\n     |\nnote: while trying to match `;`\n    --> src/translation_utils/c_alignment/c_switch.rs:5:17\n     |\n5    |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n     |                 ^\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:2366:30\n     |\n2366 |             if (mf.srcLen <= mf.mfStart) {\n     |                 ---------    ^^^^^^^^^^ expected `usize`, found `u32`\n     |                 |\n     |                 expected because this is `usize`\n     |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n     |\n2366 |             if (mf.srcLen <= mf.mfStart.try_into().unwrap()) {\n     |                                        ++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "static uint32_t CmptlzDpInit(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t position)\n{\n    const uint32_t niceLen = mf->niceLen;\n    uint32_t lenMain;\n    uint32_t matchesCount = 0;\n    if (mf->readAhead == 0)\n    {\n        lenMain = CmptlzMatchFinder(mf, &matchesCount, encCtx->matches);\n    }\n    else\n    {\n        lenMain = encCtx->longestMatchLen;\n        matchesCount = encCtx->matchesCount;\n    }\n    const uint8_t *const buf = CmptMfGetPtr(mf) - 1;\n    const uint32_t bufAvail = CMPTLZ_FIND_MIN(CmptMfAvail(mf) + 1, CMPT_MF_LONGEST_MATCH);\n    if (bufAvail < CMPTLZ_MATCH_LEN_MIN)\n    {\n        encCtx->backRes = CMPTLZ_UINT32_MAX;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n    uint32_t repLens[CMPTLZ_NUM_REPS];\n    uint32_t repMaxIndex = 0;\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        const uint8_t *const bufBack = buf - encCtx->reps[i] - 1;\n        if (NOT_EQUAL_2_BYTES(buf, bufBack))\n        {\n            repLens[i] = 0;\n            continue;\n        }\n        repLens[i] = CmptMemCmpLenSafe(buf, bufBack, CMPTLZ_MATCH_LEN_MIN, bufAvail);\n        if (repLens[i] > repLens[repMaxIndex])\n        {\n            repMaxIndex = i;\n        }\n    }\n    if (repLens[repMaxIndex] >= niceLen)\n    {\n        encCtx->backRes = repMaxIndex;\n        encCtx->lenRes = repLens[repMaxIndex];\n        CmptlzMatchSkiper(mf, repLens[repMaxIndex] - 1);\n        return CMPTLZ_UINT32_MAX;\n    }\n    if (lenMain >= niceLen)\n    {\n        encCtx->backRes = encCtx->matches[matchesCount - 1].dist + CMPTLZ_NUM_REPS;\n        encCtx->lenRes = lenMain;\n        CmptlzMatchSkiper(mf, lenMain - 1);\n        return CMPTLZ_UINT32_MAX;\n    }\n    const uint8_t currentByte = *buf;\n    const uint8_t matchByte = *(buf - encCtx->reps[0] - 1);\n    const uint32_t lenEnd = CMPTLZ_FIND_MAX(lenMain, repLens[repMaxIndex]);\n    if ((lenEnd < CMPTLZ_MATCH_LEN_MIN) && (currentByte != matchByte))\n    {\n        encCtx->backRes = CMPTLZ_UINT32_MAX;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n    encCtx->opts[0].state = encCtx->state;\n    const uint32_t posState = position & encCtx->posMask;\n    encCtx->litMarcov.pos = position;\n    encCtx->litMarcov.prevByte = *(buf - 1);\n    bool isLiteralState = (encCtx->state < 7);\n    bool isMatchMode = !isLiteralState;\n    encCtx->opts[1].price = CmptPriceBit0(encCtx, encCtx->isMatch[encCtx->state][posState]) +\n                            CmptPriceLiteral(encCtx, isMatchMode, matchByte, currentByte);\n    encCtx->opts[1].backPrev = CMPTLZ_UINT32_MAX;\n    const uint32_t matchPrice = CmptPriceBit1(encCtx, encCtx->isMatch[encCtx->state][posState]);\n    const uint32_t repMatchPrice = matchPrice + CmptPriceBit1(encCtx, encCtx->isRep[encCtx->state]);\n    if (matchByte == currentByte)\n    {\n        CmptlzDpInitShortRep(encCtx, repMatchPrice, posState);\n    }\n    if (lenEnd < CMPTLZ_MATCH_LEN_MIN)\n    {\n        encCtx->backRes = encCtx->opts[1].backPrev;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n    encCtx->opts[1].posPrev = 0;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->opts[0].backs[i] = encCtx->reps[i];\n    }\n    uint32_t len = lenEnd;\n    do\n    {\n        encCtx->opts[len].price = CMPT_INFINITY_PRICE;\n        len--;\n    } while (len >= CMPTLZ_MATCH_LEN_MIN);\n    CmptlzDpInitLongRep(encCtx, repLens, repMatchPrice, posState);\n    const uint32_t normalMatchPrice = matchPrice + CmptPriceBit0(encCtx, encCtx->isRep[encCtx->state]);\n    len = (repLens[0] > CMPTLZ_MATCH_LEN_MIN) ? repLens[0] + 1 : CMPTLZ_MATCH_LEN_MIN;\n    if (len <= lenMain)\n    {\n        CmptlzDpInitMatch(encCtx, matchesCount, normalMatchPrice, posState, len);\n    }\n    return lenEnd;\n}",
                "rust_code": "pub fn CmptlzDpInit(mut encCtx: Ptr<CmptLzEncCtx>, mut mf: Ptr<CmptMfCtx>, mut position: u32) -> u32 {\n    let niceLen: u32 = mf.niceLen;\n    let mut lenMain: u32;\n    let mut matchesCount: u32 = 0;\n    if (mf.readAhead == 0) {\n        lenMain = CmptlzMatchFinder(mf, c_ref!(matchesCount), encCtx.matches.cast());\n    } else {\n        lenMain = encCtx.longestMatchLen;\n        matchesCount = encCtx.matchesCount;\n    }\n    let buf: Ptr<u8> = CmptMfGetPtr(mf) - 1;\n    let bufAvail: u32 = CMPTLZ_FIND_MIN!(CmptMfAvail(mf) + 1, CMPT_MF_LONGEST_MATCH!());\n    if (bufAvail < CMPTLZ_MATCH_LEN_MIN!()) {\n        encCtx.backRes = CMPTLZ_UINT32_MAX!();\n        encCtx.lenRes = 1;\n        return CMPTLZ_UINT32_MAX!();\n    }\n    let mut repLens: Array<u32, { CMPTLZ_NUM_REPS!() }> = Default::default();\n    let mut repMaxIndex: u32 = 0;\n    let mut i: u32;\n    c_for!(i = 0; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_plus(); {\n        let bufBack: Ptr<u8> = buf - encCtx.reps[i] - 1;\n        if NOT_EQUAL_2_BYTES!(buf, bufBack) {\n            repLens[i] = 0;\n            continue;\n        }\n        repLens[i] = CmptMemCmpLenSafe(buf, bufBack, CMPTLZ_MATCH_LEN_MIN!(), bufAvail);\n        if (repLens[i] > repLens[repMaxIndex]) {\n            repMaxIndex = i;\n        }\n    });\n    if (repLens[repMaxIndex] >= niceLen) {\n        encCtx.backRes = repMaxIndex;\n        encCtx.lenRes = repLens[repMaxIndex];\n        CmptlzMatchSkiper(mf, (repLens[repMaxIndex] - 1));\n        return CMPTLZ_UINT32_MAX!();\n    }\n    if (lenMain >= niceLen) {\n        encCtx.backRes = (encCtx.matches[matchesCount - 1].dist + CMPTLZ_NUM_REPS!());\n        encCtx.lenRes = lenMain;\n        CmptlzMatchSkiper(mf, (lenMain - 1));\n        return CMPTLZ_UINT32_MAX!();\n    }\n    let currentByte: u8 = *buf;\n    let matchByte: u8 = *(buf - encCtx.reps[0] - 1);\n    let lenEnd: u32 = CMPTLZ_FIND_MAX!(lenMain, repLens[repMaxIndex]);\n    if (lenEnd < CMPTLZ_MATCH_LEN_MIN!()) && (currentByte != matchByte) {\n        encCtx.backRes = CMPTLZ_UINT32_MAX!();\n        encCtx.lenRes = 1;\n        return CMPTLZ_UINT32_MAX!();\n    }\n    encCtx.opts[0].state = encCtx.state;\n    let posState: u32 = position & encCtx.posMask;\n    encCtx.litMarcov.pos = position;\n    encCtx.litMarcov.prevByte = *(buf - 1);\n    let isLiteralState: bool = (encCtx.state < 7);\n    let isMatchMode: bool = !isLiteralState;\n    encCtx.opts[1].price = (CmptPriceBit0(encCtx, encCtx.isMatch[encCtx.state][posState]) +\n                            CmptPriceLiteral(encCtx, isMatchMode, matchByte.cast(), currentByte.cast()));\n    encCtx.opts[1].backPrev = CMPTLZ_UINT32_MAX!();\n    let tmp0 = encCtx.state;\n    let matchPrice: u32 = CmptPriceBit1(encCtx, encCtx.isMatch[tmp0][posState]);\n    let repMatchPrice: u32 = (matchPrice + CmptPriceBit1(encCtx, encCtx.isRep[encCtx.state]));\n    if (matchByte == currentByte) {\n        CmptlzDpInitShortRep(encCtx, repMatchPrice, posState);\n    }\n    if (lenEnd < CMPTLZ_MATCH_LEN_MIN!()) {\n        encCtx.backRes = encCtx.opts[1].backPrev;\n        encCtx.lenRes = 1;\n        return CMPTLZ_UINT32_MAX!();\n    }\n    encCtx.opts[1].posPrev = 0;\n    c_for!(i = 0; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_plus(); {\n        encCtx.opts[0].backs[i] = encCtx.reps[i];\n    });\n    let mut len: u32 = lenEnd;\n    c_do!({\n        encCtx.opts[len].price = CMPT_INFINITY_PRICE!();\n        len.suffix_minus_minus();\n    } while len >= CMPTLZ_MATCH_LEN_MIN!());\n    CmptlzDpInitLongRep(encCtx, repLens.cast(), repMatchPrice, posState);\n    let normalMatchPrice: u32 = (matchPrice + CmptPriceBit0(encCtx, encCtx.isRep[encCtx.state]));\n    len = if repLens[0] > CMPTLZ_MATCH_LEN_MIN!() { repLens[0] + 1 } else { CMPTLZ_MATCH_LEN_MIN!() };\n    if (len <= lenMain) {\n        CmptlzDpInitMatch(encCtx, matchesCount, normalMatchPrice, posState, len);\n    }\n    return lenEnd;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451161223)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:2525:33\n     |\n2525 |     encCtx.litMarcov.prevByte = *(buf - 1);\n     |     -------------------------   ^^^^^^^^^^ expected `u32`, found `u8`\n     |     |\n     |     expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "static void CmptlzDpTryCurAndLit(CmptLzEncCtx *encCtx, const uint32_t curPrice, CmptlzState curState,\n                                 const uint32_t posState, const uint32_t cur, const uint8_t latestMatchByte,\n                                 const uint8_t curByte)\n{\n    bool isLiteralState = (curState < 7);\n    bool isMatchMode = !isLiteralState;\n    const uint32_t curAndLitPrice = curPrice + CmptPriceBit0(encCtx, encCtx->isMatch[curState][posState]) +\n                                    CmptPriceLiteral(encCtx, isMatchMode, latestMatchByte, curByte);\n    if (curAndLitPrice < encCtx->opts[cur + 1].price)\n    {\n        encCtx->opts[cur + 1].price = curAndLitPrice;\n        encCtx->opts[cur + 1].posPrev = cur;\n        encCtx->opts[cur + 1].backPrev = CMPTLZ_UINT32_MAX;\n    }\n}",
                "rust_code": "pub fn CmptlzDpTryCurAndLit(mut encCtx: Ptr<CmptLzEncCtx>, mut curPrice: u32, mut curState: CmptlzState, mut posState: u32, mut cur: u32, mut latestMatchByte: u8, mut curByte: u8) {\n    let mut isLiteralState: bool = (curState < 7);\n    let mut isMatchMode: bool = !isLiteralState;\n    let mut curAndLitPrice: u32 = (curPrice + CmptPriceBit0(encCtx, encCtx.isMatch[curState][posState]) + CmptPriceLiteral(encCtx, isMatchMode, latestMatchByte, curByte.cast()));\n    if (curAndLitPrice < encCtx.opts[cur + 1].price) {\n        encCtx.opts[cur + 1].price = curAndLitPrice;\n        encCtx.opts[cur + 1].posPrev = cur;\n        encCtx.opts[cur + 1].backPrev = CMPTLZ_UINT32_MAX!();\n    }\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451166722)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:2605:145\n     |\n2605 | ...tch[curState][posState]) + CmptPriceLiteral(encCtx, isMatchMode, latestMatchByte, curByte.cast()));\n     |                               ----------------                      ^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n     |                               |\n     |                               arguments to this function are incorrect\n     |\nnote: function defined here\n    --> src/src/cmptlz_c.rs:3319:8\n     |\n3319 | pub fn CmptPriceLiteral(mut encCtx: Ptr<CmptLzEncCtx>, mut matchMode: bool, mut matchByte: u32, mut symbol: u32) -> u32 {\n     |        ^^^^^^^^^^^^^^^^                                                     ------------------\nhelp: you can convert a `u8` to a `u32`\n     |\n2605 |     let mut curAndLitPrice: u32 = (curPrice + CmptPriceBit0(encCtx, encCtx.isMatch[curState][posState]) + CmptPriceLiteral(encCtx, isMatchMode, latestMatchByte.into(), curByte.cast()));\n     |                                                                                                                                                                +++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "static uint32_t CmptlzDpProcess(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t *mainReps, uint32_t lenEnd,\n                                uint32_t position, const uint32_t cur)\n{\n    CmptlzState curState = encCtx->opts[cur].state;\n    const uint32_t bufAvailFull = CMPTLZ_FIND_MIN(CmptMfAvail(mf) + 1, CMPT_DP_OPTMAX - 1 - cur);\n    const uint8_t *buf = CmptMfGetPtr(mf) - 1;\n    const uint32_t niceLen = mf->niceLen;\n    const uint32_t curPrice = encCtx->opts[cur].price;\n    const uint8_t curByte = *buf;\n    const uint8_t latestMatchByte = *(buf - mainReps[0] - 1);\n    const uint32_t posState = position & encCtx->posMask;\n    encCtx->litMarcov.pos = position;\n    encCtx->litMarcov.prevByte = *(buf - 1);\n    CmptlzDpTryCurAndLit(encCtx, curPrice, curState, posState, cur, latestMatchByte, curByte);\n    const uint32_t matchPrice = curPrice + CmptPriceBit1(encCtx, encCtx->isMatch[curState][posState]);\n    const uint32_t repMatchPrice = matchPrice + CmptPriceBit1(encCtx, encCtx->isRep[curState]);\n    if (curByte == latestMatchByte && !(encCtx->opts[cur + 1].posPrev < cur && encCtx->opts[cur + 1].backPrev == 0))\n    {\n        CmptlzDpTryCurAndShort(encCtx, repMatchPrice, cur, curState, posState);\n    }\n    if (bufAvailFull < CMPTLZ_MATCH_LEN_MIN)\n    {\n        return lenEnd;\n    }\n    const uint32_t bufAvail = CMPTLZ_FIND_MIN(bufAvailFull, niceLen);\n    uint32_t startLen = CMPTLZ_MATCH_LEN_MIN;\n    uint32_t mainRepIndex;\n    for (mainRepIndex = 0; mainRepIndex < CMPTLZ_NUM_REPS; mainRepIndex++)\n    {\n        const uint8_t *const bufRepBack = buf - mainReps[mainRepIndex] - 1;\n        if (NOT_EQUAL_2_BYTES(buf, bufRepBack))\n        {\n            continue;\n        }\n        uint32_t lenEqual;\n        lenEqual = CmptMemCmpLenSafe(buf, bufRepBack, CMPTLZ_MATCH_LEN_MIN, bufAvail);\n        while (lenEnd < cur + lenEqual)\n        {\n            lenEnd++;\n            encCtx->opts[lenEnd].price = CMPT_INFINITY_PRICE;\n        }\n        const uint32_t lenEqualMem = lenEqual;\n        const uint32_t prefixPrice = repMatchPrice + CmptPriceLongRep(encCtx, mainRepIndex, curState, posState);\n        CmptlzDpTryCurAndLong(encCtx, prefixPrice, cur, mainRepIndex, lenEqual, posState);\n        lenEqual = lenEqualMem;\n        if (mainRepIndex == 0)\n        {\n            startLen = lenEqual + 1;\n        }\n    }\n    uint32_t newLongestLen = encCtx->longestMatchLen;\n    uint32_t matchCount = encCtx->matchesCount;\n    if (newLongestLen > bufAvail)\n    {\n        newLongestLen = bufAvail;\n        matchCount = 0;\n        while (newLongestLen > encCtx->matches[matchCount].len)\n        {\n            ++matchCount;\n        }\n        encCtx->matches[matchCount++].len = newLongestLen;\n    }\n    if (newLongestLen >= startLen)\n    {\n        const uint32_t normalmatch_prefixPrice = matchPrice + CmptPriceBit0(encCtx, encCtx->isRep[curState]);\n        while (lenEnd < cur + newLongestLen)\n        {\n            lenEnd++;\n            encCtx->opts[lenEnd].price = CMPT_INFINITY_PRICE;\n        }\n        CmptlzDpTryCurAndMatch(encCtx, startLen, matchCount, normalmatch_prefixPrice, cur, posState);\n    }\n    return lenEnd;\n}",
                "rust_code": "pub fn CmptlzDpProcess(mut encCtx: Ptr<CmptLzEncCtx>, mut mf: Ptr<CmptMfCtx>, mut mainReps: Ptr<u32>, mut lenEnd: u32, mut position: u32, mut cur: u32) -> u32 {\n    let mut curState: CmptlzState = encCtx.opts[cur].state;\n    let mut bufAvailFull: u32 = CMPTLZ_FIND_MIN!(CmptMfAvail(mf) + 1, CMPT_DP_OPTMAX!() - 1 - cur);\n    let mut buf: Ptr<u8> = CmptMfGetPtr(mf) - 1;\n    let mut niceLen: u32 = mf.niceLen;\n    let mut curPrice: u32 = encCtx.opts[cur].price;\n    let mut curByte: u8 = *buf;\n    let mut latestMatchByte: u8 = *(buf - mainReps[0] - 1);\n    let mut posState: u32 = position & encCtx.posMask;\n    encCtx.litMarcov.pos = position;\n    encCtx.litMarcov.prevByte = *(buf - 1);\n    CmptlzDpTryCurAndLit(encCtx, curPrice, curState, posState, cur, latestMatchByte, curByte);\n    let mut matchPrice: u32 = curPrice + CmptPriceBit1(encCtx, encCtx.isMatch[curState][posState]);\n    let mut repMatchPrice: u32 = matchPrice + CmptPriceBit1(encCtx, encCtx.isRep[curState]);\n    let tmp0 = cur + 1;\n    if (curByte == latestMatchByte) && !(encCtx.opts[tmp0].backPrev == 0) {\n        CmptlzDpTryCurAndShort(encCtx, repMatchPrice, cur, curState, posState);\n    }\n    if (bufAvailFull < CMPTLZ_MATCH_LEN_MIN!()) {\n        return lenEnd;\n    }\n    let mut bufAvail: u32 = CMPTLZ_FIND_MIN!(bufAvailFull, niceLen);\n    let mut startLen: u32 = CMPTLZ_MATCH_LEN_MIN!();\n    let mut mainRepIndex: u32;\n    c_for!(mainRepIndex = 0; mainRepIndex < CMPTLZ_NUM_REPS!(); mainRepIndex.suffix_plus_plus(); {\n        let mut bufRepBack: Ptr<u8> = (buf - mainReps[mainRepIndex] - 1);\n        if NOT_EQUAL_2_BYTES!(buf, bufRepBack) {\n            continue;\n        }\n        let mut lenEqual: u32;\n        lenEqual = CmptMemCmpLenSafe(buf, bufRepBack, CMPTLZ_MATCH_LEN_MIN!(), bufAvail);\n        while (lenEnd < cur + lenEqual) {\n            lenEnd.suffix_plus_plus();\n            encCtx.opts[lenEnd].price = CMPT_INFINITY_PRICE!();\n        }\n        let mut lenEqualMem: u32 = lenEqual;\n        let mut prefixPrice: u32 = repMatchPrice + CmptPriceLongRep(encCtx, mainRepIndex, curState, posState);\n        CmptlzDpTryCurAndLong(encCtx, prefixPrice, cur, mainRepIndex, lenEqual, posState);\n        lenEqual = lenEqualMem;\n        if (mainRepIndex == 0) {\n            startLen = lenEqual + 1;\n        }\n    });\n    let mut newLongestLen: u32 = encCtx.longestMatchLen;\n    let mut matchCount: u32 = encCtx.matchesCount;\n    if (newLongestLen > bufAvail) {\n        newLongestLen = bufAvail;\n        matchCount = 0;\n        while (newLongestLen > encCtx.matches[matchCount].len) {\n            matchCount.suffix_plus_plus();\n        }\n        encCtx.matches[matchCount].len = newLongestLen;\n        matchCount.suffix_plus_plus();\n    }\n    if (newLongestLen >= startLen) {\n        let mut normalmatch_prefixPrice: u32 = matchPrice + CmptPriceBit0(encCtx, encCtx.isRep[curState]);\n        while (lenEnd < cur + newLongestLen) {\n            lenEnd.suffix_plus_plus();\n            encCtx.opts[lenEnd].price = CMPT_INFINITY_PRICE!();\n        }\n        CmptlzDpTryCurAndMatch(encCtx, startLen, matchCount, normalmatch_prefixPrice, cur, posState);\n    }\n    return lenEnd;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451182291)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:2673:33\n     |\n2673 |     encCtx.litMarcov.prevByte = *(buf - 1);\n     |     -------------------------   ^^^^^^^^^^ expected `u32`, found `u8`\n     |     |\n     |     expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "void CmptlzEncPrepare(CmptLzEncCtx *encCtx)\n{\n    uint32_t i;\n    uint32_t j;\n    encCtx->encNeedFinish = false;\n    encCtx->cmptlzResponse = 0;\n    encCtx->nowpos64 = 0;\n    encCtx->state = 0;\n    encCtx->pbMask = (1 << encCtx->posBits) - 1;\n    encCtx->lpMask = ((uint32_t)0x100 << encCtx->litPos) - ((uint32_t)0x100 >> encCtx->litCtx);\n    encCtx->posMask = (1 << encCtx->posBits) - 1;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->reps[i] = 0;\n    }\n    encCtx->optsCurIndex = 0;\n    encCtx->optEndIndex = 0;\n    for (i = 0; i < CMPT_DP_OPTMAX; i++)\n    {\n        encCtx->opts[i].price = CMPT_INFINITY_PRICE;\n    }\n    for (i = 0; i < CMPTLZ_NUM_STATES; i++)\n    {\n        for (j = 0; j < CMPTLZ_NUM_PB_STATES_MAX; j++)\n        {\n            encCtx->isMatch[i][j] = CMPTLZ_PROB_INIT;\n            encCtx->isRep0Long[i][j] = CMPTLZ_PROB_INIT;\n        }\n        encCtx->isRep[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG0[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG1[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG2[i] = CMPTLZ_PROB_INIT;\n    }\n    for (i = 0; i < CMPTLZ_DIST_STATE_TOTAL; i++)\n    {\n        for (j = 0; j < (1 << CMPTLZ_DIST_SLOT_BITS); j++)\n        {\n            encCtx->probDistSlot[i][j] = CMPTLZ_PROB_INIT;\n        }\n    }\n    for (i = 0; i < CMPT_DIST_LIMIT_2; i++)\n    {\n        encCtx->probDistSpecial[i] = CMPTLZ_PROB_INIT;\n    }\n    for (i = 0; i < (1 << CMPTLZ_ALIGN_BITS); i++)\n    {\n        encCtx->probAlign[i] = CMPTLZ_PROB_INIT;\n    }\n    encCtx->litMarcov.lcBits = encCtx->litCtx;\n    encCtx->litMarcov.posMask = (1U << encCtx->litPos) - 1;\n    for (i = 0; i < (1 << CMPTLZ_LCLP_MAX); i++)\n    {\n        for (j = 0; j < CMPTLZ_LIT_MAX_SIZE; j++)\n        {\n            encCtx->litMarcov.literal[i][j] = CMPTLZ_PROB_INIT;\n        }\n    }\n    for (i = 0; i < (1 << CMPT_LEN_HIGH_BITS); i++)\n    {\n        encCtx->matchLenEncoder.high[i] = CMPTLZ_PROB_INIT;\n        encCtx->repLenEncoder.high[i] = CMPTLZ_PROB_INIT;\n        encCtx->matchLenEncoder.low[i] = CMPTLZ_PROB_INIT;\n        encCtx->repLenEncoder.low[i] = CMPTLZ_PROB_INIT;\n    }\n    CmptlzPriceInit(encCtx);\n    encCtx->repLenEncoder.tableSize = encCtx->numFastBytes - 1;\n    encCtx->matchLenEncoder.tableSize = encCtx->numFastBytes - 1;\n    CmptPriceGenLenTable(encCtx, &encCtx->matchLenEncoder);\n    CmptPriceGenLenTable(encCtx, &encCtx->repLenEncoder);\n}",
                "rust_code": "pub fn CmptlzEncPrepare(mut encCtx: Ptr<CmptLzEncCtx>) {\n    let mut i: u32 = Default::default();\n    let mut j: u32 = Default::default();\n    encCtx.encNeedFinish = false;\n    encCtx.cmptlzResponse = 0;\n    encCtx.nowpos64 = 0;\n    encCtx.state = 0;\n    encCtx.pbMask = (1 << encCtx.posBits) - 1;\n    encCtx.lpMask = (0x100 << encCtx.litPos) - (0x100 >> encCtx.litCtx);\n    encCtx.posMask = (1 << encCtx.posBits) - 1;\n    c_for!(i = 0; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_plus(); {\n        encCtx.reps[i] = 0;\n    });\n    encCtx.optsCurIndex = 0;\n    encCtx.optEndIndex = 0;\n    c_for!(i = 0; i < CMPT_DP_OPTMAX!(); i.suffix_plus_plus(); {\n        encCtx.opts[i].price = CMPT_INFINITY_PRICE!();\n    });\n    c_for!(i = 0; i < CMPTLZ_NUM_STATES!(); i.suffix_plus_plus(); {\n        c_for!(j = 0; j < CMPTLZ_NUM_PB_STATES_MAX!(); j.suffix_plus_plus(); {\n            encCtx.isMatch[i][j] = CMPTLZ_PROB_INIT!();\n            encCtx.isRep0Long[i][j] = CMPTLZ_PROB_INIT!();\n        });\n        encCtx.isRep[i] = CMPTLZ_PROB_INIT!();\n        encCtx.isRepG0[i] = CMPTLZ_PROB_INIT!();\n        encCtx.isRepG1[i] = CMPTLZ_PROB_INIT!();\n        encCtx.isRepG2[i] = CMPTLZ_PROB_INIT!();\n    });\n    c_for!(i = 0; i < CMPTLZ_DIST_STATE_TOTAL!(); i.suffix_plus_plus(); {\n        c_for!(j = 0; j < (1 << CMPTLZ_DIST_SLOT_BITS!()); j.suffix_plus_plus(); {\n            encCtx.probDistSlot[i][j] = CMPTLZ_PROB_INIT!();\n        });\n    });\n    c_for!(i = 0; i < CMPT_DIST_LIMIT_2!(); i.suffix_plus_plus(); {\n        encCtx.probDistSpecial[i] = CMPTLZ_PROB_INIT!();\n    });\n    c_for!(i = 0; i < (1 << CMPTLZ_ALIGN_BITS!()); i.suffix_plus_plus(); {\n        encCtx.probAlign[i] = CMPTLZ_PROB_INIT!();\n    });\n    encCtx.litMarcov.lcBits = encCtx.litCtx;\n    encCtx.litMarcov.posMask = (1 << encCtx.litPos) - 1;\n    c_for!(i = 0; i < (1 << CMPTLZ_LCLP_MAX!()); i.suffix_plus_plus(); {\n        c_for!(j = 0; j < CMPTLZ_LIT_MAX_SIZE!(); j.suffix_plus_plus(); {\n            encCtx.litMarcov.literal[i][j] = CMPTLZ_PROB_INIT!();\n        });\n    });\n    c_for!(i = 0; i < (1 << CMPT_LEN_HIGH_BITS!()); i.suffix_plus_plus(); {\n        encCtx.matchLenEncoder.high[i] = CMPTLZ_PROB_INIT!();\n        encCtx.repLenEncoder.high[i] = CMPTLZ_PROB_INIT!();\n        encCtx.matchLenEncoder.low[i] = CMPTLZ_PROB_INIT!();\n        encCtx.repLenEncoder.low[i] = CMPTLZ_PROB_INIT!();\n    });\n    CmptlzPriceInit(encCtx);\n    encCtx.repLenEncoder.tableSize = encCtx.numFastBytes - 1;\n    encCtx.matchLenEncoder.tableSize = encCtx.numFastBytes - 1;\n    CmptPriceGenLenTable(encCtx, c_ref!(encCtx.matchLenEncoder));\n    CmptPriceGenLenTable(encCtx, c_ref!(encCtx.repLenEncoder));\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451213095)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:2880:31\n     |\n2880 |     encCtx.litMarcov.lcBits = encCtx.litCtx;\n     |     -----------------------   ^^^^^^^^^^^^^ expected `u32`, found `i32`\n     |     |\n     |     expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "void *CmptInitCctx(CmptLzMemHook *alloc, int writeEndMark)\n{\n    void *handle = alloc->CmptLzAlloc(CMPTLZ_ENC_CCTX_HANDLE, sizeof(CmptLzEncCtx));\n    if (handle == NULL)\n    {\n        return NULL;\n    }\n    memset_s(handle, sizeof(CmptLzEncCtx), 0, sizeof(CmptLzEncCtx));\n    CmptLzEncCtx *encCtx = (CmptLzEncCtx *)handle;\n    encCtx->endMarker = writeEndMark;\n    encCtx->rcCtx = NULL;\n    encCtx->mfCtx = NULL;\n    return encCtx;\n}",
                "rust_code": "pub fn CmptInitCctx(mut alloc: Ptr<CmptLzMemHook>, mut writeEndMark: i32) -> Ptr<Void> {\n    let mut handle: Ptr<Void> = alloc.CmptLzAlloc(CMPTLZ_ENC_CCTX_HANDLE!(), c_sizeof!(CmptLzEncCtx));\n    if (handle == NULL!()) {\n        return NULL!();\n    }\n    c_memset_s!(handle, c_sizeof!(CmptLzEncCtx), 0, c_sizeof!(CmptLzEncCtx)).cast::<Void>();\n    let mut encCtx: Ptr<CmptLzEncCtx> = handle;\n    encCtx.endMarker = writeEndMark;\n    encCtx.rcCtx = NULL!();\n    encCtx.mfCtx = NULL!();\n    return encCtx;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451213536)\nerror[E0599]: no method named `CmptLzAlloc` found for struct `memory::ptr::Ptr<CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:2901:39\n     |\n2901 |     let mut handle: Ptr<Void> = alloc.CmptLzAlloc(CMPTLZ_ENC_CCTX_HANDLE!(), c_sizeof!(CmptLzEncCtx));\n     |                                       ^^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzAlloc` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzAlloc`, surround the field access with parentheses\n     |\n2901 |     let mut handle: Ptr<Void> = (alloc.CmptLzAlloc)(CMPTLZ_ENC_CCTX_HANDLE!(), c_sizeof!(CmptLzEncCtx));\n     |                                 +                 +\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n    --> src/translation_utils/types/null.rs:15:16\n     |\n15   |         Null().cast()\n     |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n     |\n    ::: src/src/cmptlz_c.rs:2908:20\n     |\n2908 |     encCtx.rcCtx = NULL!();\n     |                    ------- in this macro invocation\n     |\n     = help: the following other types implement trait `integer::Integer`:\n               bool\n               i128\n               i16\n               i32\n               i64\n               i8\n               isize\n               types::num::Num\n             and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n    --> src/translation_utils/types/integer.rs:195:32\n     |\n195  | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n     |          -------               ^^^^^^^^^^^^     ^^\n     |          |\n     |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n    --> src/translation_utils/types/cast_trait.rs:11:14\n     |\n11   | impl<T1, T2> CastInto<T2> for T1\n     |              ^^^^^^^^^^^^     ^^\n12   | where\n13   |     T2: CastFrom<T1>,\n     |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n    --> src/translation_utils/types/cast_trait.rs:23:15\n     |\n21   |     fn cast<T>(&mut self) -> T\n     |        ---- required by a bound in this associated function\n22   |     where\n23   |         Self: CastInto<T>,\n     |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n     = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n    --> src/translation_utils/types/null.rs:15:16\n     |\n15   |         Null().cast()\n     |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n     |\n    ::: src/src/cmptlz_c.rs:2909:20\n     |\n2909 |     encCtx.mfCtx = NULL!();\n     |                    ------- in this macro invocation\n     |\n     = help: the following other types implement trait `integer::Integer`:\n               bool\n               i128\n               i16\n               i32\n               i64\n               i8\n               isize\n               types::num::Num\n             and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n    --> src/translation_utils/types/integer.rs:195:32\n     |\n195  | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n     |          -------               ^^^^^^^^^^^^     ^^\n     |          |\n     |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n    --> src/translation_utils/types/cast_trait.rs:11:14\n     |\n11   | impl<T1, T2> CastInto<T2> for T1\n     |              ^^^^^^^^^^^^     ^^\n12   | where\n13   |     T2: CastFrom<T1>,\n     |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n    --> src/translation_utils/types/cast_trait.rs:23:15\n     |\n21   |     fn cast<T>(&mut self) -> T\n     |        ---- required by a bound in this associated function\n22   |     where\n23   |         Self: CastInto<T>,\n     |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n     = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n    --> src/translation_utils/types/null.rs:15:16\n     |\n15   |         Null().cast()\n     |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n     |\n    ::: src/src/cmptlz_c.rs:2902:19\n     |\n2902 |     if (handle == NULL!()) {\n     |                   ------- in this macro invocation\n     |\n     = help: the following other types implement trait `integer::Integer`:\n               bool\n               i128\n               i16\n               i32\n               i64\n               i8\n               isize\n               types::num::Num\n             and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n    --> src/translation_utils/types/integer.rs:195:32\n     |\n195  | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n     |          -------               ^^^^^^^^^^^^     ^^\n     |          |\n     |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n    --> src/translation_utils/types/cast_trait.rs:11:14\n     |\n11   | impl<T1, T2> CastInto<T2> for T1\n     |              ^^^^^^^^^^^^     ^^\n12   | where\n13   |     T2: CastFrom<T1>,\n     |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n    --> src/translation_utils/types/cast_trait.rs:23:15\n     |\n21   |     fn cast<T>(&mut self) -> T\n     |        ---- required by a bound in this associated function\n22   |     where\n23   |         Self: CastInto<T>,\n     |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n     = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `CmptLzAlloc` found for struct `memory::ptr::Ptr<cmptlz_c::CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:2901:39\n     |\n2901 |     let mut handle: Ptr<Void> = alloc.CmptLzAlloc(CMPTLZ_ENC_CCTX_HANDLE!(), c_sizeof!(CmptLzEncCtx));\n     |                                       ^^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzAlloc` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzAlloc`, surround the field access with parentheses\n     |\n2901 |     let mut handle: Ptr<Void> = (alloc.CmptLzAlloc)(CMPTLZ_ENC_CCTX_HANDLE!(), c_sizeof!(CmptLzEncCtx));\n     |                                 +                 +\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 4 previous errors\n"
            },
            {
                "c_code": "static uint32_t CmptMfAvail(const CmptMfCtx *mf)\n{\n    return mf->srcLen - mf->readPos;\n}",
                "rust_code": "pub fn CmptMfAvail(mut mf: Ptr<CmptMfCtx>) -> u32 {\n    return (mf.srcLen - mf.readPos).cast();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451224111)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:2926:25\n     |\n2926 |     return (mf.srcLen - mf.readPos).cast();\n     |                         ^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n    --> src/src/cmptlz_c.rs:2926:23\n     |\n2926 |     return (mf.srcLen - mf.readPos).cast();\n     |                       ^ no implementation for `usize - u32`\n     |\n     = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n     = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n               `&usize` implements `std::ops::Sub<usize>`\n               `&usize` implements `std::ops::Sub`\n               `usize` implements `std::ops::Sub<&usize>`\n               `usize` implements `std::ops::Sub<types::num::Num>`\n               `usize` implements `std::ops::Sub`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "int CmptMfPrepare(CmptLzEncCtx *encCtx, const uint8_t *src, size_t srcLen, CmptLzMemHook *alloc)\n{\n    CmptMfCtx *mf = alloc->CmptLzAlloc(CMPTLZ_MF_CCTX_HANDLE, sizeof(CmptMfCtx));\n    if (mf == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    memset_s(mf, sizeof(CmptMfCtx), 0, sizeof(CmptMfCtx));\n    encCtx->mfCtx = mf;\n    mf->cycleSize = encCtx->dicSize + 1;\n    uint32_t hashMask = encCtx->dicSize - 1;\n    CMPT_HASH_MASK_CALC(hashMask);\n    mf->hashMask = hashMask;\n    ++hashMask;\n    hashMask += CMPTLZ_HASH_2_SIZE;\n    hashMask += CMPTLZ_HASH_3_SIZE;\n    mf->hashCount = hashMask;\n    mf->sonsCount = mf->cycleSize * 2;\n    mf->hash = NULL;\n    mf->son = NULL;\n    mf->hash = alloc->CmptLzAlloc(CMPTLZ_MF_HASH_HANDLE, mf->hashCount * sizeof(uint32_t));\n    memset_s(mf->hash, mf->hashCount * sizeof(uint32_t), 0, mf->hashCount * sizeof(uint32_t));\n    if (mf->hash == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    mf->son = alloc->CmptLzAlloc(CMPTLZ_MF_SON_HANDLE, mf->sonsCount * sizeof(uint32_t));\n    memset_s(mf->son, mf->sonsCount * sizeof(uint32_t), 0, mf->sonsCount * sizeof(uint32_t));\n    if (mf->son == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    CmptlzMfGenHashTable(mf);\n    mf->srcStart = src;\n    mf->srcLen = srcLen;\n    mf->offset = mf->cycleSize;\n    mf->niceLen = encCtx->numFastBytes;\n    mf->depth = CMPT_MF_BASE_DEPTH + mf->niceLen / 2;\n    return 0;\n}",
                "rust_code": "pub fn CmptMfPrepare(mut encCtx: Ptr<CmptLzEncCtx>, mut src: Ptr<u8>, mut srcLen: usize, mut alloc: Ptr<CmptLzMemHook>) -> i32 {\n    let mut mf: Ptr<CmptMfCtx> = (alloc.CmptLzAlloc)(CMPTLZ_MF_CCTX_HANDLE!(), c_sizeof!(CmptMfCtx));\n    if (mf == NULL!()) {\n        return CMPT_ENC_MF_INIT_FAIL!();\n    }\n    c_memset_s!(mf, c_sizeof!(CmptMfCtx), 0, c_sizeof!(CmptMfCtx)).cast::<Void>();\n    encCtx.mfCtx = mf;\n    mf.cycleSize = encCtx.dicSize + 1;\n    let mut hashMask: u32 = encCtx.dicSize - 1;\n    CMPT_HASH_MASK_CALC!(hashMask);\n    mf.hashMask = hashMask;\n    hashMask += 1;\n    hashMask += CMPTLZ_HASH_2_SIZE!();\n    hashMask += CMPTLZ_HASH_3_SIZE!();\n    mf.hashCount = hashMask;\n    mf.sonsCount = mf.cycleSize * 2;\n    mf.hash = NULL!();\n    mf.son = NULL!();\n    mf.hash = (alloc.CmptLzAlloc)(CMPTLZ_MF_HASH_HANDLE!(), mf.hashCount * c_sizeof!(u32));\n    c_memset_s!(mf.hash, mf.hashCount * c_sizeof!(u32), 0, mf.hashCount * c_sizeof!(u32)).cast::<Void>();\n    if (mf.hash == NULL!()) {\n        return CMPT_ENC_MF_INIT_FAIL!();\n    }\n    mf.son = (alloc.CmptLzAlloc)(CMPTLZ_MF_SON_HANDLE!(), mf.sonsCount * c_sizeof!(u32));\n    c_memset_s!(mf.son, mf.sonsCount * c_sizeof!(u32), 0, mf.sonsCount * c_sizeof!(u32)).cast::<Void>();\n    if (mf.son == NULL!()) {\n        return CMPT_ENC_MF_INIT_FAIL!();\n    }\n    CmptlzMfGenHashTable(mf);\n    mf.srcStart = src;\n    mf.srcLen = srcLen;\n    mf.offset = mf.cycleSize;\n    mf.niceLen = encCtx.numFastBytes;\n    mf.depth = CMPT_MF_BASE_DEPTH!() + mf.niceLen / 2;\n    return 0;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451244607)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:2985:80\n     |\n2985 |     let mut mf: Ptr<CmptMfCtx> = (alloc.CmptLzAlloc)(CMPTLZ_MF_CCTX_HANDLE!(), c_sizeof!(CmptMfCtx));\n     |                                  -------------------                           ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `Num`\n     |                                  |\n     |                                  arguments to this function are incorrect\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:2985:34\n     |\n2985 |     let mut mf: Ptr<CmptMfCtx> = (alloc.CmptLzAlloc)(CMPTLZ_MF_CCTX_HANDLE!(), c_sizeof!(CmptMfCtx));\n     |                 --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ptr<TagCmptMatchFinder>`, found `Ptr<u8>`\n     |                 |\n     |                 expected due to this\n     |\n     = note: expected struct `memory::ptr::Ptr<TagCmptMatchFinder>`\n                found struct `memory::ptr::Ptr<u8>`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3002:61\n     |\n3002 |     mf.hash = (alloc.CmptLzAlloc)(CMPTLZ_MF_HASH_HANDLE!(), mf.hashCount * c_sizeof!(u32));\n     |               -------------------                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n     |               |\n     |               arguments to this function are incorrect\n     |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n     |\n3002 |     mf.hash = (alloc.CmptLzAlloc)(CMPTLZ_MF_HASH_HANDLE!(), (mf.hashCount * c_sizeof!(u32)).try_into().unwrap());\n     |                                                             +                             +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3002:15\n     |\n3002 |     mf.hash = (alloc.CmptLzAlloc)(CMPTLZ_MF_HASH_HANDLE!(), mf.hashCount * c_sizeof!(u32));\n     |     -------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ptr<u32>`, found `Ptr<u8>`\n     |     |\n     |     expected due to the type of this binding\n     |\n     = note: expected struct `memory::ptr::Ptr<u32>`\n                found struct `memory::ptr::Ptr<u8>`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3007:59\n     |\n3007 |     mf.son = (alloc.CmptLzAlloc)(CMPTLZ_MF_SON_HANDLE!(), mf.sonsCount * c_sizeof!(u32));\n     |              -------------------                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n     |              |\n     |              arguments to this function are incorrect\n     |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n     |\n3007 |     mf.son = (alloc.CmptLzAlloc)(CMPTLZ_MF_SON_HANDLE!(), (mf.sonsCount * c_sizeof!(u32)).try_into().unwrap());\n     |                                                           +                             +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3007:14\n     |\n3007 |     mf.son = (alloc.CmptLzAlloc)(CMPTLZ_MF_SON_HANDLE!(), mf.sonsCount * c_sizeof!(u32));\n     |     ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ptr<u32>`, found `Ptr<u8>`\n     |     |\n     |     expected due to the type of this binding\n     |\n     = note: expected struct `memory::ptr::Ptr<u32>`\n                found struct `memory::ptr::Ptr<u8>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 6 previous errors\n"
            },
            {
                "c_code": "void CmptlzMatchSkiper(CmptMfCtx *mf, uint32_t amount)\n{\n    mf->readAhead += amount;\n    uint32_t pos, temp, hash2Value, hash3Value, hashValue, curMatch;\n    const uint32_t niceLen = mf->niceLen;\n    do\n    {\n        uint32_t lenLimit = mf->srcLen - mf->readPos;\n        if (CMPTLZ_LIKELY(niceLen <= lenLimit))\n        {\n            lenLimit = niceLen;\n        }\n        else\n        {\n            mf->readPos++;\n            continue;\n        }\n        const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n        pos = mf->readPos + mf->offset;\n        CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue);\n        curMatch = mf->hash[CMPTLZ_FIX_4_HASH + hashValue];\n        CMPT_HASH_UPDATE(mf, hash2Value, hash3Value, hashValue, pos);\n        CmptBtSkip(mf, lenLimit, pos, cur, curMatch);\n        CMPT_MF_MOVE_POS(mf);\n    } while (--amount != 0);\n}",
                "rust_code": "pub fn CmptlzMatchSkiper(mut mf: Ptr<CmptMfCtx>, mut amount: u32) {\n    mf.readAhead += amount;\n    let mut pos: u32 = Default::default();\n    let mut temp: u32 = Default::default();\n    let mut hash2Value: u32 = Default::default();\n    let mut hash3Value: u32 = Default::default();\n    let mut hashValue: u32 = Default::default();\n    let mut curMatch: u32 = Default::default();\n    let niceLen: u32 = mf.niceLen;\n    c_do!({\n        let mut lenLimit: u32 = mf.srcLen - mf.readPos;\n        if CMPTLZ_LIKELY!(niceLen <= lenLimit) {\n            lenLimit = niceLen;\n        } else {\n            mf.readPos += 1;\n            continue;\n        }\n        let mut cur: Ptr<u8> = (mf.srcStart + mf.readPos);\n        pos = mf.readPos + mf.offset;\n        CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n        curMatch = mf.hash[CMPTLZ_FIX_4_HASH!() + hashValue];\n        CMPT_HASH_UPDATE!(mf, hash2Value, hash3Value, hashValue, pos);\n        CmptBtSkip(mf, lenLimit, pos, cur, curMatch);\n        CMPT_MF_MOVE_POS!(mf);\n    } while amount.prefix_minus_minus() != 0);\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451265128)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3166:45\n     |\n3166 |         let mut lenLimit: u32 = mf.srcLen - mf.readPos;\n     |                                             ^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3166:33\n     |\n3166 |         let mut lenLimit: u32 = mf.srcLen - mf.readPos;\n     |                           ---   ^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `usize`\n     |                           |\n     |                           expected due to this\n     |\nhelp: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit\n     |\n3166 |         let mut lenLimit: u32 = (mf.srcLen - mf.readPos).try_into().unwrap();\n     |                                 +                      +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `u32` from `usize`\n    --> src/src/cmptlz_c.rs:3166:43\n     |\n3166 |         let mut lenLimit: u32 = mf.srcLen - mf.readPos;\n     |                                           ^ no implementation for `usize - u32`\n     |\n     = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n     = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n               `&usize` implements `std::ops::Sub<usize>`\n               `&usize` implements `std::ops::Sub`\n               `usize` implements `std::ops::Sub<&usize>`\n               `usize` implements `std::ops::Sub<types::num::Num>`\n               `usize` implements `std::ops::Sub`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 3 previous errors\n"
            },
            {
                "c_code": "uint32_t CmptlzMatchFinder(CmptMfCtx *mf, uint32_t *pCount, CmptlzMatchPair *matches)\n{\n    if (CMPTLZ_UNLIKELY(mf->srcLen - mf->readPos < mf->niceLen))\n    {\n        *pCount = 0;\n        mf->readPos++;\n        mf->readAhead++;\n        return 0;\n    }\n    const uint32_t count = CmptlzBt4Finder(mf, matches);\n    if (count == 0)\n    {\n        *pCount = 0;\n        mf->readAhead++;\n        return 0;\n    }\n    uint32_t longestLen = matches[count - 1].len;\n    if (longestLen == mf->niceLen)\n    {\n        uint32_t bytesAvail = CMPTLZ_FIND_MIN(mf->srcLen - mf->readPos + 1, CMPT_MF_LONGEST_MATCH);\n        const uint8_t *p1 = (const uint8_t *)(mf->srcStart + mf->readPos - 1);\n        const uint8_t *p2 = p1 - matches[count - 1].dist - 1;\n        longestLen = CmptMemCmpLenSafe(p1, p2, longestLen, bytesAvail);\n    }\n    *pCount = count;\n    mf->readAhead++;\n    return longestLen;\n}",
                "rust_code": "pub fn CmptlzMatchFinder(mut mf: Ptr<CmptMfCtx>, mut pCount: Ptr<u32>, mut matches: Ptr<CmptlzMatchPair>) -> u32 {\n    if CMPTLZ_UNLIKELY!(mf.srcLen - mf.readPos < mf.niceLen) {\n        *pCount = 0;\n        mf.readPos += 1;\n        mf.readAhead += 1;\n        return 0;\n    }\n    let mut count: u32 = CmptlzBt4Finder(mf, matches);\n    if (count == 0) {\n        *pCount = 0;\n        mf.readAhead += 1;\n        return 0;\n    }\n    let mut longestLen: u32 = matches[count - 1].len;\n    if (longestLen == mf.niceLen) {\n        let mut bytesAvail: u32 = CMPTLZ_FIND_MIN!(mf.srcLen - mf.readPos + 1, CMPT_MF_LONGEST_MATCH!()).cast();\n        let mut p1: Ptr<u8> = (mf.srcStart + mf.readPos - 1).cast::<Ptr<u8>>();\n        let mut p2: Ptr<u8> = (p1 - matches[count - 1].dist - 1);\n        longestLen = CmptMemCmpLenSafe(p1, p2, longestLen, bytesAvail);\n    }\n    *pCount = count;\n    mf.readAhead += 1;\n    return longestLen;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451265559)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3193:37\n     |\n3193 |     if CMPTLZ_UNLIKELY!(mf.srcLen - mf.readPos < mf.niceLen) {\n     |                                     ^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n    --> src/src/cmptlz_c.rs:3193:35\n     |\n3193 |     if CMPTLZ_UNLIKELY!(mf.srcLen - mf.readPos < mf.niceLen) {\n     |                                   ^ no implementation for `usize - u32`\n     |\n     = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n     = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n               `&usize` implements `std::ops::Sub<usize>`\n               `&usize` implements `std::ops::Sub`\n               `usize` implements `std::ops::Sub<&usize>`\n               `usize` implements `std::ops::Sub<types::num::Num>`\n               `usize` implements `std::ops::Sub`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3193:50\n     |\n3193 |     if CMPTLZ_UNLIKELY!(mf.srcLen - mf.readPos < mf.niceLen) {\n     |                         ----------------------   ^^^^^^^^^^ expected `usize`, found `u32`\n     |                         |\n     |                         expected because this is `usize`\n     |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n     |\n3193 |     if CMPTLZ_UNLIKELY!(mf.srcLen - mf.readPos < mf.niceLen.try_into().unwrap()) {\n     |                                                            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3207:64\n     |\n3207 |         let mut bytesAvail: u32 = CMPTLZ_FIND_MIN!(mf.srcLen - mf.readPos + 1, CMPT_MF_LONGEST_MATCH!()).cast();\n     |                                                                ^^^^^^^^^^ expected `usize`, found `u32`\n\nerror[E0277]: cannot subtract `u32` from `usize`\n    --> src/src/cmptlz_c.rs:3207:62\n     |\n3207 |         let mut bytesAvail: u32 = CMPTLZ_FIND_MIN!(mf.srcLen - mf.readPos + 1, CMPT_MF_LONGEST_MATCH!()).cast();\n     |                                                              ^ no implementation for `usize - u32`\n     |\n     = help: the trait `std::ops::Sub<u32>` is not implemented for `usize`\n     = help: the following other types implement trait `std::ops::Sub<Rhs>`:\n               `&usize` implements `std::ops::Sub<usize>`\n               `&usize` implements `std::ops::Sub`\n               `usize` implements `std::ops::Sub<&usize>`\n               `usize` implements `std::ops::Sub<types::num::Num>`\n               `usize` implements `std::ops::Sub`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 5 previous errors\n"
            },
            {
                "c_code": "static uint32_t CmptPriceOneBit(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob, uint32_t curbit)\n{\n    return encCtx->priceRootTable[(bit0Prob ^ ((uint32_t)(0 - curbit) & (CMPTLZ_PROB_MAX_NUM - 1))) >>\n                                  CMPT_PRICE_BITS_MOVING_NUM];\n}",
                "rust_code": "pub fn CmptPriceOneBit(mut encCtx: Ptr<CmptLzEncCtx>, mut bit0Prob: CmptlzProb, mut curbit: u32) -> u32 {\n    let tmp0 = ((bit0Prob ^ ((0 - curbit).cast::<u32>() & (CMPTLZ_PROB_MAX_NUM!() - 1))) >> CMPT_PRICE_BITS_MOVING_NUM!()).cast::<usize>();\n    return encCtx.priceRootTable[tmp0];\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451271039)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3222:29\n     |\n3222 |     let tmp0 = ((bit0Prob ^ ((0 - curbit).cast::<u32>() & (CMPTLZ_PROB_MAX_NUM!() - 1))) >> CMPT_PRICE_BITS_MOVING_NUM!()).cast::<usize>();\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found `u32`\n\nerror[E0277]: no implementation for `u16 ^ u32`\n    --> src/src/cmptlz_c.rs:3222:27\n     |\n3222 |     let tmp0 = ((bit0Prob ^ ((0 - curbit).cast::<u32>() & (CMPTLZ_PROB_MAX_NUM!() - 1))) >> CMPT_PRICE_BITS_MOVING_NUM!()).cast::<usize>();\n     |                           ^ no implementation for `u16 ^ u32`\n     |\n     = help: the trait `BitXor<u32>` is not implemented for `u16`\n     = help: the following other types implement trait `BitXor<Rhs>`:\n               `&u16` implements `BitXor<u16>`\n               `&u16` implements `BitXor`\n               `u16` implements `BitXor<&u16>`\n               `u16` implements `BitXor`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "static uint32_t CmptPriceSymbolReverse(CmptLzEncCtx *encCtx, CmptlzProb *symbolProbs, uint32_t symbolBitsNum,\n                                       uint32_t symbol)\n{\n    uint32_t price = 0;\n    uint32_t i = 1;\n    do\n    {\n        uint32_t bit = symbol & 1;\n        symbol >>= 1;\n        price += CmptPriceOneBit(encCtx, symbolProbs[i], bit);\n        i = (i << 1) + bit;\n    } while (--symbolBitsNum);\n    return price;\n}",
                "rust_code": "pub fn CmptPriceSymbolReverse(mut encCtx: Ptr<CmptLzEncCtx>, mut symbolProbs: Ptr<CmptlzProb>, mut symbolBitsNum: u32, mut symbol: u32) -> u32 {\n    let mut price: u32 = 0;\n    let mut i: u32 = 1;\n    c_do!({\n        let mut bit: u32 = symbol & 1;\n        symbol >>= 1;\n        price += CmptPriceOneBit(encCtx, symbolProbs[i], bit).cast::<u32>();\n        i = (i << 1) + bit;\n    } while symbolBitsNum.prefix_minus_minus());\n    return price;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451286620)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3255:13\n     |\n3255 |     } while symbolBitsNum.prefix_minus_minus());\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `u32`\n     |\n    ::: src/translation_utils/c_alignment/c_do_while.rs:7:15\n     |\n7    |         while core::mem::replace(&mut __first, false) || $cond\n     |               --------------------------------------- expected because this is `bool`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "void CmptPriceGenDistTable(CmptLzEncCtx *encCtx)\n{\n    uint32_t distState = 0;\n    do\n    {\n        uint32_t *const tmpPriceDistSlot = encCtx->priceDistSlotTable[distState];\n        for (uint32_t i = 0; i < encCtx->distTableSize; i++)\n        {\n            tmpPriceDistSlot[i] = CmptPriceSymbol(encCtx, encCtx->probDistSlot[distState], CMPTLZ_DIST_SLOT_BITS, i);\n        }\n        for (uint32_t i = 14; i < encCtx->distTableSize; i++)\n        {\n            tmpPriceDistSlot[i] += CmptPriceOneBitDirect((i >> 1) - 1 - CMPTLZ_ALIGN_BITS);\n        }\n        for (uint32_t i = 0; i < 4; i++)\n        {\n            encCtx->priceDistTable[distState][i] = tmpPriceDistSlot[i];\n        }\n        distState++;\n    } while (distState < CMPTLZ_DIST_STATE_TOTAL);\n    for (uint32_t i = 4; i < 128; i++)\n    {\n        uint32_t distSlot = PosSloter(i);\n        uint32_t footerBits = (distSlot >> 1) - 1;\n        uint32_t base = (2 | (distSlot & 1)) << footerBits;\n        uint32_t price =\n            CmptPriceSymbolReverse(encCtx, encCtx->probDistSpecial + base - distSlot - 1, footerBits, i - base);\n        for (distState = 0; distState < 4; distState++)\n        {\n            encCtx->priceDistTable[distState][i] = price + encCtx->priceDistSlotTable[distState][distSlot];\n        }\n    }\n    encCtx->matchPriceCount = 0;\n}",
                "rust_code": "pub fn CmptPriceGenDistTable(mut encCtx: Ptr<CmptLzEncCtx>) {\n    let mut distState: u32 = 0;\n    c_do!({\n        let mut tmpPriceDistSlot: Ptr<u32> = encCtx.priceDistSlotTable[distState].cast();\n        c_for!(let mut i: u32 = 0; i < encCtx.distTableSize; i.suffix_plus_plus(); {\n            tmpPriceDistSlot[i] = CmptPriceSymbol(encCtx, encCtx.probDistSlot[distState].cast(), CMPTLZ_DIST_SLOT_BITS!(), i);\n        });\n        c_for!(let mut i: u32 = 14; i < encCtx.distTableSize; i.suffix_plus_plus(); {\n            tmpPriceDistSlot[i] += CmptPriceOneBitDirect(((i >> 1) - 1 - CMPTLZ_ALIGN_BITS!()));\n        });\n        c_for!(let mut i: u32 = 0; i < 4; i.suffix_plus_plus(); {\n            encCtx.priceDistTable[distState][i] = tmpPriceDistSlot[i];\n        });\n        distState.suffix_plus_plus();\n    } while distState < CMPTLZ_DIST_STATE_TOTAL!());\n    c_for!(let mut i: u32 = 4; i < 128; i.suffix_plus_plus(); {\n        let mut distSlot: u32 = PosSloter(i);\n        let mut footerBits: u32 = ((distSlot >> 1) - 1);\n        let mut base: u32 = ((2 | (distSlot & 1)) << footerBits);\n        let mut price: u32 = CmptPriceSymbolReverse(encCtx, (encCtx.probDistSpecial + base - distSlot - 1), footerBits, (i - base));\n        c_for!(distState = 0; distState < 4; distState.suffix_plus_plus(); {\n            encCtx.priceDistTable[distState][i] = (price + encCtx.priceDistSlotTable[distState][distSlot]);\n        });\n    });\n    encCtx.matchPriceCount = 0;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451292142)\nerror[E0369]: cannot add `u32` to `types::array::Array<u16, 128>`\n    --> src/src/cmptlz_c.rs:3303:85\n     |\n3303 |         let mut price: u32 = CmptPriceSymbolReverse(encCtx, (encCtx.probDistSpecial + base - distSlot - 1), footerBits, (i - base));\n     |                                                              ---------------------- ^ ---- u32\n     |                                                              |\n     |                                                              types::array::Array<u16, 128>\n     |\nnote: an implementation of `std::ops::Add<u32>` might be missing for `types::array::Array<u16, 128>`\n    --> src/translation_utils/types/array.rs:5:1\n     |\n5    | pub struct Array<T, const N: usize>(pub [T; N]);\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `std::ops::Add<u32>`\nnote: the trait `std::ops::Add` must be implemented\n    --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/ops/arith.rs:78:1\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "uint32_t CmptPriceLiteral(CmptLzEncCtx *encCtx, bool matchMode, uint32_t matchByte, uint32_t symbol)\n{\n    uint32_t pos = encCtx->litMarcov.pos;\n    uint32_t prevByte = encCtx->litMarcov.prevByte;\n    uint32_t litCtx = encCtx->litMarcov.lcBits;\n    uint32_t lpMask = encCtx->litMarcov.posMask;\n    CmptlzProb *subCoder = CMPT_LIT_SUBCODER(encCtx->litMarcov.literal, litCtx, lpMask, pos, prevByte);\n    uint32_t price = 0;\n    if (!matchMode)\n    {\n        price = CmptPriceSymbol(encCtx, subCoder, 8, symbol);\n    }\n    else\n    {\n        uint32_t offset = 0x100;\n        symbol += 1 << 8;\n        do\n        {\n            matchByte <<= 1;\n            const uint32_t matchBit = matchByte & offset;\n            const uint32_t subCoderIndex = offset + matchBit + (symbol >> 8);\n            const uint32_t bit = (symbol >> 7) & 1;\n            price += CmptPriceOneBit(encCtx, subCoder[subCoderIndex], bit);\n            symbol <<= 1;\n            offset &= ~(matchByte ^ symbol);\n        } while (symbol < (1 << 16));\n    }\n    return price;\n}",
                "rust_code": "pub fn CmptPriceLiteral(mut encCtx: Ptr<CmptLzEncCtx>, mut matchMode: bool, mut matchByte: u32, mut symbol: u32) -> u32 {\n    let mut pos: u32 = encCtx.litMarcov.pos;\n    let mut prevByte: u32 = encCtx.litMarcov.prevByte;\n    let mut litCtx: u32 = encCtx.litMarcov.lcBits;\n    let mut lpMask: u32 = encCtx.litMarcov.posMask;\n    let mut subCoder: Ptr<CmptlzProb> = CMPT_LIT_SUBCODER!(encCtx.litMarcov.literal, litCtx, lpMask, pos, prevByte);\n    let mut price: u32 = 0;\n    if !matchMode {\n        price = CmptPriceSymbol(encCtx, subCoder, 8, symbol);\n    } else {\n        let mut offset: u32 = 0x100;\n        symbol += 1 << 8;\n        c_do!({\n            matchByte <<= 1;\n            let mut matchBit: u32 = (matchByte & offset);\n            let mut subCoderIndex: u32 = (offset + matchBit + (symbol >> 8));\n            let mut bit: u32 = ((symbol >> 7) & 1);\n            price += CmptPriceOneBit(encCtx, subCoder[subCoderIndex], bit);\n            symbol <<= 1;\n            offset &= !(matchByte ^ symbol);\n        } while symbol < (1 << 16));\n    }\n    return price;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451297727)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1071:9\n     |\n1071 |         $probs[((($pos & $lpMask) << $litCtx) + (($prevByte as u32) >> (8 - $litCtx))) as usize]\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ptr<u16>`, found `Array<u16, 768>`\n...\n3325 |     let mut subCoder: Ptr<CmptlzProb> = CMPT_LIT_SUBCODER!(encCtx.litMarcov.literal, litCtx, lpMask, pos, prevByte);\n     |                       ---------------   --------------------------------------------------------------------------- in this macro invocation\n     |                       |\n     |                       expected due to this\n     |\n     = note: expected struct `memory::ptr::Ptr<u16>`\n                found struct `types::array::Array<u16, 768>`\n     = note: this error originates in the macro `CMPT_LIT_SUBCODER` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "void CmptPriceGenLenTable(CmptLzEncCtx *encCtx, CmptLenEncoder *lenEncoder)\n{\n    const uint32_t numPosStates = 1 << encCtx->posBits;\n    uint32_t b;\n    uint32_t prob = lenEncoder->low[0];\n    uint32_t a, c;\n    uint32_t posState;\n    b = CmptPriceBit1(encCtx, prob);\n    a = CmptPriceBit0(encCtx, prob);\n    c = b + CmptPriceBit0(encCtx, lenEncoder->low[1 << CMPT_LEN_LOW_BITS]);\n    for (posState = 0; posState < numPosStates; posState++)\n    {\n        uint32_t *prices = lenEncoder->prices[posState];\n        const CmptlzProb *probs = lenEncoder->low + (posState << (1 + CMPT_LEN_LOW_BITS));\n        CmptPriceSet(encCtx, probs, a, prices);\n        CmptPriceSet(encCtx, probs + (1 << CMPT_LEN_LOW_BITS), c, prices + (1 << CMPT_LEN_LOW_BITS));\n    }\n    uint32_t i = lenEncoder->tableSize;\n    if (i > (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE)\n    {\n        const CmptlzProb *probs = lenEncoder->high;\n        uint32_t *prices = lenEncoder->prices[0] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE;\n        i -= (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE - 1;\n        i >>= 1;\n        b += CmptPriceBit1(encCtx, lenEncoder->low[(1 << CMPT_LEN_LOW_BITS)]);\n        do\n        {\n            uint32_t sym = --i + (1 << (CMPT_LEN_HIGH_BITS - 1));\n            uint32_t price = b;\n            do\n            {\n                uint32_t bit = sym & 1;\n                sym >>= 1;\n                price += CmptPriceOneBit(encCtx, probs[sym], bit);\n            } while (sym >= 2);\n            prob = probs[(size_t)i + (1 << (CMPT_LEN_HIGH_BITS - 1))];\n            prices[(size_t)i * CMPT_DOUBLE] = price + CmptPriceBit0(encCtx, prob);\n            prices[(size_t)i * CMPT_DOUBLE + 1] = price + CmptPriceBit1(encCtx, prob);\n        } while (i);\n        size_t num =\n            (lenEncoder->tableSize - (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE) * sizeof(lenEncoder->prices[0][0]);\n        for (posState = 1; posState < numPosStates; posState++)\n        {\n            memcpy_s(lenEncoder->prices[posState] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE, CMPT_MF_LONGEST_MATCH - 1,\n                     lenEncoder->prices[0] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE, num);\n        }\n    }\n}",
                "rust_code": "pub fn CmptPriceGenLenTable(mut encCtx: Ptr<CmptLzEncCtx>, mut lenEncoder: Ptr<CmptLenEncoder>) {\n    let numPosStates: u32 = 1 << encCtx.posBits;\n    let mut b: u32;\n    let mut prob: u32 = lenEncoder.low[0];\n    let mut a: u32;\n    let mut c: u32;\n    let mut posState: u32;\n    b = CmptPriceBit1(encCtx, prob.cast());\n    a = CmptPriceBit0(encCtx, prob.cast());\n    c = (b + CmptPriceBit0(encCtx, lenEncoder.low[1 << CMPT_LEN_LOW_BITS!()]));\n    c_for!(posState = 0; posState < numPosStates; posState.suffix_plus_plus(); {\n        let mut prices: Ptr<u32> = lenEncoder.prices[posState].cast();\n        let mut probs: Ptr<CmptlzProb> = (lenEncoder.low + (posState << (1 + CMPT_LEN_LOW_BITS!())));\n        CmptPriceSet(encCtx, probs, a, prices);\n        CmptPriceSet(encCtx, (probs + (1 << CMPT_LEN_LOW_BITS!())), c, (prices + (1 << CMPT_LEN_LOW_BITS!())));\n    });\n    let mut i: u32 = lenEncoder.tableSize;\n    if (i > (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) {\n        let mut probs: Ptr<CmptlzProb> = lenEncoder.high.cast();\n        let mut prices: Ptr<u32> = (lenEncoder.prices[0] + (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!());\n        i -= (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!() - 1;\n        i >>= 1;\n        b += CmptPriceBit1(encCtx, lenEncoder.low[(1 << CMPT_LEN_LOW_BITS!())]);\n        c_do!({\n            let mut sym: u32 = (i.prefix_minus_minus() + (1 << (CMPT_LEN_HIGH_BITS!() - 1)));\n            let mut price: u32 = b;\n            c_do!({\n                let mut bit: u32 = (sym & 1);\n                sym >>= 1;\n                price += CmptPriceOneBit(encCtx, probs[sym], bit);\n            } while sym >= 2);\n            prob = probs[(i + (1 << (CMPT_LEN_HIGH_BITS!() - 1)))].cast();\n            prices[(i * CMPT_DOUBLE!())] = (price + CmptPriceBit0(encCtx, prob.cast()));\n            prices[(i * CMPT_DOUBLE!() + 1)] = (price + CmptPriceBit1(encCtx, prob.cast()));\n        } while i != 0);\n        let mut num: usize = (lenEncoder.tableSize - (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) * c_sizeofval!(lenEncoder.prices[0][0]);\n        c_for!(posState = 1; posState < numPosStates; posState.suffix_plus_plus(); {\n            let tmp0 = posState;\n            c_memcpy_s!((lenEncoder.prices[tmp0] + (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()), num);\n        });\n    }\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451303250)\nerror: unexpected end of macro invocation\n    --> src/src/cmptlz_c.rs:3399:102\n     |\n3399 |             c_memcpy_s!((lenEncoder.prices[tmp0] + (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()), num);\n     |                                                                                                      ^ missing tokens in macro arguments\n     |\n    ::: src/translation_utils/c_alignment/libraries/safelib/c_memcpy_s.rs:34:1\n     |\n34   | macro_rules! c_memcpy_s {\n     | ----------------------- when calling this macro\n     |\nnote: while trying to match `,`\n    --> src/translation_utils/c_alignment/libraries/safelib/c_memcpy_s.rs:35:31\n     |\n35   |     ($dst:expr, $dst_size:expr, $src:expr, $count:expr) => {\n     |                               ^\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3364:25\n     |\n3364 |     let mut prob: u32 = lenEncoder.low[0];\n     |                   ---   ^^^^^^^^^^^^^^^^^ expected `u32`, found `u16`\n     |                   |\n     |                   expected due to this\n     |\nhelp: you can convert a `u16` to a `u32`\n     |\n3364 |     let mut prob: u32 = lenEncoder.low[0].into();\n     |                                          +++++++\n\nerror[E0369]: cannot add `u32` to `types::array::Array<u16, 256>`\n    --> src/src/cmptlz_c.rs:3373:58\n     |\n3373 |         let mut probs: Ptr<CmptlzProb> = (lenEncoder.low + (posState << (1 + CMPT_LEN_LOW_BITS!())));\n     |                                           -------------- ^ ---------------------------------------- u32\n     |                                           |\n     |                                           types::array::Array<u16, 256>\n     |\nnote: an implementation of `std::ops::Add<u32>` might be missing for `types::array::Array<u16, 256>`\n    --> src/translation_utils/types/array.rs:5:1\n     |\n5    | pub struct Array<T, const N: usize>(pub [T; N]);\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `std::ops::Add<u32>`\nnote: the trait `std::ops::Add` must be implemented\n    --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/ops/arith.rs:78:1\n\nerror[E0369]: cannot add `{integer}` to `types::array::Array<u32, 272>`\n    --> src/src/cmptlz_c.rs:3380:58\n     |\n3380 |         let mut prices: Ptr<u32> = (lenEncoder.prices[0] + (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!());\n     |                                     -------------------- ^ -------------------------------------------- {integer}\n     |                                     |\n     |                                     types::array::Array<u32, 272>\n     |\nnote: an implementation of `std::ops::Add<{integer}>` might be missing for `types::array::Array<u32, 272>`\n    --> src/translation_utils/types/array.rs:5:1\n     |\n5    | pub struct Array<T, const N: usize>(pub [T; N]);\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `std::ops::Add<{integer}>`\nnote: the trait `std::ops::Add` must be implemented\n    --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/ops/arith.rs:78:1\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3396:30\n     |\n3396 |         let mut num: usize = (lenEncoder.tableSize - (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) * c_sizeofval!(lenEncoder.prices[0][0]);\n     |                      -----   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u32`\n     |                      |\n     |                      expected due to this\n     |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n     |\n3396 |         let mut num: usize = ((lenEncoder.tableSize - (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) * c_sizeofval!(lenEncoder.prices[0][0])).try_into().unwrap();\n     |                              +                                                                                                             +++++++++++++++++++++\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 5 previous errors\n"
            },
            {
                "c_code": "uint32_t CmptPriceLongRep(CmptLzEncCtx *encCtx, uint32_t longRepIndex, CmptlzState state, uint32_t posState)\n{\n    uint32_t price = 0;\n    switch (longRepIndex)\n    {\n    case 0:\n        price =\n            CmptPriceBit0(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRep0Long[state][posState]);\n        break;\n    case 1:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit0(encCtx, encCtx->isRepG1[state]);\n        break;\n    case 2:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRepG1[state]) +\n                CmptPriceBit0(encCtx, encCtx->isRepG2[state]);\n        break;\n    case 3:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRepG1[state]) +\n                CmptPriceBit1(encCtx, encCtx->isRepG2[state]);\n        break;\n    default:\n        break;\n    }\n    return price;\n}",
                "rust_code": "pub fn CmptPriceLongRep(mut encCtx: Ptr<CmptLzEncCtx>, mut longRepIndex: u32, mut state: CmptlzState, mut posState: u32) -> u32 {\n    let mut price: u32 = 0;\n    c_switch!(longRepIndex, {\n        0 => {\n            let tmp0 = state;\n            price = (CmptPriceBit0(encCtx, encCtx.isRepG0[tmp0][posState]));\n            break;\n        },\n        1 => {\n            price = (CmptPriceBit1(encCtx, encCtx.isRepG0[state]) + CmptPriceBit0(encCtx, encCtx.isRepG1[state]));\n            break;\n        },\n        2 => {\n            price = (CmptPriceBit1(encCtx, encCtx.isRepG0[state]) + CmptPriceBit1(encCtx, encCtx.isRepG1[state]) + CmptPriceBit0(encCtx, encCtx.isRepG2[state]));\n            break;\n        },\n        3 => {\n            price = (CmptPriceBit1(encCtx, encCtx.isRepG0[state]) + CmptPriceBit1(encCtx, encCtx.isRepG1[state]) + CmptPriceBit1(encCtx, encCtx.isRepG2[state]));\n            break;\n        },\n        _ => {\n            break;\n        },\n    });\n    return price;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451313873)\nerror: no rules expected `,`\n    --> src/src/cmptlz_c.rs:3421:27\n     |\n3421 |     c_switch!(longRepIndex, {\n     |                           ^ no rules expected this token in macro call\n     |\n    ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n     |\n3    | macro_rules! c_switch {\n     | --------------------- when calling this macro\n     |\nnote: while trying to match `;`\n    --> src/translation_utils/c_alignment/c_switch.rs:5:17\n     |\n5    |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n     |                 ^\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "static int CmptRcLitAfterMatch(CmptRcCtx *rcCtx, CmptlzProb *prob, uint32_t sym, uint32_t matchByte)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = rcCtx->range, offs = 0x100, bit0Prob, newBound, curBit;\n    for (sym |= 0x100; sym < 0x10000;)\n    {\n        matchByte <<= 1;\n        CmptlzProb *litProbTableIndex = prob + (offs + (matchByte & offs) + (sym >> 8));\n        curBit = (sym >> 7) & 1;\n        sym <<= 1;\n        offs &= ~(matchByte ^ sym);\n        CMPT_RC_BIT_PROCESS(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    rcCtx->range = range;\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptRcLitAfterMatch(mut rcCtx: Ptr<CmptRcCtx>, mut prob: Ptr<CmptlzProb>, mut sym: u32, mut matchByte: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut range: u32 = rcCtx.range;\n    let mut offs: u32 = 0x100;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    let mut curBit: u32;\n    c_for!(sym |= 0x100; sym < 0x10000; {\n        matchByte <<= 1;\n        let mut litProbTableIndex: Ptr<CmptlzProb> = (prob + (offs + (matchByte & offs) + (sym >> 8)));\n        curBit = (sym >> 7) & 1;\n        sym <<= 1;\n        offs &= !(matchByte ^ sym);\n        CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    });\n    rcCtx.range = range;\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451324402)\nerror: unexpected end of macro invocation\n    --> src/src/cmptlz_c.rs:3493:6\n     |\n3493 |     });\n     |      ^ missing tokens in macro arguments\n     |\n    ::: src/translation_utils/c_alignment/c_for.rs:3:1\n     |\n3    | macro_rules! c_for {\n     | ------------------ when calling this macro\n     |\nnote: while trying to match `;`\n    --> src/translation_utils/c_alignment/c_for.rs:13:53\n     |\n13   |     ($($init: stmt),+; $cond: expr; $($step: expr),+; $body: block) => {\n     |                                                     ^\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "int CmptRcPrepare(CmptLzEncCtx *encCtx, uint8_t *dest, size_t *destLen, CmptLzMemHook *alloc)\n{\n    CmptRcCtx *rc = alloc->CmptLzAlloc(CMPTLZ_RC_CCTX_HANDLE, sizeof(CmptRcCtx));\n    if (rc == NULL)\n    {\n        return CMPT_ENC_RC_INIT_FAIL;\n    }\n    memset_s(rc, sizeof(CmptRcCtx), 0, sizeof(CmptRcCtx));\n    encCtx->rcCtx = rc;\n    rc->bufBase = alloc->CmptLzAlloc(CMPTLZ_RC_BUF_HANDLE, CMPTLZ_RC_BUFFER_SIZE);\n    memset_s(rc->bufBase, CMPTLZ_RC_BUFFER_SIZE, 0, CMPTLZ_RC_BUFFER_SIZE);\n    if (rc->bufBase == NULL)\n    {\n        return CMPT_ENC_RC_INIT_FAIL;\n    }\n    rc->outBufLeft = *destLen;\n    rc->outBuf = dest;\n    rc->buf = rc->bufBase;\n    rc->range = 0xFFFFFFFF;\n    rc->cacheSize = 0;\n    rc->cache = 0;\n    rc->low = 0;\n    return 0;\n}",
                "rust_code": "pub fn CmptRcPrepare(mut encCtx: Ptr<CmptLzEncCtx>, mut dest: Ptr<u8>, mut destLen: Ptr<usize>, mut alloc: Ptr<CmptLzMemHook>) -> i32 {\n    let mut rc: Ptr<CmptRcCtx> = (alloc.CmptLzAlloc)(CMPTLZ_RC_CCTX_HANDLE!(), c_sizeof!(CmptRcCtx));\n    if (rc == NULL!()) {\n        return CMPT_ENC_RC_INIT_FAIL!();\n    }\n    c_memset_s!(rc, c_sizeof!(CmptRcCtx), 0, c_sizeof!(CmptRcCtx)).cast::<Void>();\n    encCtx.rcCtx = rc;\n    rc.bufBase = (alloc.CmptLzAlloc)(CMPTLZ_RC_BUF_HANDLE!(), CMPTLZ_RC_BUFFER_SIZE!());\n    c_memset_s!(rc.bufBase, CMPTLZ_RC_BUFFER_SIZE!(), 0, CMPTLZ_RC_BUFFER_SIZE!()).cast::<Void>();\n    if (rc.bufBase == NULL!()) {\n        return CMPT_ENC_RC_INIT_FAIL!();\n    }\n    rc.outBufLeft = *destLen;\n    rc.outBuf = dest;\n    rc.buf = rc.bufBase;\n    rc.range = 0xFFFFFFFF;\n    rc.cacheSize = 0;\n    rc.cache = 0;\n    rc.low = 0;\n    return 0;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451324820)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3500:80\n     |\n3500 |     let mut rc: Ptr<CmptRcCtx> = (alloc.CmptLzAlloc)(CMPTLZ_RC_CCTX_HANDLE!(), c_sizeof!(CmptRcCtx));\n     |                                  -------------------                           ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `Num`\n     |                                  |\n     |                                  arguments to this function are incorrect\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3500:34\n     |\n3500 |     let mut rc: Ptr<CmptRcCtx> = (alloc.CmptLzAlloc)(CMPTLZ_RC_CCTX_HANDLE!(), c_sizeof!(CmptRcCtx));\n     |                 --------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ptr<CmptRcCtx>`, found `Ptr<u8>`\n     |                 |\n     |                 expected due to this\n     |\n     = note: expected struct `memory::ptr::Ptr<CmptRcCtx>`\n                found struct `memory::ptr::Ptr<u8>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "int CmptRcShiftLow(CmptRcCtx *rcCtx)\n{\n    int res = CMPT_OK;\n    uint32_t lowLow32 = (uint32_t)rcCtx->low;\n    uint64_t high = (uint32_t)(rcCtx->low >> 32);\n    rcCtx->low = (uint32_t)(lowLow32 << 8);\n    CMPT_RC_BREAK_CHECK(rcCtx, rcCtx->buf, res);\n    if (lowLow32 < 0xFF000000 || high != 0)\n    {\n        uint8_t *buf = rcCtx->buf;\n        *(buf) = (uint8_t)(rcCtx->cache + high);\n        buf++;\n        rcCtx->buf = buf;\n        rcCtx->cache = (uint8_t)(lowLow32 >> 24);\n        CMPT_RC_BREAK_SHIFTING(rcCtx, buf, res);\n        high += 0xFF;\n        while (1)\n        {\n            uint8_t *buf1 = rcCtx->buf;\n            CMPT_RC_BREAK_SHIFTING(rcCtx, buf1, res);\n            *(buf1++) = (uint8_t)(high);\n            rcCtx->buf = buf1;\n            rcCtx->cacheSize--;\n        }\n        CMPT_RC_BREAK_SHIFTING(rcCtx, buf, res);\n    }\n    else\n    {\n        rcCtx->cacheSize++;\n    }\n    return res;\n}",
                "rust_code": "pub fn CmptRcShiftLow(mut rcCtx: Ptr<CmptRcCtx>) -> i32 {\n    let mut res: i32 = CMPT_OK!();\n    let mut lowLow32: u32 = rcCtx.low.cast::<u32>();\n    let mut high: u64 = (rcCtx.low >> 32).cast::<u32>().cast::<u64>();\n    rcCtx.low = (lowLow32 << 8).cast();\n    CMPT_RC_BREAK_CHECK!(rcCtx, rcCtx.buf, res);\n    if (lowLow32 < 0xFF000000 || high != 0) {\n        let mut buf: Ptr<u8> = rcCtx.buf;\n        *buf = (rcCtx.cache + high).cast::<u8>();\n        buf += 1;\n        rcCtx.buf = buf;\n        rcCtx.cache = (lowLow32 >> 24).cast::<u8>();\n        CMPT_RC_BREAK_SHIFTING!(rcCtx, buf, res);\n        high += 0xFF;\n        loop {\n            let mut buf1: Ptr<u8> = rcCtx.buf;\n            CMPT_RC_BREAK_SHIFTING!(rcCtx, buf1, res);\n            *buf1 = high.cast::<u8>();\n            buf1 += 1;\n            rcCtx.buf = buf1;\n            rcCtx.cacheSize -= 1;\n        }\n        CMPT_RC_BREAK_SHIFTING!(rcCtx, buf, res);\n    } else {\n        rcCtx.cacheSize += 1;\n    }\n    return res;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451330399)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3544:23\n     |\n3544 |         rcCtx.cache = (lowLow32 >> 24).cast::<u8>();\n     |         -----------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `u8`\n     |         |\n     |         expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "int CmptRcFlushData(CmptRcCtx *rcCtx)\n{\n    int i;\n    int res;\n    for (i = 0; i < 5; i++)\n    {\n        res = CmptRcShiftLow(rcCtx);\n        if (res != CMPT_OK)\n        {\n            break;\n        }\n    }\n    return res;\n}",
                "rust_code": "pub fn CmptRcFlushData(mut rcCtx: Ptr<CmptRcCtx>) -> i32 {\n    let mut i: i32;\n    let mut res: i32;\n    c_for!(i = 0; i < 5; i.suffix_plus_plus(); {\n        res = CmptRcShiftLow(rcCtx);\n        if (res != CMPT_OK!()) {\n            break;\n        }\n    });\n    return res;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451330853)\nerror[E0381]: used binding `res` is possibly-uninitialized\n    --> src/src/cmptlz_c.rs:3571:12\n     |\n3564 |     let mut res: i32;\n     |         ------- binding declared here but left uninitialized\n3565 |     c_for!(i = 0; i < 5; i.suffix_plus_plus(); {\n3566 |         res = CmptRcShiftLow(rcCtx);\n     |         --------------------------- binding initialized here in some conditions\n...\n3571 |     return res;\n     |            ^^^ `res` used here but it is possibly-uninitialized\n\nFor more information about this error, try `rustc --explain E0381`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "int CmptRcPosSlotProcess(CmptLzEncCtx *encCtx, uint32_t posSlot, uint32_t len)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = encCtx->rcCtx->range;\n    uint32_t sym = posSlot + (1 << 6);\n    uint32_t bit0Prob, newBound;\n    uint32_t bit;\n    CmptlzProb *probs = encCtx->probDistSlot[GET_LEN_TO_POS_STATE(len)];\n    do\n    {\n        CmptlzProb *posSlotProbTableIndex = probs + (sym >> CMPTLZ_DIST_SLOT_BITS);\n        bit = (sym >> (CMPTLZ_DIST_SLOT_BITS - 1)) & 1;\n        sym <<= 1;\n        CMPT_RC_BIT_PROCESS(encCtx->rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    } while (sym < (1 << (CMPTLZ_DIST_SLOT_BITS * 2)));\n    encCtx->rcCtx->range = range;\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptRcPosSlotProcess(mut encCtx: Ptr<CmptLzEncCtx>, mut posSlot: u32, mut len: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut range: u32 = encCtx.rcCtx.range;\n    let mut sym: u32 = posSlot + (1 << 6);\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    let mut bit: u32;\n    let mut probs: Ptr<CmptlzProb> = encCtx.probDistSlot[GET_LEN_TO_POS_STATE!(len)];\n    c_do!({\n        let mut posSlotProbTableIndex: Ptr<CmptlzProb> = probs + (sym >> CMPTLZ_DIST_SLOT_BITS!());\n        bit = (sym >> (CMPTLZ_DIST_SLOT_BITS!() - 1)) & 1;\n        sym <<= 1;\n        CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    } while sym < (1 << (CMPTLZ_DIST_SLOT_BITS!() * 2)));\n    encCtx.rcCtx.range = range;\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451336486)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3624:38\n     |\n3624 |     let mut probs: Ptr<CmptlzProb> = encCtx.probDistSlot[GET_LEN_TO_POS_STATE!(len)];\n     |                    ---------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ptr<u16>`, found `Array<u16, 64>`\n     |                    |\n     |                    expected due to this\n     |\n     = note: expected struct `memory::ptr::Ptr<u16>`\n                found struct `types::array::Array<u16, 64>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "int CmptRcDistProcess(CmptLzEncCtx *encCtx, uint32_t posSlot, uint32_t dist)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t footerBits = ((posSlot >> 1) - 1);\n    if (dist < CMPT_DIST_LIMIT_2)\n    {\n        uint32_t base = ((2 | (posSlot & 1)) << footerBits);\n        shiftRes = CmptRcReverseProcess(encCtx->rcCtx, encCtx->probDistSpecial + base, footerBits, dist);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    else\n    {\n        uint32_t pos2 = (dist | 0xF) << (32 - footerBits);\n        uint32_t range = encCtx->rcCtx->range;\n        do\n        {\n            range >>= 1;\n            encCtx->rcCtx->low += range & (0 - (pos2 >> 31));\n            pos2 += pos2;\n            CMPT_RC_NORMALIZE(encCtx->rcCtx, range, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        } while (pos2 != 0xF0000000);\n        uint32_t m = 1;\n        uint32_t bit;\n        uint32_t bit0Prob, newBound;\n        int k;\n        for (k = 0; k < CMPTLZ_ALIGN_BITS - 1; k++)\n        {\n            bit = dist & 1;\n            dist >>= 1;\n            CMPT_RC_BIT_PROCESS(encCtx->rcCtx, encCtx->probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            m = (m << 1) + bit;\n        }\n        bit = dist & 1;\n        CMPT_RC_BIT_PROCESS(encCtx->rcCtx, encCtx->probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n    }\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptRcDistProcess(mut encCtx: Ptr<CmptLzEncCtx>, mut posSlot: u32, mut dist: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut footerBits: u32 = ((posSlot >> 1) - 1);\n    if (dist < CMPT_DIST_LIMIT_2!()) {\n        let mut base: u32 = ((2 | (posSlot & 1)) << footerBits);\n        shiftRes = CmptRcReverseProcess(encCtx.rcCtx, (encCtx.probDistSpecial + base), footerBits, dist);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    } else {\n        let mut pos2: u32 = (dist | 0xF) << (32 - footerBits);\n        let mut range: u32 = encCtx.rcCtx.range;\n        c_do!({\n            range >>= 1;\n            encCtx.rcCtx.low += range & (0 - (pos2 >> 31));\n            pos2 += pos2;\n            CMPT_RC_NORMALIZE!(encCtx.rcCtx, range, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n        } while pos2 != 0xF0000000);\n        let mut m: u32 = 1;\n        let mut bit: u32;\n        let mut bit0Prob: u32;\n        let mut newBound: u32;\n        let mut k: i32;\n        c_for!(k = 0; k < CMPTLZ_ALIGN_BITS!() - 1; k.suffix_plus_plus(); {\n            bit = (dist & 1);\n            dist >>= 1;\n            CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            m = (m << 1) + bit;\n        });\n        bit = (dist & 1);\n        CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n        encCtx.rcCtx.range = range;\n    }\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451341961)\nerror[E0369]: cannot add `u32` to `types::array::Array<u16, 128>`\n    --> src/src/cmptlz_c.rs:3666:79\n     |\n3666 |         shiftRes = CmptRcReverseProcess(encCtx.rcCtx, (encCtx.probDistSpecial + base), footerBits, dist);\n     |                                                        ---------------------- ^ ---- u32\n     |                                                        |\n     |                                                        types::array::Array<u16, 128>\n     |\nnote: an implementation of `std::ops::Add<u32>` might be missing for `types::array::Array<u16, 128>`\n    --> src/translation_utils/types/array.rs:5:1\n     |\n5    | pub struct Array<T, const N: usize>(pub [T; N]);\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `std::ops::Add<u32>`\nnote: the trait `std::ops::Add` must be implemented\n    --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/ops/arith.rs:78:1\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3673:33\n     |\n3673 |             encCtx.rcCtx.low += range & (0 - (pos2 >> 31));\n     |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:3673:30\n     |\n3673 |             encCtx.rcCtx.low += range & (0 - (pos2 >> 31));\n     |                              ^^ no implementation for `u64 += u32`\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n\nerror[E0369]: cannot add `u32` to `types::array::Array<u16, 16>`\n    --> src/src/cmptlz_c.rs:3686:65\n     |\n3686 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n     |                                                ---------------- ^ - u32\n     |                                                |\n     |                                                types::array::Array<u16, 16>\n     |\nnote: an implementation of `std::ops::Add<u32>` might be missing for `types::array::Array<u16, 16>`\n    --> src/translation_utils/types/array.rs:5:1\n     |\n5    | pub struct Array<T, const N: usize>(pub [T; N]);\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `std::ops::Add<u32>`\nnote: the trait `std::ops::Add` must be implemented\n    --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/ops/arith.rs:78:1\n\nerror[E0369]: cannot add `u32` to `types::array::Array<u16, 16>`\n    --> src/src/cmptlz_c.rs:3691:61\n     |\n3691 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n     |                                            ---------------- ^ - u32\n     |                                            |\n     |                                            types::array::Array<u16, 16>\n     |\nnote: an implementation of `std::ops::Add<u32>` might be missing for `types::array::Array<u16, 16>`\n    --> src/translation_utils/types/array.rs:5:1\n     |\n5    | pub struct Array<T, const N: usize>(pub [T; N]);\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `std::ops::Add<u32>`\nnote: the trait `std::ops::Add` must be implemented\n    --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/ops/arith.rs:78:1\n\nSome errors have detailed explanations: E0277, E0308, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 5 previous errors\n"
            },
            {
                "c_code": "static int CmptlzEncLit(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t nowpos32)\n{\n    int shiftRes = CMPT_OK;\n    CmptRcCtx *rc = encCtx->rcCtx;\n    uint32_t posState = nowpos32 & encCtx->pbMask;\n    uint32_t range, bit0Prob, newBound;\n    range = rc->range;\n    CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS(rc, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    rc->range = range;\n    CmptlzProb *litProb = &encCtx->litMarcov.literal[0][0];\n    const uint8_t curByte = mf->srcStart[mf->readPos - mf->readAhead];\n    probs = CMPT_LIT_PROB_GET(encCtx, litProb, nowpos32, mf->srcStart[mf->readPos - mf->readAhead - 1]);\n    CmptlzState state = encCtx->state;\n    CMPT_STATE_UPDATE_WHEN_LIT(encCtx->state);\n    if (state < 7)\n    {\n        shiftRes = CmptRcLitProcess(rc, probs, curByte);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    else\n    {\n        const uint8_t match_byte = mf->srcStart[mf->readPos - encCtx->reps[0] - 1 - mf->readAhead];\n        shiftRes = CmptRcLitAfterMatch(rc, probs, curByte, match_byte);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptlzEncLit(mut encCtx: Ptr<CmptLzEncCtx>, mut mf: Ptr<CmptMfCtx>, mut nowpos32: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut rc: Ptr<CmptRcCtx> = encCtx.rcCtx;\n    let mut posState: u32 = (nowpos32 & encCtx.pbMask);\n    let mut range: u32;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    range = rc.range;\n    let tmp0 = encCtx.state;\n    let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[tmp0][posState]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    rc.range = range;\n    let mut litProb: Ptr<CmptlzProb> = c_ref!(encCtx.litMarcov.literal[0][0]);\n    let mut curByte: u8 = mf.srcStart[mf.readPos - mf.readAhead];\n    probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1]);\n    let mut state: CmptlzState = encCtx.state;\n    CMPT_STATE_UPDATE_WHEN_LIT!(encCtx.state);\n    if (state < 7) {\n        shiftRes = CmptRcLitProcess(rc, probs, curByte.cast());\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    } else {\n        let mut match_byte: u8 = mf.srcStart[mf.readPos - encCtx.reps[0] - 1 - mf.readAhead];\n        shiftRes = CmptRcLitAfterMatch(rc, probs, curByte.cast(), match_byte.cast());\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    }\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451342397)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3704:41\n     |\n3704 |     let mut posState: u32 = (nowpos32 & encCtx.pbMask);\n     |                                         ^^^^^^^^^^^^^ expected `u32`, found `u64`\n\nerror[E0277]: no implementation for `u32 & u64`\n    --> src/src/cmptlz_c.rs:3704:39\n     |\n3704 |     let mut posState: u32 = (nowpos32 & encCtx.pbMask);\n     |                                       ^ no implementation for `u32 & u64`\n     |\n     = help: the trait `BitAnd<u64>` is not implemented for `u32`\n     = help: the following other types implement trait `BitAnd<Rhs>`:\n               `&u32` implements `BitAnd<u32>`\n               `&u32` implements `BitAnd`\n               `u32` implements `BitAnd<&u32>`\n               `u32` implements `BitAnd`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "static int CmptlzEncShortRep(CmptLzEncCtx *encCtx, uint32_t nowpos32)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t posState = nowpos32 & encCtx->pbMask;\n    uint32_t range, bit0Prob, newBound;\n    range = encCtx->rcCtx->range;\n    CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRep[encCtx->state];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRepG0[encCtx->state];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRep0Long[encCtx->state][posState];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    encCtx->rcCtx->range = range;\n    CmptlzState state = encCtx->state;\n    encCtx->state = CMPT_STATE_UPDATE_WHEN_SHORTREP(state);\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptlzEncShortRep(mut encCtx: Ptr<CmptLzEncCtx>, mut nowpos32: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut posState: u32 = nowpos32 & encCtx.pbMask;\n    let mut range: u32;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    range = encCtx.rcCtx.range;\n    let tmp0 = encCtx.state;\n    let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[tmp0][posState]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    probs = c_ref!(encCtx.isRep[encCtx.state]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    probs = c_ref!(encCtx.isRepG0[encCtx.state]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    probs = c_ref!(encCtx.isRep0Long[encCtx.state][posState]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    encCtx.rcCtx.range = range;\n    let mut state: CmptlzState = encCtx.state;\n    encCtx.state = CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451342856)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3733:40\n     |\n3733 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n     |                                        ^^^^^^^^^^^^^ expected `u32`, found `u64`\n\nerror[E0277]: no implementation for `u32 & u64`\n    --> src/src/cmptlz_c.rs:3733:38\n     |\n3733 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n     |                                      ^ no implementation for `u32 & u64`\n     |\n     = help: the trait `BitAnd<u64>` is not implemented for `u32`\n     = help: the following other types implement trait `BitAnd<Rhs>`:\n               `&u32` implements `BitAnd<u32>`\n               `&u32` implements `BitAnd`\n               `u32` implements `BitAnd<&u32>`\n               `u32` implements `BitAnd`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "static int CmptlzEncNormalMatch(CmptLzEncCtx *encCtx, uint32_t nowpos32, uint32_t backRes, uint32_t lenRes)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t posState = nowpos32 & encCtx->pbMask;\n    uint32_t range, bit0Prob, newBound;\n    range = encCtx->rcCtx->range;\n    CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRep[encCtx->state];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    encCtx->rcCtx->range = range;\n    CmptlzState state = encCtx->state;\n    encCtx->state = CMPT_STATE_UPDATE_WHEN_MATCH(state);\n    shiftRes = CmptRcLenProcess(&encCtx->matchLenEncoder, encCtx->rcCtx, lenRes, posState);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    backRes -= CMPTLZ_NUM_REPS;\n    encCtx->reps[3] = encCtx->reps[2];\n    encCtx->reps[2] = encCtx->reps[1];\n    encCtx->reps[1] = encCtx->reps[0];\n    encCtx->reps[0] = backRes;\n    encCtx->matchPriceCount++;\n    uint32_t posSlot = PosSloter(backRes);\n    shiftRes = CmptRcPosSlotProcess(encCtx, posSlot, lenRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    if (backRes >= 4)\n    {\n        shiftRes = CmptRcDistProcess(encCtx, posSlot, backRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptlzEncNormalMatch(mut encCtx: Ptr<CmptLzEncCtx>, mut nowpos32: u32, mut backRes: u32, mut lenRes: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut posState: u32 = (nowpos32 & encCtx.pbMask);\n    let mut range: u32;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    range = encCtx.rcCtx.range;\n    let tmp0 = encCtx.state;\n    let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[tmp0][posState]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    probs = c_ref!(encCtx.isRep[encCtx.state]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    encCtx.rcCtx.range = range;\n    let mut state: CmptlzState = encCtx.state;\n    encCtx.state = CMPT_STATE_UPDATE_WHEN_MATCH!(state);\n    shiftRes = CmptRcLenProcess(c_ref!(encCtx.matchLenEncoder), encCtx.rcCtx, lenRes, posState.cast());\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    backRes -= CMPTLZ_NUM_REPS!();\n    encCtx.reps[3] = encCtx.reps[2];\n    encCtx.reps[2] = encCtx.reps[1];\n    encCtx.reps[1] = encCtx.reps[0];\n    encCtx.reps[0] = backRes;\n    encCtx.matchPriceCount += 1;\n    let mut posSlot: u32 = PosSloter(backRes);\n    shiftRes = CmptRcPosSlotProcess(encCtx, posSlot, lenRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    if (backRes >= 4) {\n        shiftRes = CmptRcDistProcess(encCtx, posSlot, backRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    }\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451343302)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3766:41\n     |\n3766 |     let mut posState: u32 = (nowpos32 & encCtx.pbMask);\n     |                                         ^^^^^^^^^^^^^ expected `u32`, found `u64`\n\nerror[E0277]: no implementation for `u32 & u64`\n    --> src/src/cmptlz_c.rs:3766:39\n     |\n3766 |     let mut posState: u32 = (nowpos32 & encCtx.pbMask);\n     |                                       ^ no implementation for `u32 & u64`\n     |\n     = help: the trait `BitAnd<u64>` is not implemented for `u32`\n     = help: the following other types implement trait `BitAnd<Rhs>`:\n               `&u32` implements `BitAnd<u32>`\n               `&u32` implements `BitAnd`\n               `u32` implements `BitAnd<&u32>`\n               `u32` implements `BitAnd`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "static int CmptlzEncLongRep(CmptLzEncCtx *encCtx, uint32_t repIndex, uint32_t nowpos32, uint32_t lenRes)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t posState = nowpos32 & encCtx->pbMask;\n    uint32_t range, bit0Prob, newBound;\n    uint32_t realDist;\n    range = encCtx->rcCtx->range;\n    CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRep[encCtx->state];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRepG0[encCtx->state];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    switch (repIndex)\n    {\n    case 0:\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRep0Long[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1(encCtx->rcCtx, probs, newBound, range, bit0Prob);\n        break;\n    case 1:\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRepG1[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0(probs, newBound, range, bit0Prob);\n        realDist = encCtx->reps[1];\n        encCtx->reps[1] = encCtx->reps[0];\n        encCtx->reps[0] = realDist;\n        break;\n    case 2:\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRepG1[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRepG2[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0(probs, newBound, range, bit0Prob);\n        realDist = encCtx->reps[2];\n        encCtx->reps[2] = encCtx->reps[1];\n        encCtx->reps[1] = encCtx->reps[0];\n        encCtx->reps[0] = realDist;\n        break;\n    case 3:\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRepG1[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRepG2[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1(encCtx->rcCtx, probs, newBound, range, bit0Prob);\n        realDist = encCtx->reps[3];\n        encCtx->reps[3] = encCtx->reps[2];\n        encCtx->reps[2] = encCtx->reps[1];\n        encCtx->reps[1] = encCtx->reps[0];\n        encCtx->reps[0] = realDist;\n        break;\n    default:\n        break;\n    }\n    CMPT_RC_NORMALIZE(encCtx->rcCtx, range, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    encCtx->rcCtx->range = range;\n    shiftRes = CmptRcLenProcess(&encCtx->repLenEncoder, encCtx->rcCtx, lenRes, posState);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    --encCtx->repLenPriceCount;\n    CmptlzState state = encCtx->state;\n    encCtx->state = CMPT_STATE_UPDATE_WHEN_LONGREP(state);\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptlzEncLongRep(mut encCtx: Ptr<CmptLzEncCtx>, mut repIndex: u32, mut nowpos32: u32, mut lenRes: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut posState: u32 = nowpos32 & encCtx.pbMask;\n    let mut range: u32;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    let mut realDist: u32;\n    range = encCtx.rcCtx.range;\n    let tmp0 = encCtx.state;\n    let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[tmp0][posState]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    probs = c_ref!(encCtx.isRep[encCtx.state]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    probs = c_ref!(encCtx.isRepG0[encCtx.state]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    c_switch!(repIndex, {\n        0 => {\n            CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRep0Long[encCtx.state][posState]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1!(encCtx.rcCtx, probs, newBound, range, bit0Prob);\n            break;\n        },\n        1 => {\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRepG1[encCtx.state]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0!(probs, newBound, range, bit0Prob);\n            realDist = encCtx.reps[1];\n            encCtx.reps[1] = encCtx.reps[0];\n            encCtx.reps[0] = realDist;\n            break;\n        },\n        2 => {\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRepG1[encCtx.state]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRepG2[encCtx.state]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0!(probs, newBound, range, bit0Prob);\n            realDist = encCtx.reps[2];\n            encCtx.reps[2] = encCtx.reps[1];\n            encCtx.reps[1] = encCtx.reps[0];\n            encCtx.reps[0] = realDist;\n            break;\n        },\n        3 => {\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRepG1[encCtx.state]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRepG2[encCtx.state]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1!(encCtx.rcCtx, probs, newBound, range, bit0Prob);\n            realDist = encCtx.reps[3];\n            encCtx.reps[3] = encCtx.reps[2];\n            encCtx.reps[2] = encCtx.reps[1];\n            encCtx.reps[1] = encCtx.reps[0];\n            encCtx.reps[0] = realDist;\n            break;\n        },\n        _ => {\n            break;\n        },\n    });\n    CMPT_RC_NORMALIZE!(encCtx.rcCtx, range, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    encCtx.rcCtx.range = range;\n    shiftRes = CmptRcLenProcess(c_ref!(encCtx.repLenEncoder), encCtx.rcCtx, lenRes, posState.cast());\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    encCtx.repLenPriceCount -= 1;\n    let mut state: CmptlzState = encCtx.state;\n    encCtx.state = CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451343747)\nerror: no rules expected `,`\n    --> src/src/cmptlz_c.rs:3821:23\n     |\n3821 |     c_switch!(repIndex, {\n     |                       ^ no rules expected this token in macro call\n     |\n    ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n     |\n3    | macro_rules! c_switch {\n     | --------------------- when calling this macro\n     |\nnote: while trying to match `;`\n    --> src/translation_utils/c_alignment/c_switch.rs:5:17\n     |\n5    |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n     |                 ^\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3804:40\n     |\n3804 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n     |                                        ^^^^^^^^^^^^^ expected `u32`, found `u64`\n\nerror[E0277]: no implementation for `u32 & u64`\n    --> src/src/cmptlz_c.rs:3804:38\n     |\n3804 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n     |                                      ^ no implementation for `u32 & u64`\n     |\n     = help: the trait `BitAnd<u64>` is not implemented for `u32`\n     = help: the following other types implement trait `BitAnd<Rhs>`:\n               `&u32` implements `BitAnd<u32>`\n               `&u32` implements `BitAnd`\n               `u32` implements `BitAnd<&u32>`\n               `u32` implements `BitAnd`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 3 previous errors\n"
            },
            {
                "c_code": "void CmptlzFreeAll(CmptLzEncCtx *encCtx, CmptLzMemHook *alloc)\n{\n    if (encCtx == NULL)\n    {\n        return;\n    }\n    if (encCtx->mfCtx != NULL)\n    {\n        if (encCtx->mfCtx->hash != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_MF_HASH_HANDLE, encCtx->mfCtx->hash);\n            encCtx->mfCtx->hash = NULL;\n        }\n        if (encCtx->mfCtx->son != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_MF_SON_HANDLE, encCtx->mfCtx->son);\n            encCtx->mfCtx->son = NULL;\n        }\n        alloc->CmptLzFree(CMPTLZ_MF_CCTX_HANDLE, encCtx->mfCtx);\n        encCtx->mfCtx = NULL;\n    }\n    if (encCtx->rcCtx != NULL)\n    {\n        if (encCtx->rcCtx->bufBase != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_RC_BUF_HANDLE, encCtx->rcCtx->bufBase);\n            encCtx->rcCtx->bufBase = NULL;\n        }\n        alloc->CmptLzFree(CMPTLZ_RC_CCTX_HANDLE, encCtx->rcCtx);\n        encCtx->rcCtx = NULL;\n    }\n    alloc->CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE, encCtx);\n    encCtx = NULL;\n}",
                "rust_code": "pub fn CmptlzFreeAll(mut encCtx: Ptr<CmptLzEncCtx>, mut alloc: Ptr<CmptLzMemHook>) {\n    if (encCtx == NULL!()) {\n        return;\n    }\n    if (encCtx.mfCtx != NULL!()) {\n        if (encCtx.mfCtx.hash != NULL!()) {\n            alloc.CmptLzFree(CMPTLZ_MF_HASH_HANDLE!(), encCtx.mfCtx.hash);\n            encCtx.mfCtx.hash = NULL!();\n        }\n        if (encCtx.mfCtx.son != NULL!()) {\n            alloc.CmptLzFree(CMPTLZ_MF_SON_HANDLE!(), encCtx.mfCtx.son);\n            encCtx.mfCtx.son = NULL!();\n        }\n        alloc.CmptLzFree(CMPTLZ_MF_CCTX_HANDLE!(), encCtx.mfCtx);\n        encCtx.mfCtx = NULL!();\n    }\n    if (encCtx.rcCtx != NULL!()) {\n        if (encCtx.rcCtx.bufBase != NULL!()) {\n            alloc.CmptLzFree(CMPTLZ_RC_BUF_HANDLE!(), encCtx.rcCtx.bufBase);\n            encCtx.rcCtx.bufBase = NULL!();\n        }\n        alloc.CmptLzFree(CMPTLZ_RC_CCTX_HANDLE!(), encCtx.rcCtx);\n        encCtx.rcCtx = NULL!();\n    }\n    alloc.CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx);\n    encCtx = NULL!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451344191)\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:3901:19\n     |\n3901 |             alloc.CmptLzFree(CMPTLZ_MF_HASH_HANDLE!(), encCtx.mfCtx.hash);\n     |                   ^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzFree` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n     |\n3901 |             (alloc.CmptLzFree)(CMPTLZ_MF_HASH_HANDLE!(), encCtx.mfCtx.hash);\n     |             +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:3905:19\n     |\n3905 |             alloc.CmptLzFree(CMPTLZ_MF_SON_HANDLE!(), encCtx.mfCtx.son);\n     |                   ^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzFree` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n     |\n3905 |             (alloc.CmptLzFree)(CMPTLZ_MF_SON_HANDLE!(), encCtx.mfCtx.son);\n     |             +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:3908:15\n     |\n3908 |         alloc.CmptLzFree(CMPTLZ_MF_CCTX_HANDLE!(), encCtx.mfCtx);\n     |               ^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzFree` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n     |\n3908 |         (alloc.CmptLzFree)(CMPTLZ_MF_CCTX_HANDLE!(), encCtx.mfCtx);\n     |         +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:3913:19\n     |\n3913 |             alloc.CmptLzFree(CMPTLZ_RC_BUF_HANDLE!(), encCtx.rcCtx.bufBase);\n     |                   ^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzFree` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n     |\n3913 |             (alloc.CmptLzFree)(CMPTLZ_RC_BUF_HANDLE!(), encCtx.rcCtx.bufBase);\n     |             +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:3916:15\n     |\n3916 |         alloc.CmptLzFree(CMPTLZ_RC_CCTX_HANDLE!(), encCtx.rcCtx);\n     |               ^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzFree` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n     |\n3916 |         (alloc.CmptLzFree)(CMPTLZ_RC_CCTX_HANDLE!(), encCtx.rcCtx);\n     |         +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:3919:11\n     |\n3919 |     alloc.CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx);\n     |           ^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzFree` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n     |\n3919 |     (alloc.CmptLzFree)(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx);\n     |     +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_c::CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:3901:19\n     |\n3901 |             alloc.CmptLzFree(CMPTLZ_MF_HASH_HANDLE!(), encCtx.mfCtx.hash);\n     |                   ^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzFree` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n     |\n3901 |             (alloc.CmptLzFree)(CMPTLZ_MF_HASH_HANDLE!(), encCtx.mfCtx.hash);\n     |             +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_c::CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:3905:19\n     |\n3905 |             alloc.CmptLzFree(CMPTLZ_MF_SON_HANDLE!(), encCtx.mfCtx.son);\n     |                   ^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzFree` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n     |\n3905 |             (alloc.CmptLzFree)(CMPTLZ_MF_SON_HANDLE!(), encCtx.mfCtx.son);\n     |             +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_c::CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:3908:15\n     |\n3908 |         alloc.CmptLzFree(CMPTLZ_MF_CCTX_HANDLE!(), encCtx.mfCtx);\n     |               ^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzFree` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n     |\n3908 |         (alloc.CmptLzFree)(CMPTLZ_MF_CCTX_HANDLE!(), encCtx.mfCtx);\n     |         +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_c::CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:3913:19\n     |\n3913 |             alloc.CmptLzFree(CMPTLZ_RC_BUF_HANDLE!(), encCtx.rcCtx.bufBase);\n     |                   ^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzFree` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n     |\n3913 |             (alloc.CmptLzFree)(CMPTLZ_RC_BUF_HANDLE!(), encCtx.rcCtx.bufBase);\n     |             +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_c::CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:3916:15\n     |\n3916 |         alloc.CmptLzFree(CMPTLZ_RC_CCTX_HANDLE!(), encCtx.rcCtx);\n     |               ^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzFree` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n     |\n3916 |         (alloc.CmptLzFree)(CMPTLZ_RC_CCTX_HANDLE!(), encCtx.rcCtx);\n     |         +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_c::CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:3919:11\n     |\n3919 |     alloc.CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx);\n     |           ^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzFree` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n     |\n3919 |     (alloc.CmptLzFree)(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx);\n     |     +                +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 6 previous errors\n"
            },
            {
                "c_code": "int CmptlzEncodeIO(CmptLzEncCtx *encCtx, uint8_t *dest, size_t *destLen, const uint8_t *src, size_t srcLen,\n                   CmptLzMemHook *alloc)\n{\n    int res;\n    res = CmptMfPrepare(encCtx, src, srcLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptMfPrepare Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n    res = CmptRcPrepare(encCtx, dest, destLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptRcPrepare Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n    CmptlzEncPrepare(encCtx);\n    res = CmptEncodeAll(encCtx);\n    if (res != 0)\n    {\n        CmptlzFreeAll(encCtx, alloc);\n        CMPTLZ_LOG(res, \"CmptEncode Process Fail!\");\n        return res;\n    }\n    *destLen -= encCtx->rcCtx->outBufLeft;\n    if (encCtx->nowpos64 != srcLen)\n    {\n        CMPTLZ_LOG(res, \"CmptEncode FileSize Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return CMPT_ENC_ERROR_FILESIZE;\n    }\n    CmptlzFreeAll(encCtx, alloc);\n    return res;\n}",
                "rust_code": "pub fn CmptlzEncodeIO(mut encCtx: Ptr<CmptLzEncCtx>, mut dest: Ptr<u8>, mut destLen: Ptr<usize>, mut src: Ptr<u8>, mut srcLen: usize, mut alloc: Ptr<CmptLzMemHook>) -> i32 {\n    let mut res: i32;\n    res = CmptMfPrepare(encCtx, src, srcLen, alloc);\n    if (res != 0) {\n        CMPTLZ_LOG!(res, cstr!(\"CmptMfPrepare Fail!\"));\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n    res = CmptRcPrepare(encCtx, dest, destLen, alloc);\n    if (res != 0) {\n        CMPTLZ_LOG!(res, cstr!(\"CmptRcPrepare Fail!\"));\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n    CmptlzEncPrepare(encCtx);\n    res = CmptEncodeAll(encCtx);\n    if (res != 0) {\n        CmptlzFreeAll(encCtx, alloc);\n        CMPTLZ_LOG!(res, cstr!(\"CmptEncode Process Fail!\"));\n        return res;\n    }\n    *destLen -= encCtx.rcCtx.outBufLeft;\n    if (encCtx.nowpos64 != srcLen) {\n        CMPTLZ_LOG!(res, cstr!(\"CmptEncode FileSize Fail!\"));\n        CmptlzFreeAll(encCtx, alloc);\n        return CMPT_ENC_ERROR_FILESIZE!();\n    }\n    CmptlzFreeAll(encCtx, alloc);\n    return res;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451344639)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3945:28\n     |\n3945 |     if (encCtx.nowpos64 != srcLen) {\n     |         ---------------    ^^^^^^ expected `u64`, found `usize`\n     |         |\n     |         expected because this is `u64`\n     |\nhelp: you can convert a `usize` to a `u64` and panic if the converted value doesn't fit\n     |\n3945 |     if (encCtx.nowpos64 != srcLen.try_into().unwrap()) {\n     |                                  ++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "int CmptlzEncode(uint8_t *dest, size_t *destLen, const uint8_t *src, size_t srcLen, const CmptlzEncParam *props,\n                 uint8_t *propsEncoded, size_t *propsSize, int writeEndMark, CmptLzMemHook *alloc)\n{\n    int res;\n    if (alloc == NULL || alloc->CmptLzAlloc == NULL || alloc->CmptLzFree == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ENC_ERROR_PARAM, \"Cmptlz input wrong param!\");\n        return CMPT_ENC_ERROR_PARAM;\n    }\n    CmptLzEncCtx *encCtx = (CmptLzEncCtx *)CmptInitCctx(alloc, writeEndMark);\n    if (encCtx == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ENC_CTX_INIT_FAIL, \"CmptInitCctx Fail!\");\n        return CMPT_ENC_CTX_INIT_FAIL;\n    }\n    CmptlzSetParam(encCtx, props);\n    res = CmptHeadWrite(encCtx, propsEncoded, propsSize);\n    if (res != 0)\n    {\n        alloc->CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE, encCtx);\n        CMPTLZ_LOG(res, \"CmptHeadWrite Fail!\");\n        return res;\n    }\n    res = CmptlzEncodeIO(encCtx, dest, destLen, src, srcLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptlzEncode I / O Fail!\");\n    }\n    return res;\n}",
                "rust_code": "pub fn CmptlzEncode(mut dest: Ptr<u8>, mut destLen: Ptr<usize>, mut src: Ptr<u8>, mut srcLen: usize, mut props: Ptr<CmptlzEncParam>, mut propsEncoded: Ptr<u8>, mut propsSize: Ptr<usize>, mut writeEndMark: i32, mut alloc: Ptr<CmptLzMemHook>) -> i32 {\n    let mut res: i32;\n    if (alloc == NULL!()) || (alloc.CmptLzAlloc == NULL!()) || (alloc.CmptLzFree == NULL!()) {\n        CMPTLZ_LOG!(CMPT_ENC_ERROR_PARAM!(), cstr!(\"Cmptlz input wrong param!\"));\n        return CMPT_ENC_ERROR_PARAM!();\n    }\n    let mut encCtx: Ptr<CmptLzEncCtx> = CmptInitCctx(alloc, writeEndMark).cast::<Ptr<CmptLzEncCtx>>();\n    if (encCtx == NULL!()) {\n        CMPTLZ_LOG!(CMPT_ENC_CTX_INIT_FAIL!(), cstr!(\"CmptInitCctx Fail!\"));\n        return CMPT_ENC_CTX_INIT_FAIL!();\n    }\n    CmptlzSetParam(encCtx, props);\n    res = CmptHeadWrite(encCtx, propsEncoded, propsSize);\n    if (res != 0) {\n        alloc.CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx);\n        CMPTLZ_LOG!(res, cstr!(\"CmptHeadWrite Fail!\"));\n        return res;\n    }\n    res = CmptlzEncodeIO(encCtx, dest, destLen, src, srcLen, alloc);\n    if (res != 0) {\n        CMPTLZ_LOG!(res, cstr!(\"CmptlzEncode I / O Fail!\"));\n    }\n    return res;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750451345073)\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:3968:15\n     |\n3968 |         alloc.CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx);\n     |               ^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzFree` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n     |\n3968 |         (alloc.CmptLzFree)(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx);\n     |         +                +\n\nerror[E0599]: no method named `CmptLzFree` found for struct `memory::ptr::Ptr<cmptlz_c::CmptLzMemHook>` in the current scope\n    --> src/src/cmptlz_c.rs:3968:15\n     |\n3968 |         alloc.CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx);\n     |               ^^^^^^^^^^ field, not a method\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `CmptLzFree` not found for this struct\n     |\nhelp: to call the function pointer stored in `CmptLzFree`, surround the field access with parentheses\n     |\n3968 |         (alloc.CmptLzFree)(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx);\n     |         +                +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            }
        ]
    }
}