{
    "macro": {
        "all_cnt": 114,
        "passed_cnt": 114,
        "pass_rate": 1.0,
        "messages": []
    },
    "macro_function": {
        "all_cnt": 52,
        "passed_cnt": 31,
        "pass_rate": 0.5961538461538461,
        "messages": [
            {
                "c_code": "#define CMPTLZ_ERROR_CONVERT(x) (int32_t)((CMPTLZ_MODULE << 16) | (uint32_t)(x))",
                "rust_code": "macro_rules! CMPTLZ_ERROR_CONVERT { ($x:expr) => { ((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32 } }\npub(crate) use CMPTLZ_ERROR_CONVERT;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408443437)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:669:52\n     |\n669  | macro_rules! CMPTLZ_ERROR_CONVERT { ($x:expr) => { ((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32 } }\n     |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n1546 | pub fn CmptLzDecByDistAndLen(mut decCtx: Ptr<CmptLzDecCtx>, mut matchDist: usize, mut matchLen: u32, mut dicPosLimit: usize) -> u32 {\n     |                                                                                                                                 --- expected `u32` because of return type\n...\n1553 |         return CMPT_ERROR_DATA!();\n     |                ------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_ERROR_CONVERT` which comes from the expansion of the macro `CMPT_ERROR_DATA` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you can convert an `i32` to a `u32` and panic if the converted value doesn't fit\n     |\n669  | macro_rules! CMPTLZ_ERROR_CONVERT { ($x:expr) => { (((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32).try_into().unwrap() } }\n     |                                                    +                                               +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:669:52\n     |\n669  | ...TLZ_ERROR_CONVERT { ($x:expr) => { ((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32 } }\n     |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n1655 | ...chDec(mut decCtx: Ptr<CmptLzDecCtx>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut dicPosLimit: usize, mut posState: u32) -> u32 {\n     |                                                                                                                                                                  --- expected `u32` because of return type\n...\n1669 | ...rn CMPT_ERROR_DATA!();\n     |       ------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_ERROR_CONVERT` which comes from the expansion of the macro `CMPT_ERROR_DATA` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you can convert an `i32` to a `u32` and panic if the converted value doesn't fit\n     |\n669  | macro_rules! CMPTLZ_ERROR_CONVERT { ($x:expr) => { (((CMPTLZ_MODULE!() << 16) | ($x as u32)) as i32).try_into().unwrap() } }\n     |                                                    +                                               +++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "#define CMPTLZ_HANDLE_CONVERT(x) (int32_t)((CMPTLZ_MODULE << 16) | ((uint32_t)(x) << 8))",
                "rust_code": "macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\npub(crate) use CMPTLZ_HANDLE_CONVERT;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408443843)\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n1279 |         CmptLzDecMemFree(memHook, CMPTLZ_PROB_HANDLE!(), decCtx.probs.cast());\n     |                                   --------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_PROB_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n1287 |         decCtx.probs = CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE!(), (numProbs as u32 * c_sizeof!(CmptLzDecProb)).cast()).cast();\n     |                                                   --------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_PROB_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n1291 |             decCtx.probs = CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE!(), (numProbs as u32 * c_sizeof!(CmptLzDecProb)).cast()).cast();\n     |                                                       --------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_PROB_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n2902 |     let mut handle: VoidPtr = (alloc.CmptLzAlloc)(CMPTLZ_ENC_CCTX_HANDLE!(), c_sizeof!(CmptLzEncCtx).cast());\n     |                                                   ------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_ENC_CCTX_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n2986 |     let mut mf: Ptr<CmptMfCtx> = (alloc.CmptLzAlloc)(CMPTLZ_MF_CCTX_HANDLE!(), c_sizeof!(CmptMfCtx).cast()).cast();\n     |                                                      ------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_MF_CCTX_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3003 |     mf.hash = (alloc.CmptLzAlloc)(CMPTLZ_MF_HASH_HANDLE!(),(mf.hashCount as u32 * c_sizeof!(u32)).cast()).cast();\n     |                                   ------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_MF_HASH_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3008 |     mf.son = (alloc.CmptLzAlloc)(CMPTLZ_MF_SON_HANDLE!(), (mf.sonsCount as u32 * c_sizeof!(u32)).cast()).cast();\n     |                                  ----------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_MF_SON_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3501 |     let mut rc: Ptr<CmptRcCtx> = (alloc.CmptLzAlloc)(CMPTLZ_RC_CCTX_HANDLE!(), c_sizeof!(CmptRcCtx).cast()).cast();\n     |                                                      ------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_RC_CCTX_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3507 |     rc.bufBase = (alloc.CmptLzAlloc)(CMPTLZ_RC_BUF_HANDLE!(), CMPTLZ_RC_BUFFER_SIZE!());\n     |                                      ----------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_RC_BUF_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3902 |             (alloc.CmptLzFree)(CMPTLZ_MF_HASH_HANDLE!(), encCtx.mfCtx.hash.cast());\n     |                                ------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_MF_HASH_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3906 |             (alloc.CmptLzFree)(CMPTLZ_MF_SON_HANDLE!(), encCtx.mfCtx.son.cast());\n     |                                ----------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_MF_SON_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3909 |         (alloc.CmptLzFree)(CMPTLZ_MF_CCTX_HANDLE!(), encCtx.mfCtx.cast());\n     |                            ------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_MF_CCTX_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3914 |             (alloc.CmptLzFree)(CMPTLZ_RC_BUF_HANDLE!(), encCtx.rcCtx.bufBase.cast());\n     |                                ----------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_RC_BUF_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3917 |         (alloc.CmptLzFree)(CMPTLZ_RC_CCTX_HANDLE!(), encCtx.rcCtx.cast());\n     |                            ------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_RC_CCTX_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3920 |     (alloc.CmptLzFree)(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx.cast());\n     |                        ------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_ENC_CCTX_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: `<<` is interpreted as a start of generic arguments for `u32`, not a shift\n    --> src/src/cmptlz_c.rs:672:91\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | ($x as u32 << 8) as i32 } }\n     |                                                                                           ^^ - interpreted as generic arguments\n     |                                                                                           |\n     |                                                                                           not interpreted as shift\n...\n3970 |         (alloc.CmptLzFree)(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx.cast());\n     |                            ------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_HANDLE_CONVERT` which comes from the expansion of the macro `CMPTLZ_ENC_CCTX_HANDLE` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: try shifting the cast value\n     |\n672  | macro_rules! CMPTLZ_HANDLE_CONVERT { ($x:expr) => { (CMPTLZ_MODULE!() << 16) | (($x as u32) << 8) as i32 } }\n     |                                                                                 +         +\n\nerror: could not compile `my_proj` (lib) due to 16 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 16 previous errors\n"
            },
            {
                "c_code": "#define CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec)                                                             \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if ((range) < CMPTLZ_RANGE_DOWN_LIMIT)                                                                         \\\n        {                                                                                                              \\\n            (range) <<= CMPTLZ_ONE_BYTE_WIDTH;                                                                         \\\n            (rangeCode) <<= CMPTLZ_ONE_BYTE_WIDTH;                                                                     \\\n            (rangeCode) |= (*(bufToDec)++);                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
                "rust_code": "macro_rules! CMPTLZ_RANGE_NORMALIZE {\n    ($range:expr, $rangeCode:expr, $bufToDec:expr) => {\n        if $range < CMPTLZ_RANGE_DOWN_LIMIT!() {\n            $range <<= CMPTLZ_ONE_BYTE_WIDTH!();\n            $rangeCode <<= CMPTLZ_ONE_BYTE_WIDTH!();\n            $rangeCode |= $bufToDec.plus_plus();\n        }\n    }\n}\npub(crate) use CMPTLZ_RANGE_NORMALIZE;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408465099)\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1420 |         CMPTLZ_POSSLOT_BIT_DEC!(probPosSlot + posSlot, range, rangeCode, rangeBound, posSlot, bufToDec);\n     |         ----------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_POSSLOT_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1442 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |                 --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1447 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |                 --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1460 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1477 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1481 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |         --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1490 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |         --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1511 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |         --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1514 |             CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |             --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1519 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |         --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1523 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1526 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                 --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1530 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1533 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                 --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1602 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |         --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1606 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1615 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1620 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |         --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1624 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1628 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1632 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |                 --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1636 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |                 --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1711 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |             --------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1720 |             CMPTLZ_MATCH_BIT_DEC!(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n     |             ------------------------------------------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` which comes from the expansion of the macro `CMPTLZ_MATCH_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1751 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n     |         ----------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1754 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n     |             ----------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1758 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n     |             ----------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1762 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n     |                 ----------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= memory::ptr::Ptr<u8>`\n    --> src/src/cmptlz_c.rs:703:24\n     |\n703  |             $rangeCode |= $bufToDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= memory::ptr::Ptr<u8>`\n...\n1766 |                 CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, decCtx.buf);\n     |                 ----------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitOrAssign<memory::ptr::Ptr<u8>>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 29 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 29 previous errors\n"
            },
            {
                "c_code": "#define CMPTLZ_IS_THE_BIT_0(probSlot, range, rangeCode, rangeBound)                                                    \\\n    (rangeBound) = (range >> CMPTLZ_PROB_LG_BIT) * (*(probSlot));                                                      \\\n    if ((rangeCode) < (rangeBound))",
                "rust_code": "macro_rules! CMPTLZ_IS_THE_BIT_0 { ($probSlot:expr, $range:expr, $rangeCode:expr, $rangeBound:expr) =>\n    {\n        $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n        if $rangeCode < $rangeBound\n    }\n}\npub(crate) use CMPTLZ_IS_THE_BIT_0;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408465493)\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1438 |             if CMPTLZ_IS_THE_BIT_0!(probPosSlot + distDec, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------------------- caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1438 |             if CMPTLZ_IS_THE_BIT_0!(probPosSlot + distDec, range, rangeCode, rangeBound); {\n     |                                                                                         +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1507 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |        ----------------------------------------------------------- caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1507 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound); {\n     |                                                                   +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1519 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |            ----------------------------------------------------------- caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1519 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound); {\n     |                                                                       +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1598 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |        ------------------------------------------------------------ caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1598 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound); {\n     |                                                                    +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1602 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1602 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound); {\n     |                                                                        +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1620 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1620 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound); {\n     |                                                                        +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1628 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------ caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1628 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound); {\n     |                                                                            +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1750 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1750 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound); {\n     |                                                                        +\n\nerror: macro expansion ignores keyword `if` and any tokens following\n    --> src/src/cmptlz_c.rs:712:9\n     |\n712  |         if $rangeCode < $rangeBound\n     |         ^^\n...\n1758 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------ caused by the macro expansion here\n     |\n     = note: the usage of `CMPTLZ_IS_THE_BIT_0!` is likely invalid in expression context\nhelp: you might be missing a semicolon here\n     |\n1758 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound); {\n     |                                                                            +\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1438 |             if CMPTLZ_IS_THE_BIT_0!(probPosSlot + distDec, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1438 |             if CMPTLZ_IS_THE_BIT_0!(probPosSlot + distDec, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1438 |             if CMPTLZ_IS_THE_BIT_0!(probPosSlot + distDec, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1507 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |        ----------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1507 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |        ----------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1507 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |        ----------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1519 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |            ----------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1519 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |            ----------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1519 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |            ----------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1598 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |        ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1598 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |        ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1598 |     if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |        ------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1602 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1602 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1602 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1620 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1620 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1620 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1628 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1628 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1628 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1750 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1750 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1750 |         if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |            ------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:59\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1758 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:711:9\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n...\n1758 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: you might have meant to compare for equality\n     |\n711  |         $rangeBound == ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                      +\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:711:57\n     |\n711  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSlot);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1758 |             if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound) {\n     |                ------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_IS_THE_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 36 previous errors; 9 warnings emitted\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 36 previous errors; 9 warnings emitted\n"
            },
            {
                "c_code": "#define CMPTLZ_NORMAL_BIT_DEC(probLit, range, rangeCode, rangeBound, decSym)                                           \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probLit));                                                 \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_0(probLit, range, rangeBound);                                                         \\\n            (decSym) = ((decSym) << 1);                                                                                \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_1(probLit, range, rangeCode, rangeBound);                                              \\\n            (decSym) = ((decSym) << 1) + 1;                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
                "rust_code": "macro_rules! CMPTLZ_NORMAL_BIT_DEC {\n    ($probLit:expr, $range:expr, $rangeCode:expr, $rangeBound:expr, $decSym:expr) => {\n        $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n        if $rangeCode < $rangeBound {\n            CMPTLZ_RANGE_UPDATE_0!($probLit, $range, $rangeBound);\n            $decSym = $decSym << 1;\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!($probLit, $range, $rangeCode, $rangeBound);\n            $decSym = ($decSym << 1) + 1;\n        }\n    };\n}\npub(crate) use CMPTLZ_NORMAL_BIT_DEC;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408475594)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:738:59\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1418 |         CMPTLZ_POSSLOT_BIT_DEC!(probPosSlot + posSlot, range, rangeCode, rangeBound, posSlot, bufToDec);\n     |         ----------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_POSSLOT_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:738:57\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1418 |         CMPTLZ_POSSLOT_BIT_DEC!(probPosSlot + posSlot, range, rangeCode, rangeBound, posSlot, bufToDec);\n     |         ----------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_POSSLOT_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:738:59\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1512 |             CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |             --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:738:57\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1512 |             CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |             --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:738:59\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1524 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                 --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:738:57\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1524 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                 --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:738:59\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1531 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                 --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:738:57\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1531 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                 --------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` which comes from the expansion of the macro `CMPTLZ_LEN_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:738:59\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1708 |             CMPTLZ_NORMAL_BIT_DEC!(probSlot + decSym, range, rangeCode, rangeBound, decSym);\n     |             ------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:738:57\n     |\n738  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1708 |             CMPTLZ_NORMAL_BIT_DEC!(probSlot + decSym, range, rangeCode, rangeBound, decSym);\n     |             ------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_NORMAL_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 10 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 10 previous errors\n"
            },
            {
                "c_code": "#define CMPTLZ_MATCH_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec)          \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (matchSym) <<= 1;                                                                                              \\\n        (bit) = (offset);                                                                                              \\\n        (offset) &= (matchSym);                                                                                        \\\n        (probLit) = (probSlot) + ((offset) + (bit) + (decSym));                                                        \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probLit));                                                 \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_0(probLit, range, rangeBound);                                                         \\\n            (decSym) = ((decSym) << 1);                                                                                \\\n            (offset) ^= (bit);                                                                                         \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_1(probLit, range, rangeCode, rangeBound);                                              \\\n            (decSym) = ((decSym) << 1) + 1;                                                                            \\\n        }                                                                                                              \\\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);                                                            \\\n    } while (0)",
                "rust_code": "macro_rules! CMPTLZ_MATCH_BIT_DEC {\n    ($probSlot:expr, $range:expr, $rangeCode:expr, $rangeBound:expr, $decSym:expr, $matchSym:expr, $offset:expr, $bit:expr, $bufToDec:expr) => {\n        $matchSym <<= 1;\n        $bit = $offset;\n        $offset &= $matchSym;\n        $probLit = $probSlot + ($offset + $bit + $decSym);\n        $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probLit);\n        if $rangeCode < $rangeBound {\n            CMPTLZ_RANGE_UPDATE_0!($probLit, $range, $rangeBound);\n            $decSym = $decSym << 1;\n            $offset ^= $bit;\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!($probLit, $range, $rangeCode, $rangeBound);\n            $decSym = ($decSym << 1) + 1;\n        }\n        CMPTLZ_RANGE_NORMALIZE!($range, $rangeCode, $bufToDec);\n    };\n}\npub(crate) use CMPTLZ_MATCH_BIT_DEC;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408475996)\nerror: expected expression, found `$`\n    --> src/src/cmptlz_c.rs:757:9\n     |\n757  |         $probLit = $probSlot + ($offset + $bit + $decSym);\n     |         ^^^^^^^^ expected expression\n...\n1720 |             CMPTLZ_MATCH_BIT_DEC!(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n     |             ------------------------------------------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_MATCH_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "#define CMPTLZ_DIST_BIT_DEC(probDist, probSlot, range, rangeCode, rangeBound, decDist, decBit)                         \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (probDist) = (probSlot) + (decDist);                                                                           \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probDist));                                                \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_0(probDist, range, rangeBound);                                                        \\\n            (decDist) += (decBit);                                                                                     \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_1(probDist, range, rangeCode, rangeBound);                                             \\\n            (decDist) += (decBit) * 2;                                                                                 \\\n        }                                                                                                              \\\n    } while (0)",
                "rust_code": "macro_rules! CMPTLZ_DIST_BIT_DEC {\n    ($probDist:expr, $probSlot:expr, $range:expr, $rangeCode:expr, $rangeBound:expr, $decDist:expr, $decBit:expr) => {\n        $probDist = $probSlot + $decDist;\n        $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probDist);\n        if $rangeCode < $rangeBound {\n            CMPTLZ_RANGE_UPDATE_0!($probDist, $range, $rangeBound);\n            $decDist += $decBit;\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!($probDist, $range, $rangeCode, $rangeBound);\n            $decDist += $decBit * 2;\n        }\n    };\n}\npub(crate) use CMPTLZ_DIST_BIT_DEC;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408476392)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:775:59\n     |\n775  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probDist);\n     |                                                           ^^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1476 |             CMPTLZ_DIST_BIT_DEC!(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n     |             ----------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_DIST_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:775:57\n     |\n775  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probDist);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1476 |             CMPTLZ_DIST_BIT_DEC!(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n     |             ----------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_DIST_BIT_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "#define CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit)                                              \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if ((range) < CMPTLZ_RANGE_DOWN_LIMIT)                                                                         \\\n        {                                                                                                              \\\n            if ((bufTryDec) >= (bufLimit))                                                                             \\\n            {                                                                                                          \\\n                return CMPTLZ_DEC_INPUT_EOF;                                                                           \\\n            }                                                                                                          \\\n            (range) <<= CMPTLZ_ONE_BYTE_WIDTH;                                                                         \\\n            (rangeCode) <<= CMPTLZ_ONE_BYTE_WIDTH;                                                                     \\\n            (rangeCode) |= (*(bufTryDec)++);                                                                           \\\n        }                                                                                                              \\\n    } while (0)",
                "rust_code": "macro_rules! CMPTLZ_RANGE_TRY_NORMALIZE { ($range:expr, $rangeCode:expr, $bufTryDec:expr, $bufLimit:expr) =>\n    {\n        if $range < CMPTLZ_RANGE_DOWN_LIMIT!()\n        {\n            if $bufTryDec >= $bufLimit\n            {\n                return CMPTLZ_DEC_INPUT_EOF!();\n            }\n            $range <<= CMPTLZ_ONE_BYTE_WIDTH!();\n            $rangeCode <<= CMPTLZ_ONE_BYTE_WIDTH!();\n            $rangeCode |= *$bufTryDec.plus_plus();\n        }\n    }\n}\npub(crate) use CMPTLZ_RANGE_TRY_NORMALIZE;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408497433)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1793 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1793 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1803 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1803 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1818 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1818 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1823 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1823 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1839 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1839 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1852 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |                 ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1852 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |                 ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1866 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1866 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1884 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1884 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1912 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1912 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1927 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1927 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1933 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1933 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1954 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1954 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1958 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1958 |     CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |     ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1970 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1970 |         CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |         ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1975 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1975 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1980 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |                 ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1980 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |                 ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1988 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1988 |             CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |             ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:834:27\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n...\n1995 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |                 ------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 |= u8`\n    --> src/src/cmptlz_c.rs:834:24\n     |\n834  |             $rangeCode |= *$bufTryDec.plus_plus();\n     |                        ^^ no implementation for `u32 |= u8`\n...\n1995 |                 CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n     |                 ------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitOrAssign<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitOrAssign<Rhs>`:\n               `u32` implements `BitOrAssign<&u32>`\n               `u32` implements `BitOrAssign`\n     = note: this error originates in the macro `CMPTLZ_RANGE_TRY_NORMALIZE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 36 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 36 previous errors\n"
            },
            {
                "c_code": "#define CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probSym)                                       \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probSym));                                                 \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);                                                     \\\n            (decSym) = ((decSym) << 1);                                                                                \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);                                          \\\n            (decSym) = ((decSym) << 1) + 1;                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
                "rust_code": "macro_rules! CMPTLZ_SINGLE_BIT_TRY_DEC {\n    ($range:expr, $rangeCode:expr, $rangeBound:expr, $decSym:expr, $probSym:expr) => {\n        $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n        if $rangeCode < $rangeBound {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!($range, $rangeBound);\n            $decSym = $decSym << 1;\n        } else {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!($range, $rangeCode, $rangeBound);\n            $decSym = ($decSym << 1) + 1;\n        }\n    };\n}\npub(crate) use CMPTLZ_SINGLE_BIT_TRY_DEC;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408497829)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:841:59\n     |\n841  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n     |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1819 |         CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n     |         ------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:841:57\n     |\n841  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1819 |         CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n     |         ------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:841:59\n     |\n841  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n     |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1835 |         CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n     |         ------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:841:57\n     |\n841  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1835 |         CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n     |         ------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:841:59\n     |\n841  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n     |                                                           ^^^^^^^^^^^ expected `u32`, found `u16`\n...\n1908 |             CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n     |             ------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot multiply `u32` by `u16`\n    --> src/src/cmptlz_c.rs:841:57\n     |\n841  |         $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n     |                                                         ^ no implementation for `u32 * u16`\n...\n1908 |             CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n     |             ------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::Mul<u16>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Mul<Rhs>`:\n               `&u32` implements `std::ops::Mul<u32>`\n               `&u32` implements `std::ops::Mul`\n               `u32` implements `std::ops::Mul<&u32>`\n               `u32` implements `std::ops::Mul<Duration>`\n               `u32` implements `std::ops::Mul<types::num::Num>`\n               `u32` implements `std::ops::Mul`\n     = note: this error originates in the macro `CMPTLZ_SINGLE_BIT_TRY_DEC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 6 previous errors\n"
            },
            {
                "c_code": "#define CMPTLZ_MATCH_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probSym)                                        \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probSym));                                                 \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);                                                     \\\n            (decSym) = ((decSym) << 1);                                                                                \\\n            (offset) ^= (bit);                                                                                         \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);                                          \\\n            (decSym) = ((decSym) << 1) + 1;                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
                "rust_code": "macro_rules! CMPTLZ_MATCH_BIT_TRY_DEC {\n    ($range:expr, $rangeCode:expr, $rangeBound:expr, $decSym:expr, $probSym:expr) => {\n        $rangeBound = ($range >> CMPTLZ_PROB_LG_BIT!()) * (*$probSym);\n        if $rangeCode < $rangeBound {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0!($range, $rangeBound);\n            $decSym = $decSym << 1;\n            $offset ^= $bit;\n        } else {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1!($range, $rangeCode, $rangeBound);\n            $decSym = ($decSym << 1) + 1;\n        }\n    };\n}\npub(crate) use CMPTLZ_MATCH_BIT_TRY_DEC;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408498223)\nerror: no rules expected `,`\n    --> src/src/cmptlz_c.rs:1923:84\n     |\n855  | macro_rules! CMPTLZ_MATCH_BIT_TRY_DEC {\n     | ------------------------------------- when calling this macro\n...\n1923 |             CMPTLZ_MATCH_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit, offset, bit);\n     |                                                                                    ^ no rules expected this token in macro call\n     |\nnote: while trying to match meta-variable `$probSym:expr`\n    --> src/src/cmptlz_c.rs:856:68\n     |\n856  |     ($range:expr, $rangeCode:expr, $rangeBound:expr, $decSym:expr, $probSym:expr) => {\n     |                                                                    ^^^^^^^^^^^^^\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "#define CMPT_STATE_UPDATE_WHEN_LIT(state)                                                                              \\\n    (state) = (((state) <= SHORTREP_LIT_LIT) ? LIT_LIT : (((state) <= LIT_SHORTREP) ? (state) - 3 : (state) - 6))",
                "rust_code": "macro_rules! CMPT_STATE_UPDATE_WHEN_LIT { ($state:expr) => \n    {\n        $state = if $state <= SHORTREP_LIT_LIT {\n            LIT_LIT\n        } else if $state <= LIT_SHORTREP {\n            $state - 3\n        } else {\n            $state - 6\n        }\n    }\n}\npub(crate) use CMPT_STATE_UPDATE_WHEN_LIT;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408533724)\nerror[E0423]: expected value, found macro `SHORTREP_LIT_LIT`\n    --> src/src/cmptlz_c.rs:935:31\n     |\n935  |         $state = if $state <= SHORTREP_LIT_LIT {\n     |                               ^^^^^^^^^^^^^^^^ not a value\n...\n2570 |             CMPT_STATE_UPDATE_WHEN_LIT!(state);\n     |             ---------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LIT` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `LIT_LIT`\n    --> src/src/cmptlz_c.rs:936:13\n     |\n936  |             LIT_LIT\n     |             ^^^^^^^ not a value\n...\n2570 |             CMPT_STATE_UPDATE_WHEN_LIT!(state);\n     |             ---------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LIT` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `LIT_SHORTREP`\n    --> src/src/cmptlz_c.rs:937:29\n     |\n937  |         } else if $state <= LIT_SHORTREP {\n     |                             ^^^^^^^^^^^^ not a value\n...\n2570 |             CMPT_STATE_UPDATE_WHEN_LIT!(state);\n     |             ---------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LIT` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `SHORTREP_LIT_LIT`\n    --> src/src/cmptlz_c.rs:935:31\n     |\n935  |         $state = if $state <= SHORTREP_LIT_LIT {\n     |                               ^^^^^^^^^^^^^^^^ not a value\n...\n3720 |     CMPT_STATE_UPDATE_WHEN_LIT!(encCtx.state);\n     |     ----------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LIT` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `LIT_LIT`\n    --> src/src/cmptlz_c.rs:936:13\n     |\n936  |             LIT_LIT\n     |             ^^^^^^^ not a value\n...\n3720 |     CMPT_STATE_UPDATE_WHEN_LIT!(encCtx.state);\n     |     ----------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LIT` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `LIT_SHORTREP`\n    --> src/src/cmptlz_c.rs:937:29\n     |\n937  |         } else if $state <= LIT_SHORTREP {\n     |                             ^^^^^^^^^^^^ not a value\n...\n3720 |     CMPT_STATE_UPDATE_WHEN_LIT!(encCtx.state);\n     |     ----------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LIT` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 6 previous errors\n"
            },
            {
                "c_code": "#define CMPT_STATE_UPDATE_WHEN_MATCH(state) (state) = (((state) < 7) ? LIT_MATCH : NOTLIT_MATCH)",
                "rust_code": "macro_rules! CMPT_STATE_UPDATE_WHEN_MATCH { ($state:expr) => { $state = if $state < 7 { LIT_MATCH!() } else { NOTLIT_MATCH!() } } }\npub(crate) use CMPT_STATE_UPDATE_WHEN_MATCH;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408534149)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:946:64\n     |\n946  | macro_rules! CMPT_STATE_UPDATE_WHEN_MATCH { ($state:expr) => { $state = if $state < 7 { LIT_MATCH!() } else { NOTLIT_MATCH!() } } }\n     |                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `()`\n...\n3778 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_MATCH!(state);\n     |     ------------   ------------------------------------ in this macro invocation\n     |     |\n     |     expected due to the type of this binding\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_MATCH` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "#define CMPT_STATE_UPDATE_WHEN_LONGREP(state) (state) = (((state) < 7) ? LIT_LONGREP : NOTLIT_REP)",
                "rust_code": "macro_rules! CMPT_STATE_UPDATE_WHEN_LONGREP { ($state:expr) => { $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP } } }\npub(crate) use CMPT_STATE_UPDATE_WHEN_LONGREP;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408534545)\nerror[E0423]: expected value, found macro `LIT_LONGREP`\n    --> src/src/cmptlz_c.rs:955:91\n     |\n955  | macro_rules! CMPT_STATE_UPDATE_WHEN_LONGREP { ($state:expr) => { $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP } } }\n     |                                                                                           ^^^^^^^^^^^ not a value\n...\n2569 |             CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n     |             -------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LONGREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `NOTLIT_REP`\n    --> src/src/cmptlz_c.rs:955:112\n     |\n955  | macro_rules! CMPT_STATE_UPDATE_WHEN_LONGREP { ($state:expr) => { $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP } } }\n     |                                                                                                                ^^^^^^^^^^ not a value\n...\n2569 |             CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n     |             -------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LONGREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `LIT_LONGREP`\n    --> src/src/cmptlz_c.rs:955:91\n     |\n955  | macro_rules! CMPT_STATE_UPDATE_WHEN_LONGREP { ($state:expr) => { $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP } } }\n     |                                                                                           ^^^^^^^^^^^ not a value\n...\n3885 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n     |                    -------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LONGREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `NOTLIT_REP`\n    --> src/src/cmptlz_c.rs:955:112\n     |\n955  | macro_rules! CMPT_STATE_UPDATE_WHEN_LONGREP { ($state:expr) => { $state = if $state < 7 { LIT_LONGREP } else { NOTLIT_REP } } }\n     |                                                                                                                ^^^^^^^^^^ not a value\n...\n3885 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n     |                    -------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_LONGREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 4 previous errors\n"
            },
            {
                "c_code": "#define CMPT_STATE_UPDATE_WHEN_SHORTREP(state) (state) = (((state) < 7) ? LIT_SHORTREP : NOTLIT_REP)",
                "rust_code": "macro_rules! CMPT_STATE_UPDATE_WHEN_SHORTREP { ($state:expr) => { $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP } } }\npub(crate) use CMPT_STATE_UPDATE_WHEN_SHORTREP;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408534959)\nerror[E0423]: expected value, found macro `LIT_SHORTREP`\n    --> src/src/cmptlz_c.rs:965:92\n     |\n965  | macro_rules! CMPT_STATE_UPDATE_WHEN_SHORTREP { ($state:expr) => { $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP } } }\n     |                                                                                            ^^^^^^^^^^^^ not a value\n...\n2561 |             CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n     |             --------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_SHORTREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `NOTLIT_REP`\n    --> src/src/cmptlz_c.rs:965:114\n     |\n965  | macro_rules! CMPT_STATE_UPDATE_WHEN_SHORTREP { ($state:expr) => { $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP } } }\n     |                                                                                                                  ^^^^^^^^^^ not a value\n...\n2561 |             CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n     |             --------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_SHORTREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `LIT_SHORTREP`\n    --> src/src/cmptlz_c.rs:965:92\n     |\n965  | macro_rules! CMPT_STATE_UPDATE_WHEN_SHORTREP { ($state:expr) => { $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP } } }\n     |                                                                                            ^^^^^^^^^^^^ not a value\n...\n3754 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n     |                    --------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_SHORTREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `NOTLIT_REP`\n    --> src/src/cmptlz_c.rs:965:114\n     |\n965  | macro_rules! CMPT_STATE_UPDATE_WHEN_SHORTREP { ($state:expr) => { $state = if $state < 7 { LIT_SHORTREP } else { NOTLIT_REP } } }\n     |                                                                                                                  ^^^^^^^^^^ not a value\n...\n3754 |     encCtx.state = CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n     |                    --------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_STATE_UPDATE_WHEN_SHORTREP` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 4 previous errors\n"
            },
            {
                "c_code": "#define CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue)                                             \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        temp = mf->hashRootTable[cur[0]] ^ cur[1];                                                                     \\\n        hash2Value = temp & CMPTLZ_HASH_2_MASK;                                                                        \\\n        hash3Value = (temp ^ ((uint32_t)(cur[2]) << 8)) & CMPTLZ_HASH_3_MASK;                                          \\\n        hashValue = (temp ^ ((uint32_t)(cur[2]) << 8) ^ (mf->hashRootTable[cur[3]] << 5)) & mf->hashMask;              \\\n    } while (0)",
                "rust_code": "macro_rules! CMPT_HASH_4_CALC {\n    ($mf:expr, $cur:expr, $temp:expr, $hash2Value:expr, $hash3Value:expr, $hashValue:expr) => {\n        $temp = $mf.hashRootTable[$cur[0]] ^ $cur[1];\n        $hash2Value = $temp & CMPTLZ_HASH_2_MASK!();\n        $hash3Value = ($temp ^ (($cur[2] as u32) << 8)) & CMPTLZ_HASH_3_MASK!();\n        $hashValue = ($temp ^ (($cur[2] as u32) << 8) ^ ($mf.hashRootTable[$cur[3]] << 5)) & $mf.hashMask;\n    }\n}\npub(crate) use CMPT_HASH_4_CALC;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408540212)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:992:46\n     |\n992  |         $temp = $mf.hashRootTable[$cur[0]] ^ $cur[1];\n     |                                              ^^^^^^^ expected `u32`, found `u8`\n...\n3131 |     CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n     |     ------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n    --> src/src/cmptlz_c.rs:992:44\n     |\n992  |         $temp = $mf.hashRootTable[$cur[0]] ^ $cur[1];\n     |                                            ^ no implementation for `u32 ^ u8`\n...\n3131 |     CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n     |     ------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitXor<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitXor<Rhs>`:\n               `&u32` implements `BitXor<u32>`\n               `&u32` implements `BitXor`\n               `u32` implements `BitXor<&u32>`\n               `u32` implements `BitXor`\n     = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:992:46\n     |\n992  |         $temp = $mf.hashRootTable[$cur[0]] ^ $cur[1];\n     |                                              ^^^^^^^ expected `u32`, found `u8`\n...\n3179 |         CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n     |         ------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 ^ u8`\n    --> src/src/cmptlz_c.rs:992:44\n     |\n992  |         $temp = $mf.hashRootTable[$cur[0]] ^ $cur[1];\n     |                                            ^ no implementation for `u32 ^ u8`\n...\n3179 |         CMPT_HASH_4_CALC!(mf, cur, temp, hash2Value, hash3Value, hashValue);\n     |         ------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `BitXor<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `BitXor<Rhs>`:\n               `&u32` implements `BitXor<u32>`\n               `&u32` implements `BitXor`\n               `u32` implements `BitXor<&u32>`\n               `u32` implements `BitXor`\n     = note: this error originates in the macro `CMPT_HASH_4_CALC` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 4 previous errors\n"
            },
            {
                "c_code": "#define GET_LEN_TO_POS_STATE(len) (((len) < CMPT_NUM_LEN_POS_STATE + 1) ? (len) - 2 : CMPT_NUM_LEN_POS_STATE - 1)",
                "rust_code": "macro_rules! GET_LEN_TO_POS_STATE { ($len:expr) => { if $len < CMPT_NUM_LEN_POS_STATE + 1 { $len - 2 } else { CMPT_NUM_LEN_POS_STATE - 1 } } }\npub(crate) use GET_LEN_TO_POS_STATE;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408576518)\nerror[E0423]: expected value, found macro `CMPT_NUM_LEN_POS_STATE`\n    --> src/src/cmptlz_c.rs:1076:64\n     |\n1076 | macro_rules! GET_LEN_TO_POS_STATE { ($len:expr) => { if $len < CMPT_NUM_LEN_POS_STATE + 1 { $len - 2 } else { CMPT_NUM_LEN_POS_STATE - 1 ...\n     |                                                                ^^^^^^^^^^^^^^^^^^^^^^ not a value\n...\n3617 |     let mut probs: Ptr<CmptlzProb> = encCtx.probDistSlot[GET_LEN_TO_POS_STATE!(len)].cast();\n     |                                                          -------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `GET_LEN_TO_POS_STATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPT_NUM_LEN_POS_STATE`\n    --> src/src/cmptlz_c.rs:1076:111\n     |\n1076 | ...{ ($len:expr) => { if $len < CMPT_NUM_LEN_POS_STATE + 1 { $len - 2 } else { CMPT_NUM_LEN_POS_STATE - 1 } } }\n     |                                                                                ^^^^^^^^^^^^^^^^^^^^^^ not a value\n...\n3617 | ... = encCtx.probDistSlot[GET_LEN_TO_POS_STATE!(len)].cast();\n     |                           -------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `GET_LEN_TO_POS_STATE` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "#define CMPT_RC_GET_NEWBOUND(prob, bit0Prob, range, newBound)                                                          \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (bit0Prob) = *(prob);                                                                                          \\\n        newBound = ((range) >> 11) * (bit0Prob);                                                                       \\\n    } while (0)",
                "rust_code": "macro_rules! CMPT_RC_GET_NEWBOUND { ($prob:expr, $bit0Prob:expr, $range:expr, $newBound:expr) =>\n    {\n        $bit0Prob = *$prob;\n        $newBound = ($range >> 11) * $bit0Prob;\n    }\n}\npub(crate) use CMPT_RC_GET_NEWBOUND;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408592726)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n2386 |         let mut bit0Prob: u32;\n     |                           --- expected due to this type\n...\n2391 |         CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |         ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3463 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3470 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3481 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3491 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3577 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3580 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3577 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3585 |         CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |         ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3577 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3602 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3577 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3606 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3577 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3610 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3620 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3628 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3641 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3648 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3682 |         let mut bit0Prob: u32;\n     |                           --- expected due to this type\n...\n3688 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>()  + m, bit, bit0Prob, range, newBound, shiftRes);\n     |             ---------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3682 |         let mut bit0Prob: u32;\n     |                           --- expected due to this type\n...\n3693 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>() + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` which comes from the expansion of the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3705 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3710 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3734 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3739 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3734 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3744 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3734 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3749 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3734 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3754 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3767 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3772 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3767 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3777 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3811 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3816 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3821 |     CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |     ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3828 |             CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |             ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3837 |             CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |             ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3849 |             CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |             ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3854 |             CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |             ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3867 |             CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |             ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1121:21\n     |\n1121 |         $bit0Prob = *$prob;\n     |                     ^^^^^^ expected `u32`, found `u16`\n...\n3805 |     let mut bit0Prob: u32;\n     |                       --- expected due to this type\n...\n3872 |             CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n     |             ------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_GET_NEWBOUND` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 28 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 28 previous errors\n"
            },
            {
                "c_code": "#define CMPT_RC_BIT_PROCESS(rcCtx, prob, bit, bit0Prob, range, newBound, shiftRes)                                     \\\n    {                                                                                                                  \\\n        do                                                                                                             \\\n        {                                                                                                              \\\n            uint32_t mask = 0 - (uint32_t)(bit);                                                                       \\\n            CMPT_RC_GET_NEWBOUND(prob, bit0Prob, range, newBound);                                                     \\\n            (range) &= mask;                                                                                           \\\n            mask &= (newBound);                                                                                        \\\n            (range) -= mask;                                                                                           \\\n            (rcCtx)->low += mask;                                                                                      \\\n            mask = (uint32_t)(bit) - 1;                                                                                \\\n            (range) += (newBound) & mask;                                                                              \\\n            mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));                                                            \\\n            mask += ((1 << 5) - 1);                                                                                    \\\n            (bit0Prob) += (int)(mask - (bit0Prob)) >> 5;                                                               \\\n            *(prob) = (CmptlzProb)(bit0Prob);                                                                          \\\n            CMPT_RC_NORMALIZE(rcCtx, range, shiftRes);                                                                 \\\n        } while (0);                                                                                                   \\\n    }",
                "rust_code": "macro_rules! CMPT_RC_BIT_PROCESS {\n    ($rcCtx:expr, $prob:expr, $bit:expr, $bit0Prob:expr, $range:expr, $newBound:expr, $shiftRes:expr) => {\n        {\n            let mut mask = 0 - ($bit as u32);\n            CMPT_RC_GET_NEWBOUND!($prob, $bit0Prob, $range, $newBound);\n            $range &= mask;\n            mask &= $newBound;\n            $range -= mask;\n            $rcCtx.low += mask;\n            mask = ($bit as u32) - 1;\n            $range += $newBound & mask;\n            mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n            mask += (1 << 5) - 1;\n            $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n            *$prob = $bit0Prob as CmptlzProb;\n            CMPT_RC_NORMALIZE!($rcCtx, $range, $shiftRes);\n        }\n    };\n}\npub(crate) use CMPT_RC_BIT_PROCESS;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408593123)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3472 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3493 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3604 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3608 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3612 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3630 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3650 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3690 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>()  + m, bit, bit0Prob, range, newBound, shiftRes);\n     |             ---------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1140:21\n     |\n1140 |             mask = (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1)) & mask;\n     |                     ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3695 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>() + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3472 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3472 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3472 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3472 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3493 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3493 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3493 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3493 |         CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n     |         ------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3604 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3604 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3604 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3604 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3608 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3608 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3608 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3608 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3612 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3612 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3612 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3612 |     CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3630 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3630 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3630 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3630 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3650 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3650 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3650 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3650 |         CMPT_RC_BIT_PROCESS!(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3690 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>()  + m, bit, bit0Prob, range, newBound, shiftRes);\n     |             ---------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3690 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>()  + m, bit, bit0Prob, range, newBound, shiftRes);\n     |             ---------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3690 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>()  + m, bit, bit0Prob, range, newBound, shiftRes);\n     |             ---------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3690 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>()  + m, bit, bit0Prob, range, newBound, shiftRes);\n     |             ---------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1137:27\n     |\n1137 |             $rcCtx.low += mask;\n     |                           ^^^^ expected `u64`, found `u32`\n...\n3695 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>() + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1137:24\n     |\n1137 |             $rcCtx.low += mask;\n     |                        ^^ no implementation for `u64 += u32`\n...\n3695 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>() + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1142:26\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `i32`\n...\n3695 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>() + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: cannot add-assign `i32` to `u32`\n    --> src/src/cmptlz_c.rs:1142:23\n     |\n1142 |             $bit0Prob += (mask - $bit0Prob as u32) as i32 >> 5;\n     |                       ^^ no implementation for `u32 += i32`\n...\n3695 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign.cast::<Ptr<u16>>() + m, bit, bit0Prob, range, newBound, shiftRes);\n     |         --------------------------------------------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<i32>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u32` implements `std::ops::AddAssign<&u32>`\n               `u32` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0423.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 45 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 45 previous errors\n"
            },
            {
                "c_code": "#define CMPT_RC_BIT_0(prob, newBound, range, bit0Prob)                                                                 \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (range) = (newBound);                                                                                          \\\n        *(prob) = (CmptlzProb)((bit0Prob) + ((CMPTLZ_PROB_MAX_NUM - (bit0Prob)) >> 5));                                \\\n    } while (0)",
                "rust_code": "macro_rules! CMPT_RC_BIT_0 { ($prob:expr, $newBound:expr, $range:expr, $bit0Prob:expr) =>\n    {\n        $range = $newBound;\n        *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n    }\n}\npub(crate) use CMPT_RC_BIT_0;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408593544)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n2395 |         CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n     |         ---------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3600 |     CMPT_RC_BIT_0_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     ------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3713 |     CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n     |     ---------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3752 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3757 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3780 |     CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3826 |             CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |             -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` which comes from the expansion of the macro `CMPT_RC_BIT_0_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3840 |             CMPT_RC_BIT_0!(probs, newBound, range, bit0Prob);\n     |             ------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:1153:33\n     |\n1153 |         *$prob = ($bit0Prob + ((CMPTLZ_PROB_MAX_NUM - $bit0Prob) >> 5)) as CmptlzProb;\n     |                                 ^^^^^^^^^^^^^^^^^^^ not a value\n...\n3857 |             CMPT_RC_BIT_0!(probs, newBound, range, bit0Prob);\n     |             ------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_RC_BIT_0` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 9 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 9 previous errors\n"
            },
            {
                "c_code": "#define CMPT_RC_BIT_1(rcCtx, prob, newBound, range, bit0Prob)                                                          \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (range) -= (newBound);                                                                                         \\\n        (rcCtx)->low += (newBound);                                                                                    \\\n        *(prob) = (CmptlzProb)((bit0Prob) - ((bit0Prob) >> 5));                                                        \\\n    } while (0)",
                "rust_code": "macro_rules! CMPT_RC_BIT_1 { ($rcCtx:expr, $prob:expr, $newBound:expr, $range:expr, $bit0Prob:expr) =>\n    {\n        $range -= $newBound;\n        $rcCtx.low += $newBound;\n        *$prob = ($bit0Prob - ($bit0Prob >> 5)) as CmptlzProb;\n    }\n}\npub(crate) use CMPT_RC_BIT_1;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408593955)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3584:46\n     |\n3584 |         CMPT_RC_BIT_1_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                              ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3584 |         CMPT_RC_BIT_1_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |         ------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3589:50\n     |\n3589 |             CMPT_RC_BIT_1_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                  ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3589 |             CMPT_RC_BIT_1_PROCESS!(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |             ------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3742:49\n     |\n3742 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                 ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3742 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3747:49\n     |\n3747 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                 ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3747 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3775:49\n     |\n3775 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                 ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3775 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3814:49\n     |\n3814 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                 ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3814 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3819:49\n     |\n3819 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                 ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3819 |     CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |     -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3831:49\n     |\n3831 |             CMPT_RC_BIT_1!(encCtx.rcCtx, probs, newBound, range, bit0Prob);\n     |                                                 ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3831 |             CMPT_RC_BIT_1!(encCtx.rcCtx, probs, newBound, range, bit0Prob);\n     |             -------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3835:57\n     |\n3835 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                         ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3835 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |             -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3847:57\n     |\n3847 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                         ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3847 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |             -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3852:57\n     |\n3852 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                         ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3852 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |             -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3865:57\n     |\n3865 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                         ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3865 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |             -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3870:57\n     |\n3870 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |                                                         ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3870 |             CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n     |             -------------------------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` which comes from the expansion of the macro `CMPT_RC_BIT_1_PROCESS` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3875:49\n     |\n3875 |             CMPT_RC_BIT_1!(encCtx.rcCtx, probs, newBound, range, bit0Prob);\n     |                                                 ^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:1161:20\n     |\n1161 |         $rcCtx.low += $newBound;\n     |                    ^^ no implementation for `u64 += u32`\n...\n3875 |             CMPT_RC_BIT_1!(encCtx.rcCtx, probs, newBound, range, bit0Prob);\n     |             -------------------------------------------------------------- in this macro invocation\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n     = note: this error originates in the macro `CMPT_RC_BIT_1` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 28 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 28 previous errors\n"
            },
            {
                "c_code": "#define CMPT_LIT_PROB_GET(encCtx, litProb, pos, prevByte)                                                              \\\n    (litProb + (uint32_t)3 * (((((pos) << 8) + (prevByte)) & encCtx->lpMask) << encCtx->litMarcov.lcBits))",
                "rust_code": "macro_rules! CMPT_LIT_PROB_GET {\n    ($encCtx:expr, $litProb:expr, $pos:expr, $prevByte:expr) => {\n        $litProb + (3 as u32) * (((($pos << 8) + $prevByte) & $encCtx.lpMask) << $encCtx.litMarcov.lcBits)\n    }\n}\npub(crate) use CMPT_LIT_PROB_GET;\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408605318)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1189:63\n     |\n1189 |         $litProb + (3 as u32) * (((($pos << 8) + $prevByte) & $encCtx.lpMask) << $encCtx.litMarcov.lcBits)\n     |                                                               ^^^^^^^^^^^^^^ expected `u32`, found `u64`\n...\n3718 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1] as u32);\n     |             ------------------------------------------------------------------------------------------------ in this macro invocation\n     |\n     = note: this error originates in the macro `CMPT_LIT_PROB_GET` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: no implementation for `u32 & u64`\n    --> src/src/cmptlz_c.rs:1189:61\n     |\n1189 |         $litProb + (3 as u32) * (((($pos << 8) + $prevByte) & $encCtx.lpMask) << $encCtx.litMarcov.lcBits)\n     |                                                             ^ no implementation for `u32 & u64`\n...\n3718 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1] as u32);\n     |             ------------------------------------------------------------------------------------------------ in this macro invocation\n     |\n     = help: the trait `BitAnd<u64>` is not implemented for `u32`\n     = help: the following other types implement trait `BitAnd<Rhs>`:\n               `&u32` implements `BitAnd<u32>`\n               `&u32` implements `BitAnd`\n               `u32` implements `BitAnd<&u32>`\n               `u32` implements `BitAnd`\n     = note: this error originates in the macro `CMPT_LIT_PROB_GET` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            }
        ]
    },
    "definition": {
        "all_cnt": 27,
        "passed_cnt": 27,
        "pass_rate": 1.0,
        "messages": []
    },
    "function": {
        "all_cnt": 122,
        "passed_cnt": 100,
        "pass_rate": 0.819672131147541,
        "messages": [
            {
                "c_code": "static size_t CmptLzDistDec(CmptLzDecCtx *decCtx, CmptLzDecProb *probsMatrix, uint32_t *pRange, uint32_t *pRangeCode,\n                            uint32_t *pRangeBound, uint32_t decLen)\n{\n    uint32_t assistBits;\n    uint32_t posSlot = 1;\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    const unsigned char *bufToDec = decCtx->buf;\n    uint32_t distDec;\n    CmptLzDecProb *probPosSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decLen);\n    int i = 0;\n    for (i = 0; i < CMPTLZ_POS_SLOT_BITS; i++)\n    {\n        CMPTLZ_POSSLOT_BIT_DEC((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    }\n    posSlot -= 64;\n    if (posSlot < CMPTLZ_LOW_POSSLOT)\n    {\n        distDec = posSlot;\n        CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n        if (distDec == (size_t)0xFFFFFFFF)\n        {\n            return distDec;\n        }\n        else\n        {\n            return (distDec + 1);\n        }\n    }\n    uint32_t directBitNum = ((posSlot >> 1) - 1);\n    distDec = CmptLzGetBaseDistByPosSlot(posSlot);\n    if (posSlot < CMPTLZ_HIGH_POSSLOT)\n    {\n        assistBits = 1;\n        distDec <<= directBitNum;\n        distDec += assistBits;\n        probPosSlot = CmptLzGetSpecPosProb(probsMatrix);\n        do\n        {\n            if CMPTLZ_IS_THE_BIT_0 ((probPosSlot + distDec), range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0((probPosSlot + distDec), range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                distDec += assistBits;\n                assistBits <<= 1;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1((probPosSlot + distDec), range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                assistBits <<= 1;\n                distDec += assistBits;\n            }\n        } while (--directBitNum);\n        distDec -= assistBits;\n    }\n    else\n    {\n        directBitNum -= CMPTLZ_REP4;\n        do\n        {\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            range >>= 1;\n            rangeCode -= range;\n            assistBits = (0 - ((uint32_t)rangeCode >> 31));\n            distDec = (distDec << 1) + (assistBits + 1);\n            rangeCode += range & assistBits;\n        } while (--directBitNum);\n        CmptLzDecProb *probDist;\n        probPosSlot = CmptLzGetAilgnProb(probsMatrix);\n        distDec <<= CMPTLZ_LARGE_DIST_LOW_BITS;\n        assistBits = 1;\n        uint32_t cycleSym = 1;\n        for (i = 0; i < 3; i++)\n        {\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            CMPTLZ_DIST_BIT_DEC(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n            cycleSym <<= 1;\n        }\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probDist = probPosSlot + assistBits;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probDist);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probDist, range, rangeBound);\n            assistBits -= 8;\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probDist, range, rangeCode, rangeBound);\n        }\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        distDec |= assistBits;\n    }\n    CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n    if (distDec == (size_t)0xFFFFFFFF)\n    {\n        return distDec;\n    }\n    else\n    {\n        return (distDec + 1);\n    }\n}",
                "rust_code": "pub fn CmptLzDistDec(mut decCtx: Ptr<CmptLzDecCtx>, mut probsMatrix: Ptr<CmptLzDecProb>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut decLen: u32) -> usize {\n    let mut assistBits: u32;\n    let mut posSlot: u32 = 1;\n    let mut range: u32 = *pRange;\n    let mut rangeCode: u32 = *pRangeCode;\n    let mut rangeBound: u32 = *pRangeBound;\n    let mut bufToDec: Ptr<u8> = decCtx.buf;\n    let mut distDec: u32;\n    let mut probPosSlot: Ptr<CmptLzDecProb> = (CmptLzGetPosSlotProb(probsMatrix)).plus(CmptLzGetLenCondition(decLen));\n    let mut i: i32 = 0;\n    c_for!(i = 0; i < CMPTLZ_POS_SLOT_BITS as i32; i.suffix_plus_plus(); {\n        CMPTLZ_POSSLOT_BIT_DEC!((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    });\n    posSlot -= 64;\n    if (posSlot < CMPTLZ_LOW_POSSLOT as u32) {\n        distDec = posSlot;\n        CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n        if (distDec == 0xFFFFFFFFu32) {\n            return distDec as usize;\n        } else {\n            return (distDec + 1) as usize;\n        }\n    }\n    let mut directBitNum: u32 = ((posSlot >> 1) - 1);\n    distDec = CmptLzGetBaseDistByPosSlot(posSlot);\n    if (posSlot < CMPTLZ_HIGH_POSSLOT as u32) {\n        assistBits = 1;\n        distDec <<= directBitNum;\n        distDec += assistBits;\n        probPosSlot = CmptLzGetSpecPosProb(probsMatrix);\n        c_do!({\n            if CMPTLZ_IS_THE_BIT_0!((probPosSlot + distDec), range, rangeCode, rangeBound) {\n                CMPTLZ_RANGE_UPDATE_0!((probPosSlot + distDec), range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n                distDec += assistBits;\n                assistBits <<= 1;\n            } else {\n                CMPTLZ_RANGE_UPDATE_1!((probPosSlot + distDec), range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n                assistBits <<= 1;\n                distDec += assistBits;\n            }\n        } while directBitNum.prefix_minus_minus() != 0);\n        distDec -= assistBits;\n    } else {\n        directBitNum -= CMPTLZ_REP4 as u32;\n        c_do!({\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            range >>= 1;\n            rangeCode -= range;\n            assistBits = (0 - ((rangeCode >> 31) as u32));\n            distDec = (distDec << 1) + (assistBits + 1);\n            rangeCode += range & assistBits;\n        } while directBitNum.prefix_minus_minus() != 0);\n        let mut probDist: Ptr<CmptLzDecProb>;\n        probPosSlot = CmptLzGetAilgnProb(probsMatrix);\n        distDec <<= CMPTLZ_LARGE_DIST_LOW_BITS as u32;\n        assistBits = 1;\n        let mut cycleSym: u32 = 1;\n        c_for!(i = 0; i < 3; i.suffix_plus_plus(); {\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            CMPTLZ_DIST_BIT_DEC!(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n            cycleSym <<= 1;\n        });\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        probDist = (probPosSlot + assistBits);\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT as u32) * (*probDist).cast::<u32>();\n        if (rangeCode < rangeBound) {\n            CMPTLZ_RANGE_UPDATE_0!(probDist, range, rangeBound);\n            assistBits -= 8;\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probDist, range, rangeCode, rangeBound);\n        }\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        distDec |= assistBits;\n    }\n    CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n    if (distDec == 0xFFFFFFFFu32) {\n        return distDec as usize;\n    } else {\n        return (distDec + 1) as usize;\n    }\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408899289)\nerror[E0423]: expected value, found macro `CMPTLZ_POS_SLOT_BITS`\n    --> src/src/cmptlz_c.rs:1418:23\n     |\n1418 |     c_for!(i = 0; i < CMPTLZ_POS_SLOT_BITS as i32; i.suffix_plus_plus(); {\n     |                       ^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_LOW_POSSLOT`\n    --> src/src/cmptlz_c.rs:1422:19\n     |\n1422 |     if (posSlot < CMPTLZ_LOW_POSSLOT as u32) {\n     |                   ^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_HIGH_POSSLOT`\n    --> src/src/cmptlz_c.rs:1433:19\n     |\n1433 |     if (posSlot < CMPTLZ_HIGH_POSSLOT as u32) {\n     |                   ^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_REP4`\n    --> src/src/cmptlz_c.rs:1453:25\n     |\n1453 |         directBitNum -= CMPTLZ_REP4 as u32;\n     |                         ^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_LARGE_DIST_LOW_BITS`\n    --> src/src/cmptlz_c.rs:1464:21\n     |\n1464 |         distDec <<= CMPTLZ_LARGE_DIST_LOW_BITS as u32;\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_LG_BIT`\n    --> src/src/cmptlz_c.rs:1474:32\n     |\n1474 |         rangeBound = (range >> CMPTLZ_PROB_LG_BIT as u32) * (*probDist).cast::<u32>();\n     |                                ^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0599]: no method named `plus` found for struct `memory::ptr::Ptr<u16>` in the current scope\n    --> src/src/cmptlz_c.rs:1416:83\n     |\n1416 |     let mut probPosSlot: Ptr<CmptLzDecProb> = (CmptLzGetPosSlotProb(probsMatrix)).plus(CmptLzGetLenCondition(decLen));\n     |                                                                                   ^^^^ method not found in `Ptr<u16>`\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `plus` not found for this struct\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 7 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 7 previous errors\n"
            },
            {
                "c_code": "static uint32_t CmptLzLenDec(CmptLzDecCtx *decCtx, CmptLzDecProb *probSlot, uint32_t *pRange, uint32_t *pRangeCode,\n                             uint32_t *pRangeBound, uint32_t posState)\n{\n    uint32_t decLen = 1;\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    const unsigned char *bufToDec = decCtx->buf;\n    CmptLzDecProb *probLen = probSlot + CMPTLZ_LEN_CHOICE;\n    int i = 0;\n    if CMPTLZ_IS_THE_BIT_0 (probLen, range, rangeCode, rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET + posState;\n        for (i = 0; i < CMPTLZ_LOW_LEN_BIT; i++)\n        {\n            CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n        }\n        decLen -= 8;\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2;\n        if CMPTLZ_IS_THE_BIT_0 (probLen, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            probLen = probSlot + (CMPTLZ_LEN_CHOICE2 + posState);\n            for (i = 0; i < CMPTLZ_LOW_LEN_BIT; i++)\n            {\n                CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            }\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET;\n            for (i = 0; i < CMPTLZ_HIGH_LEN_BIT; i++)\n            {\n                CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            }\n            decLen -= CMPTLZ_HIGH_LEN_CLASS;\n            decLen += (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n    }\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx->buf = bufToDec;\n    return decLen;\n}",
                "rust_code": "pub fn CmptLzLenDec(mut decCtx: Ptr<CmptLzDecCtx>, mut probSlot: Ptr<CmptLzDecProb>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut posState: u32) -> u32 {\n    let mut decLen: u32 = 1;\n    let mut range: u32 = *pRange;\n    let mut rangeCode: u32 = *pRangeCode;\n    let mut rangeBound: u32 = *pRangeBound;\n    let mut bufToDec: Ptr<u8> = decCtx.buf;\n    let mut probLen: Ptr<CmptLzDecProb> = (probSlot + CMPTLZ_LEN_CHOICE);\n    let mut i: i32 = 0;\n    if CMPTLZ_IS_THE_BIT_0(probLen, range, rangeCode, rangeBound) {\n        CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probLen = (probSlot + CMPTLZ_LOW_LENPROB_OFFSET + posState);\n        c_for!(i = 0; i < CMPTLZ_LOW_LEN_BIT; i.suffix_plus_plus(); {\n            CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n        });\n        decLen -= 8;\n    } else {\n        CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probLen = (probSlot + CMPTLZ_LEN_CHOICE2);\n        if CMPTLZ_IS_THE_BIT_0(probLen, range, rangeCode, rangeBound) {\n            CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            probLen = (probSlot + (CMPTLZ_LEN_CHOICE2 + posState));\n            c_for!(i = 0; i < CMPTLZ_LOW_LEN_BIT; i.suffix_plus_plus(); {\n                CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            });\n        } else {\n            CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            probLen = (probSlot + CMPTLZ_HIGH_LENPROB_OFFSET);\n            c_for!(i = 0; i < CMPTLZ_HIGH_LEN_BIT; i.suffix_plus_plus(); {\n                CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            });\n            decLen -= CMPTLZ_HIGH_LEN_CLASS;\n            decLen += (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n    }\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx.buf = bufToDec;\n    return decLen;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408899705)\nerror[E0423]: expected value, found macro `CMPTLZ_LEN_CHOICE`\n    --> src/src/cmptlz_c.rs:1506:55\n     |\n1506 |     let mut probLen: Ptr<CmptLzDecProb> = (probSlot + CMPTLZ_LEN_CHOICE);\n     |                                                       ^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_LOW_LENPROB_OFFSET`\n    --> src/src/cmptlz_c.rs:1511:31\n     |\n1511 |         probLen = (probSlot + CMPTLZ_LOW_LENPROB_OFFSET + posState);\n     |                               ^^^^^^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_LOW_LEN_BIT`\n    --> src/src/cmptlz_c.rs:1512:27\n     |\n1512 |         c_for!(i = 0; i < CMPTLZ_LOW_LEN_BIT; i.suffix_plus_plus(); {\n     |                           ^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_LEN_CHOICE2`\n    --> src/src/cmptlz_c.rs:1519:31\n     |\n1519 |         probLen = (probSlot + CMPTLZ_LEN_CHOICE2);\n     |                               ^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_LEN_CHOICE2`\n    --> src/src/cmptlz_c.rs:1523:36\n     |\n1523 |             probLen = (probSlot + (CMPTLZ_LEN_CHOICE2 + posState));\n     |                                    ^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_LOW_LEN_BIT`\n    --> src/src/cmptlz_c.rs:1524:31\n     |\n1524 |             c_for!(i = 0; i < CMPTLZ_LOW_LEN_BIT; i.suffix_plus_plus(); {\n     |                               ^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_HIGH_LENPROB_OFFSET`\n    --> src/src/cmptlz_c.rs:1530:35\n     |\n1530 |             probLen = (probSlot + CMPTLZ_HIGH_LENPROB_OFFSET);\n     |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_HIGH_LEN_BIT`\n    --> src/src/cmptlz_c.rs:1531:31\n     |\n1531 |             c_for!(i = 0; i < CMPTLZ_HIGH_LEN_BIT; i.suffix_plus_plus(); {\n     |                               ^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_HIGH_LEN_CLASS`\n    --> src/src/cmptlz_c.rs:1534:23\n     |\n1534 |             decLen -= CMPTLZ_HIGH_LEN_CLASS;\n     |                       ^^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_LOW_LEN_CLASS`\n    --> src/src/cmptlz_c.rs:1535:24\n     |\n1535 |             decLen += (CMPTLZ_LOW_LEN_CLASS << 1);\n     |                        ^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected function, tuple struct or tuple variant, found macro `CMPTLZ_IS_THE_BIT_0`\n    --> src/src/cmptlz_c.rs:1508:8\n     |\n1508 |     if CMPTLZ_IS_THE_BIT_0(probLen, range, rangeCode, rangeBound) {\n     |        ^^^^^^^^^^^^^^^^^^^ not a function, tuple struct or tuple variant\n     |\nhelp: use `!` to invoke the macro\n     |\n1508 |     if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |                           +\n\nerror[E0423]: expected function, tuple struct or tuple variant, found macro `CMPTLZ_RANGE_UPDATE_0`\n    --> src/src/cmptlz_c.rs:1509:9\n     |\n1509 |         CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n     |         ^^^^^^^^^^^^^^^^^^^^^ not a function, tuple struct or tuple variant\n     |\nhelp: use `!` to invoke the macro\n     |\n1509 |         CMPTLZ_RANGE_UPDATE_0!(probLen, range, rangeBound);\n     |                              +\n\nerror[E0423]: expected function, tuple struct or tuple variant, found macro `CMPTLZ_RANGE_NORMALIZE`\n    --> src/src/cmptlz_c.rs:1510:9\n     |\n1510 |         CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n     |         ^^^^^^^^^^^^^^^^^^^^^^ not a function, tuple struct or tuple variant\n     |\nhelp: use `!` to invoke the macro\n     |\n1510 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |                               +\n\nerror[E0423]: expected function, tuple struct or tuple variant, found macro `CMPTLZ_LEN_BIT_DEC`\n    --> src/src/cmptlz_c.rs:1513:13\n     |\n1513 |             CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |             ^^^^^^^^^^^^^^^^^^ not a function, tuple struct or tuple variant\n     |\nhelp: use `!` to invoke the macro\n     |\n1513 |             CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                               +\n\nerror[E0423]: expected function, tuple struct or tuple variant, found macro `CMPTLZ_RANGE_UPDATE_1`\n    --> src/src/cmptlz_c.rs:1517:9\n     |\n1517 |         CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n     |         ^^^^^^^^^^^^^^^^^^^^^ not a function, tuple struct or tuple variant\n     |\nhelp: use `!` to invoke the macro\n     |\n1517 |         CMPTLZ_RANGE_UPDATE_1!(probLen, range, rangeCode, rangeBound);\n     |                              +\n\nerror[E0423]: expected function, tuple struct or tuple variant, found macro `CMPTLZ_RANGE_NORMALIZE`\n    --> src/src/cmptlz_c.rs:1518:9\n     |\n1518 |         CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n     |         ^^^^^^^^^^^^^^^^^^^^^^ not a function, tuple struct or tuple variant\n     |\nhelp: use `!` to invoke the macro\n     |\n1518 |         CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |                               +\n\nerror[E0423]: expected function, tuple struct or tuple variant, found macro `CMPTLZ_IS_THE_BIT_0`\n    --> src/src/cmptlz_c.rs:1520:12\n     |\n1520 |         if CMPTLZ_IS_THE_BIT_0(probLen, range, rangeCode, rangeBound) {\n     |            ^^^^^^^^^^^^^^^^^^^ not a function, tuple struct or tuple variant\n     |\nhelp: use `!` to invoke the macro\n     |\n1520 |         if CMPTLZ_IS_THE_BIT_0!(probLen, range, rangeCode, rangeBound) {\n     |                               +\n\nerror[E0423]: expected function, tuple struct or tuple variant, found macro `CMPTLZ_RANGE_UPDATE_0`\n    --> src/src/cmptlz_c.rs:1521:13\n     |\n1521 |             CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n     |             ^^^^^^^^^^^^^^^^^^^^^ not a function, tuple struct or tuple variant\n     |\nhelp: use `!` to invoke the macro\n     |\n1521 |             CMPTLZ_RANGE_UPDATE_0!(probLen, range, rangeBound);\n     |                                  +\n\nerror[E0423]: expected function, tuple struct or tuple variant, found macro `CMPTLZ_RANGE_NORMALIZE`\n    --> src/src/cmptlz_c.rs:1522:13\n     |\n1522 |             CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n     |             ^^^^^^^^^^^^^^^^^^^^^^ not a function, tuple struct or tuple variant\n     |\nhelp: use `!` to invoke the macro\n     |\n1522 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |                                   +\n\nerror[E0423]: expected function, tuple struct or tuple variant, found macro `CMPTLZ_LEN_BIT_DEC`\n    --> src/src/cmptlz_c.rs:1525:17\n     |\n1525 |                 CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                 ^^^^^^^^^^^^^^^^^^ not a function, tuple struct or tuple variant\n     |\nhelp: use `!` to invoke the macro\n     |\n1525 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                                   +\n\nerror[E0423]: expected function, tuple struct or tuple variant, found macro `CMPTLZ_RANGE_UPDATE_1`\n    --> src/src/cmptlz_c.rs:1528:13\n     |\n1528 |             CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n     |             ^^^^^^^^^^^^^^^^^^^^^ not a function, tuple struct or tuple variant\n     |\nhelp: use `!` to invoke the macro\n     |\n1528 |             CMPTLZ_RANGE_UPDATE_1!(probLen, range, rangeCode, rangeBound);\n     |                                  +\n\nerror[E0423]: expected function, tuple struct or tuple variant, found macro `CMPTLZ_RANGE_NORMALIZE`\n    --> src/src/cmptlz_c.rs:1529:13\n     |\n1529 |             CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n     |             ^^^^^^^^^^^^^^^^^^^^^^ not a function, tuple struct or tuple variant\n     |\nhelp: use `!` to invoke the macro\n     |\n1529 |             CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n     |                                   +\n\nerror[E0423]: expected function, tuple struct or tuple variant, found macro `CMPTLZ_LEN_BIT_DEC`\n    --> src/src/cmptlz_c.rs:1532:17\n     |\n1532 |                 CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                 ^^^^^^^^^^^^^^^^^^ not a function, tuple struct or tuple variant\n     |\nhelp: use `!` to invoke the macro\n     |\n1532 |                 CMPTLZ_LEN_BIT_DEC!((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n     |                                   +\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 23 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 23 previous errors\n"
            },
            {
                "c_code": "static uint32_t CmptLzDecByDistAndLen(CmptLzDecCtx *decCtx, size_t matchDist, uint32_t matchLen, size_t dicPosLimit)\n{\n    size_t dicCopyPos;\n    size_t dicPos = decCtx->dictPos;\n    size_t dictBufSize = decCtx->dictBufSize;\n    uint32_t remainDicLen = (uint32_t)(dicPosLimit - dicPos);\n    unsigned char *dict = decCtx->dict;\n    if (remainDicLen == 0)\n    {\n        return CMPT_ERROR_DATA;\n    }\n    uint32_t decDicLen = ((remainDicLen < matchLen) ? remainDicLen : matchLen);\n    decCtx->processedPos += decDicLen;\n    decCtx->dictPos += decDicLen;\n    decCtx->remainLen = matchLen - decDicLen;\n    if (dicPos < matchDist)\n    {\n        dicCopyPos = dictBufSize - matchDist + dicPos;\n    }\n    else\n    {\n        dicCopyPos = dicPos - matchDist;\n    }\n    do\n    {\n        dict[dicPos++] = dict[dicCopyPos];\n        if (++dicCopyPos == dictBufSize)\n        {\n            dicCopyPos = 0;\n        }\n    } while (--decDicLen != 0);\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptLzDecByDistAndLen(mut decCtx: Ptr<CmptLzDecCtx>, mut matchDist: usize, mut matchLen: u32, mut dicPosLimit: usize) -> u32 {\n    let mut dicCopyPos: usize;\n    let mut dicPos: usize = decCtx.dictPos;\n    let mut dictBufSize: usize = decCtx.dictBufSize;\n    let mut remainDicLen: u32 = (dicPosLimit - dicPos).cast::<u32>();\n    let mut dict: Ptr<u8> = decCtx.dict;\n    if (remainDicLen == 0) {\n        return CMPT_ERROR_DATA!().cast::<u32>();\n    }\n    let mut decDicLen: u32 = if remainDicLen < matchLen { remainDicLen } else { matchLen };\n    decCtx.processedPos += decDicLen;\n    decCtx.dictPos += decDicLen.cast::<usize>();\n    decCtx.remainLen = (matchLen - decDicLen);\n    if (dicPos < matchDist) {\n        dicCopyPos = (dictBufSize - matchDist + dicPos);\n    } else {\n        dicCopyPos = (dicPos - matchDist);\n    }\n    c_do!({\n        dict[dicPos] = dict[dicCopyPos];\n        dicPos += 1;\n        if (dicCopyPos.prefix_plus_plus() == dictBufSize) {\n            dicCopyPos = 0;\n        }\n    } while (decDicLen.suffix_minus_minus() != 0));\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408900130)\n    Finished `test` profile [optimized + debuginfo] target(s) in 2.45s\n     Running unittests src/lib.rs (target/debug/deps/my_proj-baa1ee44ab22c9ed)\ndouble free or corruption (!prev)\nerror: test failed, to rerun pass `--lib`\n\nCaused by:\n  process didn't exit successfully: `/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408900130/target/debug/deps/my_proj-baa1ee44ab22c9ed --test-threads=1` (signal: 6, SIGABRT: process abort signal)\n"
            },
            {
                "c_code": "static uint32_t CmptLzRepDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound,\n                             size_t dicPosLimit, uint32_t posState)\n{\n    uint32_t repLen;\n    uint32_t repDist;\n    uint32_t mkState = decCtx->state;\n    const unsigned char *bufToDec = decCtx->buf;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    probSlot = CmptLzGetIsRepG0Prob(probsMatrix) + mkState;\n    if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probSlot = CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState;\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            *pRange = range;\n            *pRangeCode = rangeCode;\n            *pRangeBound = rangeBound;\n            decCtx->buf = bufToDec;\n            CmptLzShortRepDec(decCtx);\n            return CMPT_OK;\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            repDist = decCtx->reps[0];\n        }\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probSlot = CmptLzGetIsRepG1Prob(probsMatrix) + mkState;\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            repDist = decCtx->reps[1];\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            probSlot = CmptLzGetIsRepG2Prob(probsMatrix) + mkState;\n            if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                repDist = decCtx->reps[CMPTLZ_REP2];\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                repDist = decCtx->reps[CMPTLZ_REP3];\n                decCtx->reps[CMPTLZ_REP3] = decCtx->reps[CMPTLZ_REP2];\n            }\n            decCtx->reps[CMPTLZ_REP2] = decCtx->reps[1];\n        }\n        decCtx->reps[1] = decCtx->reps[0];\n        decCtx->reps[0] = repDist;\n    }\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx->buf = bufToDec;\n    decCtx->state = (mkState < CMPTLZ_LIT_STATES) ? 8 : 11;\n    probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n    repLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n    return CmptLzDecByDistAndLen(decCtx, repDist, repLen + 2, dicPosLimit);\n}",
                "rust_code": "pub fn CmptLzRepDec(mut decCtx: Ptr<CmptLzDecCtx>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>, mut dicPosLimit: usize, mut posState: u32) -> u32 {\n    let mut repLen: u32;\n    let mut repDist: u32;\n    let mut mkState: u32 = decCtx.state;\n    let mut bufToDec: Ptr<u8> = decCtx.buf;\n    let mut probSlot: Ptr<CmptLzDecProb>;\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx);\n    let mut range: u32 = *pRange;\n    let mut rangeCode: u32 = *pRangeCode;\n    let mut rangeBound: u32 = *pRangeBound;\n    probSlot = (CmptLzGetIsRepG0Prob(probsMatrix) + mkState);\n    if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n        CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        probSlot = (CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState);\n        if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n            CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            *pRange = range;\n            *pRangeCode = rangeCode;\n            *pRangeBound = rangeBound;\n            decCtx.buf = bufToDec;\n            CmptLzShortRepDec(decCtx);\n            return CMPT_OK!();\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            repDist = decCtx.reps[0];\n        }\n    } else {\n        CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        probSlot = (CmptLzGetIsRepG1Prob(probsMatrix) + mkState);\n        if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n            CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            repDist = decCtx.reps[1];\n        } else {\n            CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n            probSlot = (CmptLzGetIsRepG2Prob(probsMatrix) + mkState);\n            if CMPTLZ_IS_THE_BIT_0!(probSlot, range, rangeCode, rangeBound).as_bool() {\n                CMPTLZ_RANGE_UPDATE_0!(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n                repDist = decCtx.reps[CMPTLZ_REP2!()];\n            } else {\n                CMPTLZ_RANGE_UPDATE_1!(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n                repDist = decCtx.reps[CMPTLZ_REP3!()];\n                let tmp0 = CMPTLZ_REP3!();\n                decCtx.reps[tmp0];\n            }\n            decCtx.reps[CMPTLZ_REP2!()] = decCtx.reps[1];\n        }\n        decCtx.reps[1] = decCtx.reps[0];\n        decCtx.reps[0] = repDist;\n    }\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx.buf = bufToDec;\n    decCtx.state = if mkState < CMPTLZ_LIT_STATES!() { 8 } else { 11 };\n    probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n    repLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n    return CmptLzDecByDistAndLen(decCtx, repDist.cast(), (repLen + 2), dicPosLimit);\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408907509)\n    Finished `test` profile [optimized + debuginfo] target(s) in 2.42s\n     Running unittests src/lib.rs (target/debug/deps/my_proj-baa1ee44ab22c9ed)\nerror: test failed, to rerun pass `--lib`\n"
            },
            {
                "c_code": "static uint32_t CmptLzLitDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound)\n{\n    uint32_t decSym = 1;\n    uint32_t mkState = decCtx->state;\n    uint32_t procPos = decCtx->processedPos;\n    uint32_t checkDicSize = decCtx->checkDicSize;\n    uint32_t litCtx = decCtx->prop.litCtx;\n    uint32_t litPosMask = ((uint32_t)0x100 << decCtx->prop.litPos) - ((uint32_t)0x100 >> litCtx);\n    CmptLzDecProb *probLit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    const unsigned char *bufToDec = decCtx->buf;\n    unsigned char *dict = decCtx->dict;\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t dictPos = decCtx->dictPos;\n    uint32_t range = *pRange;\n    uint32_t rangeBound = *pRangeBound;\n    uint32_t rangeCode = *pRangeCode;\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0 || checkDicSize != 0)\n    {\n        probSlot += (uint32_t)CMPTLZ_REP3 *\n                    ((((procPos << 8) + dict[(dictPos == 0 ? dictBufSize : dictPos) - 1]) & litPosMask) << litCtx);\n    }\n    int i = 0;\n    if (mkState < CMPTLZ_LIT_STATES)\n    {\n        mkState -= (mkState < 4) ? mkState : 3;\n        for (i = 0; i < 8; i++)\n        {\n            CMPTLZ_NORMAL_BIT_DEC((probSlot + decSym), range, rangeCode, rangeBound, decSym);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        }\n    }\n    else\n    {\n        uint32_t bit;\n        uint32_t offset = 0x100;\n        uint32_t rep0 = decCtx->reps[0];\n        uint32_t matchSym = dict[dictPos - rep0 + ((dictPos < rep0) ? dictBufSize : 0)];\n        mkState -= (mkState < 10) ? CMPTLZ_REP3 : 6;\n        for (i = 0; i < 8; i++)\n        {\n            CMPTLZ_MATCH_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n        }\n    }\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    dict[dictPos++] = (uint8_t)decSym;\n    decCtx->processedPos += 1;\n    decCtx->state = mkState;\n    decCtx->dictPos = dictPos;\n    decCtx->buf = bufToDec;\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptLzLitDec(mut decCtx: Ptr<CmptLzDecCtx>, mut pRange: Ptr<u32>, mut pRangeCode: Ptr<u32>, mut pRangeBound: Ptr<u32>) -> u32 {\n    let mut decSym: u32 = 1;\n    let mut mkState: u32 = decCtx.state;\n    let mut procPos: u32 = decCtx.processedPos;\n    let mut checkDicSize: u32 = decCtx.checkDicSize;\n    let mut litCtx: u32 = decCtx.prop.litCtx.cast();\n    let mut litPosMask: u32 = ((0x100 as u32) << decCtx.prop.litPos) - ((0x100 as u32) >> litCtx);\n    let mut probLit: Ptr<CmptLzDecProb> = Default::default();\n    let mut probSlot: Ptr<CmptLzDecProb> = Default::default();\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx);\n    let mut bufToDec: Ptr<u8> = decCtx.buf;\n    let mut dict: Ptr<u8> = decCtx.dict;\n    let mut dictBufSize: usize = decCtx.dictBufSize;\n    let mut dictPos: usize = decCtx.dictPos;\n    let mut range: u32 = *pRange;\n    let mut rangeBound: u32 = *pRangeBound;\n    let mut rangeCode: u32 = *pRangeCode;\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0) || (checkDicSize != 0) {\n        probSlot += (CMPTLZ_REP3 as u32) *\n                    ((((procPos << 8) + dict[(if dictPos == 0 { dictBufSize } else { dictPos }) - 1].cast::<u32>()) & litPosMask) << litCtx);\n    }\n    let mut i: i32 = 0;\n    if (mkState < CMPTLZ_LIT_STATES) {\n        mkState -= if (mkState < 4) { mkState } else { 3 };\n        c_for!(; i < 8; i.suffix_plus_plus(); {\n            CMPTLZ_NORMAL_BIT_DEC!((probSlot + decSym.cast::<u16>()), range, rangeCode, rangeBound, decSym);\n            CMPTLZ_RANGE_NORMALIZE!(range, rangeCode, bufToDec);\n        });\n    } else {\n        let mut bit: u32 = Default::default();\n        let mut offset: u32 = 0x100;\n        let mut rep0: usize = decCtx.reps[0].cast::<usize>();\n        let mut matchSym: u32 = dict[dictPos - rep0 + (if (dictPos < rep0) { dictBufSize } else { 0 })].cast();\n        mkState -= if (mkState < 10) { CMPTLZ_REP3 } else { 6 };\n        c_for!(; i < 8; i.suffix_plus_plus(); {\n            CMPTLZ_MATCH_BIT_DEC!(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n        });\n    }\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    dict[dictPos] = decSym.cast::<u8>();\n    dictPos += 1;\n    decCtx.processedPos += 1;\n    decCtx.state = mkState;\n    decCtx.dictPos = dictPos;\n    decCtx.buf = bufToDec;\n    return CMPT_OK;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408917096)\nerror[E0423]: expected value, found macro `CMPTLZ_REP3`\n    --> src/src/cmptlz_c.rs:1693:22\n     |\n1693 |         probSlot += (CMPTLZ_REP3 as u32) *\n     |                      ^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_LIT_STATES`\n    --> src/src/cmptlz_c.rs:1697:19\n     |\n1697 |     if (mkState < CMPTLZ_LIT_STATES) {\n     |                   ^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_REP3`\n    --> src/src/cmptlz_c.rs:1708:40\n     |\n1708 |         mkState -= if (mkState < 10) { CMPTLZ_REP3 } else { 6 };\n     |                                        ^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPT_OK`\n    --> src/src/cmptlz_c.rs:1722:12\n     |\n1722 |     return CMPT_OK;\n     |            ^^^^^^^ not a value\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 4 previous errors\n"
            },
            {
                "c_code": "int CmptLzDecDirectProcess(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *bufLimit)\n{\n    uint32_t decRes;\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t procPos;\n    uint32_t mkState;\n    uint32_t posState;\n    uint32_t range = decCtx->range;\n    uint32_t rangeCode = decCtx->code;\n    uint32_t rangeBound = 0;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    do\n    {\n        procPos = decCtx->processedPos;\n        mkState = decCtx->state;\n        posState = CMPTLZ_CALC_POS_STATE(procPos, pbMask);\n        probSlot = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n            decRes = CmptLzLitDec(decCtx, &range, &rangeCode, &rangeBound);\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n            probSlot = CmptLzGetIsRepProb(probsMatrix) + mkState;\n            if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n                decRes = CmptLzMatchDec(decCtx, &range, &rangeCode, &rangeBound, dicPosLimit, posState);\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n                decRes = CmptLzRepDec(decCtx, &range, &rangeCode, &rangeBound, dicPosLimit, posState);\n            }\n            if (decRes != CMPT_OK)\n            {\n                break;\n            }\n        }\n    } while (decCtx->dictPos < dicPosLimit && decCtx->buf < bufLimit && decCtx->remainLen < CMPTLZ_MATCH_MAX_LEN);\n    decCtx->range = range;\n    decCtx->code = rangeCode;\n    return (int)decRes;\n}",
                "rust_code": "pub fn CmptLzDecDirectProcess(mut decCtx: Ptr<CmptLzDecCtx>, mut dicPosLimit: usize, mut bufLimit: Ptr<u8>) -> i32 {\n    let mut decRes: u32;\n    let mut pbMask: u32 = ((1 as u32) << decCtx.prop.posBits) - 1;\n    let mut procPos: u32;\n    let mut mkState: u32;\n    let mut posState: u32;\n    let mut range: u32 = decCtx.range;\n    let mut rangeCode: u32 = decCtx.code;\n    let mut rangeBound: u32 = 0;\n    let mut probSlot: Ptr<CmptLzDecProb>;\n    let mut probsMatrix: Ptr<CmptLzDecProb> = (CmptLzGetProbsMatrix)(decCtx);\n    c_do!({\n        procPos = decCtx.processedPos;\n        mkState = decCtx.state;\n        posState = CMPTLZ_CALC_POS_STATE(procPos, pbMask);\n        probSlot = (CmptLzGetIsMatchProb)(probsMatrix) + posState + mkState;\n        (CMPTLZ_RANGE_NORMALIZE)(range, rangeCode, decCtx.buf);\n        if (CMPTLZ_IS_THE_BIT_0)(probSlot, range, rangeCode, rangeBound) {\n            (CMPTLZ_RANGE_UPDATE_0)(probSlot, range, rangeBound);\n            (CMPTLZ_RANGE_NORMALIZE)(range, rangeCode, decCtx.buf);\n            decRes = (CmptLzLitDec)(decCtx, c_ref!(range), c_ref!(rangeCode), c_ref!(rangeBound));\n        } else {\n            (CMPTLZ_RANGE_UPDATE_1)(probSlot, range, rangeCode, rangeBound);\n            (CMPTLZ_RANGE_NORMALIZE)(range, rangeCode, decCtx.buf);\n            probSlot = (CmptLzGetIsRepProb)(probsMatrix) + mkState;\n            if (CMPTLZ_IS_THE_BIT_0)(probSlot, range, rangeCode, rangeBound) {\n                (CMPTLZ_RANGE_UPDATE_0)(probSlot, range, rangeBound);\n                (CMPTLZ_RANGE_NORMALIZE)(range, rangeCode, decCtx.buf);\n                decRes = (CmptLzMatchDec)(decCtx, c_ref!(range), c_ref!(rangeCode), c_ref!(rangeBound), dicPosLimit, posState);\n            } else {\n                (CMPTLZ_RANGE_UPDATE_1)(probSlot, range, rangeCode, rangeBound);\n                (CMPTLZ_RANGE_NORMALIZE)(range, rangeCode, decCtx.buf);\n                decRes = (CmptLzRepDec)(decCtx, c_ref!(range), c_ref!(rangeCode), c_ref!(rangeBound), dicPosLimit, posState);\n            }\n            if (decRes != CMPT_OK) {\n                break;\n            }\n        }\n    } while (decCtx.dictPos < dicPosLimit) && (decCtx.buf < bufLimit) && (decCtx.remainLen < CMPTLZ_MATCH_MAX_LEN));\n    decCtx.range = range;\n    decCtx.code = rangeCode;\n    return decRes.cast::<i32>();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408917511)\nerror[E0423]: expected value, found macro `CMPTLZ_MATCH_MAX_LEN`\n    --> src/src/cmptlz_c.rs:1772:94\n     |\n1772 |     } while (decCtx.dictPos < dicPosLimit) && (decCtx.buf < bufLimit) && (decCtx.remainLen < CMPTLZ_MATCH_MAX_LEN));\n     |                                                                                              ^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_RANGE_NORMALIZE`\n    --> src/src/cmptlz_c.rs:1750:10\n     |\n1750 |         (CMPTLZ_RANGE_NORMALIZE)(range, rangeCode, decCtx.buf);\n     |          ^^^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_IS_THE_BIT_0`\n    --> src/src/cmptlz_c.rs:1751:13\n     |\n1751 |         if (CMPTLZ_IS_THE_BIT_0)(probSlot, range, rangeCode, rangeBound) {\n     |             ^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_RANGE_UPDATE_0`\n    --> src/src/cmptlz_c.rs:1752:14\n     |\n1752 |             (CMPTLZ_RANGE_UPDATE_0)(probSlot, range, rangeBound);\n     |              ^^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_RANGE_NORMALIZE`\n    --> src/src/cmptlz_c.rs:1753:14\n     |\n1753 |             (CMPTLZ_RANGE_NORMALIZE)(range, rangeCode, decCtx.buf);\n     |              ^^^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_RANGE_UPDATE_1`\n    --> src/src/cmptlz_c.rs:1756:14\n     |\n1756 |             (CMPTLZ_RANGE_UPDATE_1)(probSlot, range, rangeCode, rangeBound);\n     |              ^^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_RANGE_NORMALIZE`\n    --> src/src/cmptlz_c.rs:1757:14\n     |\n1757 |             (CMPTLZ_RANGE_NORMALIZE)(range, rangeCode, decCtx.buf);\n     |              ^^^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_IS_THE_BIT_0`\n    --> src/src/cmptlz_c.rs:1759:17\n     |\n1759 |             if (CMPTLZ_IS_THE_BIT_0)(probSlot, range, rangeCode, rangeBound) {\n     |                 ^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_RANGE_UPDATE_0`\n    --> src/src/cmptlz_c.rs:1760:18\n     |\n1760 |                 (CMPTLZ_RANGE_UPDATE_0)(probSlot, range, rangeBound);\n     |                  ^^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_RANGE_NORMALIZE`\n    --> src/src/cmptlz_c.rs:1761:18\n     |\n1761 |                 (CMPTLZ_RANGE_NORMALIZE)(range, rangeCode, decCtx.buf);\n     |                  ^^^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_RANGE_UPDATE_1`\n    --> src/src/cmptlz_c.rs:1764:18\n     |\n1764 |                 (CMPTLZ_RANGE_UPDATE_1)(probSlot, range, rangeCode, rangeBound);\n     |                  ^^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPTLZ_RANGE_NORMALIZE`\n    --> src/src/cmptlz_c.rs:1765:18\n     |\n1765 |                 (CMPTLZ_RANGE_NORMALIZE)(range, rangeCode, decCtx.buf);\n     |                  ^^^^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPT_OK`\n    --> src/src/cmptlz_c.rs:1768:27\n     |\n1768 |             if (decRes != CMPT_OK) {\n     |                           ^^^^^^^ not a value\n\nerror[E0423]: expected function, tuple struct or tuple variant, found macro `CMPTLZ_CALC_POS_STATE`\n    --> src/src/cmptlz_c.rs:1748:20\n     |\n1748 |         posState = CMPTLZ_CALC_POS_STATE(procPos, pbMask);\n     |                    ^^^^^^^^^^^^^^^^^^^^^ not a function, tuple struct or tuple variant\n     |\nhelp: use `!` to invoke the macro\n     |\n1748 |         posState = CMPTLZ_CALC_POS_STATE!(procPos, pbMask);\n     |                                         +\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 14 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 14 previous errors\n"
            },
            {
                "c_code": "static int CmptLzTryDecLitPacket(CmptLzDecCtx *decCtx, uint32_t range, uint32_t rangeCode, uint32_t rangeBound,\n                                 const unsigned char *bufTryDec, const unsigned char **pbufLimit)\n{\n    CmptLzDecProb *probBit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    uint32_t procPos = decCtx->processedPos;\n    uint32_t litPosMask = ((uint32_t)0x100 << decCtx->prop.litPos) - ((uint32_t)0x100 >> decCtx->prop.litCtx);\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t dicPos = decCtx->dictPos;\n    const unsigned char *dict = decCtx->dict;\n    const unsigned char *bufLimit = *pbufLimit;\n    if (decCtx->dictPos >= decCtx->dictBufSize)\n    {\n        return CMPT_ERROR_DATA;\n    }\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0 || decCtx->checkDicSize != 0)\n    {\n        probSlot += (uint32_t)3 * ((((procPos << 8) + dict[(dicPos == 0 ? dictBufSize : dicPos) - 1]) & litPosMask)\n                                   << decCtx->prop.litCtx);\n    }\n    uint32_t decSym = 1;\n    if (decCtx->state < CMPTLZ_LIT_STATES)\n    {\n        do\n        {\n            probBit = probSlot + decSym;\n            CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        } while (decSym < 0x100);\n    }\n    else\n    {\n        uint32_t bit;\n        uint32_t matchSym = dict[dicPos - decCtx->reps[0] + ((dicPos < decCtx->reps[0]) ? dictBufSize : 0)];\n        uint32_t offset = 0x100;\n        do\n        {\n            matchSym <<= 1;\n            bit = offset;\n            offset &= matchSym;\n            probBit = probSlot + (offset + bit + decSym);\n            CMPTLZ_MATCH_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        } while (decSym < 0x100);\n    }\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptLzTryDecLitPacket(mut decCtx: Ptr<CmptLzDecCtx>, mut range: u32, mut rangeCode: u32, mut rangeBound: u32, mut bufTryDec: Ptr<u8>, mut pbufLimit: Ptr<Ptr<u8>>) -> i32 {\n    let mut probBit: Ptr<CmptLzDecProb> = Default::default();\n    let mut probSlot: Ptr<CmptLzDecProb> = Default::default();\n    let mut probsMatrix: Ptr<CmptLzDecProb> = CmptLzGetProbsMatrix(decCtx);\n    let mut procPos: u32 = decCtx.processedPos;\n    let mut litPosMask: u32 = ((0x100 as u32) << decCtx.prop.litPos) - ((0x100 as u32) >> decCtx.prop.litCtx);\n    let mut dictBufSize: usize = decCtx.dictBufSize;\n    let mut dicPos: usize = decCtx.dictPos;\n    let mut dict: Ptr<u8> = decCtx.dict;\n    let mut bufLimit: Ptr<u8> = *pbufLimit;\n    if (decCtx.dictPos >= decCtx.dictBufSize) {\n        return CMPT_ERROR_DATA!();\n    }\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0) || (decCtx.checkDicSize != 0) {\n        probSlot += (3 as u32) * ((((procPos << 8) + dict[(if dicPos == 0 { dictBufSize } else { dicPos }) - 1]) & litPosMask) << decCtx.prop.litCtx);\n    }\n    let mut decSym: u32 = 1;\n    if (decCtx.state < CMPTLZ_LIT_STATES!()) {\n        c_do!({\n            probBit = (probSlot + decSym);\n            CMPTLZ_SINGLE_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n        } while decSym < 0x100);\n    } else {\n        let mut bit: u32 = Default::default();\n        let tmp0 = dicPos - decCtx.reps[0;\n        let mut matchSym: u32 = dict[tmp0] + (if dicPos < decCtx.reps[0] { dictBufSize } else { 0 })];\n        let mut offset: u32 = 0x100;\n        c_do!({\n            matchSym <<= 1;\n            bit = offset;\n            offset &= matchSym;\n            probBit = (probSlot + (offset + bit + decSym));\n            CMPTLZ_MATCH_BIT_TRY_DEC!(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n        } while decSym < 0x100);\n    }\n    CMPTLZ_RANGE_TRY_NORMALIZE!(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408922688)\nerror: expected one of `.`, `?`, `]`, or an operator, found `;`\n    --> src/src/cmptlz_c.rs:1913:42\n     |\n1913 |         let tmp0 = dicPos - decCtx.reps[0;\n     |                                          ^ expected one of `.`, `?`, `]`, or an operator\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:1902:54\n     |\n1902 | ...) * ((((procPos << 8) + dict[(if dicPos == 0 { dictBufSize } else { dicPos }) - 1]) & litPosMask) << decCtx.prop.litCtx);\n     |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `u8`\n\nerror[E0277]: cannot add `u8` to `u32`\n    --> src/src/cmptlz_c.rs:1902:52\n     |\n1902 | ...   probSlot += (3 as u32) * ((((procPos << 8) + dict[(if dicPos == 0 { dictBufSize } else { dicPos }) - 1]) & litPosMask) << decCtx.pr...\n     |                                                  ^ no implementation for `u32 + u8`\n     |\n     = help: the trait `std::ops::Add<u8>` is not implemented for `u32`\n     = help: the following other types implement trait `std::ops::Add<Rhs>`:\n               `&u32` implements `std::ops::Add<u32>`\n               `&u32` implements `std::ops::Add`\n               `u32` implements `std::ops::Add<&u32>`\n               `u32` implements `std::ops::Add<types::num::Num>`\n               `u32` implements `std::ops::Add`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 3 previous errors\n"
            },
            {
                "c_code": "int CmptEncodeOneBlock(CmptLzEncCtx *encCtx)\n{\n    CmptMfCtx *mf = encCtx->mfCtx;\n    uint32_t nowpos32 = encCtx->nowpos64;\n    uint32_t startpos = nowpos32;\n    uint32_t backRes, lenRes;\n    int shiftRes = CMPT_OK;\n    while (true)\n    {\n        CmptlzDp(encCtx, mf, nowpos32);\n        backRes = encCtx->backRes;\n        lenRes = encCtx->lenRes;\n        switch (backRes)\n        {\n        case CMPTLZ_UINT32_MAX:\n            shiftRes = CmptlzEncLit(encCtx, mf, nowpos32);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 0:\n            shiftRes = CmptEncShortOrRep0(encCtx, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 1:\n            shiftRes = CmptlzEncLongRep(encCtx, 1, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 2:\n            shiftRes = CmptlzEncLongRep(encCtx, 2, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 3:\n            shiftRes = CmptlzEncLongRep(encCtx, 3, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        default:\n            shiftRes = CmptlzEncNormalMatch(encCtx, nowpos32, backRes, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        }\n        nowpos32 += lenRes;\n        mf->mfStart += lenRes;\n        mf->readAhead -= lenRes;\n        if (mf->readAhead == 0)\n        {\n            CmptPriceCheck(encCtx);\n            if (mf->srcLen <= mf->mfStart)\n            {\n                break;\n            }\n            if (nowpos32 - startpos >= CMPT_ONE_BLOCK_MAX_SIZE)\n            {\n                encCtx->nowpos64 += nowpos32 - startpos;\n                return 0;\n            }\n        }\n    }\n    encCtx->nowpos64 += nowpos32 - startpos;\n    return CmptlzFlush(encCtx);\n}",
                "rust_code": "pub fn CmptEncodeOneBlock(mut encCtx: Ptr<CmptLzEncCtx>) -> i32 {\n    let mut mf: Ptr<CmptMfCtx> = encCtx.mfCtx;\n    let mut nowpos32: u32 = encCtx.nowpos64.cast();\n    let mut startpos: u32 = nowpos32;\n    let mut backRes: u32 = Default::default();\n    let mut lenRes: u32 = Default::default();\n    let mut shiftRes: i32 = CMPT_OK!();\n    loop {\n        CmptlzDp(encCtx, mf, nowpos32);\n        backRes = encCtx.backRes;\n        lenRes = encCtx.lenRes;\n        c_switch!(backRes, {\n            CMPTLZ_UINT32_MAX!() => {\n                shiftRes = CmptlzEncLit(encCtx, mf, nowpos32);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n            0 => {\n                shiftRes = CmptEncShortOrRep0(encCtx, nowpos32, lenRes);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n            1 => {\n                shiftRes = CmptlzEncLongRep(encCtx, 1, nowpos32, lenRes);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n            2 => {\n                shiftRes = CmptlzEncLongRep(encCtx, 2, nowpos32, lenRes);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n            3 => {\n                shiftRes = CmptlzEncLongRep(encCtx, 3, nowpos32, lenRes);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n            _ => {\n                shiftRes = CmptlzEncNormalMatch(encCtx, nowpos32, backRes, lenRes);\n                CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n                break;\n            },\n        });\n        nowpos32 += lenRes;\n        mf.mfStart += lenRes;\n        mf.readAhead -= lenRes;\n        if (mf.readAhead == 0) {\n            CmptPriceCheck(encCtx);\n            if (mf.srcLen <= mf.mfStart) {\n                break;\n            }\n            if (nowpos32 - startpos >= CMPT_ONE_BLOCK_MAX_SIZE!()) {\n                encCtx.nowpos64 += (nowpos32 - startpos).cast();\n                return 0;\n            }\n        }\n    }\n    encCtx.nowpos64 += (nowpos32 - startpos).cast();\n    return CmptlzFlush(encCtx);\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750408992724)\nerror: no rules expected `,`\n    --> src/src/cmptlz_c.rs:2329:26\n     |\n2329 |         c_switch!(backRes, {\n     |                          ^ no rules expected this token in macro call\n     |\n    ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n     |\n3    | macro_rules! c_switch {\n     | --------------------- when calling this macro\n     |\nnote: while trying to match `;`\n    --> src/translation_utils/c_alignment/c_switch.rs:5:17\n     |\n5    |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n     |                 ^\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:2366:30\n     |\n2366 |             if (mf.srcLen <= mf.mfStart) {\n     |                 ---------    ^^^^^^^^^^ expected `usize`, found `u32`\n     |                 |\n     |                 expected because this is `usize`\n     |\nhelp: you can convert a `u32` to a `usize` and panic if the converted value doesn't fit\n     |\n2366 |             if (mf.srcLen <= mf.mfStart.try_into().unwrap()) {\n     |                                        ++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "static uint32_t CmptlzDpInit(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t position)\n{\n    const uint32_t niceLen = mf->niceLen;\n    uint32_t lenMain;\n    uint32_t matchesCount = 0;\n    if (mf->readAhead == 0)\n    {\n        lenMain = CmptlzMatchFinder(mf, &matchesCount, encCtx->matches);\n    }\n    else\n    {\n        lenMain = encCtx->longestMatchLen;\n        matchesCount = encCtx->matchesCount;\n    }\n    const uint8_t *const buf = CmptMfGetPtr(mf) - 1;\n    const uint32_t bufAvail = CMPTLZ_FIND_MIN(CmptMfAvail(mf) + 1, CMPT_MF_LONGEST_MATCH);\n    if (bufAvail < CMPTLZ_MATCH_LEN_MIN)\n    {\n        encCtx->backRes = CMPTLZ_UINT32_MAX;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n    uint32_t repLens[CMPTLZ_NUM_REPS];\n    uint32_t repMaxIndex = 0;\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        const uint8_t *const bufBack = buf - encCtx->reps[i] - 1;\n        if (NOT_EQUAL_2_BYTES(buf, bufBack))\n        {\n            repLens[i] = 0;\n            continue;\n        }\n        repLens[i] = CmptMemCmpLenSafe(buf, bufBack, CMPTLZ_MATCH_LEN_MIN, bufAvail);\n        if (repLens[i] > repLens[repMaxIndex])\n        {\n            repMaxIndex = i;\n        }\n    }\n    if (repLens[repMaxIndex] >= niceLen)\n    {\n        encCtx->backRes = repMaxIndex;\n        encCtx->lenRes = repLens[repMaxIndex];\n        CmptlzMatchSkiper(mf, repLens[repMaxIndex] - 1);\n        return CMPTLZ_UINT32_MAX;\n    }\n    if (lenMain >= niceLen)\n    {\n        encCtx->backRes = encCtx->matches[matchesCount - 1].dist + CMPTLZ_NUM_REPS;\n        encCtx->lenRes = lenMain;\n        CmptlzMatchSkiper(mf, lenMain - 1);\n        return CMPTLZ_UINT32_MAX;\n    }\n    const uint8_t currentByte = *buf;\n    const uint8_t matchByte = *(buf - encCtx->reps[0] - 1);\n    const uint32_t lenEnd = CMPTLZ_FIND_MAX(lenMain, repLens[repMaxIndex]);\n    if ((lenEnd < CMPTLZ_MATCH_LEN_MIN) && (currentByte != matchByte))\n    {\n        encCtx->backRes = CMPTLZ_UINT32_MAX;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n    encCtx->opts[0].state = encCtx->state;\n    const uint32_t posState = position & encCtx->posMask;\n    encCtx->litMarcov.pos = position;\n    encCtx->litMarcov.prevByte = *(buf - 1);\n    bool isLiteralState = (encCtx->state < 7);\n    bool isMatchMode = !isLiteralState;\n    encCtx->opts[1].price = CmptPriceBit0(encCtx, encCtx->isMatch[encCtx->state][posState]) +\n                            CmptPriceLiteral(encCtx, isMatchMode, matchByte, currentByte);\n    encCtx->opts[1].backPrev = CMPTLZ_UINT32_MAX;\n    const uint32_t matchPrice = CmptPriceBit1(encCtx, encCtx->isMatch[encCtx->state][posState]);\n    const uint32_t repMatchPrice = matchPrice + CmptPriceBit1(encCtx, encCtx->isRep[encCtx->state]);\n    if (matchByte == currentByte)\n    {\n        CmptlzDpInitShortRep(encCtx, repMatchPrice, posState);\n    }\n    if (lenEnd < CMPTLZ_MATCH_LEN_MIN)\n    {\n        encCtx->backRes = encCtx->opts[1].backPrev;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n    encCtx->opts[1].posPrev = 0;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->opts[0].backs[i] = encCtx->reps[i];\n    }\n    uint32_t len = lenEnd;\n    do\n    {\n        encCtx->opts[len].price = CMPT_INFINITY_PRICE;\n        len--;\n    } while (len >= CMPTLZ_MATCH_LEN_MIN);\n    CmptlzDpInitLongRep(encCtx, repLens, repMatchPrice, posState);\n    const uint32_t normalMatchPrice = matchPrice + CmptPriceBit0(encCtx, encCtx->isRep[encCtx->state]);\n    len = (repLens[0] > CMPTLZ_MATCH_LEN_MIN) ? repLens[0] + 1 : CMPTLZ_MATCH_LEN_MIN;\n    if (len <= lenMain)\n    {\n        CmptlzDpInitMatch(encCtx, matchesCount, normalMatchPrice, posState, len);\n    }\n    return lenEnd;\n}",
                "rust_code": "pub fn CmptlzDpInit(mut encCtx: Ptr<CmptLzEncCtx>, mut mf: Ptr<CmptMfCtx>, mut position: u32) -> u32 {\n    let niceLen: u32 = mf.niceLen;\n    let mut lenMain: u32;\n    let mut matchesCount: u32 = 0;\n    if (mf.readAhead == 0) {\n        lenMain = CmptlzMatchFinder(mf, c_ref!(matchesCount), encCtx.matches.cast());\n    } else {\n        lenMain = encCtx.longestMatchLen;\n        matchesCount = encCtx.matchesCount;\n    }\n    let buf: Ptr<u8> = CmptMfGetPtr(mf) - 1;\n    let bufAvail: u32 = CMPTLZ_FIND_MIN!(CmptMfAvail(mf) + 1, CMPT_MF_LONGEST_MATCH!());\n    if (bufAvail < CMPTLZ_MATCH_LEN_MIN!()) {\n        encCtx.backRes = CMPTLZ_UINT32_MAX!();\n        encCtx.lenRes = 1;\n        return CMPTLZ_UINT32_MAX!();\n    }\n    let mut repLens: Array<u32, { CMPTLZ_NUM_REPS!() }> = Default::default();\n    let mut repMaxIndex: u32 = 0;\n    let mut i: u32;\n    c_for!(i = 0; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_plus(); {\n        let bufBack: Ptr<u8> = buf - encCtx.reps[i] - 1;\n        if NOT_EQUAL_2_BYTES!(buf, bufBack) {\n            repLens[i] = 0;\n            continue;\n        }\n        repLens[i] = CmptMemCmpLenSafe(buf, bufBack, CMPTLZ_MATCH_LEN_MIN!(), bufAvail);\n        if (repLens[i] > repLens[repMaxIndex]) {\n            repMaxIndex = i;\n        }\n    });\n    if (repLens[repMaxIndex] >= niceLen) {\n        encCtx.backRes = repMaxIndex;\n        encCtx.lenRes = repLens[repMaxIndex];\n        CmptlzMatchSkiper(mf, (repLens[repMaxIndex] - 1));\n        return CMPTLZ_UINT32_MAX!();\n    }\n    if (lenMain >= niceLen) {\n        encCtx.backRes = (encCtx.matches[matchesCount - 1].dist + CMPTLZ_NUM_REPS!());\n        encCtx.lenRes = lenMain;\n        CmptlzMatchSkiper(mf, (lenMain - 1));\n        return CMPTLZ_UINT32_MAX!();\n    }\n    let currentByte: u8 = *buf;\n    let matchByte: u8 = *(buf - encCtx.reps[0] - 1);\n    let lenEnd: u32 = CMPTLZ_FIND_MAX!(lenMain, repLens[repMaxIndex]);\n    if (lenEnd < CMPTLZ_MATCH_LEN_MIN!()) && (currentByte != matchByte) {\n        encCtx.backRes = CMPTLZ_UINT32_MAX!();\n        encCtx.lenRes = 1;\n        return CMPTLZ_UINT32_MAX!();\n    }\n    encCtx.opts[0].state = encCtx.state;\n    let posState: u32 = position & encCtx.posMask;\n    encCtx.litMarcov.pos = position;\n    encCtx.litMarcov.prevByte = *(buf - 1);\n    let isLiteralState: bool = (encCtx.state < 7);\n    let isMatchMode: bool = !isLiteralState;\n    encCtx.opts[1].price = (CmptPriceBit0(encCtx, encCtx.isMatch[encCtx.state][posState]) +\n                            CmptPriceLiteral(encCtx, isMatchMode, matchByte.cast(), currentByte.cast()));\n    encCtx.opts[1].backPrev = CMPTLZ_UINT32_MAX!();\n    let tmp0 = encCtx.state;\n    let matchPrice: u32 = CmptPriceBit1(encCtx, encCtx.isMatch[tmp0][posState]);\n    let repMatchPrice: u32 = (matchPrice + CmptPriceBit1(encCtx, encCtx.isRep[encCtx.state]));\n    if (matchByte == currentByte) {\n        CmptlzDpInitShortRep(encCtx, repMatchPrice, posState);\n    }\n    if (lenEnd < CMPTLZ_MATCH_LEN_MIN!()) {\n        encCtx.backRes = encCtx.opts[1].backPrev;\n        encCtx.lenRes = 1;\n        return CMPTLZ_UINT32_MAX!();\n    }\n    encCtx.opts[1].posPrev = 0;\n    c_for!(i = 0; i < CMPTLZ_NUM_REPS!(); i.suffix_plus_plus(); {\n        encCtx.opts[0].backs[i] = encCtx.reps[i];\n    });\n    let mut len: u32 = lenEnd;\n    c_do!({\n        encCtx.opts[len].price = CMPT_INFINITY_PRICE!();\n        len.suffix_minus_minus();\n    } while len >= CMPTLZ_MATCH_LEN_MIN!());\n    CmptlzDpInitLongRep(encCtx, repLens.cast(), repMatchPrice, posState);\n    let normalMatchPrice: u32 = (matchPrice + CmptPriceBit0(encCtx, encCtx.isRep[encCtx.state]));\n    len = if repLens[0] > CMPTLZ_MATCH_LEN_MIN!() { repLens[0] + 1 } else { CMPTLZ_MATCH_LEN_MIN!() };\n    if (len <= lenMain) {\n        CmptlzDpInitMatch(encCtx, matchesCount, normalMatchPrice, posState, len);\n    }\n    return lenEnd;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750409013394)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:2525:33\n     |\n2525 |     encCtx.litMarcov.prevByte = *(buf - 1);\n     |     -------------------------   ^^^^^^^^^^ expected `u32`, found `u8`\n     |     |\n     |     expected due to the type of this binding\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "int CmptMfPrepare(CmptLzEncCtx *encCtx, const uint8_t *src, size_t srcLen, CmptLzMemHook *alloc)\n{\n    CmptMfCtx *mf = alloc->CmptLzAlloc(CMPTLZ_MF_CCTX_HANDLE, sizeof(CmptMfCtx));\n    if (mf == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    memset_s(mf, sizeof(CmptMfCtx), 0, sizeof(CmptMfCtx));\n    encCtx->mfCtx = mf;\n    mf->cycleSize = encCtx->dicSize + 1;\n    uint32_t hashMask = encCtx->dicSize - 1;\n    CMPT_HASH_MASK_CALC(hashMask);\n    mf->hashMask = hashMask;\n    ++hashMask;\n    hashMask += CMPTLZ_HASH_2_SIZE;\n    hashMask += CMPTLZ_HASH_3_SIZE;\n    mf->hashCount = hashMask;\n    mf->sonsCount = mf->cycleSize * 2;\n    mf->hash = NULL;\n    mf->son = NULL;\n    mf->hash = alloc->CmptLzAlloc(CMPTLZ_MF_HASH_HANDLE, mf->hashCount * sizeof(uint32_t));\n    memset_s(mf->hash, mf->hashCount * sizeof(uint32_t), 0, mf->hashCount * sizeof(uint32_t));\n    if (mf->hash == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    mf->son = alloc->CmptLzAlloc(CMPTLZ_MF_SON_HANDLE, mf->sonsCount * sizeof(uint32_t));\n    memset_s(mf->son, mf->sonsCount * sizeof(uint32_t), 0, mf->sonsCount * sizeof(uint32_t));\n    if (mf->son == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    CmptlzMfGenHashTable(mf);\n    mf->srcStart = src;\n    mf->srcLen = srcLen;\n    mf->offset = mf->cycleSize;\n    mf->niceLen = encCtx->numFastBytes;\n    mf->depth = CMPT_MF_BASE_DEPTH + mf->niceLen / 2;\n    return 0;\n}",
                "rust_code": "pub fn CmptMfPrepare(mut encCtx: Ptr<CmptLzEncCtx>, mut src: Ptr<u8>, mut srcLen: usize, mut alloc: Ptr<CmptLzMemHook>) -> i32 {\n    let mut mf: Ptr<CmptMfCtx> = (alloc.CmptLzAlloc)(CMPTLZ_MF_CCTX_HANDLE!(), c_sizeof!(CmptMfCtx)).cast::<Ptr<CmptMfCtx>>();\n    if (mf == NULL!()) {\n        return CMPT_ENC_MF_INIT_FAIL!();\n    }\n    c_memset_s!(mf, c_sizeof!(CmptMfCtx), 0, c_sizeof!(CmptMfCtx)).cast::<Void>();\n    encCtx.mfCtx = mf;\n    mf.cycleSize = encCtx.dicSize + 1;\n    let mut hashMask: u32 = encCtx.dicSize - 1;\n    CMPT_HASH_MASK_CALC!(hashMask);\n    mf.hashMask = hashMask;\n    hashMask += 1;\n    hashMask += CMPTLZ_HASH_2_SIZE!();\n    hashMask += CMPTLZ_HASH_3_SIZE!();\n    mf.hashCount = hashMask;\n    mf.sonsCount = mf.cycleSize * 2;\n    mf.hash = NULL!();\n    mf.son = NULL!();\n    mf.hash = (alloc.CmptLzAlloc)(CMPTLZ_MF_HASH_HANDLE!(), (mf.hashCount * c_sizeof!(u32)).try_into().unwrap()).cast::<Ptr<u32>>();\n    c_memset_s!(mf.hash, (mf.hashCount * c_sizeof!(u32)).try_into().unwrap(), 0, (mf.hashCount * c_sizeof!(u32)).try_into().unwrap()).cast::<Void>();\n    if (mf.hash == NULL!()) {\n        return CMPT_ENC_MF_INIT_FAIL!();\n    }\n    mf.son = (alloc.CmptLzAlloc)(CMPTLZ_MF_SON_HANDLE!(), (mf.sonsCount * c_sizeof!(u32)).try_into().unwrap()).cast::<Ptr<u32>>();\n    c_memset_s!(mf.son, (mf.sonsCount * c_sizeof!(u32)).try_into().unwrap(), 0, (mf.sonsCount * c_sizeof!(u32)).try_into().unwrap()).cast::<Void>();\n    if (mf.son == NULL!()) {\n        return CMPT_ENC_MF_INIT_FAIL!();\n    }\n    CmptlzMfGenHashTable(mf);\n    mf.srcStart = src;\n    mf.srcLen = srcLen;\n    mf.offset = mf.cycleSize;\n    mf.niceLen = encCtx.numFastBytes;\n    mf.depth = CMPT_MF_BASE_DEPTH!() + mf.niceLen / 2;\n    return 0;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750409117567)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:2985:80\n     |\n2985 |     let mut mf: Ptr<CmptMfCtx> = (alloc.CmptLzAlloc)(CMPTLZ_MF_CCTX_HANDLE!(), c_sizeof!(CmptMfCtx)).cast::<Ptr<CmptMfCtx>>();\n     |                                  -------------------                           ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `Num`\n     |                                  |\n     |                                  arguments to this function are incorrect\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "static uint32_t CmptPriceOneBit(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob, uint32_t curbit)\n{\n    return encCtx->priceRootTable[(bit0Prob ^ ((uint32_t)(0 - curbit) & (CMPTLZ_PROB_MAX_NUM - 1))) >>\n                                  CMPT_PRICE_BITS_MOVING_NUM];\n}",
                "rust_code": "pub fn CmptPriceOneBit(mut encCtx: Ptr<CmptLzEncCtx>, mut bit0Prob: CmptlzProb, mut curbit: u32) -> u32 {\n    let tmp0 = ((bit0Prob.cast::<u32>() ^ ((0 - curbit).cast::<u32>() & (CMPTLZ_PROB_MAX_NUM.cast::<u32>() - 1))) >> CMPT_PRICE_BITS_MOVING_NUM.cast::<u32>()).cast::<usize>();\n    return encCtx.priceRootTable[tmp0];\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750409152490)\nerror[E0423]: expected value, found macro `CMPTLZ_PROB_MAX_NUM`\n    --> src/src/cmptlz_c.rs:3222:74\n     |\n3222 |     let tmp0 = ((bit0Prob.cast::<u32>() ^ ((0 - curbit).cast::<u32>() & (CMPTLZ_PROB_MAX_NUM.cast::<u32>() - 1))) >> CMPT_PRICE_BITS_MOVI...\n     |                                                                          ^^^^^^^^^^^^^^^^^^^ not a value\n\nerror[E0423]: expected value, found macro `CMPT_PRICE_BITS_MOVING_NUM`\n    --> src/src/cmptlz_c.rs:3222:118\n     |\n3222 | ... & (CMPTLZ_PROB_MAX_NUM.cast::<u32>() - 1))) >> CMPT_PRICE_BITS_MOVING_NUM.cast::<u32>()).cast::<usize>();\n     |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ not a value\n\nFor more information about this error, try `rustc --explain E0423`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "void CmptPriceGenDistTable(CmptLzEncCtx *encCtx)\n{\n    uint32_t distState = 0;\n    do\n    {\n        uint32_t *const tmpPriceDistSlot = encCtx->priceDistSlotTable[distState];\n        for (uint32_t i = 0; i < encCtx->distTableSize; i++)\n        {\n            tmpPriceDistSlot[i] = CmptPriceSymbol(encCtx, encCtx->probDistSlot[distState], CMPTLZ_DIST_SLOT_BITS, i);\n        }\n        for (uint32_t i = 14; i < encCtx->distTableSize; i++)\n        {\n            tmpPriceDistSlot[i] += CmptPriceOneBitDirect((i >> 1) - 1 - CMPTLZ_ALIGN_BITS);\n        }\n        for (uint32_t i = 0; i < 4; i++)\n        {\n            encCtx->priceDistTable[distState][i] = tmpPriceDistSlot[i];\n        }\n        distState++;\n    } while (distState < CMPTLZ_DIST_STATE_TOTAL);\n    for (uint32_t i = 4; i < 128; i++)\n    {\n        uint32_t distSlot = PosSloter(i);\n        uint32_t footerBits = (distSlot >> 1) - 1;\n        uint32_t base = (2 | (distSlot & 1)) << footerBits;\n        uint32_t price =\n            CmptPriceSymbolReverse(encCtx, encCtx->probDistSpecial + base - distSlot - 1, footerBits, i - base);\n        for (distState = 0; distState < 4; distState++)\n        {\n            encCtx->priceDistTable[distState][i] = price + encCtx->priceDistSlotTable[distState][distSlot];\n        }\n    }\n    encCtx->matchPriceCount = 0;\n}",
                "rust_code": "pub fn CmptPriceGenDistTable(mut encCtx: Ptr<CmptLzEncCtx>) {\n    let mut distState: u32 = 0;\n    c_do!({\n        let mut tmpPriceDistSlot: Ptr<u32> = encCtx.priceDistSlotTable[distState].cast();\n        c_for!(let mut i: u32 = 0; i < encCtx.distTableSize; i.suffix_plus_plus(); {\n            tmpPriceDistSlot[i] = CmptPriceSymbol(encCtx, encCtx.probDistSlot[distState].cast(), CMPTLZ_DIST_SLOT_BITS!(), i);\n        });\n        c_for!(let mut i: u32 = 14; i < encCtx.distTableSize; i.suffix_plus_plus(); {\n            tmpPriceDistSlot[i] += CmptPriceOneBitDirect(((i >> 1) - 1 - CMPTLZ_ALIGN_BITS!()));\n        });\n        c_for!(let mut i: u32 = 0; i < 4; i.suffix_plus_plus(); {\n            encCtx.priceDistTable[distState][i] = tmpPriceDistSlot[i];\n        });\n        distState.suffix_plus_plus();\n    } while distState < CMPTLZ_DIST_STATE_TOTAL!());\n    c_for!(let mut i: u32 = 4; i < 128; i.suffix_plus_plus(); {\n        let mut distSlot: u32 = PosSloter(i);\n        let mut footerBits: u32 = ((distSlot >> 1) - 1);\n        let mut base: u32 = ((2 | (distSlot & 1)) << footerBits);\n        let mut price: u32 = CmptPriceSymbolReverse(encCtx, (encCtx.probDistSpecial + base - distSlot - 1), footerBits, (i - base));\n        c_for!(distState = 0; distState < 4; distState.suffix_plus_plus(); {\n            encCtx.priceDistTable[distState][i] = (price + encCtx.priceDistSlotTable[distState][distSlot]);\n        });\n    });\n    encCtx.matchPriceCount = 0;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750409176505)\nerror[E0369]: cannot add `u32` to `types::array::Array<u16, 128>`\n    --> src/src/cmptlz_c.rs:3303:85\n     |\n3303 |         let mut price: u32 = CmptPriceSymbolReverse(encCtx, (encCtx.probDistSpecial + base - distSlot - 1), footerBits, (i - base));\n     |                                                              ---------------------- ^ ---- u32\n     |                                                              |\n     |                                                              types::array::Array<u16, 128>\n     |\nnote: an implementation of `std::ops::Add<u32>` might be missing for `types::array::Array<u16, 128>`\n    --> src/translation_utils/types/array.rs:5:1\n     |\n5    | pub struct Array<T, const N: usize>(pub [T; N]);\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `std::ops::Add<u32>`\nnote: the trait `std::ops::Add` must be implemented\n    --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/ops/arith.rs:78:1\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "void CmptPriceGenLenTable(CmptLzEncCtx *encCtx, CmptLenEncoder *lenEncoder)\n{\n    const uint32_t numPosStates = 1 << encCtx->posBits;\n    uint32_t b;\n    uint32_t prob = lenEncoder->low[0];\n    uint32_t a, c;\n    uint32_t posState;\n    b = CmptPriceBit1(encCtx, prob);\n    a = CmptPriceBit0(encCtx, prob);\n    c = b + CmptPriceBit0(encCtx, lenEncoder->low[1 << CMPT_LEN_LOW_BITS]);\n    for (posState = 0; posState < numPosStates; posState++)\n    {\n        uint32_t *prices = lenEncoder->prices[posState];\n        const CmptlzProb *probs = lenEncoder->low + (posState << (1 + CMPT_LEN_LOW_BITS));\n        CmptPriceSet(encCtx, probs, a, prices);\n        CmptPriceSet(encCtx, probs + (1 << CMPT_LEN_LOW_BITS), c, prices + (1 << CMPT_LEN_LOW_BITS));\n    }\n    uint32_t i = lenEncoder->tableSize;\n    if (i > (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE)\n    {\n        const CmptlzProb *probs = lenEncoder->high;\n        uint32_t *prices = lenEncoder->prices[0] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE;\n        i -= (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE - 1;\n        i >>= 1;\n        b += CmptPriceBit1(encCtx, lenEncoder->low[(1 << CMPT_LEN_LOW_BITS)]);\n        do\n        {\n            uint32_t sym = --i + (1 << (CMPT_LEN_HIGH_BITS - 1));\n            uint32_t price = b;\n            do\n            {\n                uint32_t bit = sym & 1;\n                sym >>= 1;\n                price += CmptPriceOneBit(encCtx, probs[sym], bit);\n            } while (sym >= 2);\n            prob = probs[(size_t)i + (1 << (CMPT_LEN_HIGH_BITS - 1))];\n            prices[(size_t)i * CMPT_DOUBLE] = price + CmptPriceBit0(encCtx, prob);\n            prices[(size_t)i * CMPT_DOUBLE + 1] = price + CmptPriceBit1(encCtx, prob);\n        } while (i);\n        size_t num =\n            (lenEncoder->tableSize - (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE) * sizeof(lenEncoder->prices[0][0]);\n        for (posState = 1; posState < numPosStates; posState++)\n        {\n            memcpy_s(lenEncoder->prices[posState] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE, CMPT_MF_LONGEST_MATCH - 1,\n                     lenEncoder->prices[0] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE, num);\n        }\n    }\n}",
                "rust_code": "pub fn CmptPriceGenLenTable(mut encCtx: Ptr<CmptLzEncCtx>, mut lenEncoder: Ptr<CmptLenEncoder>) {\n    let numPosStates: u32 = 1 << encCtx.posBits;\n    let mut b: u32;\n    let mut prob: u32 = lenEncoder.low[0].cast::<u32>();\n    let mut a: u32;\n    let mut c: u32;\n    let mut posState: u32;\n    b = CmptPriceBit1(encCtx, prob.cast());\n    a = CmptPriceBit0(encCtx, prob.cast());\n    c = (b + CmptPriceBit0(encCtx, lenEncoder.low[1 << CMPT_LEN_LOW_BITS!()].cast()));\n    c_for!(posState = 0; posState < numPosStates; posState.suffix_plus_plus(); {\n        let mut prices: Ptr<u32> = lenEncoder.prices[posState].cast();\n        let mut probs: Ptr<CmptlzProb> = (lenEncoder.low.as_ptr().offset((posState << (1 + CMPT_LEN_LOW_BITS!())) as isize)).cast();\n        CmptPriceSet(encCtx, probs, a, prices);\n        CmptPriceSet(encCtx, (probs.offset((1 << CMPT_LEN_LOW_BITS!()) as isize)), c, (prices.offset((1 << CMPT_LEN_LOW_BITS!()) as isize)));\n    });\n    let mut i: u32 = lenEncoder.tableSize;\n    if (i > (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) {\n        let mut probs: Ptr<CmptlzProb> = lenEncoder.high.cast();\n        let mut prices: Ptr<u32> = (lenEncoder.prices[0].as_ptr().offset(((1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) as isize)).cast();\n        i -= (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!() - 1;\n        i >>= 1;\n        b += CmptPriceBit1(encCtx, lenEncoder.low[(1 << CMPT_LEN_LOW_BITS!())].cast());\n        c_do!({\n            let mut sym: u32 = (i.prefix_minus_minus() + (1 << (CMPT_LEN_HIGH_BITS!() - 1)));\n            let mut price: u32 = b;\n            c_do!({\n                let mut bit: u32 = (sym & 1);\n                sym >>= 1;\n                price += CmptPriceOneBit(encCtx, probs[sym].cast(), bit);\n            } while sym >= 2);\n            prob = probs[(i + (1 << (CMPT_LEN_HIGH_BITS!() - 1)))].cast();\n            prices[(i * CMPT_DOUBLE!())] = (price + CmptPriceBit0(encCtx, prob.cast()));\n            prices[(i * CMPT_DOUBLE!() + 1)] = (price + CmptPriceBit1(encCtx, prob.cast()));\n        } while i != 0);\n        let mut num: usize = ((lenEncoder.tableSize - (1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) * c_sizeofval!(lenEncoder.prices[0][0])).try_into().unwrap();\n        c_for!(posState = 1; posState < numPosStates; posState.suffix_plus_plus(); {\n            let tmp0 = posState;\n            c_memcpy_s!((lenEncoder.prices[tmp0].as_ptr().offset(((1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) as isize)), num, (lenEncoder.prices[0].as_ptr().offset(((1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) as isize)), num);\n        });\n    }\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750409192655)\nerror[E0599]: no method named `as_ptr` found for struct `types::array::Array` in the current scope\n    --> src/src/cmptlz_c.rs:3373:58\n     |\n3373 |         let mut probs: Ptr<CmptlzProb> = (lenEncoder.low.as_ptr().offset((posState << (1 + CMPT_LEN_LOW_BITS!())) as isize)).cast();\n     |                                                          ^^^^^^ method not found in `Array<u16, 256>`\n     |\n    ::: src/translation_utils/types/array.rs:5:1\n     |\n5    | pub struct Array<T, const N: usize>(pub [T; N]);\n     | ----------------------------------- method `as_ptr` not found for this struct\n     |\nhelp: one of the expressions' fields has a method of the same name\n     |\n3373 |         let mut probs: Ptr<CmptlzProb> = (lenEncoder.low.0.as_ptr().offset((posState << (1 + CMPT_LEN_LOW_BITS!())) as isize)).cast();\n     |                                                          ++\n\nerror[E0599]: no method named `offset` found for struct `memory::ptr::Ptr<u32>` in the current scope\n    --> src/src/cmptlz_c.rs:3375:95\n     |\n3375 | ...   CmptPriceSet(encCtx, (probs.offset((1 << CMPT_LEN_LOW_BITS!()) as isize)), c, (prices.offset((1 << CMPT_LEN_LOW_BITS!()) as isize)));\n     |                                                                                             ^^^^^^ method not found in `Ptr<u32>`\n     |\n    ::: src/translation_utils/memory/ptr.rs:8:1\n     |\n8    | pub struct Ptr<T>(pub Option<NonNull<T>>);\n     | ----------------- method `offset` not found for this struct\n\nerror[E0599]: no method named `as_ptr` found for struct `types::array::Array` in the current scope\n    --> src/src/cmptlz_c.rs:3380:58\n     |\n3380 |         let mut prices: Ptr<u32> = (lenEncoder.prices[0].as_ptr().offset(((1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) as isize)).cast();\n     |                                                          ^^^^^^ method not found in `Array<u32, 272>`\n     |\n    ::: src/translation_utils/types/array.rs:5:1\n     |\n5    | pub struct Array<T, const N: usize>(pub [T; N]);\n     | ----------------------------------- method `as_ptr` not found for this struct\n     |\nhelp: one of the expressions' fields has a method of the same name\n     |\n3380 |         let mut prices: Ptr<u32> = (lenEncoder.prices[0].0.as_ptr().offset(((1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) as isize)).cast();\n     |                                                          ++\n\nerror[E0599]: no method named `as_ptr` found for struct `types::array::Array` in the current scope\n    --> src/src/cmptlz_c.rs:3399:50\n     |\n3399 | ...   c_memcpy_s!((lenEncoder.prices[tmp0].as_ptr().offset(((1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) as isize)), num, (lenEncoder.pr...\n     |                                            ^^^^^^ method not found in `Array<u32, 272>`\n     |\n    ::: src/translation_utils/types/array.rs:5:1\n     |\n5    | pub struct Array<T, const N: usize>(pub [T; N]);\n     | ----------------------------------- method `as_ptr` not found for this struct\n     |\nhelp: one of the expressions' fields has a method of the same name\n     |\n3399 |             c_memcpy_s!((lenEncoder.prices[tmp0].0.as_ptr().offset(((1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) as isize)), num, (lenEncoder.prices[0].as_ptr().offset(((1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) as isize)), num);\n     |                                                  ++\n\nerror[E0599]: no method named `as_ptr` found for struct `types::array::Array` in the current scope\n    --> src/src/cmptlz_c.rs:3399:152\n     |\n3399 | ...E!()) as isize)), num, (lenEncoder.prices[0].as_ptr().offset(((1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) as isize)), num);\n     |                                                 ^^^^^^ method not found in `Array<u32, 272>`\n     |\n    ::: src/translation_utils/types/array.rs:5:1\n     |\n5    | pub struct Array<T, const N: usize>(pub [T; N]);\n     | ----------------------------------- method `as_ptr` not found for this struct\n     |\nhelp: one of the expressions' fields has a method of the same name\n     |\n3399 |             c_memcpy_s!((lenEncoder.prices[tmp0].as_ptr().offset(((1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) as isize)), num, (lenEncoder.prices[0].0.as_ptr().offset(((1 << CMPT_LEN_LOW_BITS!()) * CMPT_DOUBLE!()) as isize)), num);\n     |                                                                                                                                                        ++\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 5 previous errors\n"
            },
            {
                "c_code": "uint32_t CmptPriceLongRep(CmptLzEncCtx *encCtx, uint32_t longRepIndex, CmptlzState state, uint32_t posState)\n{\n    uint32_t price = 0;\n    switch (longRepIndex)\n    {\n    case 0:\n        price =\n            CmptPriceBit0(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRep0Long[state][posState]);\n        break;\n    case 1:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit0(encCtx, encCtx->isRepG1[state]);\n        break;\n    case 2:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRepG1[state]) +\n                CmptPriceBit0(encCtx, encCtx->isRepG2[state]);\n        break;\n    case 3:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRepG1[state]) +\n                CmptPriceBit1(encCtx, encCtx->isRepG2[state]);\n        break;\n    default:\n        break;\n    }\n    return price;\n}",
                "rust_code": "pub fn CmptPriceLongRep(mut encCtx: Ptr<CmptLzEncCtx>, mut longRepIndex: u32, mut state: CmptlzState, mut posState: u32) -> u32 {\n    let mut price: u32 = 0;\n    c_switch!(longRepIndex, {\n        0 => {\n            let tmp0 = state;\n            price = (CmptPriceBit0(encCtx, encCtx.isRepG0[tmp0][posState]));\n            break;\n        },\n        1 => {\n            price = (CmptPriceBit1(encCtx, encCtx.isRepG0[state]) + CmptPriceBit0(encCtx, encCtx.isRepG1[state]));\n            break;\n        },\n        2 => {\n            price = (CmptPriceBit1(encCtx, encCtx.isRepG0[state]) + CmptPriceBit1(encCtx, encCtx.isRepG1[state]) + CmptPriceBit0(encCtx, encCtx.isRepG2[state]));\n            break;\n        },\n        3 => {\n            price = (CmptPriceBit1(encCtx, encCtx.isRepG0[state]) + CmptPriceBit1(encCtx, encCtx.isRepG1[state]) + CmptPriceBit1(encCtx, encCtx.isRepG2[state]));\n            break;\n        },\n        _ => {\n            break;\n        },\n    });\n    return price;\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750409202399)\nerror: no rules expected `,`\n    --> src/src/cmptlz_c.rs:3421:27\n     |\n3421 |     c_switch!(longRepIndex, {\n     |                           ^ no rules expected this token in macro call\n     |\n    ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n     |\n3    | macro_rules! c_switch {\n     | --------------------- when calling this macro\n     |\nnote: while trying to match `;`\n    --> src/translation_utils/c_alignment/c_switch.rs:5:17\n     |\n5    |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n     |                 ^\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "static int CmptRcLitAfterMatch(CmptRcCtx *rcCtx, CmptlzProb *prob, uint32_t sym, uint32_t matchByte)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = rcCtx->range, offs = 0x100, bit0Prob, newBound, curBit;\n    for (sym |= 0x100; sym < 0x10000;)\n    {\n        matchByte <<= 1;\n        CmptlzProb *litProbTableIndex = prob + (offs + (matchByte & offs) + (sym >> 8));\n        curBit = (sym >> 7) & 1;\n        sym <<= 1;\n        offs &= ~(matchByte ^ sym);\n        CMPT_RC_BIT_PROCESS(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    rcCtx->range = range;\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptRcLitAfterMatch(mut rcCtx: Ptr<CmptRcCtx>, mut prob: Ptr<CmptlzProb>, mut sym: u32, mut matchByte: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut range: u32 = rcCtx.range;\n    let mut offs: u32 = 0x100;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    let mut curBit: u32;\n    c_for!(sym |= 0x100; sym < 0x10000; {\n        matchByte <<= 1;\n        let mut litProbTableIndex: Ptr<CmptlzProb> = (prob + (offs + (matchByte & offs) + (sym >> 8)));\n        curBit = (sym >> 7) & 1;\n        sym <<= 1;\n        offs &= !(matchByte ^ sym);\n        CMPT_RC_BIT_PROCESS!(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    });\n    rcCtx.range = range;\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750409212120)\nerror: unexpected end of macro invocation\n    --> src/src/cmptlz_c.rs:3493:6\n     |\n3493 |     });\n     |      ^ missing tokens in macro arguments\n     |\n    ::: src/translation_utils/c_alignment/c_for.rs:3:1\n     |\n3    | macro_rules! c_for {\n     | ------------------ when calling this macro\n     |\nnote: while trying to match `;`\n    --> src/translation_utils/c_alignment/c_for.rs:13:53\n     |\n13   |     ($($init: stmt),+; $cond: expr; $($step: expr),+; $body: block) => {\n     |                                                     ^\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "int CmptRcPosSlotProcess(CmptLzEncCtx *encCtx, uint32_t posSlot, uint32_t len)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = encCtx->rcCtx->range;\n    uint32_t sym = posSlot + (1 << 6);\n    uint32_t bit0Prob, newBound;\n    uint32_t bit;\n    CmptlzProb *probs = encCtx->probDistSlot[GET_LEN_TO_POS_STATE(len)];\n    do\n    {\n        CmptlzProb *posSlotProbTableIndex = probs + (sym >> CMPTLZ_DIST_SLOT_BITS);\n        bit = (sym >> (CMPTLZ_DIST_SLOT_BITS - 1)) & 1;\n        sym <<= 1;\n        CMPT_RC_BIT_PROCESS(encCtx->rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    } while (sym < (1 << (CMPTLZ_DIST_SLOT_BITS * 2)));\n    encCtx->rcCtx->range = range;\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptRcPosSlotProcess(mut encCtx: Ptr<CmptLzEncCtx>, mut posSlot: u32, mut len: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut range: u32 = encCtx.rcCtx.range;\n    let mut sym: u32 = posSlot + (1 << 6);\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    let mut bit: u32;\n    let mut probs: Ptr<CmptlzProb> = encCtx.probDistSlot[GET_LEN_TO_POS_STATE!(len)];\n    c_do!({\n        let mut posSlotProbTableIndex: Ptr<CmptlzProb> = probs + (sym >> CMPTLZ_DIST_SLOT_BITS!());\n        bit = (sym >> (CMPTLZ_DIST_SLOT_BITS!() - 1)) & 1;\n        sym <<= 1;\n        CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    } while sym < (1 << (CMPTLZ_DIST_SLOT_BITS!() * 2)));\n    encCtx.rcCtx.range = range;\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750409237411)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3624:38\n     |\n3624 |     let mut probs: Ptr<CmptlzProb> = encCtx.probDistSlot[GET_LEN_TO_POS_STATE!(len)];\n     |                    ---------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Ptr<u16>`, found `Array<u16, 64>`\n     |                    |\n     |                    expected due to this\n     |\n     = note: expected struct `memory::ptr::Ptr<u16>`\n                found struct `types::array::Array<u16, 64>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 1 previous error\n"
            },
            {
                "c_code": "int CmptRcDistProcess(CmptLzEncCtx *encCtx, uint32_t posSlot, uint32_t dist)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t footerBits = ((posSlot >> 1) - 1);\n    if (dist < CMPT_DIST_LIMIT_2)\n    {\n        uint32_t base = ((2 | (posSlot & 1)) << footerBits);\n        shiftRes = CmptRcReverseProcess(encCtx->rcCtx, encCtx->probDistSpecial + base, footerBits, dist);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    else\n    {\n        uint32_t pos2 = (dist | 0xF) << (32 - footerBits);\n        uint32_t range = encCtx->rcCtx->range;\n        do\n        {\n            range >>= 1;\n            encCtx->rcCtx->low += range & (0 - (pos2 >> 31));\n            pos2 += pos2;\n            CMPT_RC_NORMALIZE(encCtx->rcCtx, range, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        } while (pos2 != 0xF0000000);\n        uint32_t m = 1;\n        uint32_t bit;\n        uint32_t bit0Prob, newBound;\n        int k;\n        for (k = 0; k < CMPTLZ_ALIGN_BITS - 1; k++)\n        {\n            bit = dist & 1;\n            dist >>= 1;\n            CMPT_RC_BIT_PROCESS(encCtx->rcCtx, encCtx->probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            m = (m << 1) + bit;\n        }\n        bit = dist & 1;\n        CMPT_RC_BIT_PROCESS(encCtx->rcCtx, encCtx->probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n    }\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptRcDistProcess(mut encCtx: Ptr<CmptLzEncCtx>, mut posSlot: u32, mut dist: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut footerBits: u32 = ((posSlot >> 1) - 1);\n    if (dist < CMPT_DIST_LIMIT_2!()) {\n        let mut base: u32 = ((2 | (posSlot & 1)) << footerBits);\n        shiftRes = CmptRcReverseProcess(encCtx.rcCtx, (encCtx.probDistSpecial + base), footerBits, dist);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    } else {\n        let mut pos2: u32 = (dist | 0xF) << (32 - footerBits);\n        let mut range: u32 = encCtx.rcCtx.range;\n        c_do!({\n            range >>= 1;\n            encCtx.rcCtx.low += range & (0 - (pos2 >> 31));\n            pos2 += pos2;\n            CMPT_RC_NORMALIZE!(encCtx.rcCtx, range, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n        } while pos2 != 0xF0000000);\n        let mut m: u32 = 1;\n        let mut bit: u32;\n        let mut bit0Prob: u32;\n        let mut newBound: u32;\n        let mut k: i32;\n        c_for!(k = 0; k < CMPTLZ_ALIGN_BITS!() - 1; k.suffix_plus_plus(); {\n            bit = (dist & 1);\n            dist >>= 1;\n            CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            m = (m << 1) + bit;\n        });\n        bit = (dist & 1);\n        CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n        encCtx.rcCtx.range = range;\n    }\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750409242496)\nerror[E0369]: cannot add `u32` to `types::array::Array<u16, 128>`\n    --> src/src/cmptlz_c.rs:3666:79\n     |\n3666 |         shiftRes = CmptRcReverseProcess(encCtx.rcCtx, (encCtx.probDistSpecial + base), footerBits, dist);\n     |                                                        ---------------------- ^ ---- u32\n     |                                                        |\n     |                                                        types::array::Array<u16, 128>\n     |\nnote: an implementation of `std::ops::Add<u32>` might be missing for `types::array::Array<u16, 128>`\n    --> src/translation_utils/types/array.rs:5:1\n     |\n5    | pub struct Array<T, const N: usize>(pub [T; N]);\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `std::ops::Add<u32>`\nnote: the trait `std::ops::Add` must be implemented\n    --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/ops/arith.rs:78:1\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3673:33\n     |\n3673 |             encCtx.rcCtx.low += range & (0 - (pos2 >> 31));\n     |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u64`, found `u32`\n\nerror[E0277]: cannot add-assign `u32` to `u64`\n    --> src/src/cmptlz_c.rs:3673:30\n     |\n3673 |             encCtx.rcCtx.low += range & (0 - (pos2 >> 31));\n     |                              ^^ no implementation for `u64 += u32`\n     |\n     = help: the trait `std::ops::AddAssign<u32>` is not implemented for `u64`\n     = help: the following other types implement trait `std::ops::AddAssign<Rhs>`:\n               `u64` implements `std::ops::AddAssign<&u64>`\n               `u64` implements `std::ops::AddAssign`\n\nerror[E0369]: cannot add `u32` to `types::array::Array<u16, 16>`\n    --> src/src/cmptlz_c.rs:3686:65\n     |\n3686 |             CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n     |                                                ---------------- ^ - u32\n     |                                                |\n     |                                                types::array::Array<u16, 16>\n     |\nnote: an implementation of `std::ops::Add<u32>` might be missing for `types::array::Array<u16, 16>`\n    --> src/translation_utils/types/array.rs:5:1\n     |\n5    | pub struct Array<T, const N: usize>(pub [T; N]);\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `std::ops::Add<u32>`\nnote: the trait `std::ops::Add` must be implemented\n    --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/ops/arith.rs:78:1\n\nerror[E0369]: cannot add `u32` to `types::array::Array<u16, 16>`\n    --> src/src/cmptlz_c.rs:3691:61\n     |\n3691 |         CMPT_RC_BIT_PROCESS!(encCtx.rcCtx, encCtx.probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n     |                                            ---------------- ^ - u32\n     |                                            |\n     |                                            types::array::Array<u16, 16>\n     |\nnote: an implementation of `std::ops::Add<u32>` might be missing for `types::array::Array<u16, 16>`\n    --> src/translation_utils/types/array.rs:5:1\n     |\n5    | pub struct Array<T, const N: usize>(pub [T; N]);\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `std::ops::Add<u32>`\nnote: the trait `std::ops::Add` must be implemented\n    --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/ops/arith.rs:78:1\n\nSome errors have detailed explanations: E0277, E0308, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 5 previous errors\n"
            },
            {
                "c_code": "static int CmptlzEncLit(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t nowpos32)\n{\n    int shiftRes = CMPT_OK;\n    CmptRcCtx *rc = encCtx->rcCtx;\n    uint32_t posState = nowpos32 & encCtx->pbMask;\n    uint32_t range, bit0Prob, newBound;\n    range = rc->range;\n    CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS(rc, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    rc->range = range;\n    CmptlzProb *litProb = &encCtx->litMarcov.literal[0][0];\n    const uint8_t curByte = mf->srcStart[mf->readPos - mf->readAhead];\n    probs = CMPT_LIT_PROB_GET(encCtx, litProb, nowpos32, mf->srcStart[mf->readPos - mf->readAhead - 1]);\n    CmptlzState state = encCtx->state;\n    CMPT_STATE_UPDATE_WHEN_LIT(encCtx->state);\n    if (state < 7)\n    {\n        shiftRes = CmptRcLitProcess(rc, probs, curByte);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    else\n    {\n        const uint8_t match_byte = mf->srcStart[mf->readPos - encCtx->reps[0] - 1 - mf->readAhead];\n        shiftRes = CmptRcLitAfterMatch(rc, probs, curByte, match_byte);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptlzEncLit(mut encCtx: Ptr<CmptLzEncCtx>, mut mf: Ptr<CmptMfCtx>, mut nowpos32: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut rc: Ptr<CmptRcCtx> = encCtx.rcCtx;\n    let mut posState: u32 = (nowpos32 & encCtx.pbMask.cast::<u32>());\n    let mut range: u32;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    range = rc.range;\n    let tmp0 = encCtx.state;\n    let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[tmp0][posState]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS!(rc, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    rc.range = range;\n    let mut litProb: Ptr<CmptlzProb> = c_ref!(encCtx.litMarcov.literal[0][0]);\n    let mut curByte: u8 = mf.srcStart[mf.readPos - mf.readAhead];\n    probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1].cast::<u32>());\n    let mut state: CmptlzState = encCtx.state;\n    CMPT_STATE_UPDATE_WHEN_LIT!(encCtx.state);\n    if (state < 7) {\n        shiftRes = CmptRcLitProcess(rc, probs, curByte.cast());\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    } else {\n        let mut match_byte: u8 = mf.srcStart[mf.readPos - encCtx.reps[0] - 1 - mf.readAhead];\n        shiftRes = CmptRcLitAfterMatch(rc, probs, curByte.cast(), match_byte.cast());\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    }\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750409242889)\nerror[E0502]: cannot borrow `mf` as immutable because it is also borrowed as mutable\n    --> src/src/cmptlz_c.rs:3717:71\n     |\n3717 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1].cast::<u32>());\n     |                                                           --         -^^----------------------------\n     |                                                           |          ||\n     |                                                           |          |immutable borrow occurs here\n     |                                                           |          mutable borrow later used here\n     |                                                           mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/src/cmptlz_c.rs:3717:71\n     |\n3717 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1].cast::<u32>());\n     |                                                                       ^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/src/cmptlz_c.rs:3717:70\n     |\n3717 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1].cast::<u32>());\n     |                                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `mf` as immutable because it is also borrowed as mutable\n    --> src/src/cmptlz_c.rs:3717:84\n     |\n3717 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1].cast::<u32>());\n     |                                                           --         --------------^^---------------\n     |                                                           |          |             |\n     |                                                           |          |             immutable borrow occurs here\n     |                                                           |          mutable borrow later used here\n     |                                                           mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/src/cmptlz_c.rs:3717:84\n     |\n3717 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1].cast::<u32>());\n     |                                                                                    ^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/src/cmptlz_c.rs:3717:70\n     |\n3717 |     probs = CMPT_LIT_PROB_GET!(encCtx, litProb, nowpos32, mf.srcStart[mf.readPos - mf.readAhead - 1].cast::<u32>());\n     |                                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "static int CmptlzEncShortRep(CmptLzEncCtx *encCtx, uint32_t nowpos32)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t posState = nowpos32 & encCtx->pbMask;\n    uint32_t range, bit0Prob, newBound;\n    range = encCtx->rcCtx->range;\n    CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRep[encCtx->state];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRepG0[encCtx->state];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRep0Long[encCtx->state][posState];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    encCtx->rcCtx->range = range;\n    CmptlzState state = encCtx->state;\n    encCtx->state = CMPT_STATE_UPDATE_WHEN_SHORTREP(state);\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptlzEncShortRep(mut encCtx: Ptr<CmptLzEncCtx>, mut nowpos32: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut posState: u32 = nowpos32 & encCtx.pbMask;\n    let mut range: u32;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    range = encCtx.rcCtx.range;\n    let tmp0 = encCtx.state;\n    let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[tmp0][posState]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    probs = c_ref!(encCtx.isRep[encCtx.state]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    probs = c_ref!(encCtx.isRepG0[encCtx.state]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    probs = c_ref!(encCtx.isRep0Long[encCtx.state][posState]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    encCtx.rcCtx.range = range;\n    let mut state: CmptlzState = encCtx.state;\n    encCtx.state = CMPT_STATE_UPDATE_WHEN_SHORTREP!(state);\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750409243284)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3733:40\n     |\n3733 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n     |                                        ^^^^^^^^^^^^^ expected `u32`, found `u64`\n\nerror[E0277]: no implementation for `u32 & u64`\n    --> src/src/cmptlz_c.rs:3733:38\n     |\n3733 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n     |                                      ^ no implementation for `u32 & u64`\n     |\n     = help: the trait `BitAnd<u64>` is not implemented for `u32`\n     = help: the following other types implement trait `BitAnd<Rhs>`:\n               `&u32` implements `BitAnd<u32>`\n               `&u32` implements `BitAnd`\n               `u32` implements `BitAnd<&u32>`\n               `u32` implements `BitAnd`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "static int CmptlzEncNormalMatch(CmptLzEncCtx *encCtx, uint32_t nowpos32, uint32_t backRes, uint32_t lenRes)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t posState = nowpos32 & encCtx->pbMask;\n    uint32_t range, bit0Prob, newBound;\n    range = encCtx->rcCtx->range;\n    CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRep[encCtx->state];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    encCtx->rcCtx->range = range;\n    CmptlzState state = encCtx->state;\n    encCtx->state = CMPT_STATE_UPDATE_WHEN_MATCH(state);\n    shiftRes = CmptRcLenProcess(&encCtx->matchLenEncoder, encCtx->rcCtx, lenRes, posState);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    backRes -= CMPTLZ_NUM_REPS;\n    encCtx->reps[3] = encCtx->reps[2];\n    encCtx->reps[2] = encCtx->reps[1];\n    encCtx->reps[1] = encCtx->reps[0];\n    encCtx->reps[0] = backRes;\n    encCtx->matchPriceCount++;\n    uint32_t posSlot = PosSloter(backRes);\n    shiftRes = CmptRcPosSlotProcess(encCtx, posSlot, lenRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    if (backRes >= 4)\n    {\n        shiftRes = CmptRcDistProcess(encCtx, posSlot, backRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptlzEncNormalMatch(mut encCtx: Ptr<CmptLzEncCtx>, mut nowpos32: u32, mut backRes: u32, mut lenRes: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut posState: u32 = (nowpos32 & encCtx.pbMask);\n    let mut range: u32;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    range = encCtx.rcCtx.range;\n    let tmp0 = encCtx.state;\n    let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[tmp0][posState]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    probs = c_ref!(encCtx.isRep[encCtx.state]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    encCtx.rcCtx.range = range;\n    let mut state: CmptlzState = encCtx.state;\n    encCtx.state = CMPT_STATE_UPDATE_WHEN_MATCH!(state);\n    shiftRes = CmptRcLenProcess(c_ref!(encCtx.matchLenEncoder), encCtx.rcCtx, lenRes, posState.cast());\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    backRes -= CMPTLZ_NUM_REPS!();\n    encCtx.reps[3] = encCtx.reps[2];\n    encCtx.reps[2] = encCtx.reps[1];\n    encCtx.reps[1] = encCtx.reps[0];\n    encCtx.reps[0] = backRes;\n    encCtx.matchPriceCount += 1;\n    let mut posSlot: u32 = PosSloter(backRes);\n    shiftRes = CmptRcPosSlotProcess(encCtx, posSlot, lenRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    if (backRes >= 4) {\n        shiftRes = CmptRcDistProcess(encCtx, posSlot, backRes);\n        CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    }\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750409243673)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3766:41\n     |\n3766 |     let mut posState: u32 = (nowpos32 & encCtx.pbMask);\n     |                                         ^^^^^^^^^^^^^ expected `u32`, found `u64`\n\nerror[E0277]: no implementation for `u32 & u64`\n    --> src/src/cmptlz_c.rs:3766:39\n     |\n3766 |     let mut posState: u32 = (nowpos32 & encCtx.pbMask);\n     |                                       ^ no implementation for `u32 & u64`\n     |\n     = help: the trait `BitAnd<u64>` is not implemented for `u32`\n     = help: the following other types implement trait `BitAnd<Rhs>`:\n               `&u32` implements `BitAnd<u32>`\n               `&u32` implements `BitAnd`\n               `u32` implements `BitAnd<&u32>`\n               `u32` implements `BitAnd`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 2 previous errors\n"
            },
            {
                "c_code": "static int CmptlzEncLongRep(CmptLzEncCtx *encCtx, uint32_t repIndex, uint32_t nowpos32, uint32_t lenRes)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t posState = nowpos32 & encCtx->pbMask;\n    uint32_t range, bit0Prob, newBound;\n    uint32_t realDist;\n    range = encCtx->rcCtx->range;\n    CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRep[encCtx->state];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRepG0[encCtx->state];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    switch (repIndex)\n    {\n    case 0:\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRep0Long[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1(encCtx->rcCtx, probs, newBound, range, bit0Prob);\n        break;\n    case 1:\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRepG1[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0(probs, newBound, range, bit0Prob);\n        realDist = encCtx->reps[1];\n        encCtx->reps[1] = encCtx->reps[0];\n        encCtx->reps[0] = realDist;\n        break;\n    case 2:\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRepG1[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRepG2[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0(probs, newBound, range, bit0Prob);\n        realDist = encCtx->reps[2];\n        encCtx->reps[2] = encCtx->reps[1];\n        encCtx->reps[1] = encCtx->reps[0];\n        encCtx->reps[0] = realDist;\n        break;\n    case 3:\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRepG1[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRepG2[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1(encCtx->rcCtx, probs, newBound, range, bit0Prob);\n        realDist = encCtx->reps[3];\n        encCtx->reps[3] = encCtx->reps[2];\n        encCtx->reps[2] = encCtx->reps[1];\n        encCtx->reps[1] = encCtx->reps[0];\n        encCtx->reps[0] = realDist;\n        break;\n    default:\n        break;\n    }\n    CMPT_RC_NORMALIZE(encCtx->rcCtx, range, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    encCtx->rcCtx->range = range;\n    shiftRes = CmptRcLenProcess(&encCtx->repLenEncoder, encCtx->rcCtx, lenRes, posState);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    --encCtx->repLenPriceCount;\n    CmptlzState state = encCtx->state;\n    encCtx->state = CMPT_STATE_UPDATE_WHEN_LONGREP(state);\n    return CMPT_OK;\n}",
                "rust_code": "pub fn CmptlzEncLongRep(mut encCtx: Ptr<CmptLzEncCtx>, mut repIndex: u32, mut nowpos32: u32, mut lenRes: u32) -> i32 {\n    let mut shiftRes: i32 = CMPT_OK!();\n    let mut posState: u32 = nowpos32 & encCtx.pbMask;\n    let mut range: u32;\n    let mut bit0Prob: u32;\n    let mut newBound: u32;\n    let mut realDist: u32;\n    range = encCtx.rcCtx.range;\n    let tmp0 = encCtx.state;\n    let mut probs: Ptr<CmptlzProb> = c_ref!(encCtx.isMatch[tmp0][posState]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    probs = c_ref!(encCtx.isRep[encCtx.state]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    probs = c_ref!(encCtx.isRepG0[encCtx.state]);\n    CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n    c_switch!(repIndex, {\n        0 => {\n            CMPT_RC_BIT_0_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRep0Long[encCtx.state][posState]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1!(encCtx.rcCtx, probs, newBound, range, bit0Prob);\n            break;\n        },\n        1 => {\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRepG1[encCtx.state]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0!(probs, newBound, range, bit0Prob);\n            realDist = encCtx.reps[1];\n            encCtx.reps[1] = encCtx.reps[0];\n            encCtx.reps[0] = realDist;\n            break;\n        },\n        2 => {\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRepG1[encCtx.state]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRepG2[encCtx.state]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0!(probs, newBound, range, bit0Prob);\n            realDist = encCtx.reps[2];\n            encCtx.reps[2] = encCtx.reps[1];\n            encCtx.reps[1] = encCtx.reps[0];\n            encCtx.reps[0] = realDist;\n            break;\n        },\n        3 => {\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRepG1[encCtx.state]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS!(encCtx.rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n            probs = c_ref!(encCtx.isRepG2[encCtx.state]);\n            CMPT_RC_GET_NEWBOUND!(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1!(encCtx.rcCtx, probs, newBound, range, bit0Prob);\n            realDist = encCtx.reps[3];\n            encCtx.reps[3] = encCtx.reps[2];\n            encCtx.reps[2] = encCtx.reps[1];\n            encCtx.reps[1] = encCtx.reps[0];\n            encCtx.reps[0] = realDist;\n            break;\n        },\n        _ => {\n            break;\n        },\n    });\n    CMPT_RC_NORMALIZE!(encCtx.rcCtx, range, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    encCtx.rcCtx.range = range;\n    shiftRes = CmptRcLenProcess(c_ref!(encCtx.repLenEncoder), encCtx.rcCtx, lenRes, posState.cast());\n    CMPTLZ_RETURN_IF_NOT_OK!(shiftRes);\n    encCtx.repLenPriceCount -= 1;\n    let mut state: CmptlzState = encCtx.state;\n    encCtx.state = CMPT_STATE_UPDATE_WHEN_LONGREP!(state);\n    return CMPT_OK!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750409244068)\nerror: no rules expected `,`\n    --> src/src/cmptlz_c.rs:3821:23\n     |\n3821 |     c_switch!(repIndex, {\n     |                       ^ no rules expected this token in macro call\n     |\n    ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n     |\n3    | macro_rules! c_switch {\n     | --------------------- when calling this macro\n     |\nnote: while trying to match `;`\n    --> src/translation_utils/c_alignment/c_switch.rs:5:17\n     |\n5    |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n     |                 ^\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3804:40\n     |\n3804 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n     |                                        ^^^^^^^^^^^^^ expected `u32`, found `u64`\n\nerror[E0277]: no implementation for `u32 & u64`\n    --> src/src/cmptlz_c.rs:3804:38\n     |\n3804 |     let mut posState: u32 = nowpos32 & encCtx.pbMask;\n     |                                      ^ no implementation for `u32 & u64`\n     |\n     = help: the trait `BitAnd<u64>` is not implemented for `u32`\n     = help: the following other types implement trait `BitAnd<Rhs>`:\n               `&u32` implements `BitAnd<u32>`\n               `&u32` implements `BitAnd`\n               `u32` implements `BitAnd<&u32>`\n               `u32` implements `BitAnd`\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 3 previous errors\n"
            },
            {
                "c_code": "void CmptlzFreeAll(CmptLzEncCtx *encCtx, CmptLzMemHook *alloc)\n{\n    if (encCtx == NULL)\n    {\n        return;\n    }\n    if (encCtx->mfCtx != NULL)\n    {\n        if (encCtx->mfCtx->hash != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_MF_HASH_HANDLE, encCtx->mfCtx->hash);\n            encCtx->mfCtx->hash = NULL;\n        }\n        if (encCtx->mfCtx->son != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_MF_SON_HANDLE, encCtx->mfCtx->son);\n            encCtx->mfCtx->son = NULL;\n        }\n        alloc->CmptLzFree(CMPTLZ_MF_CCTX_HANDLE, encCtx->mfCtx);\n        encCtx->mfCtx = NULL;\n    }\n    if (encCtx->rcCtx != NULL)\n    {\n        if (encCtx->rcCtx->bufBase != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_RC_BUF_HANDLE, encCtx->rcCtx->bufBase);\n            encCtx->rcCtx->bufBase = NULL;\n        }\n        alloc->CmptLzFree(CMPTLZ_RC_CCTX_HANDLE, encCtx->rcCtx);\n        encCtx->rcCtx = NULL;\n    }\n    alloc->CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE, encCtx);\n    encCtx = NULL;\n}",
                "rust_code": "pub fn CmptlzFreeAll(mut encCtx: Ptr<CmptLzEncCtx>, mut alloc: Ptr<CmptLzMemHook>) {\n    if (encCtx == NULL!()) {\n        return;\n    }\n    if (encCtx.mfCtx != NULL!()) {\n        if (encCtx.mfCtx.hash != NULL!()) {\n            (alloc.CmptLzFree)(CMPTLZ_MF_HASH_HANDLE!(), encCtx.mfCtx.hash);\n            encCtx.mfCtx.hash = NULL!();\n        }\n        if (encCtx.mfCtx.son != NULL!()) {\n            (alloc.CmptLzFree)(CMPTLZ_MF_SON_HANDLE!(), encCtx.mfCtx.son);\n            encCtx.mfCtx.son = NULL!();\n        }\n        (alloc.CmptLzFree)(CMPTLZ_MF_CCTX_HANDLE!(), encCtx.mfCtx);\n        encCtx.mfCtx = NULL!();\n    }\n    if (encCtx.rcCtx != NULL!()) {\n        if (encCtx.rcCtx.bufBase != NULL!()) {\n            (alloc.CmptLzFree)(CMPTLZ_RC_BUF_HANDLE!(), encCtx.rcCtx.bufBase);\n            encCtx.rcCtx.bufBase = NULL!();\n        }\n        (alloc.CmptLzFree)(CMPTLZ_RC_CCTX_HANDLE!(), encCtx.rcCtx);\n        encCtx.rcCtx = NULL!();\n    }\n    (alloc.CmptLzFree)(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx);\n    encCtx = NULL!();\n}\n",
                "error_msg": "   Compiling my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/cmptlz_1750409244466)\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3901:58\n     |\n3901 |             (alloc.CmptLzFree)(CMPTLZ_MF_HASH_HANDLE!(), encCtx.mfCtx.hash);\n     |             ------------------                           ^^^^^^^^^^^^^^^^^ expected `Ptr<u8>`, found `Ptr<u32>`\n     |             |\n     |             arguments to this function are incorrect\n     |\n     = note: expected struct `memory::ptr::Ptr<u8>`\n                found struct `memory::ptr::Ptr<u32>`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3905:57\n     |\n3905 |             (alloc.CmptLzFree)(CMPTLZ_MF_SON_HANDLE!(), encCtx.mfCtx.son);\n     |             ------------------                          ^^^^^^^^^^^^^^^^ expected `Ptr<u8>`, found `Ptr<u32>`\n     |             |\n     |             arguments to this function are incorrect\n     |\n     = note: expected struct `memory::ptr::Ptr<u8>`\n                found struct `memory::ptr::Ptr<u32>`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3908:54\n     |\n3908 |         (alloc.CmptLzFree)(CMPTLZ_MF_CCTX_HANDLE!(), encCtx.mfCtx);\n     |         ------------------                           ^^^^^^^^^^^^ expected `Ptr<u8>`, found `Ptr<TagCmptMatchFinder>`\n     |         |\n     |         arguments to this function are incorrect\n     |\n     = note: expected struct `memory::ptr::Ptr<u8>`\n                found struct `memory::ptr::Ptr<TagCmptMatchFinder>`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3916:54\n     |\n3916 |         (alloc.CmptLzFree)(CMPTLZ_RC_CCTX_HANDLE!(), encCtx.rcCtx);\n     |         ------------------                           ^^^^^^^^^^^^ expected `Ptr<u8>`, found `Ptr<CmptRcCtx>`\n     |         |\n     |         arguments to this function are incorrect\n     |\n     = note: expected struct `memory::ptr::Ptr<u8>`\n                found struct `memory::ptr::Ptr<CmptRcCtx>`\n\nerror[E0308]: mismatched types\n    --> src/src/cmptlz_c.rs:3919:51\n     |\n3919 |     (alloc.CmptLzFree)(CMPTLZ_ENC_CCTX_HANDLE!(), encCtx);\n     |     ------------------                            ^^^^^^ expected `Ptr<u8>`, found `Ptr<TagCmptLzEncCtx>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected struct `memory::ptr::Ptr<u8>`\n                found struct `memory::ptr::Ptr<TagCmptLzEncCtx>`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `my_proj` (lib test) due to 5 previous errors\n"
            }
        ]
    }
}