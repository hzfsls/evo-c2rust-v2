{"static void CmptlzMfGenHashTable(CmptMfCtx *mf)\n{\n    uint32_t *hashRootTable = mf->hashRootTable;\n    const uint32_t poly32 = 0xEDB88320;\n    uint32_t i, j;\n    for (i = 0; i < CMPT_MF_HASH_TABLE_SIZE; i++)\n    {\n        uint32_t value = i;\n        for (j = 0; j < 8; j++)\n        {\n            if (value & 1)\n            {\n                value = (value >> 1) ^ poly32;\n            }\n            else\n            {\n                value >>= 1;\n            }\n        }\n        hashRootTable[i] = value;\n    }\n    return;\n}": "0", "int CmptMfPrepare(CmptLzEncCtx *encCtx, const uint8_t *src, size_t srcLen, CmptLzMemHook *alloc)\n{\n\n    CmptMfCtx *mf = alloc->CmptLzAlloc(CMPTLZ_MF_CCTX_HANDLE, sizeof(CmptMfCtx));\n    if (mf == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    memset_s(mf, sizeof(CmptMfCtx), 0, sizeof(CmptMfCtx));\n\n    encCtx->mfCtx = mf;\n    mf->cycleSize = encCtx->dicSize + 1;\n    uint32_t hashMask = encCtx->dicSize - 1;\n    CMPT_HASH_MASK_CALC(hashMask);\n    mf->hashMask = hashMask;\n    ++hashMask;\n    hashMask += CMPTLZ_HASH_2_SIZE;\n    hashMask += CMPTLZ_HASH_3_SIZE;\n    mf->hashCount = hashMask;\n    mf->sonsCount = mf->cycleSize * 2;\n    mf->hash = NULL;\n    mf->son = NULL;\n    mf->hash = alloc->CmptLzAlloc(CMPTLZ_MF_HASH_HANDLE, mf->hashCount * sizeof(uint32_t));\n    memset_s(mf->hash, mf->hashCount * sizeof(uint32_t), 0, mf->hashCount * sizeof(uint32_t));\n    if (mf->hash == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    mf->son = alloc->CmptLzAlloc(CMPTLZ_MF_SON_HANDLE, mf->sonsCount * sizeof(uint32_t));\n    memset_s(mf->son, mf->sonsCount * sizeof(uint32_t), 0, mf->sonsCount * sizeof(uint32_t));\n    if (mf->son == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n\n    CmptlzMfGenHashTable(mf);\n    mf->srcStart = src;\n    mf->srcLen = srcLen;\n    mf->offset = mf->cycleSize;\n    mf->niceLen = encCtx->numFastBytes;\n    mf->depth = CMPT_MF_BASE_DEPTH + mf->niceLen / 2;\n    return 0;\n}": "1", "static void CmptMfMovePos(CmptMfCtx *mf)\n{\n    const uint32_t subvalue = (CMPTLZ_UINT32_MAX - mf->cycleSize);\n    uint32_t i;\n    for (i = 0; i < mf->hashCount; i++)\n    {\n        if (mf->hash[i] <= subvalue)\n        {\n            mf->hash[i] = CMPT_EMPTY_HASH_VALUE;\n        }\n        else\n        {\n            mf->hash[i] -= subvalue;\n        }\n    }\n    for (i = 0; i < mf->sonsCount; ++i)\n    {\n        if (mf->son[i] <= subvalue)\n        {\n            mf->son[i] = CMPT_EMPTY_HASH_VALUE;\n        }\n        else\n        {\n            mf->son[i] -= subvalue;\n        }\n    }\n    mf->offset -= subvalue;\n}": "2", "static CmptlzMatchPair *CmptBtFind(CmptMfCtx *mf, uint32_t curMatch, CmptlzMatchPair *matches, uint32_t longestLen)\n{\n\n    uint32_t depth = mf->depth;\n    uint32_t *const son = mf->son;\n    const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n    const uint32_t niceLen = mf->niceLen;\n    const uint32_t cyclePos = mf->cyclePos;\n    const uint32_t cycleSize = mf->cycleSize;\n    const uint32_t pos = mf->readPos + mf->offset;\n    uint32_t *ptr0 = son + (cyclePos << 1) + 1;\n    uint32_t *ptr1 = son + (cyclePos << 1);\n    uint32_t len0 = 0;\n    uint32_t len1 = 0;\n\n    while (true)\n    {\n        const uint32_t delta = pos - curMatch;\n        if (depth-- == 0 || delta >= cycleSize)\n        {\n            *ptr0 = CMPT_EMPTY_HASH_VALUE;\n            *ptr1 = CMPT_EMPTY_HASH_VALUE;\n            return matches;\n        }\n        uint32_t *const pair = son + ((cyclePos - delta + ((delta > cyclePos) ? cycleSize : 0)) << 1);\n        const uint8_t *const pb = cur - delta;\n        uint32_t len = CMPTLZ_FIND_MIN(len0, len1);\n        if (pb[len] == cur[len])\n        {\n            len = CmptMemCmpLenSafe(pb, cur, len + 1, niceLen);\n            if (longestLen < len)\n            {\n                longestLen = len;\n                matches->len = len;\n                matches->dist = delta - 1;\n                ++matches;\n                if (len == niceLen)\n                {\n                    *ptr1 = pair[0];\n                    *ptr0 = pair[1];\n                    return matches;\n                }\n            }\n        }\n        if (pb[len] < cur[len])\n        {\n            CMPT_MF_LEFT_SON_UPDATE(ptr1, pair, curMatch, len1, len);\n        }\n        else\n        {\n            CMPT_MF_RIGHT_SON_UPDATE(ptr0, pair, curMatch, len0, len);\n        }\n    }\n}": "3", "static void CmptBtSkip(CmptMfCtx *mf, const uint32_t lenLimit, const uint32_t pos, const uint8_t *const cur,\n                       uint32_t curMatch)\n{\n    uint32_t depth = mf->depth;\n    uint32_t *const son = mf->son;\n    const uint32_t cyclePos = mf->cyclePos;\n    const uint32_t cycleSize = mf->cycleSize;\n\n    uint32_t *ptr0 = son + (cyclePos << 1) + 1;\n    uint32_t *ptr1 = son + (cyclePos << 1);\n    uint32_t len0 = 0;\n    uint32_t len1 = 0;\n\n    while (true)\n    {\n        const uint32_t delta = pos - curMatch;\n        if (depth-- == 0 || delta >= cycleSize)\n        {\n            *ptr0 = CMPT_EMPTY_HASH_VALUE;\n            *ptr1 = CMPT_EMPTY_HASH_VALUE;\n            return;\n        }\n        uint32_t *pair = son + ((cyclePos - delta + ((delta > cyclePos) ? cycleSize : 0)) << 1);\n        const uint8_t *pb = cur - delta;\n        uint32_t len = CMPTLZ_FIND_MIN(len0, len1);\n        if (pb[len] == cur[len])\n        {\n            len = CmptMemCmpLenSafe(pb, cur, len + 1, lenLimit);\n            if (len == lenLimit)\n            {\n                *ptr1 = pair[0];\n                *ptr0 = pair[1];\n                return;\n            }\n        }\n        if (pb[len] < cur[len])\n        {\n            CMPT_MF_LEFT_SON_UPDATE(ptr1, pair, curMatch, len1, len);\n        }\n        else\n        {\n            CMPT_MF_RIGHT_SON_UPDATE(ptr0, pair, curMatch, len0, len);\n        }\n    }\n}": "4", "static uint32_t CmptlzBt4Finder(CmptMfCtx *mf, CmptlzMatchPair *matches)\n{\n    const uint32_t niceLen = mf->niceLen;\n    const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n    const uint32_t pos = mf->readPos + mf->offset;\n    uint32_t temp, hash2Value, hash3Value, hashValue;\n    uint32_t longestLen = 1, matchesCount = 0;\n    CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue);\n\n    uint32_t delta2 = pos - mf->hash[hash2Value];\n    uint32_t delta3 = pos - mf->hash[CMPTLZ_FIX_3_HASH + hash3Value];\n    uint32_t curMatch = mf->hash[CMPTLZ_FIX_4_HASH + hashValue];\n    CMPT_HASH_UPDATE(mf, hash2Value, hash3Value, hashValue, pos);\n    CMPT_HASH_FIND_2_BYTES(mf, delta2, longestLen, matchesCount, cur, matches);\n    CMPT_HASH_FIND_3_BYTES(mf, delta2, delta3, longestLen, matchesCount, cur, matches);\n\n    if (matchesCount != 0)\n    {\n        longestLen = CmptMemCmpLenSafe(cur, cur - delta2, longestLen, niceLen);\n        matches[matchesCount - 1].len = longestLen;\n        if (longestLen == niceLen)\n        {\n            CmptBtSkip(mf, niceLen, pos, cur, curMatch);\n            CMPT_MF_MOVE_POS(mf);\n            return matchesCount;\n        }\n    }\n\n    if (longestLen < CMPT_MF_MATCH_3_BYTES)\n    {\n        longestLen = CMPT_MF_MATCH_3_BYTES;\n    }\n    matchesCount = (uint32_t)(CmptBtFind(mf, curMatch, matches + matchesCount, longestLen) - matches);\n\n    CMPT_MF_MOVE_POS(mf);\n    return matchesCount;\n}": "5", "void CmptlzMatchSkiper(CmptMfCtx *mf, uint32_t amount)\n{\n    mf->readAhead += amount;\n    uint32_t pos, temp, hash2Value, hash3Value, hashValue, curMatch;\n    const uint32_t niceLen = mf->niceLen;\n    do\n    {\n        uint32_t lenLimit = mf->srcLen - mf->readPos;\n        if (CMPTLZ_LIKELY(niceLen <= lenLimit))\n        {\n            lenLimit = niceLen;\n        }\n        else\n        {\n            mf->readPos++;\n            continue;\n        }\n        const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n        pos = mf->readPos + mf->offset;\n        CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue);\n        curMatch = mf->hash[CMPTLZ_FIX_4_HASH + hashValue];\n        CMPT_HASH_UPDATE(mf, hash2Value, hash3Value, hashValue, pos);\n        CmptBtSkip(mf, lenLimit, pos, cur, curMatch);\n        CMPT_MF_MOVE_POS(mf);\n    } while (--amount != 0);\n}": "6", "uint32_t CmptlzMatchFinder(CmptMfCtx *mf, uint32_t *pCount, CmptlzMatchPair *matches)\n{\n    if (CMPTLZ_UNLIKELY(mf->srcLen - mf->readPos < mf->niceLen))\n    {\n        *pCount = 0;\n        mf->readPos++;\n        mf->readAhead++;\n        return 0;\n    }\n    const uint32_t count = CmptlzBt4Finder(mf, matches);\n    if (count == 0)\n    {\n        *pCount = 0;\n        mf->readAhead++;\n        return 0;\n    }\n    uint32_t longestLen = matches[count - 1].len;\n    if (longestLen == mf->niceLen)\n    {\n        uint32_t bytesAvail = CMPTLZ_FIND_MIN(mf->srcLen - mf->readPos + 1, CMPT_MF_LONGEST_MATCH);\n        const uint8_t *p1 = (const uint8_t *)(mf->srcStart + mf->readPos - 1);\n        const uint8_t *p2 = p1 - matches[count - 1].dist - 1;\n        longestLen = CmptMemCmpLenSafe(p1, p2, longestLen, bytesAvail);\n    }\n    *pCount = count;\n    mf->readAhead++;\n    return longestLen;\n}": "7", "static void CmptlzEndMarker(void)\n{\n\n    return;\n}": "8", "static int CmptlzFlush(CmptLzEncCtx *encCtx)\n{\n    encCtx->encNeedFinish = true;\n    if (encCtx->endMarker != 0)\n    {\n        CmptlzEndMarker();\n    }\n\n    CmptRcFlushData(encCtx->rcCtx);\n    return CmptRcFlush64Kb(encCtx->rcCtx);\n}": "9", "static inline void CmptPriceCheck(CmptLzEncCtx *encCtx)\n{\n\n    if (encCtx->matchPriceCount >= CMPT_PRICE_COUNT)\n    {\n        CmptPriceGenDistTable(encCtx);\n        CmptPriceGenAlignTable(encCtx);\n        CmptPriceGenLenTable(encCtx, &encCtx->matchLenEncoder);\n    }\n    if (encCtx->repLenPriceCount <= 0)\n    {\n        encCtx->repLenPriceCount = CMPT_PRICE_COUNT;\n        CmptPriceGenLenTable(encCtx, &encCtx->repLenEncoder);\n    }\n}": "10", "static inline int CmptEncShortOrRep0(CmptLzEncCtx *encCtx, uint32_t nowpos32, uint32_t lenRes)\n{\n    int shiftRes = CMPT_OK;\n    if (lenRes == 1)\n    {\n        shiftRes = CmptlzEncShortRep(encCtx, nowpos32);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    else\n    {\n        shiftRes = CmptlzEncLongRep(encCtx, 0, nowpos32, lenRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    return CMPT_OK;\n}": "11", "CMPTLZ_static int CmptEncodeOneBlock(CmptLzEncCtx *encCtx)\n{\n    CmptMfCtx *mf = encCtx->mfCtx;\n    uint32_t nowpos32 = encCtx->nowpos64;\n    uint32_t startpos = nowpos32;\n    uint32_t backRes, lenRes;\n    int shiftRes = CMPT_OK;\n    while (true)\n    {\n        CmptlzDp(encCtx, mf, nowpos32);\n        backRes = encCtx->backRes;\n        lenRes = encCtx->lenRes;\n#ifdef CMPTLZ_PRINTF_ENC_PROCESS\n        printf(\" now in CmptEncodeOneBlock process, backRes is %u, lenRes is %u\\n\", backRes, lenRes);\n        printf(\" nowpos32 is %u\\n\", nowpos32);\n#endif\n\n        switch (backRes)\n        {\n        case CMPTLZ_UINT32_MAX:\n            shiftRes = CmptlzEncLit(encCtx, mf, nowpos32);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 0:\n            shiftRes = CmptEncShortOrRep0(encCtx, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 1:\n            shiftRes = CmptlzEncLongRep(encCtx, 1, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 2:\n            shiftRes = CmptlzEncLongRep(encCtx, 2, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 3:\n            shiftRes = CmptlzEncLongRep(encCtx, 3, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        default:\n            shiftRes = CmptlzEncNormalMatch(encCtx, nowpos32, backRes, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        }\n\n        nowpos32 += lenRes;\n        mf->mfStart += lenRes;\n        mf->readAhead -= lenRes;\n\n        if (mf->readAhead == 0)\n        {\n\n            CmptPriceCheck(encCtx);\n            if (mf->srcLen <= mf->mfStart)\n            {\n                break;\n            }\n            if (nowpos32 - startpos >= CMPT_ONE_BLOCK_MAX_SIZE)\n            {\n                encCtx->nowpos64 += nowpos32 - startpos;\n                return 0;\n            }\n        }\n    }\n    encCtx->nowpos64 += nowpos32 - startpos;\n    return CmptlzFlush(encCtx);\n}": "12", "int CmptEncodeAll(CmptLzEncCtx *encCtx)\n{\n    CmptRcCtx *rc = encCtx->rcCtx;\n    CmptMfCtx *mf = encCtx->mfCtx;\n\n    if (mf->srcLen == 0)\n    {\n        return CmptlzFlush(encCtx);\n    }\n\n    if (encCtx->nowpos64 == 0)\n    {\n        uint32_t range, bit0Prob, newBound;\n        range = rc->range;\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][0];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        int shiftRes = CMPT_OK;\n        CMPT_RC_BIT_0_PROCESS(rc, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        rc->range = range;\n        uint8_t curByte = *(mf->srcStart);\n        CmptlzProb *litProb = &encCtx->litMarcov.literal[0][0];\n        shiftRes = CmptRcLitProcess(rc, litProb, curByte);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        mf->mfStart++;\n        encCtx->nowpos64++;\n        mf->readPos++;\n        if (mf->srcLen == 1)\n        {\n            return CmptlzFlush(encCtx);\n        }\n    }\n\n    int res;\n    while (true)\n    {\n        res = CmptEncodeOneBlock(encCtx);\n        if (res != 0 || encCtx->encNeedFinish)\n        {\n            break;\n        }\n    }\n    return res;\n}": "13", "static inline int CmptRcLitProcess(CmptRcCtx *rcCtx, CmptlzProb *prob, uint32_t sym)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t range = rcCtx->range, bit0Prob, newBound, curBit;\n\n        for (sym |= 0x100; sym < 0x10000; sym <<= 1)\n        {\n            CmptlzProb *litProbTableIndex = prob + (sym >> 8);\n            curBit = (sym >> 7) & 1;\n            CMPT_RC_BIT_PROCESS(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        rcCtx->range = range;\n        return CMPT_OK;\n    }": "14", "static inline int CmptRcLitAfterMatch(CmptRcCtx *rcCtx, CmptlzProb *prob, uint32_t sym, uint32_t matchByte)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t range = rcCtx->range, offs = 0x100, bit0Prob, newBound, curBit;\n        for (sym |= 0x100; sym < 0x10000;)\n        {\n            matchByte <<= 1;\n            CmptlzProb *litProbTableIndex = prob + (offs + (matchByte & offs) + (sym >> 8));\n            curBit = (sym >> 7) & 1;\n            sym <<= 1;\n            offs &= ~(matchByte ^ sym);\n            CMPT_RC_BIT_PROCESS(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        rcCtx->range = range;\n        return CMPT_OK;\n    }": "15", "static inline void CmptlzDpInitShortRep(CmptLzEncCtx *encCtx, uint32_t repMatchPrice, const uint32_t posState)\n{\n    const uint32_t shortRepPrice = repMatchPrice + CmptPriceShortRep(encCtx, encCtx->state, posState);\n    if (shortRepPrice < encCtx->opts[1].price)\n    {\n        encCtx->opts[1].price = shortRepPrice;\n        encCtx->opts[1].backPrev = 0;\n    }\n}": "16", "static inline void CmptlzDpInitLongRep(CmptLzEncCtx *encCtx, uint32_t *repLens, const uint32_t repMatchPrice,\n                                       const uint32_t posState)\n{\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        uint32_t repLen = repLens[i];\n        if (repLen < CMPTLZ_MATCH_LEN_MIN)\n        {\n            continue;\n        }\n        const uint32_t price = repMatchPrice + CmptPriceLongRep(encCtx, i, encCtx->state, posState);\n        do\n        {\n            const uint32_t curAndLenPrice = price + CmptPriceLen(&encCtx->repLenEncoder, repLen, posState);\n            if (curAndLenPrice < encCtx->opts[repLen].price)\n            {\n                encCtx->opts[repLen].price = curAndLenPrice;\n                encCtx->opts[repLen].posPrev = 0;\n                encCtx->opts[repLen].backPrev = i;\n            }\n            repLen--;\n        } while (repLen >= CMPTLZ_MATCH_LEN_MIN);\n    }\n}": "17", "static inline void CmptlzDpInitMatch(CmptLzEncCtx *encCtx, uint32_t matchesCount, uint32_t normalMatchPrice,\n                                     uint32_t posState, uint32_t len)\n{\n    uint32_t i = 0;\n    while (len > encCtx->matches[i].len)\n    {\n        i++;\n    }\n    for (;; len++)\n    {\n        const uint32_t dist = encCtx->matches[i].dist;\n        const uint32_t curAndLenPrice = normalMatchPrice + CmptPriceDistWithLen(encCtx, dist, len, posState);\n        if (curAndLenPrice < encCtx->opts[len].price)\n        {\n            encCtx->opts[len].price = curAndLenPrice;\n            encCtx->opts[len].posPrev = 0;\n            encCtx->opts[len].backPrev = dist + CMPTLZ_NUM_REPS;\n        }\n        if (len == encCtx->matches[i].len)\n        {\n            if (++i == matchesCount)\n            {\n                break;\n            }\n        }\n    }\n}": "18", "static uint32_t CmptlzDpInit(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t position)\n{\n    const uint32_t niceLen = mf->niceLen;\n    uint32_t lenMain;\n    uint32_t matchesCount = 0;\n\n    if (mf->readAhead == 0)\n    {\n        lenMain = CmptlzMatchFinder(mf, &matchesCount, encCtx->matches);\n    }\n    else\n    {\n        lenMain = encCtx->longestMatchLen;\n        matchesCount = encCtx->matchesCount;\n    }\n\n    const uint8_t *const buf = CmptMfGetPtr(mf) - 1;\n    const uint32_t bufAvail = CMPTLZ_FIND_MIN(CmptMfAvail(mf) + 1, CMPT_MF_LONGEST_MATCH);\n\n    if (bufAvail < CMPTLZ_MATCH_LEN_MIN)\n    {\n        encCtx->backRes = CMPTLZ_UINT32_MAX;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    uint32_t repLens[CMPTLZ_NUM_REPS];\n    uint32_t repMaxIndex = 0;\n\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        const uint8_t *const bufBack = buf - encCtx->reps[i] - 1;\n\n        if (NOT_EQUAL_2_BYTES(buf, bufBack))\n        {\n            repLens[i] = 0;\n            continue;\n        }\n        repLens[i] = CmptMemCmpLenSafe(buf, bufBack, CMPTLZ_MATCH_LEN_MIN, bufAvail);\n        if (repLens[i] > repLens[repMaxIndex])\n        {\n            repMaxIndex = i;\n        }\n    }\n\n    if (repLens[repMaxIndex] >= niceLen)\n    {\n        encCtx->backRes = repMaxIndex;\n        encCtx->lenRes = repLens[repMaxIndex];\n        CmptlzMatchSkiper(mf, repLens[repMaxIndex] - 1);\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    if (lenMain >= niceLen)\n    {\n        encCtx->backRes = encCtx->matches[matchesCount - 1].dist + CMPTLZ_NUM_REPS;\n        encCtx->lenRes = lenMain;\n        CmptlzMatchSkiper(mf, lenMain - 1);\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    const uint8_t currentByte = *buf;\n    const uint8_t matchByte = *(buf - encCtx->reps[0] - 1);\n    const uint32_t lenEnd = CMPTLZ_FIND_MAX(lenMain, repLens[repMaxIndex]);\n    if ((lenEnd < CMPTLZ_MATCH_LEN_MIN) && (currentByte != matchByte))\n    {\n        encCtx->backRes = CMPTLZ_UINT32_MAX;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    encCtx->opts[0].state = encCtx->state;\n\n    const uint32_t posState = position & encCtx->posMask;\n\n    encCtx->litMarcov.pos = position;\n    encCtx->litMarcov.prevByte = *(buf - 1);\n    bool isLiteralState = (encCtx->state < 7);\n    bool isMatchMode = !isLiteralState;\n\n    encCtx->opts[1].price = CmptPriceBit0(encCtx, encCtx->isMatch[encCtx->state][posState]) +\n                            CmptPriceLiteral(encCtx, isMatchMode, matchByte, currentByte);\n    encCtx->opts[1].backPrev = CMPTLZ_UINT32_MAX;\n\n    const uint32_t matchPrice = CmptPriceBit1(encCtx, encCtx->isMatch[encCtx->state][posState]);\n    const uint32_t repMatchPrice = matchPrice + CmptPriceBit1(encCtx, encCtx->isRep[encCtx->state]);\n\n    if (matchByte == currentByte)\n    {\n        CmptlzDpInitShortRep(encCtx, repMatchPrice, posState);\n    }\n\n    if (lenEnd < CMPTLZ_MATCH_LEN_MIN)\n    {\n        encCtx->backRes = encCtx->opts[1].backPrev;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    encCtx->opts[1].posPrev = 0;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->opts[0].backs[i] = encCtx->reps[i];\n    }\n\n    uint32_t len = lenEnd;\n    do\n    {\n        encCtx->opts[len].price = CMPT_INFINITY_PRICE;\n        len--;\n    } while (len >= CMPTLZ_MATCH_LEN_MIN);\n\n    CmptlzDpInitLongRep(encCtx, repLens, repMatchPrice, posState);\n\n    const uint32_t normalMatchPrice = matchPrice + CmptPriceBit0(encCtx, encCtx->isRep[encCtx->state]);\n    len = (repLens[0] > CMPTLZ_MATCH_LEN_MIN) ? repLens[0] + 1 : CMPTLZ_MATCH_LEN_MIN;\n\n    if (len <= lenMain)\n    {\n        CmptlzDpInitMatch(encCtx, matchesCount, normalMatchPrice, posState, len);\n    }\n    return lenEnd;\n}": "19", "static inline void CmptlzDpPre(CmptLzEncCtx *encCtx, uint32_t *mainReps, const uint32_t cur)\n{\n    uint32_t posPointer = encCtx->opts[cur].posPrev;\n    CmptlzState state = encCtx->opts[posPointer].state;\n\n    if (posPointer == cur - 1)\n    {\n        if (encCtx->opts[cur].backPrev == 0)\n        {\n            CMPT_STATE_UPDATE_WHEN_SHORTREP(state);\n        }\n        else\n        {\n            CMPT_STATE_UPDATE_WHEN_LIT(state);\n        }\n    }\n    else\n    {\n        uint32_t backPointer;\n        backPointer = encCtx->opts[cur].backPrev;\n\n        if (backPointer < CMPTLZ_NUM_REPS)\n        {\n            CMPT_STATE_UPDATE_WHEN_LONGREP(state);\n        }\n        else\n        {\n            CMPT_STATE_UPDATE_WHEN_MATCH(state);\n        }\n\n        uint32_t i;\n        if (backPointer < CMPTLZ_NUM_REPS)\n        {\n            mainReps[0] = encCtx->opts[posPointer].backs[backPointer];\n\n            for (i = 1; i <= backPointer; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i - 1];\n            }\n            for (; i < CMPTLZ_NUM_REPS; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i];\n            }\n        }\n        else\n        {\n            mainReps[0] = backPointer - CMPTLZ_NUM_REPS;\n            for (i = 1; i < CMPTLZ_NUM_REPS; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i - 1];\n            }\n        }\n    }\n\n    encCtx->opts[cur].state = state;\n\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->opts[cur].backs[i] = mainReps[i];\n    }\n}": "20", "static inline void CmptlzDpTryCurAndLit(CmptLzEncCtx *encCtx, const uint32_t curPrice, CmptlzState curState,\n                                        const uint32_t posState, const uint32_t cur, const uint8_t latestMatchByte,\n                                        const uint8_t curByte)\n{\n    bool isLiteralState = (curState < 7);\n    bool isMatchMode = !isLiteralState;\n    const uint32_t curAndLitPrice = curPrice + CmptPriceBit0(encCtx, encCtx->isMatch[curState][posState]) +\n                                    CmptPriceLiteral(encCtx, isMatchMode, latestMatchByte, curByte);\n    if (curAndLitPrice < encCtx->opts[cur + 1].price)\n    {\n        encCtx->opts[cur + 1].price = curAndLitPrice;\n        encCtx->opts[cur + 1].posPrev = cur;\n        encCtx->opts[cur + 1].backPrev = CMPTLZ_UINT32_MAX;\n    }\n}": "21", "static inline void CmptlzDpTryCurAndShort(CmptLzEncCtx *encCtx, const uint32_t repMatchPrice, const uint32_t cur,\n                                          CmptlzState curState, const uint32_t posState)\n{\n    const uint32_t shortRepPrice = repMatchPrice + CmptPriceShortRep(encCtx, curState, posState);\n    if (shortRepPrice < encCtx->opts[cur + 1].price)\n    {\n        encCtx->opts[cur + 1].price = shortRepPrice;\n        encCtx->opts[cur + 1].posPrev = cur;\n        encCtx->opts[cur + 1].backPrev = 0;\n    }\n}": "22", "static inline void CmptlzDpTryCurAndLong(CmptLzEncCtx *encCtx, const uint32_t prefixPrice, const uint32_t cur,\n                                         uint32_t mainRepIndex, uint32_t lenEqual, const uint32_t posState)\n{\n    do\n    {\n        const uint32_t curLongRepPrice = prefixPrice + CmptPriceLen(&encCtx->repLenEncoder, lenEqual, posState);\n\n        if (curLongRepPrice < encCtx->opts[cur + lenEqual].price)\n        {\n            encCtx->opts[cur + lenEqual].price = curLongRepPrice;\n            encCtx->opts[cur + lenEqual].posPrev = cur;\n            encCtx->opts[cur + lenEqual].backPrev = mainRepIndex;\n        }\n    } while (--lenEqual >= CMPTLZ_MATCH_LEN_MIN);\n}": "23", "static inline void CmptlzDpTryCurAndMatch(CmptLzEncCtx *encCtx, uint32_t startLen, uint32_t matchCount,\n                                          const uint32_t normalmatch_prefixPrice, const uint32_t cur,\n                                          const uint32_t posState)\n{\n    uint32_t i = 0;\n    while (startLen > encCtx->matches[i].len)\n    {\n        i++;\n    }\n    uint32_t lenTest;\n    for (lenTest = startLen;; lenTest++)\n    {\n        const uint32_t curBack = encCtx->matches[i].dist;\n        uint32_t cur_normalmatchPrice =\n            normalmatch_prefixPrice + CmptPriceDistWithLen(encCtx, curBack, lenTest, posState);\n        if (cur_normalmatchPrice < encCtx->opts[cur + lenTest].price)\n        {\n            encCtx->opts[cur + lenTest].price = cur_normalmatchPrice;\n            encCtx->opts[cur + lenTest].posPrev = cur;\n            encCtx->opts[cur + lenTest].backPrev = curBack + CMPTLZ_NUM_REPS;\n        }\n        if (lenTest == encCtx->matches[i].len)\n        {\n            if (++i == matchCount)\n            {\n                break;\n            }\n        }\n    }\n}": "24", "static inline uint32_t CmptlzDpProcess(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t *mainReps, uint32_t lenEnd,\n                                       uint32_t position, const uint32_t cur)\n{\n\n    CmptlzState curState = encCtx->opts[cur].state;\n    const uint32_t bufAvailFull = CMPTLZ_FIND_MIN(CmptMfAvail(mf) + 1, CMPT_DP_OPTMAX - 1 - cur);\n    const uint8_t *buf = CmptMfGetPtr(mf) - 1;\n    const uint32_t niceLen = mf->niceLen;\n    const uint32_t curPrice = encCtx->opts[cur].price;\n    const uint8_t curByte = *buf;\n    const uint8_t latestMatchByte = *(buf - mainReps[0] - 1);\n    const uint32_t posState = position & encCtx->posMask;\n\n    encCtx->litMarcov.pos = position;\n    encCtx->litMarcov.prevByte = *(buf - 1);\n\n    CmptlzDpTryCurAndLit(encCtx, curPrice, curState, posState, cur, latestMatchByte, curByte);\n\n    const uint32_t matchPrice = curPrice + CmptPriceBit1(encCtx, encCtx->isMatch[curState][posState]);\n    const uint32_t repMatchPrice = matchPrice + CmptPriceBit1(encCtx, encCtx->isRep[curState]);\n\n    if (curByte == latestMatchByte && !(encCtx->opts[cur + 1].posPrev < cur && encCtx->opts[cur + 1].backPrev == 0))\n    {\n\n        CmptlzDpTryCurAndShort(encCtx, repMatchPrice, cur, curState, posState);\n    }\n\n    if (bufAvailFull < CMPTLZ_MATCH_LEN_MIN)\n    {\n        return lenEnd;\n    }\n    const uint32_t bufAvail = CMPTLZ_FIND_MIN(bufAvailFull, niceLen);\n    uint32_t startLen = CMPTLZ_MATCH_LEN_MIN;\n\n    uint32_t mainRepIndex;\n    for (mainRepIndex = 0; mainRepIndex < CMPTLZ_NUM_REPS; mainRepIndex++)\n    {\n        const uint8_t *const bufRepBack = buf - mainReps[mainRepIndex] - 1;\n\n        if (NOT_EQUAL_2_BYTES(buf, bufRepBack))\n        {\n            continue;\n        }\n\n        uint32_t lenEqual;\n        lenEqual = CmptMemCmpLenSafe(buf, bufRepBack, CMPTLZ_MATCH_LEN_MIN, bufAvail);\n        while (lenEnd < cur + lenEqual)\n        {\n\n            lenEnd++;\n            encCtx->opts[lenEnd].price = CMPT_INFINITY_PRICE;\n        }\n\n        const uint32_t lenEqualMem = lenEqual;\n\n        const uint32_t prefixPrice = repMatchPrice + CmptPriceLongRep(encCtx, mainRepIndex, curState, posState);\n\n        CmptlzDpTryCurAndLong(encCtx, prefixPrice, cur, mainRepIndex, lenEqual, posState);\n\n        lenEqual = lenEqualMem;\n\n        if (mainRepIndex == 0)\n        {\n            startLen = lenEqual + 1;\n        }\n    }\n\n    uint32_t newLongestLen = encCtx->longestMatchLen;\n    uint32_t matchCount = encCtx->matchesCount;\n\n    if (newLongestLen > bufAvail)\n    {\n        newLongestLen = bufAvail;\n        matchCount = 0;\n        while (newLongestLen > encCtx->matches[matchCount].len)\n        {\n            ++matchCount;\n        }\n        encCtx->matches[matchCount++].len = newLongestLen;\n    }\n\n    if (newLongestLen >= startLen)\n    {\n        const uint32_t normalmatch_prefixPrice = matchPrice + CmptPriceBit0(encCtx, encCtx->isRep[curState]);\n\n        while (lenEnd < cur + newLongestLen)\n        {\n            lenEnd++;\n            encCtx->opts[lenEnd].price = CMPT_INFINITY_PRICE;\n        }\n        CmptlzDpTryCurAndMatch(encCtx, startLen, matchCount, normalmatch_prefixPrice, cur, posState);\n    }\n    return lenEnd;\n}": "25", "static inline void CmptlzDpReverse(CmptLzEncCtx *encCtx, uint32_t cur)\n{\n    encCtx->optEndIndex = cur;\n    uint32_t posTmp = encCtx->opts[cur].posPrev;\n    uint32_t backTmp = encCtx->opts[cur].backPrev;\n    uint32_t posPrev, backCurPacket;\n    do\n    {\n        posPrev = posTmp;\n        backCurPacket = backTmp;\n\n        backTmp = encCtx->opts[posPrev].backPrev;\n        posTmp = encCtx->opts[posPrev].posPrev;\n\n        encCtx->opts[posPrev].backPrev = backCurPacket;\n        encCtx->opts[posPrev].posPrev = cur;\n        cur = posPrev;\n    } while (cur != 0);\n\n    encCtx->lenRes = encCtx->opts[0].posPrev;\n    encCtx->backRes = encCtx->opts[0].backPrev;\n    encCtx->optsCurIndex = encCtx->opts[0].posPrev;\n}": "26", "void CmptlzDp(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t position)\n{\n    uint32_t curIndex = encCtx->optsCurIndex;\n    uint32_t endIndex = encCtx->optEndIndex;\n\n    if (endIndex != curIndex)\n    {\n        encCtx->lenRes = encCtx->opts[curIndex].posPrev - curIndex;\n        encCtx->backRes = encCtx->opts[curIndex].backPrev;\n        encCtx->optsCurIndex = encCtx->opts[curIndex].posPrev;\n        return;\n    }\n    uint32_t lenEnd = CmptlzDpInit(encCtx, mf, position);\n\n    if (lenEnd == CMPTLZ_UINT32_MAX)\n    {\n        return;\n    }\n    uint32_t mainReps[CMPTLZ_NUM_REPS];\n    memcpy_s(mainReps, sizeof(mainReps), encCtx->reps, sizeof(encCtx->reps));\n\n    uint32_t cur;\n    for (cur = 1; cur < lenEnd; cur++)\n    {\n        encCtx->longestMatchLen = CmptlzMatchFinder(mf, &encCtx->matchesCount, encCtx->matches);\n        if (encCtx->longestMatchLen >= mf->niceLen)\n        {\n            break;\n        }\n        CmptlzDpPre(encCtx, mainReps, cur);\n        lenEnd = CmptlzDpProcess(encCtx, mf, mainReps, lenEnd, position + cur, cur);\n    }\n    CmptlzDpReverse(encCtx, cur);\n    return;\n}": "27", "int CmptRcPrepare(CmptLzEncCtx *encCtx, uint8_t *dest, size_t *destLen, CmptLzMemHook *alloc)\n{\n\n    CmptRcCtx *rc = alloc->CmptLzAlloc(CMPTLZ_RC_CCTX_HANDLE, sizeof(CmptRcCtx));\n    if (rc == NULL)\n    {\n        return CMPT_ENC_RC_INIT_FAIL;\n    }\n    memset_s(rc, sizeof(CmptRcCtx), 0, sizeof(CmptRcCtx));\n\n    encCtx->rcCtx = rc;\n\n    rc->bufBase = alloc->CmptLzAlloc(CMPTLZ_RC_BUF_HANDLE, CMPTLZ_RC_BUFFER_SIZE);\n    memset_s(rc->bufBase, CMPTLZ_RC_BUFFER_SIZE, 0, CMPTLZ_RC_BUFFER_SIZE);\n    if (rc->bufBase == NULL)\n    {\n        return CMPT_ENC_RC_INIT_FAIL;\n    }\n\n    rc->outBufLeft = *destLen;\n    rc->outBuf = dest;\n\n    rc->buf = rc->bufBase;\n    rc->range = 0xFFFFFFFF;\n    rc->cacheSize = 0;\n    rc->cache = 0;\n    rc->low = 0;\n    return 0;\n}": "28", "int CmptRcFlush64Kb(CmptRcCtx *rcCtx)\n{\n    size_t flushOutLen = rcCtx->buf - rcCtx->bufBase;\n    int res = memcpy_s(rcCtx->outBuf, rcCtx->outBufLeft, rcCtx->bufBase, flushOutLen);\n    if (res != 0)\n    {\n        return CMPT_ENC_ERROR_WRITE;\n    }\n    rcCtx->outBuf += flushOutLen;\n    rcCtx->outBufLeft -= flushOutLen;\n    rcCtx->buf = rcCtx->bufBase;\n    return CMPT_OK;\n}": "29", "int CmptRcShiftLow(CmptRcCtx *rcCtx)\n{\n    int res = CMPT_OK;\n    uint32_t lowLow32 = (uint32_t)rcCtx->low;\n    uint64_t high = (uint32_t)(rcCtx->low >> 32);\n    rcCtx->low = (uint32_t)(lowLow32 << 8);\n    CMPT_RC_BREAK_CHECK(rcCtx, rcCtx->buf, res);\n    if (lowLow32 < 0xFF000000 || high != 0)\n    {\n        uint8_t *buf = rcCtx->buf;\n        *(buf) = (uint8_t)(rcCtx->cache + high);\n        buf++;\n        rcCtx->buf = buf;\n        rcCtx->cache = (uint8_t)(lowLow32 >> 24);\n        CMPT_RC_BREAK_SHIFTING(rcCtx, buf, res);\n        high += 0xFF;\n        while (1)\n        {\n            uint8_t *buf1 = rcCtx->buf;\n            CMPT_RC_BREAK_SHIFTING(rcCtx, buf1, res);\n            *(buf1++) = (uint8_t)(high);\n            rcCtx->buf = buf1;\n            rcCtx->cacheSize--;\n        }\n        CMPT_RC_BREAK_SHIFTING(rcCtx, buf, res);\n    }\n    else\n    {\n        rcCtx->cacheSize++;\n    }\n    return res;\n}": "30", "int CmptRcFlushData(CmptRcCtx *rcCtx)\n{\n    int i;\n    int res;\n    for (i = 0; i < 5; i++)\n    {\n        res = CmptRcShiftLow(rcCtx);\n        if (res != CMPT_OK)\n        {\n            break;\n        }\n    }\n    return res;\n}": "31", "void CmptRcCtxInit(CmptRcCtx *rcCtx)\n{\n    rcCtx->range = 0xFFFFFFFF;\n    rcCtx->cache = 0;\n    rcCtx->low = 0;\n    rcCtx->cacheSize = 0;\n    rcCtx->buf = rcCtx->bufBase;\n}": "32", "int CmptRcLenProcess(CmptLenEncoder *lenEncoder, CmptRcCtx *rcCtx, uint32_t len, uint64_t posState)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = rcCtx->range;\n    uint32_t newBound, bit0Prob;\n    len -= CMPTLZ_MATCH_LEN_MIN;\n\n    CmptlzProb *probs = lenEncoder->low;\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    if (len >= CMPT_LEN_BOUND)\n    {\n        CMPT_RC_BIT_1_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs += CMPT_LEN_BOUND;\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        if (len >= CMPT_LEN_BOUND * CMPT_DOUBLE)\n        {\n            CMPT_RC_BIT_1_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            rcCtx->range = range;\n            shiftRes = CmptRcLitProcess(rcCtx, lenEncoder->high, len - CMPT_LEN_BOUND * CMPT_DOUBLE);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            return CMPT_OK;\n        }\n        len -= CMPT_LEN_BOUND;\n    }\n\n    uint32_t m, bit;\n    CMPT_RC_BIT_0_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs += (posState << (1 + 3));\n    bit = (len >> 2);\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    m = (1 << 1) + bit;\n    bit = (len >> 1) & 1;\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    m = (m << 1) + bit;\n    bit = len & 1;\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    rcCtx->range = range;\n    return CMPT_OK;\n}": "33", "inline int CmptRcPosSlotProcess(CmptLzEncCtx *encCtx, uint32_t posSlot, uint32_t len)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = encCtx->rcCtx->range;\n    uint32_t sym = posSlot + (1 << 6);\n    uint32_t bit0Prob, newBound;\n    uint32_t bit;\n    CmptlzProb *probs = encCtx->probDistSlot[GET_LEN_TO_POS_STATE(len)];\n    do\n    {\n        CmptlzProb *posSlotProbTableIndex = probs + (sym >> CMPTLZ_DIST_SLOT_BITS);\n        bit = (sym >> (CMPTLZ_DIST_SLOT_BITS - 1)) & 1;\n        sym <<= 1;\n        CMPT_RC_BIT_PROCESS(encCtx->rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    } while (sym < (1 << (CMPTLZ_DIST_SLOT_BITS * 2)));\n    encCtx->rcCtx->range = range;\n    return CMPT_OK;\n}": "34", "static inline int CmptRcReverseProcess(CmptRcCtx *rcCtx, CmptlzProb *probs, uint32_t numBits, uint32_t sym)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = rcCtx->range;\n    uint32_t bit0Prob, newBound;\n    uint32_t bit;\n    uint32_t m = 1;\n    do\n    {\n        bit = sym & 1;\n        sym >>= 1;\n        CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        m = (m << 1) | bit;\n    } while (--numBits);\n\n    rcCtx->range = range;\n    return CMPT_OK;\n}": "35", "int CmptRcDistProcess(CmptLzEncCtx *encCtx, uint32_t posSlot, uint32_t dist)\n{\n    int shiftRes = CMPT_OK;\n\n    uint32_t footerBits = ((posSlot >> 1) - 1);\n    if (dist < CMPT_DIST_LIMIT_2)\n    {\n        uint32_t base = ((2 | (posSlot & 1)) << footerBits);\n        shiftRes = CmptRcReverseProcess(encCtx->rcCtx, encCtx->probDistSpecial + base, footerBits, dist);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    else\n    {\n        uint32_t pos2 = (dist | 0xF) << (32 - footerBits);\n        uint32_t range = encCtx->rcCtx->range;\n        do\n        {\n            range >>= 1;\n            encCtx->rcCtx->low += range & (0 - (pos2 >> 31));\n            pos2 += pos2;\n            CMPT_RC_NORMALIZE(encCtx->rcCtx, range, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        } while (pos2 != 0xF0000000);\n\n        uint32_t m = 1;\n        uint32_t bit;\n        uint32_t bit0Prob, newBound;\n        int k;\n        for (k = 0; k < CMPTLZ_ALIGN_BITS - 1; k++)\n        {\n            bit = dist & 1;\n            dist >>= 1;\n            CMPT_RC_BIT_PROCESS(encCtx->rcCtx, encCtx->probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            m = (m << 1) + bit;\n        }\n        bit = dist & 1;\n        CMPT_RC_BIT_PROCESS(encCtx->rcCtx, encCtx->probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n    }\n    return CMPT_OK;\n}": "36", "void CmptlzFreeAll(CmptLzEncCtx *encCtx, CmptLzMemHook *alloc)\n{\n    if (encCtx == NULL)\n    {\n        return;\n    }\n\n    if (encCtx->mfCtx != NULL)\n    {\n        if (encCtx->mfCtx->hash != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_MF_HASH_HANDLE, encCtx->mfCtx->hash);\n            encCtx->mfCtx->hash = NULL;\n        }\n        if (encCtx->mfCtx->son != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_MF_SON_HANDLE, encCtx->mfCtx->son);\n            encCtx->mfCtx->son = NULL;\n        }\n        alloc->CmptLzFree(CMPTLZ_MF_CCTX_HANDLE, encCtx->mfCtx);\n        encCtx->mfCtx = NULL;\n    }\n\n    if (encCtx->rcCtx != NULL)\n    {\n        if (encCtx->rcCtx->bufBase != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_RC_BUF_HANDLE, encCtx->rcCtx->bufBase);\n            encCtx->rcCtx->bufBase = NULL;\n        }\n        alloc->CmptLzFree(CMPTLZ_RC_CCTX_HANDLE, encCtx->rcCtx);\n        encCtx->rcCtx = NULL;\n    }\n\n    alloc->CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE, encCtx);\n    encCtx = NULL;\n}": "37", "int CmptlzEncodeIO(CmptLzEncCtx *encCtx, uint8_t *dest, size_t *destLen, const uint8_t *src, size_t srcLen,\n                   CmptLzMemHook *alloc)\n{\n    int res;\n\n    res = CmptMfPrepare(encCtx, src, srcLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptMfPrepare Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n\n    res = CmptRcPrepare(encCtx, dest, destLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptRcPrepare Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n\n    CmptlzEncPrepare(encCtx);\n\n    res = CmptEncodeAll(encCtx);\n\n    if (res != 0)\n    {\n        CmptlzFreeAll(encCtx, alloc);\n        CMPTLZ_LOG(res, \"CmptEncode Process Fail!\");\n        return res;\n    }\n\n    *destLen -= encCtx->rcCtx->outBufLeft;\n\n    if (encCtx->nowpos64 != srcLen)\n    {\n        CMPTLZ_LOG(res, \"CmptEncode FileSize Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return CMPT_ENC_ERROR_FILESIZE;\n    }\n\n    CmptlzFreeAll(encCtx, alloc);\n    return res;\n}": "38", "int CmptlzEncode(uint8_t *dest, size_t *destLen, const uint8_t *src, size_t srcLen, const CmptlzEncParam *props,\n                 uint8_t *propsEncoded, size_t *propsSize, int writeEndMark, CmptLzMemHook *alloc)\n{\n    int res;\n    if (alloc == NULL || alloc->CmptLzAlloc == NULL || alloc->CmptLzFree == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ENC_ERROR_PARAM, \"Cmptlz input wrong param!\");\n        return CMPT_ENC_ERROR_PARAM;\n    }\n\n    CmptLzEncCtx *encCtx = (CmptLzEncCtx *)CmptInitCctx(alloc, writeEndMark);\n    if (encCtx == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ENC_CTX_INIT_FAIL, \"CmptInitCctx Fail!\");\n        return CMPT_ENC_CTX_INIT_FAIL;\n    }\n    CmptlzSetParam(encCtx, props);\n    res = CmptHeadWrite(encCtx, propsEncoded, propsSize);\n    if (res != 0)\n    {\n        alloc->CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE, encCtx);\n        CMPTLZ_LOG(res, \"CmptHeadWrite Fail!\");\n        return res;\n    }\n    res = CmptlzEncodeIO(encCtx, dest, destLen, src, srcLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptlzEncode I / O Fail!\");\n    }\n    return res;\n}": "39", "int CmptlzCompress(void *src, size_t srcSize, void *dst, size_t *dstSize, CmptlzCompParam *param)\n{\n    if ((src == NULL) && (srcSize != 0))\n    {\n        return CMPT_ENC_ERROR_PARAM;\n    }\n\n    const int endMarker = 0;\n\n    CmptlzEncParam props;\n    props.level = param->level;\n    props.dictSize = param->dictSize;\n    props.litCtx = param->litCtx;\n    props.litPos = param->litPos;\n    props.posBits = param->posBits;\n    props.fastBytes = param->fastBytes;\n    props.numThreads = param->numThreads;\n    CmptLzMemHook *alloc = param->memHook;\n    return CmptlzEncode((uint8_t *)dst, dstSize, (const uint8_t *)src, srcSize, &props, param->protData,\n                        &param->protSize, endMarker, alloc);\n}": "40", "static inline uint32_t CmptMemCmpByOneByte(const uint8_t *buf1, const uint8_t *buf2, uint32_t len, uint32_t limit)\n    {\n        uint32_t lenIn = len;\n        while ((lenIn < limit) && (buf1[lenIn] == buf2[lenIn]))\n        {\n            lenIn++;\n        }\n        return lenIn;\n    }": "41", "static inline uint32_t CmptMemCmpLenSafe(const uint8_t *buf1, const uint8_t *buf2, uint32_t len, uint32_t limit)\n    {\n        return CmptMemCmpByOneByte(buf1, buf2, len, limit);\n    }": "42", "static inline uint32_t CmptMemCmpLen(const uint8_t *buf1, const uint8_t *buf2, uint32_t len, uint32_t limit)\n    {\n        return CmptMemCmpByOneByte(buf1, buf2, len, limit);\n    }": "43", "static inline uint32_t CmptMfAvail(const CmptMfCtx *mf)\n    {\n        return mf->srcLen - mf->readPos;\n    }": "44", "static inline const uint8_t *CmptMfGetPtr(const CmptMfCtx *mf)\n    {\n        return mf->srcStart + mf->readPos;\n    }": "45", "static inline uint32_t PosSlotHelper(uint32_t n)\n    {\n#if (defined(__GNUC__) && (__GNUC__ >= 3))\n        return 31 - (uint32_t)__builtin_clz(n);\n#else\n    uint32_t i = 31;\n    if ((n & 0xFFFF0000) == 0)\n    {\n        n <<= 16;\n        i = 15;\n    }\n    if ((n & 0xFF000000) == 0)\n    {\n        n <<= 8;\n        i -= 8;\n    }\n    if ((n & 0xF0000000) == 0)\n    {\n        n <<= 4;\n        i -= 4;\n    }\n    if ((n & 0xC0000000) == 0)\n    {\n        n <<= 2;\n        i -= 2;\n    }\n    if ((n & 0x80000000) == 0)\n        --i;\n    return i;\n#endif\n    }": "46", "static inline uint32_t PosSloter(uint32_t dist)\n    {\n        if (dist <= 4)\n        {\n            return dist;\n        }\n        uint32_t helper = PosSlotHelper(dist);\n        return (helper + helper + ((dist >> (helper - 1)) & 1));\n    }": "47", "void CmptlzParamNormalize(CmptlzEncParam *props)\n{\n\n    int level = props->level;\n    if (level < 0 || level > 9)\n    {\n        level = 5;\n    }\n    props->level = level;\n\n    if (props->dictSize < CMPTLZ_MIN_DICTSIZE || props->dictSize > CMPTLZ_MAX_DICTSIZE)\n    {\n        CMPTLZ_SET_DICTSIZE_BY_LEVEL(level, props->dictSize);\n    }\n    if (props->fastBytes < 5 || props->fastBytes > CMPT_MF_LONGEST_MATCH)\n    {\n        CMPTLZ_SET_FB_BY_LEVEL(level, props->fastBytes);\n    }\n\n    if (props->litCtx < 0 || props->litCtx > CMPTLZ_LC_MAX)\n    {\n        props->litCtx = 3;\n    }\n    if (props->litPos < 0 || props->litPos > CMPTLZ_LP_MAX)\n    {\n        props->litPos = 0;\n    }\n    if (props->posBits < 0 || props->posBits > CMPTLZ_PB_MAX)\n    {\n        props->posBits = 2;\n    }\n\n    props->numThreads = 1;\n}": "48", "void CmptlzSetParam(CmptLzEncCtx *encCtx, const CmptlzEncParam *props)\n{\n    CmptlzEncParam param = *props;\n\n    CmptlzParamNormalize(&param);\n\n    encCtx->dicSize = param.dictSize;\n    encCtx->numFastBytes = param.fastBytes;\n    encCtx->litCtx = param.litCtx;\n    encCtx->litPos = param.litPos;\n    encCtx->posBits = param.posBits;\n    uint32_t i;\n    for (i = 7; i < 32; i++)\n    {\n        if (encCtx->dicSize <= (uint32_t)(1 << i))\n        {\n            break;\n        }\n    }\n    encCtx->distTableSize = i * 2;\n}": "49", "void CmptlzPriceInit(CmptLzEncCtx *encCtx)\n{\n    CmptPriceGenRootTable(encCtx);\n    CmptPriceGenDistTable(encCtx);\n    CmptPriceGenAlignTable(encCtx);\n}": "50", "void CmptlzEncPrepare(CmptLzEncCtx *encCtx)\n{\n    uint32_t i;\n    uint32_t j;\n\n    encCtx->encNeedFinish = false;\n    encCtx->cmptlzResponse = 0;\n    encCtx->nowpos64 = 0;\n\n    encCtx->state = 0;\n    encCtx->pbMask = (1 << encCtx->posBits) - 1;\n    encCtx->lpMask = ((uint32_t)0x100 << encCtx->litPos) - ((uint32_t)0x100 >> encCtx->litCtx);\n    encCtx->posMask = (1 << encCtx->posBits) - 1;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->reps[i] = 0;\n    }\n\n    encCtx->optsCurIndex = 0;\n    encCtx->optEndIndex = 0;\n    for (i = 0; i < CMPT_DP_OPTMAX; i++)\n    {\n        encCtx->opts[i].price = CMPT_INFINITY_PRICE;\n    }\n\n    for (i = 0; i < CMPTLZ_NUM_STATES; i++)\n    {\n        for (j = 0; j < CMPTLZ_NUM_PB_STATES_MAX; j++)\n        {\n            encCtx->isMatch[i][j] = CMPTLZ_PROB_INIT;\n            encCtx->isRep0Long[i][j] = CMPTLZ_PROB_INIT;\n        }\n        encCtx->isRep[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG0[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG1[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG2[i] = CMPTLZ_PROB_INIT;\n    }\n\n    for (i = 0; i < CMPTLZ_DIST_STATE_TOTAL; i++)\n    {\n        for (j = 0; j < (1 << CMPTLZ_DIST_SLOT_BITS); j++)\n        {\n            encCtx->probDistSlot[i][j] = CMPTLZ_PROB_INIT;\n        }\n    }\n    for (i = 0; i < CMPT_DIST_LIMIT_2; i++)\n    {\n        encCtx->probDistSpecial[i] = CMPTLZ_PROB_INIT;\n    }\n    for (i = 0; i < (1 << CMPTLZ_ALIGN_BITS); i++)\n    {\n        encCtx->probAlign[i] = CMPTLZ_PROB_INIT;\n    }\n\n    encCtx->litMarcov.lcBits = encCtx->litCtx;\n    encCtx->litMarcov.posMask = (1U << encCtx->litPos) - 1;\n\n    for (i = 0; i < (1 << CMPTLZ_LCLP_MAX); i++)\n    {\n        for (j = 0; j < CMPTLZ_LIT_MAX_SIZE; j++)\n        {\n            encCtx->litMarcov.literal[i][j] = CMPTLZ_PROB_INIT;\n        }\n    }\n\n    for (i = 0; i < (1 << CMPT_LEN_HIGH_BITS); i++)\n    {\n        encCtx->matchLenEncoder.high[i] = CMPTLZ_PROB_INIT;\n        encCtx->repLenEncoder.high[i] = CMPTLZ_PROB_INIT;\n        encCtx->matchLenEncoder.low[i] = CMPTLZ_PROB_INIT;\n        encCtx->repLenEncoder.low[i] = CMPTLZ_PROB_INIT;\n    }\n\n    CmptlzPriceInit(encCtx);\n\n    encCtx->repLenEncoder.tableSize = encCtx->numFastBytes - 1;\n    encCtx->matchLenEncoder.tableSize = encCtx->numFastBytes - 1;\n    CmptPriceGenLenTable(encCtx, &encCtx->matchLenEncoder);\n    CmptPriceGenLenTable(encCtx, &encCtx->repLenEncoder);\n}": "51", "void *CmptInitCctx(CmptLzMemHook *alloc, int writeEndMark)\n{\n    void *handle = alloc->CmptLzAlloc(CMPTLZ_ENC_CCTX_HANDLE, sizeof(CmptLzEncCtx));\n    if (handle == NULL)\n    {\n        return NULL;\n    }\n    memset_s(handle, sizeof(CmptLzEncCtx), 0, sizeof(CmptLzEncCtx));\n    CmptLzEncCtx *encCtx = (CmptLzEncCtx *)handle;\n    encCtx->endMarker = writeEndMark;\n    encCtx->rcCtx = NULL;\n    encCtx->mfCtx = NULL;\n    return encCtx;\n}": "52", "int CmptHeadWrite(CmptLzEncCtx *encCtx, uint8_t *protData, size_t *propsSize)\n{\n    if (protData == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_DATA, \"protData is NULL\");\n        return CMPT_ENC_ERROR_HEAD;\n    }\n\n    if (*propsSize < CMPTLZ_PROPS_SIZE)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_DATA, \"propsSize need 5 bytes, get %zu\", *propsSize);\n        return CMPT_ENC_ERROR_HEAD;\n    }\n\n    CmptlzWriteLE32Bit(protData + 1, encCtx->dicSize);\n    protData[0] = (encCtx->posBits * CMPTLZ_POS_STATE_MAX + encCtx->litPos) * CMPTLZ_LIT_CTX_MAX + encCtx->litCtx;\n    *propsSize = CMPTLZ_PROPS_SIZE;\n    return 0;\n}": "53", "static inline uint32_t CmptPriceOneBitDirect(uint32_t bit)\n    {\n        return (bit << CMPT_PRICE_BITS_MOVING_NUM);\n    }": "54", "static inline uint32_t CmptPriceOneBit(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob, uint32_t curbit)\n    {\n        return encCtx->priceRootTable[(bit0Prob ^ ((uint32_t)(0 - curbit) & (CMPTLZ_PROB_MAX_NUM - 1))) >>\n                                      CMPT_PRICE_BITS_MOVING_NUM];\n    }": "55", "static inline uint32_t CmptPriceBit0(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob)\n    {\n        return encCtx->priceRootTable[bit0Prob >> CMPT_PRICE_BITS_MOVING_NUM];\n    }": "56", "static inline uint32_t CmptPriceBit1(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob)\n    {\n        return encCtx->priceRootTable[(bit0Prob ^ (CMPTLZ_PROB_MAX_NUM - 1)) >> CMPT_PRICE_BITS_MOVING_NUM];\n    }": "57", "static inline uint32_t CmptPriceSymbol(CmptLzEncCtx *encCtx, CmptlzProb *symbolProbs, uint32_t symbolBitsNum,\n                                           uint32_t symbol)\n    {\n        uint32_t price = 0;\n        symbol += (1U << symbolBitsNum);\n        do\n        {\n            uint32_t bit = symbol & 1;\n            symbol >>= 1;\n            price += CmptPriceOneBit(encCtx, symbolProbs[symbol], bit);\n        } while (symbol != 1);\n        return price;\n    }": "58", "static inline uint32_t CmptPriceSymbolReverse(CmptLzEncCtx *encCtx, CmptlzProb *symbolProbs, uint32_t symbolBitsNum,\n                                                  uint32_t symbol)\n    {\n        uint32_t price = 0;\n        uint32_t i = 1;\n        do\n        {\n            uint32_t bit = symbol & 1;\n            symbol >>= 1;\n            price += CmptPriceOneBit(encCtx, symbolProbs[i], bit);\n            i = (i << 1) + bit;\n        } while (--symbolBitsNum);\n\n        return price;\n    }": "59", "static inline int CmptlzEncLit(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t nowpos32)\n    {\n        int shiftRes = CMPT_OK;\n        CmptRcCtx *rc = encCtx->rcCtx;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n        uint32_t range, bit0Prob, newBound;\n        range = rc->range;\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(rc, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        rc->range = range;\n        CmptlzProb *litProb = &encCtx->litMarcov.literal[0][0];\n        const uint8_t curByte = mf->srcStart[mf->readPos - mf->readAhead];\n        probs = CMPT_LIT_PROB_GET(encCtx, litProb, nowpos32, mf->srcStart[mf->readPos - mf->readAhead - 1]);\n        CmptlzState state = encCtx->state;\n        CMPT_STATE_UPDATE_WHEN_LIT(encCtx->state);\n        if (state < 7)\n        {\n            shiftRes = CmptRcLitProcess(rc, probs, curByte);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        else\n        {\n            const uint8_t match_byte = mf->srcStart[mf->readPos - encCtx->reps[0] - 1 - mf->readAhead];\n            shiftRes = CmptRcLitAfterMatch(rc, probs, curByte, match_byte);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        return CMPT_OK;\n    }": "60", "static inline int CmptlzEncShortRep(CmptLzEncCtx *encCtx, uint32_t nowpos32)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n        uint32_t range, bit0Prob, newBound;\n        range = encCtx->rcCtx->range;\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRepG0[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep0Long[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n\n        CmptlzState state = encCtx->state;\n        encCtx->state = CMPT_STATE_UPDATE_WHEN_SHORTREP(state);\n        return CMPT_OK;\n    }": "61", "static inline int CmptlzEncNormalMatch(CmptLzEncCtx *encCtx, uint32_t nowpos32, uint32_t backRes, uint32_t lenRes)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n        uint32_t range, bit0Prob, newBound;\n        range = encCtx->rcCtx->range;\n\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        encCtx->rcCtx->range = range;\n        CmptlzState state = encCtx->state;\n        encCtx->state = CMPT_STATE_UPDATE_WHEN_MATCH(state);\n\n        shiftRes = CmptRcLenProcess(&encCtx->matchLenEncoder, encCtx->rcCtx, lenRes, posState);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        backRes -= CMPTLZ_NUM_REPS;\n        encCtx->reps[3] = encCtx->reps[2];\n        encCtx->reps[2] = encCtx->reps[1];\n        encCtx->reps[1] = encCtx->reps[0];\n        encCtx->reps[0] = backRes;\n\n        encCtx->matchPriceCount++;\n\n        uint32_t posSlot = PosSloter(backRes);\n        shiftRes = CmptRcPosSlotProcess(encCtx, posSlot, lenRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        if (backRes >= 4)\n        {\n            shiftRes = CmptRcDistProcess(encCtx, posSlot, backRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        return CMPT_OK;\n    }": "62", "static inline int CmptlzEncLongRep(CmptLzEncCtx *encCtx, uint32_t repIndex, uint32_t nowpos32, uint32_t lenRes)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n\n        uint32_t range, bit0Prob, newBound;\n        uint32_t realDist;\n        range = encCtx->rcCtx->range;\n\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRepG0[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n\n        switch (repIndex)\n        {\n        case 0:\n            CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRep0Long[encCtx->state][posState];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1(encCtx->rcCtx, probs, newBound, range, bit0Prob);\n            break;\n        case 1:\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG1[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0(probs, newBound, range, bit0Prob);\n\n            realDist = encCtx->reps[1];\n            encCtx->reps[1] = encCtx->reps[0];\n            encCtx->reps[0] = realDist;\n            break;\n        case 2:\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG1[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG2[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0(probs, newBound, range, bit0Prob);\n\n            realDist = encCtx->reps[2];\n            encCtx->reps[2] = encCtx->reps[1];\n            encCtx->reps[1] = encCtx->reps[0];\n            encCtx->reps[0] = realDist;\n            break;\n        case 3:\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG1[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG2[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1(encCtx->rcCtx, probs, newBound, range, bit0Prob);\n            realDist = encCtx->reps[3];\n            encCtx->reps[3] = encCtx->reps[2];\n            encCtx->reps[2] = encCtx->reps[1];\n            encCtx->reps[1] = encCtx->reps[0];\n            encCtx->reps[0] = realDist;\n            break;\n        default:\n            break;\n        }\n        CMPT_RC_NORMALIZE(encCtx->rcCtx, range, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n\n        shiftRes = CmptRcLenProcess(&encCtx->repLenEncoder, encCtx->rcCtx, lenRes, posState);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        --encCtx->repLenPriceCount;\n\n        CmptlzState state = encCtx->state;\n        encCtx->state = CMPT_STATE_UPDATE_WHEN_LONGREP(state);\n        return CMPT_OK;\n    }": "63", "void CmptPriceGenRootTable(CmptLzEncCtx *encCtx)\n{\n    uint32_t *rootTable = encCtx->priceRootTable;\n\n    const unsigned expandCycleNum = 4;\n    const unsigned bitsTotalModeNum = 11;\n    const unsigned valueForNormal = 15;\n    const unsigned wTopBoarder = 1 << 16;\n\n    for (unsigned i = 0; i < ((uint32_t)1 << bitsTotalModeNum >> CMPT_PRICE_BITS_MOVING_NUM); i++)\n    {\n        unsigned w = (i << CMPT_PRICE_BITS_MOVING_NUM) + (1 << (CMPT_PRICE_BITS_MOVING_NUM - 1));\n        unsigned dummyNormalizeCnt = 0;\n        for (unsigned j = 0; j < expandCycleNum; j++)\n        {\n            w = w * w;\n            dummyNormalizeCnt <<= 1;\n            while (w >= wTopBoarder)\n            {\n                w >>= 1;\n                dummyNormalizeCnt++;\n            }\n        }\n        rootTable[i] = (uint32_t)((bitsTotalModeNum << expandCycleNum) - valueForNormal - dummyNormalizeCnt);\n    }\n}": "64", "void CmptPriceGenDistTable(CmptLzEncCtx *encCtx)\n{\n    uint32_t distState = 0;\n\n    do\n    {\n        uint32_t *const tmpPriceDistSlot = encCtx->priceDistSlotTable[distState];\n\n        for (uint32_t i = 0; i < encCtx->distTableSize; i++)\n        {\n            tmpPriceDistSlot[i] = CmptPriceSymbol(encCtx, encCtx->probDistSlot[distState], CMPTLZ_DIST_SLOT_BITS, i);\n        }\n\n        for (uint32_t i = 14; i < encCtx->distTableSize; i++)\n        {\n            tmpPriceDistSlot[i] += CmptPriceOneBitDirect((i >> 1) - 1 - CMPTLZ_ALIGN_BITS);\n        }\n\n        for (uint32_t i = 0; i < 4; i++)\n        {\n            encCtx->priceDistTable[distState][i] = tmpPriceDistSlot[i];\n        }\n\n        distState++;\n    } while (distState < CMPTLZ_DIST_STATE_TOTAL);\n\n    for (uint32_t i = 4; i < 128; i++)\n    {\n        uint32_t distSlot = PosSloter(i);\n        uint32_t footerBits = (distSlot >> 1) - 1;\n        uint32_t base = (2 | (distSlot & 1)) << footerBits;\n        uint32_t price =\n            CmptPriceSymbolReverse(encCtx, encCtx->probDistSpecial + base - distSlot - 1, footerBits, i - base);\n\n        for (distState = 0; distState < 4; distState++)\n        {\n            encCtx->priceDistTable[distState][i] = price + encCtx->priceDistSlotTable[distState][distSlot];\n        }\n    }\n\n    encCtx->matchPriceCount = 0;\n}": "65", "void CmptPriceGenAlignTable(CmptLzEncCtx *encCtx)\n{\n    for (uint32_t i = 0; i < (1 << CMPTLZ_ALIGN_BITS); i++)\n    {\n        encCtx->priceAlignTable[i] = CmptPriceSymbolReverse(encCtx, encCtx->probAlign, CMPTLZ_ALIGN_BITS, i);\n    }\n}": "66", "uint32_t CmptPriceLiteral(CmptLzEncCtx *encCtx, bool matchMode, uint32_t matchByte, uint32_t symbol)\n{\n    uint32_t pos = encCtx->litMarcov.pos;\n    uint32_t prevByte = encCtx->litMarcov.prevByte;\n    uint32_t litCtx = encCtx->litMarcov.lcBits;\n    uint32_t lpMask = encCtx->litMarcov.posMask;\n    CmptlzProb *subCoder = CMPT_LIT_SUBCODER(encCtx->litMarcov.literal, litCtx, lpMask, pos, prevByte);\n\n    uint32_t price = 0;\n    if (!matchMode)\n    {\n        price = CmptPriceSymbol(encCtx, subCoder, 8, symbol);\n    }\n    else\n    {\n        uint32_t offset = 0x100;\n        symbol += 1 << 8;\n        do\n        {\n            matchByte <<= 1;\n            const uint32_t matchBit = matchByte & offset;\n            const uint32_t subCoderIndex = offset + matchBit + (symbol >> 8);\n            const uint32_t bit = (symbol >> 7) & 1;\n            price += CmptPriceOneBit(encCtx, subCoder[subCoderIndex], bit);\n            symbol <<= 1;\n            offset &= ~(matchByte ^ symbol);\n        } while (symbol < (1 << 16));\n    }\n    return price;\n}": "67", "static void CmptPriceSet(CmptLzEncCtx *encCtx, const CmptlzProb *probs, uint32_t startPrice, uint32_t *prices)\n{\n    uint32_t i;\n    for (i = 0; i < 8; i += 2)\n    {\n        uint32_t price = startPrice;\n        uint32_t prob;\n        price += CmptPriceOneBit(encCtx, probs[1], (i >> 2));\n        price += CmptPriceOneBit(encCtx, probs[2 + (i >> 2)], (i >> 1) & 1);\n        prob = probs[4 + (i >> 1)];\n        prices[i] = price + CmptPriceBit0(encCtx, prob);\n        prices[i + 1] = price + CmptPriceBit1(encCtx, prob);\n    }\n}": "68", "void CmptPriceGenLenTable(CmptLzEncCtx *encCtx, CmptLenEncoder *lenEncoder)\n{\n    const uint32_t numPosStates = 1 << encCtx->posBits;\n\n    uint32_t b;\n\n    uint32_t prob = lenEncoder->low[0];\n    uint32_t a, c;\n    uint32_t posState;\n\n    b = CmptPriceBit1(encCtx, prob);\n    a = CmptPriceBit0(encCtx, prob);\n    c = b + CmptPriceBit0(encCtx, lenEncoder->low[1 << CMPT_LEN_LOW_BITS]);\n\n    for (posState = 0; posState < numPosStates; posState++)\n    {\n        uint32_t *prices = lenEncoder->prices[posState];\n        const CmptlzProb *probs = lenEncoder->low + (posState << (1 + CMPT_LEN_LOW_BITS));\n        CmptPriceSet(encCtx, probs, a, prices);\n        CmptPriceSet(encCtx, probs + (1 << CMPT_LEN_LOW_BITS), c, prices + (1 << CMPT_LEN_LOW_BITS));\n    }\n\n    uint32_t i = lenEncoder->tableSize;\n    if (i > (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE)\n    {\n        const CmptlzProb *probs = lenEncoder->high;\n        uint32_t *prices = lenEncoder->prices[0] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE;\n        i -= (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE - 1;\n        i >>= 1;\n        b += CmptPriceBit1(encCtx, lenEncoder->low[(1 << CMPT_LEN_LOW_BITS)]);\n        do\n        {\n            uint32_t sym = --i + (1 << (CMPT_LEN_HIGH_BITS - 1));\n            uint32_t price = b;\n            do\n            {\n                uint32_t bit = sym & 1;\n                sym >>= 1;\n                price += CmptPriceOneBit(encCtx, probs[sym], bit);\n            } while (sym >= 2);\n\n            prob = probs[(size_t)i + (1 << (CMPT_LEN_HIGH_BITS - 1))];\n            prices[(size_t)i * CMPT_DOUBLE] = price + CmptPriceBit0(encCtx, prob);\n            prices[(size_t)i * CMPT_DOUBLE + 1] = price + CmptPriceBit1(encCtx, prob);\n        } while (i);\n        size_t num =\n            (lenEncoder->tableSize - (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE) * sizeof(lenEncoder->prices[0][0]);\n\n        for (posState = 1; posState < numPosStates; posState++)\n        {\n            memcpy_s(lenEncoder->prices[posState] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE, CMPT_MF_LONGEST_MATCH - 1,\n                     lenEncoder->prices[0] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE, num);\n        }\n    }\n}": "69", "uint32_t CmptPriceLen(CmptLenEncoder *lenEncoder, uint32_t len, uint32_t posState)\n{\n\n    return lenEncoder->prices[posState][len - CMPTLZ_MATCH_LEN_MIN];\n}": "70", "uint32_t CmptPriceShortRep(CmptLzEncCtx *encCtx, CmptlzState state, uint32_t posState)\n{\n    return CmptPriceBit0(encCtx, encCtx->isRepG0[state]) + CmptPriceBit0(encCtx, encCtx->isRep0Long[state][posState]);\n}": "71", "uint32_t CmptPriceLongRep(CmptLzEncCtx *encCtx, uint32_t longRepIndex, CmptlzState state, uint32_t posState)\n{\n    uint32_t price = 0;\n    switch (longRepIndex)\n    {\n    case 0:\n        price =\n            CmptPriceBit0(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRep0Long[state][posState]);\n        break;\n    case 1:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit0(encCtx, encCtx->isRepG1[state]);\n        break;\n    case 2:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRepG1[state]) +\n                CmptPriceBit0(encCtx, encCtx->isRepG2[state]);\n        break;\n    case 3:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRepG1[state]) +\n                CmptPriceBit1(encCtx, encCtx->isRepG2[state]);\n        break;\n    default:\n        break;\n    }\n    return price;\n}": "72", "uint32_t CmptPriceDistWithLen(CmptLzEncCtx *encCtx, uint32_t dist, uint32_t len, uint32_t posState)\n{\n    const uint32_t distState = CMPT_GET_DIST_STATE(len);\n    uint32_t price;\n    if (dist < 128)\n    {\n        price = encCtx->priceDistTable[distState][dist];\n    }\n    else\n    {\n\n        uint32_t distSlot = PosSloter(dist);\n        price = encCtx->priceDistSlotTable[distState][distSlot] +\n                encCtx->priceAlignTable[dist & ((1 << CMPTLZ_ALIGN_BITS) - 1)];\n    }\n\n    price += CmptPriceLen(&encCtx->matchLenEncoder, len, posState);\n\n    return price;\n}": "73", "static inline CmptLzDecProb *CmptLzGetProbsMatrix(CmptLzDecCtx *decCtx)\n    {\n\n        return decCtx->probsPlus1664;\n    }": "74", "static inline CmptLzDecProb *CmptLzGetIsMatchProb(CmptLzDecProb *probsMatrix)\n    {\n\n        return probsMatrix + CMPTLZ_IS_MATCH;\n    }": "75", "static inline CmptLzDecProb *CmptLzGetIsRepProb(CmptLzDecProb *probsMatrix)\n    {\n\n        return probsMatrix + CMPTLZ_ISREP;\n    }": "76", "static inline CmptLzDecProb *CmptLzGetIsRepG0Prob(CmptLzDecProb *probsMatrix)\n    {\n\n        return probsMatrix + CMPTLZ_ISREPG0;\n    }": "77", "static inline CmptLzDecProb *CmptLzGetIsRepG1Prob(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_ISREPG1;\n    }": "78", "static inline CmptLzDecProb *CmptLzGetIsRepG2Prob(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_ISREPG2;\n    }": "79", "static inline CmptLzDecProb *CmptLzGetIsRepG0LongProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_REP0_LONG;\n    }": "80", "static inline CmptLzDecProb *CmptLzGetLiteralProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_LITERAL;\n    }": "81", "static inline CmptLzDecProb *CmptLzGetPosSlotProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_POSSLOT;\n    }": "82", "static inline CmptLzDecProb *CmptLzGetSpecPosProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_SPEC_POS;\n    }": "83", "static inline CmptLzDecProb *CmptLzGetAilgnProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_ALIGN;\n    }": "84", "static inline CmptLzDecProb *CmptLzGetRepLenCoderProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_REP_LEN_CODER;\n    }": "85", "static inline CmptLzDecProb *CmptLzGetMatchLenCoderProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_MATCH_LEN_CODER;\n    }": "86", "static inline uint32_t CmptLzGetLenCondition(uint32_t decLen)\n    {\n        return ((decLen < CMPTLZ_LEN_CONDITION_TO_POSSLOT ? decLen : CMPTLZ_LEN_CONDITION_TO_POSSLOT - 1)\n                << CMPTLZ_POS_SLOT_BITS);\n    }": "87", "static inline uint32_t CmptLzGetBaseDistByPosSlot(uint32_t posSlot)\n    {\n        return (2 | (posSlot & 1));\n    }": "88", "static inline uint32_t CmptLzGetNumProbs(CmptLzDecProt *decProt)\n    {\n\n        return (NUM_BASE_PROBS + ((uint32_t)0x300 << (decProt->litCtx + decProt->litPos)));\n    }": "89", "static inline void CmptLzDistDecHelper(CmptLzDecCtx *decCtx, uint32_t distDec, const unsigned char *bufToDec,\n                                       uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound, uint32_t range,\n                                       uint32_t rangeCode, uint32_t rangeBound)\n{\n    decCtx->reps[CMPTLZ_REP3] = decCtx->reps[CMPTLZ_REP2];\n    decCtx->reps[CMPTLZ_REP2] = decCtx->reps[1];\n    decCtx->reps[1] = decCtx->reps[0];\n    decCtx->reps[0] = (distDec + 1);\n\n    decCtx->buf = bufToDec;\n    decCtx->state = (decCtx->state < CMPTLZ_LIT_STATES) ? CMPTLZ_LIT_STATES : CMPTLZ_LIT_STATES + CMPTLZ_REP3;\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n}": "90", "static size_t CmptLzDistDec(CmptLzDecCtx *decCtx, CmptLzDecProb *probsMatrix, uint32_t *pRange, uint32_t *pRangeCode,\n                            uint32_t *pRangeBound, uint32_t decLen)\n{\n    uint32_t assistBits;\n    uint32_t posSlot = 1;\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    const unsigned char *bufToDec = decCtx->buf;\n    uint32_t distDec;\n\n    CmptLzDecProb *probPosSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decLen);\n\n    int i = 0;\n    for (i = 0; i < CMPTLZ_POS_SLOT_BITS; i++)\n    {\n        CMPTLZ_POSSLOT_BIT_DEC((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    }\n    posSlot -= 64;\n\n    if (posSlot < CMPTLZ_LOW_POSSLOT)\n    {\n        distDec = posSlot;\n        CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n\n        if (distDec == (size_t)0xFFFFFFFF)\n        {\n            return distDec;\n        }\n        else\n        {\n            return (distDec + 1);\n        }\n    }\n\n    uint32_t directBitNum = ((posSlot >> 1) - 1);\n    distDec = CmptLzGetBaseDistByPosSlot(posSlot);\n    if (posSlot < CMPTLZ_HIGH_POSSLOT)\n    {\n        assistBits = 1;\n        distDec <<= directBitNum;\n\n        distDec += assistBits;\n        probPosSlot = CmptLzGetSpecPosProb(probsMatrix);\n        do\n        {\n\n            if CMPTLZ_IS_THE_BIT_0 ((probPosSlot + distDec), range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0((probPosSlot + distDec), range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                distDec += assistBits;\n                assistBits <<= 1;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1((probPosSlot + distDec), range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                assistBits <<= 1;\n                distDec += assistBits;\n            }\n        } while (--directBitNum);\n        distDec -= assistBits;\n    }\n    else\n    {\n        directBitNum -= CMPTLZ_REP4;\n        do\n        {\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            range >>= 1;\n            rangeCode -= range;\n            assistBits = (0 - ((uint32_t)rangeCode >> 31));\n            distDec = (distDec << 1) + (assistBits + 1);\n            rangeCode += range & assistBits;\n        } while (--directBitNum);\n\n        CmptLzDecProb *probDist;\n        probPosSlot = CmptLzGetAilgnProb(probsMatrix);\n\n        distDec <<= CMPTLZ_LARGE_DIST_LOW_BITS;\n        assistBits = 1;\n\n        uint32_t cycleSym = 1;\n        for (i = 0; i < 3; i++)\n        {\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            CMPTLZ_DIST_BIT_DEC(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n            cycleSym <<= 1;\n        }\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probDist = probPosSlot + assistBits;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probDist);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probDist, range, rangeBound);\n            assistBits -= 8;\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probDist, range, rangeCode, rangeBound);\n        }\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        distDec |= assistBits;\n    }\n\n    CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n\n    if (distDec == (size_t)0xFFFFFFFF)\n    {\n        return distDec;\n    }\n    else\n    {\n        return (distDec + 1);\n    }\n}": "91", "static uint32_t CmptLzLenDec(CmptLzDecCtx *decCtx, CmptLzDecProb *probSlot, uint32_t *pRange, uint32_t *pRangeCode,\n                             uint32_t *pRangeBound, uint32_t posState)\n{\n    uint32_t decLen = 1;\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    const unsigned char *bufToDec = decCtx->buf;\n    CmptLzDecProb *probLen = probSlot + CMPTLZ_LEN_CHOICE;\n\n    int i = 0;\n    if CMPTLZ_IS_THE_BIT_0 (probLen, range, rangeCode, rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET + posState;\n        for (i = 0; i < CMPTLZ_LOW_LEN_BIT; i++)\n        {\n            CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n        }\n        decLen -= 8;\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2;\n        if CMPTLZ_IS_THE_BIT_0 (probLen, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n            probLen = probSlot + (CMPTLZ_LEN_CHOICE2 + posState);\n            for (i = 0; i < CMPTLZ_LOW_LEN_BIT; i++)\n            {\n                CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            }\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET;\n            for (i = 0; i < CMPTLZ_HIGH_LEN_BIT; i++)\n            {\n                CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            }\n            decLen -= CMPTLZ_HIGH_LEN_CLASS;\n            decLen += (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx->buf = bufToDec;\n\n    return decLen;\n}": "92", "static uint32_t CmptLzDecByDistAndLen(CmptLzDecCtx *decCtx, size_t matchDist, uint32_t matchLen, size_t dicPosLimit)\n{\n    size_t dicCopyPos;\n    size_t dicPos = decCtx->dictPos;\n    size_t dictBufSize = decCtx->dictBufSize;\n    uint32_t remainDicLen = (uint32_t)(dicPosLimit - dicPos);\n    unsigned char *dict = decCtx->dict;\n\n    if (remainDicLen == 0)\n    {\n        return CMPT_ERROR_DATA;\n    }\n\n    uint32_t decDicLen = ((remainDicLen < matchLen) ? remainDicLen : matchLen);\n    decCtx->processedPos += decDicLen;\n    decCtx->dictPos += decDicLen;\n    decCtx->remainLen = matchLen - decDicLen;\n\n    if (dicPos < matchDist)\n    {\n        dicCopyPos = dictBufSize - matchDist + dicPos;\n    }\n    else\n    {\n        dicCopyPos = dicPos - matchDist;\n    }\n\n    do\n    {\n        dict[dicPos++] = dict[dicCopyPos];\n        if (++dicCopyPos == dictBufSize)\n        {\n            dicCopyPos = 0;\n        }\n    } while (--decDicLen != 0);\n\n    return CMPT_OK;\n}": "93", "static inline void CmptLzShortRepDec(CmptLzDecCtx *decCtx)\n{\n    uint32_t rep0 = decCtx->reps[0];\n    unsigned char *dict = decCtx->dict;\n    size_t dictPos = decCtx->dictPos;\n    size_t dictBufSize = decCtx->dictBufSize;\n\n    dict[dictPos] = dict[dictPos - rep0 + (dictPos < rep0 ? dictBufSize : 0)];\n    decCtx->dictPos++;\n    decCtx->processedPos++;\n    if (decCtx->state < CMPTLZ_LIT_STATES)\n    {\n        decCtx->state = 9;\n    }\n    else\n    {\n        decCtx->state = 11;\n    }\n}": "94", "static inline uint32_t CmptLzRepDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound,\n                                    size_t dicPosLimit, uint32_t posState)\n{\n    uint32_t repLen;\n    uint32_t repDist;\n    uint32_t mkState = decCtx->state;\n    const unsigned char *bufToDec = decCtx->buf;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n\n    probSlot = CmptLzGetIsRepG0Prob(probsMatrix) + mkState;\n    if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n        probSlot = CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState;\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            *pRange = range;\n            *pRangeCode = rangeCode;\n            *pRangeBound = rangeBound;\n            decCtx->buf = bufToDec;\n            CmptLzShortRepDec(decCtx);\n            return CMPT_OK;\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            repDist = decCtx->reps[0];\n        }\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n        probSlot = CmptLzGetIsRepG1Prob(probsMatrix) + mkState;\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            repDist = decCtx->reps[1];\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n            probSlot = CmptLzGetIsRepG2Prob(probsMatrix) + mkState;\n            if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                repDist = decCtx->reps[CMPTLZ_REP2];\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                repDist = decCtx->reps[CMPTLZ_REP3];\n                decCtx->reps[CMPTLZ_REP3] = decCtx->reps[CMPTLZ_REP2];\n            }\n            decCtx->reps[CMPTLZ_REP2] = decCtx->reps[1];\n        }\n        decCtx->reps[1] = decCtx->reps[0];\n        decCtx->reps[0] = repDist;\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx->buf = bufToDec;\n\n    decCtx->state = (mkState < CMPTLZ_LIT_STATES) ? 8 : 11;\n    probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n    repLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n\n    return CmptLzDecByDistAndLen(decCtx, repDist, repLen + 2, dicPosLimit);\n}": "95", "static inline uint32_t CmptLzMatchDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode,\n                                      uint32_t *pRangeBound, size_t dicPosLimit, uint32_t posState)\n{\n    uint32_t matchLen;\n    size_t matchDist;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    probSlot = CmptLzGetMatchLenCoderProb(probsMatrix);\n    matchLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n    matchDist = CmptLzDistDec(decCtx, probsMatrix, pRange, pRangeCode, pRangeBound, matchLen);\n    if (matchDist > decCtx->dictBufSize)\n    {\n        if (matchDist == (size_t)0xFFFFFFFF)\n        {\n            decCtx->remainLen = CMPTLZ_MATCH_MAX_LEN;\n            decCtx->state -= CMPTLZ_MKSTATE_NUM;\n            return CMPT_OK;\n        }\n        else\n        {\n            return CMPT_ERROR_DATA;\n        }\n    }\n    return CmptLzDecByDistAndLen(decCtx, matchDist, matchLen + 2, dicPosLimit);\n}": "96", "static inline uint32_t CmptLzLitDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound)\n{\n    uint32_t decSym = 1;\n    uint32_t mkState = decCtx->state;\n    uint32_t procPos = decCtx->processedPos;\n    uint32_t checkDicSize = decCtx->checkDicSize;\n    uint32_t litCtx = decCtx->prop.litCtx;\n    uint32_t litPosMask = ((uint32_t)0x100 << decCtx->prop.litPos) - ((uint32_t)0x100 >> litCtx);\n\n    CmptLzDecProb *probLit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    const unsigned char *bufToDec = decCtx->buf;\n    unsigned char *dict = decCtx->dict;\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t dictPos = decCtx->dictPos;\n\n    uint32_t range = *pRange;\n    uint32_t rangeBound = *pRangeBound;\n    uint32_t rangeCode = *pRangeCode;\n\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0 || checkDicSize != 0)\n    {\n        probSlot += (uint32_t)CMPTLZ_REP3 *\n                    ((((procPos << 8) + dict[(dictPos == 0 ? dictBufSize : dictPos) - 1]) & litPosMask) << litCtx);\n    }\n\n    int i = 0;\n    if (mkState < CMPTLZ_LIT_STATES)\n    {\n        mkState -= (mkState < 4) ? mkState : 3;\n        for (i = 0; i < 8; i++)\n        {\n            CMPTLZ_NORMAL_BIT_DEC((probSlot + decSym), range, rangeCode, rangeBound, decSym);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        }\n    }\n    else\n    {\n        uint32_t bit;\n        uint32_t offset = 0x100;\n        uint32_t rep0 = decCtx->reps[0];\n        uint32_t matchSym = dict[dictPos - rep0 + ((dictPos < rep0) ? dictBufSize : 0)];\n        mkState -= (mkState < 10) ? CMPTLZ_REP3 : 6;\n        for (i = 0; i < 8; i++)\n        {\n            CMPTLZ_MATCH_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n        }\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n\n    dict[dictPos++] = (uint8_t)decSym;\n    decCtx->processedPos += 1;\n    decCtx->state = mkState;\n    decCtx->dictPos = dictPos;\n    decCtx->buf = bufToDec;\n\n    return CMPT_OK;\n}": "97", "int CmptLzDecDirectProcess(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *bufLimit)\n{\n    uint32_t decRes;\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t procPos;\n    uint32_t mkState;\n    uint32_t posState;\n\n    uint32_t range = decCtx->range;\n    uint32_t rangeCode = decCtx->code;\n    uint32_t rangeBound = 0;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    do\n    {\n        procPos = decCtx->processedPos;\n        mkState = decCtx->state;\n        posState = CMPTLZ_CALC_POS_STATE(procPos, pbMask);\n        probSlot = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n            decRes = CmptLzLitDec(decCtx, &range, &rangeCode, &rangeBound);\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n\n            probSlot = CmptLzGetIsRepProb(probsMatrix) + mkState;\n\n            if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n                decRes = CmptLzMatchDec(decCtx, &range, &rangeCode, &rangeBound, dicPosLimit, posState);\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n                decRes = CmptLzRepDec(decCtx, &range, &rangeCode, &rangeBound, dicPosLimit, posState);\n            }\n            if (decRes != CMPT_OK)\n            {\n                break;\n            }\n        }\n    } while (decCtx->dictPos < dicPosLimit && decCtx->buf < bufLimit && decCtx->remainLen < CMPTLZ_MATCH_MAX_LEN);\n\n    decCtx->range = range;\n    decCtx->code = rangeCode;\n\n    return (int)decRes;\n}": "98", "static inline void CmptLzDecCheckDictSizeUpdate(CmptLzDecCtx *decCtx)\n{\n    if (decCtx->checkDicSize == 0 && decCtx->processedPos >= decCtx->prop.dicSize)\n    {\n        decCtx->checkDicSize = decCtx->prop.dicSize;\n    }\n}": "99", "static inline void CmptLzDecRemWriteInDict(CmptLzDecCtx *decCtx, size_t dicPosLimit)\n{\n    size_t dictPos = decCtx->dictPos;\n    size_t remainDecLen = decCtx->remainLen;\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t remainDicLen = dicPosLimit - dictPos;\n    if (remainDicLen < remainDecLen)\n    {\n        remainDecLen = remainDicLen;\n    }\n\n    if (remainDecLen == 0)\n    {\n        return;\n    }\n\n    decCtx->processedPos += (uint32_t)remainDecLen;\n    decCtx->remainLen -= (uint32_t)remainDecLen;\n\n    unsigned char *dict = decCtx->dict;\n    size_t rep0 = decCtx->reps[0];\n    while (remainDecLen != 0)\n    {\n        remainDecLen--;\n        dict[dictPos] = dict[dictPos - rep0 + (dictPos < rep0 ? dictBufSize : 0)];\n        dictPos++;\n    }\n    decCtx->dictPos = dictPos;\n\n    CmptLzDecCheckDictSizeUpdate(decCtx);\n}": "100", "static inline void CmptLzDecGetProbsInit(CmptLzDecCtx *decCtx)\n{\n    uint32_t idx;\n    uint32_t numProbs = CmptLzGetNumProbs(&(decCtx->prop));\n    CmptLzDecProb *decProbs = decCtx->probs;\n\n    for (idx = 0; idx < numProbs; idx++)\n    {\n        decProbs[idx] = CMPTLZ_PROB_LG >> 1;\n    }\n    decCtx->state = 0;\n}": "101", "static inline void CmptLzRangeCodeInit(CmptLzDecCtx *decCtx)\n{\n    uint32_t rangeCode = (uint32_t)(decCtx->tempBuf[1]) << 24;\n    rangeCode |= (uint32_t)(decCtx->tempBuf[2]) << 16;\n    rangeCode |= (uint32_t)(decCtx->tempBuf[3]) << 8;\n    rangeCode |= (uint32_t)(decCtx->tempBuf[4]);\n    decCtx->code = rangeCode;\n    decCtx->range = 0xFFFFFFFF;\n}": "102", "static inline int CmptLzDecCtxPrepare(CmptLzDecCtx *decCtx, const unsigned char *pSrcIn, size_t srcInLen,\n                                      EnCmptLzStatus *finStatus)\n{\n    size_t readCodeLen = CMPTLZ_RANGE_CODE_SIZE - decCtx->tempBufSize;\n    readCodeLen = (srcInLen < readCodeLen) ? srcInLen : readCodeLen;\n    while (readCodeLen-- > 0)\n    {\n        decCtx->tempBuf[decCtx->tempBufSize++] = *pSrcIn++;\n    }\n\n    if (decCtx->tempBufSize != 0 && decCtx->tempBuf[0] != 0)\n    {\n        decCtx->tempBufSize = 0;\n        *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n        return CMPT_ERROR_DATA;\n    }\n    if (decCtx->tempBufSize < CMPTLZ_RANGE_CODE_SIZE)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    CmptLzRangeCodeInit(decCtx);\n\n    if (decCtx->remainLen > CMPTLZ_MATCH_MAX_LEN + 1)\n    {\n        CmptLzDecGetProbsInit(decCtx);\n        decCtx->reps[0] = 1;\n        decCtx->reps[1] = 1;\n        decCtx->reps[2] = 1;\n        decCtx->reps[3] = 1;\n    }\n\n    decCtx->remainLen = 0;\n\n    return CMPT_OK;\n}": "103", "int CmptLzDecDecodeToDic(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *pSrcIn, size_t *pStrInLen,\n                         EnCmptLzFinMode finMode, EnCmptLzStatus *finStatus)\n{\n    int res;\n    bool carefulDecDone = false;\n    size_t srcDecLenTmp;\n    size_t srcDecLen = 0;\n    size_t srcInLen = *pStrInLen;\n\n    if (decCtx->remainLen > CMPTLZ_MATCH_MAX_LEN)\n    {\n        size_t oldTempBufSize = decCtx->tempBufSize;\n        res = CmptLzDecCtxPrepare(decCtx, pSrcIn, srcInLen, finStatus);\n        srcDecLenTmp = (decCtx->tempBufSize - oldTempBufSize);\n        if ((res != CMPT_OK) || (*finStatus == CMPTLZ_STATUS_NEEDS_MORE_INPUT))\n        {\n            *pStrInLen = srcDecLenTmp;\n            return res;\n        }\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n        decCtx->tempBufSize = 0;\n    }\n\n    if (decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN)\n    {\n        if (decCtx->code != 0)\n        {\n            return CMPT_ERROR_DATA;\n        }\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n\n    if (decCtx->remainLen != 0)\n    {\n        CmptLzDecRemWriteInDict(decCtx, dicPosLimit);\n    }\n\n    if (decCtx->tempBufSize != 0)\n    {\n        res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, &srcDecLenTmp);\n        *pStrInLen = srcDecLenTmp;\n        if (res == CMPT_ERROR_DATA)\n        {\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n            return CMPT_ERROR_DATA;\n        }\n        else if (res == CMPTLZ_DEC_INPUT_EOF)\n        {\n            *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n            return CMPT_OK;\n        }\n        else\n        {\n            srcDecLen += srcDecLenTmp;\n            pSrcIn += srcDecLenTmp;\n            srcInLen -= srcDecLenTmp;\n        }\n    }\n\n    while ((decCtx->dictPos < dicPosLimit) && (carefulDecDone == false))\n    {\n        decCtx->buf = pSrcIn;\n        if (srcInLen <= CMPTLZ_REQUIRED_INPUT_MAX)\n        {\n            res = CmptLzDecCarefulProcess(decCtx, dicPosLimit, pSrcIn + srcInLen);\n            carefulDecDone = true;\n        }\n        else\n        {\n            res = CmptLzDecDirectProcess(decCtx, dicPosLimit, pSrcIn + srcInLen - CMPTLZ_REQUIRED_INPUT_MAX);\n        }\n        srcDecLenTmp = (size_t)(decCtx->buf - pSrcIn) + decCtx->tempBufSize;\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n\n        if (res == CMPT_ERROR_DATA)\n        {\n            *pStrInLen = srcDecLen;\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n            return CMPT_ERROR_DATA;\n        }\n    }\n\n    *pStrInLen = srcDecLen;\n    if ((decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n    if (decCtx->dictPos < dicPosLimit)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    if ((decCtx->remainLen == 0) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_MAYBE_FINISHED_WITHOUT_MARK;\n        return CMPT_OK;\n    }\n    if (finMode == CMPTLZ_FINISH_ANY)\n    {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n        return CMPT_OK;\n    }\n    if (decCtx->remainLen != 0)\n    {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n        return CMPT_ERROR_DATA;\n    }\n\n    srcDecLenTmp = 0;\n    res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, &srcDecLenTmp);\n    srcDecLen += srcDecLenTmp;\n    *pStrInLen = srcDecLen;\n    if (res == CMPTLZ_DEC_INPUT_EOF)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    if ((decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n\n    *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n    return CMPT_ERROR_DATA;\n}": "104", "int CmptLzDecDecodeToBuf(CmptLzDecCtx *decCtx, CmptLzDecIn *pDecIn, CmptLzDecOut *pDecOut, EnCmptLzFinMode finMode,\n                         EnCmptLzStatus *finStatus)\n{\n    int res = CMPT_OK;\n    size_t dictPos;\n    size_t dictPosLimit;\n    size_t srcCostSize;\n\n    size_t leftSrcSize = pDecIn->strInLen;\n    size_t leftDestSize = pDecOut->destOutLen;\n    const unsigned char *pSrcIn = pDecIn->pSrcIn;\n    unsigned char *pDestOut = pDecOut->pDestOut;\n    EnCmptLzFinMode tmpFinMode;\n\n    do\n    {\n        if (decCtx->dictPos == decCtx->dictBufSize)\n        {\n            decCtx->dictPos = 0;\n        }\n        dictPos = decCtx->dictPos;\n        if (leftDestSize > decCtx->dictBufSize - dictPos)\n        {\n            dictPosLimit = decCtx->dictBufSize;\n            tmpFinMode = CMPTLZ_FINISH_ANY;\n        }\n        else\n        {\n            dictPosLimit = dictPos + leftDestSize;\n            tmpFinMode = finMode;\n        }\n        srcCostSize = leftSrcSize;\n        res = CmptLzDecDecodeToDic(decCtx, dictPosLimit, pSrcIn, &srcCostSize, tmpFinMode, finStatus);\n        if (res != CMPT_OK)\n        {\n            break;\n        }\n        pSrcIn += srcCostSize;\n        leftSrcSize -= srcCostSize;\n        dictPosLimit = decCtx->dictPos - dictPos;\n        leftDestSize -= dictPosLimit;\n        if (dictPosLimit == 0)\n        {\n            break;\n        }\n        if (memcpy_s(pDestOut, (pDecOut->destOutLen - leftDestSize), decCtx->dict + dictPos, dictPosLimit) != EOK)\n        {\n            return CMPT_ERROR_MEM;\n        }\n        pDestOut += dictPosLimit;\n    } while (leftDestSize != 0);\n\n    pDecIn->strInCostLen = pDecIn->strInLen - leftSrcSize;\n    pDecOut->destOutFillLen = pDecOut->destOutLen - leftDestSize;\n\n    return res;\n}": "105", "int CmptlzDecompress(void *src, size_t srcSize, void *dst, size_t *dstSize, CmptlzDecParam *param)\n{\n    if (src == NULL || dst == NULL || dstSize == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"The input parameter NULL is incorrect.\");\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    if (srcSize > 0x7fffffff || *dstSize > 0x7fffffff)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"dstSize:0x%zx srcSize:0x%zx\", *dstSize, srcSize);\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    if (param == NULL || param->memHook == NULL || param->protData == NULL || param->protSize != CMPTLZ_PROPS_SIZE)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"The compress param NULL is incorrect.\");\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    CmptLzDecIn decIn = {.pSrcIn = src, .strInLen = srcSize, .strInCostLen = 0};\n    CmptLzDecOut decOut = {.pDestOut = dst, .destOutLen = *dstSize, .destOutFillLen = 0};\n    EnCmptLzStatus enFinStat = CMPTLZ_STATUS_BUT;\n    int ret = CmptLzDecode(&decIn, &decOut, param->protData, CMPTLZ_FINISH_ANY, &enFinStat, param->memHook);\n\n    *dstSize = decOut.destOutFillLen;\n    return ret;\n}": "106", "static inline int CmptLzTryDecLenAndDist(CmptLzDecCtx *decCtx, uint32_t mkState, uint32_t range, uint32_t rangeCode,\n                                         uint32_t rangeBound, CmptLzDecProb *probSlot, const unsigned char *bufTryDec,\n                                         const unsigned char **pbufLimit)\n{\n    uint32_t offset;\n    uint32_t bits2BeDec;\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t posState = CMPTLZ_CALC_POS_STATE(decCtx->processedPos, pbMask);\n    const unsigned char *bufLimit = *pbufLimit;\n    CmptLzDecProb *probBit;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    CmptLzDecProb *probLen = probSlot + CMPTLZ_LEN_CHOICE;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probLen);\n    if (rangeCode < rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET + posState;\n        bits2BeDec = 3;\n        offset = 0;\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probLen);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            probLen = probSlot + CMPTLZ_LEN_CHOICE + CMPTLZ_LEN_CHOICE2 + posState;\n            bits2BeDec = 3;\n            offset = (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET;\n            bits2BeDec = 8;\n            offset = (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n    uint32_t decSym = 1;\n    do\n    {\n        probBit = probLen + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    } while (decSym < ((uint32_t)1 << bits2BeDec));\n    decSym -= ((uint32_t)1 << bits2BeDec);\n    decSym += offset;\n\n    if (mkState >= 4)\n    {\n        *pbufLimit = bufTryDec;\n        return CMPT_OK;\n    }\n\n    probSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decSym);\n\n    decSym = 1;\n    do\n    {\n        probBit = probSlot + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    } while (decSym < (1 << CMPTLZ_POS_SLOT_BITS));\n    decSym -= (1 << CMPTLZ_POS_SLOT_BITS);\n\n    bits2BeDec = ((decSym >> 1) - 1);\n    if (decSym >= CMPTLZ_LOW_POSSLOT)\n    {\n        if (decSym < CMPTLZ_HIGH_POSSLOT)\n        {\n            probSlot = CmptLzGetSpecPosProb(probsMatrix) + (CmptLzGetBaseDistByPosSlot(decSym) << bits2BeDec);\n        }\n        else\n        {\n            bits2BeDec -= CMPTLZ_LARGE_DIST_LOW_BITS;\n            do\n            {\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n                range >>= 1;\n                rangeCode -= range & (((rangeCode - range) >> 31) - 1);\n            } while (--bits2BeDec);\n            probSlot = CmptLzGetAilgnProb(probsMatrix);\n            bits2BeDec = CMPTLZ_LARGE_DIST_LOW_BITS;\n        }\n\n        decSym = 1;\n        offset = 1;\n        do\n        {\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n            probBit = probSlot + decSym;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probBit);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                decSym += offset;\n                offset <<= 1;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                offset <<= 1;\n                decSym += offset;\n            }\n        } while (--bits2BeDec);\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK;\n}": "107", "static inline int CmptLzTryDecLitPacket(CmptLzDecCtx *decCtx, uint32_t range, uint32_t rangeCode, uint32_t rangeBound,\n                                        const unsigned char *bufTryDec, const unsigned char **pbufLimit)\n{\n    CmptLzDecProb *probBit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    uint32_t procPos = decCtx->processedPos;\n    uint32_t litPosMask = ((uint32_t)0x100 << decCtx->prop.litPos) - ((uint32_t)0x100 >> decCtx->prop.litCtx);\n\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t dicPos = decCtx->dictPos;\n    const unsigned char *dict = decCtx->dict;\n    const unsigned char *bufLimit = *pbufLimit;\n\n    if (decCtx->dictPos >= decCtx->dictBufSize)\n    {\n        return CMPT_ERROR_DATA;\n    }\n\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0 || decCtx->checkDicSize != 0)\n    {\n        probSlot += (uint32_t)3 * ((((procPos << 8) + dict[(dicPos == 0 ? dictBufSize : dicPos) - 1]) & litPosMask)\n                                   << decCtx->prop.litCtx);\n    }\n\n    uint32_t decSym = 1;\n    if (decCtx->state < CMPTLZ_LIT_STATES)\n    {\n        do\n        {\n            probBit = probSlot + decSym;\n            CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        } while (decSym < 0x100);\n    }\n    else\n    {\n        uint32_t bit;\n        uint32_t matchSym = dict[dicPos - decCtx->reps[0] + ((dicPos < decCtx->reps[0]) ? dictBufSize : 0)];\n        uint32_t offset = 0x100;\n        do\n        {\n            matchSym <<= 1;\n            bit = offset;\n            offset &= matchSym;\n            probBit = probSlot + (offset + bit + decSym);\n            CMPTLZ_MATCH_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        } while (decSym < 0x100);\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK;\n}": "108", "int CmptLzTryDecOnePacket(CmptLzDecCtx *decCtx, const unsigned char *bufTryDec, const unsigned char **pbufLimit)\n{\n    uint32_t rangeBound = 0;\n    uint32_t range = decCtx->range;\n    uint32_t rangeCode = decCtx->code;\n    uint32_t mkState = decCtx->state;\n    const unsigned char *bufLimit = *pbufLimit;\n\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probSlot1;\n    CmptLzDecProb *probSlot2;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t posState = CMPTLZ_CALC_POS_STATE(decCtx->processedPos, pbMask);\n\n    probSlot1 = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot1);\n    if (rangeCode < rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        return CmptLzTryDecLitPacket(decCtx, range, rangeCode, rangeBound, bufTryDec, pbufLimit);\n    }\n\n    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n    probSlot2 = CmptLzGetIsRepProb(probsMatrix) + mkState;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot2);\n    if (rangeCode < rangeBound)\n    {\n\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        probSlot = CmptLzGetMatchLenCoderProb(probsMatrix);\n        mkState = 0;\n    }\n    else\n    {\n        if (decCtx->dictPos >= decCtx->dictBufSize)\n        {\n            return CMPT_ERROR_DATA;\n        }\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n        probSlot = CmptLzGetIsRepG0Prob(probsMatrix) + mkState;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n            probSlot = CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n                *pbufLimit = bufTryDec;\n                return CMPT_OK;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            }\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n            probSlot = CmptLzGetIsRepG1Prob(probsMatrix) + mkState;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n                probSlot = CmptLzGetIsRepG2Prob(probsMatrix) + mkState;\n                rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n                if (rangeCode < rangeBound)\n                {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                }\n                else\n                {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                }\n            }\n        }\n\n        probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n        mkState = CMPTLZ_MKSTATE_NUM;\n    }\n    return CmptLzTryDecLenAndDist(decCtx, mkState, range, rangeCode, rangeBound, probSlot, bufTryDec, pbufLimit);\n}": "109", "int CmptLzDecCarefulProcess(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *bufLimit)\n{\n    int res = CMPT_OK;\n    uint32_t remainLen;\n    const unsigned char *bufLimitTmp;\n    const unsigned char *pSrcIn;\n\n    do\n    {\n        bufLimitTmp = bufLimit;\n        pSrcIn = decCtx->buf;\n\n        res = CmptLzTryDecOnePacket(decCtx, pSrcIn, &bufLimitTmp);\n        if (res == CMPTLZ_DEC_INPUT_EOF)\n        {\n            break;\n        }\n        res = CmptLzDecDirectProcess(decCtx, dicPosLimit, bufLimitTmp);\n        if ((res != CMPT_OK) || (decCtx->buf != bufLimitTmp))\n        {\n            return CMPT_ERROR_DATA;\n        }\n        if (decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN)\n        {\n            break;\n        }\n    } while (decCtx->dictPos < dicPosLimit);\n\n    if ((res == CMPTLZ_DEC_INPUT_EOF) && (decCtx->buf < bufLimit))\n    {\n        remainLen = (uint32_t)(bufLimit - decCtx->buf);\n        decCtx->tempBufSize = remainLen;\n        for (uint32_t idx = 0; idx < remainLen; idx++)\n        {\n            decCtx->tempBuf[idx] = decCtx->buf[idx];\n        }\n    }\n\n    return CMPT_OK;\n}": "110", "int CmptLzDecSinglePacket(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *pSrcIn, size_t srcInLen,\n                          size_t *psrcCostLen)\n{\n    int res;\n    size_t lookAheadLen = 0;\n    uint32_t newTempBufSize = decCtx->tempBufSize;\n    unsigned char *oldTmpBuf = &(decCtx->tempBuf[decCtx->tempBufSize]);\n\n    while (newTempBufSize < CMPTLZ_REQUIRED_INPUT_MAX && lookAheadLen < srcInLen)\n    {\n        decCtx->tempBuf[newTempBufSize++] = pSrcIn[lookAheadLen++];\n    }\n\n    const unsigned char *bufLimit = decCtx->tempBuf + newTempBufSize;\n    res = CmptLzTryDecOnePacket(decCtx, &(decCtx->tempBuf[0]), &bufLimit);\n    if (res == CMPTLZ_DEC_INPUT_EOF)\n    {\n        *psrcCostLen = lookAheadLen;\n        decCtx->tempBufSize = newTempBufSize;\n        return CMPTLZ_DEC_INPUT_EOF;\n    }\n\n    if (res == CMPT_ERROR_DATA)\n    {\n        return res;\n    }\n\n    decCtx->buf = &(decCtx->tempBuf[0]);\n\n    res = CmptLzDecDirectProcess(decCtx, dicPosLimit, bufLimit);\n    if ((res != CMPT_OK) || (bufLimit != decCtx->buf) || (bufLimit <= oldTmpBuf))\n    {\n        *psrcCostLen = 0;\n        return CMPT_ERROR_DATA;\n    }\n    *psrcCostLen = (size_t)(bufLimit - oldTmpBuf);\n    decCtx->tempBufSize = 0;\n    return res;\n}": "111", "static inline int CmptLzPropsDecode(const unsigned char *protData, unsigned protSize, CmptLzDecProt *decProt)\n{\n    uint32_t dictSize;\n\n    if (protSize < CMPTLZ_PROPS_SIZE)\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n    else\n    {\n\n        dictSize =\n            protData[1] | ((uint32_t)protData[2] << 8) | ((uint32_t)protData[3] << 16) | ((uint32_t)protData[4] << 24);\n    }\n\n    if (dictSize < CMPTLZ_DICT_MIN_LEN)\n    {\n        dictSize = CMPTLZ_DICT_MIN_LEN;\n    }\n    decProt->dicSize = dictSize;\n\n    unsigned char firstData = protData[0];\n    if (firstData >= (CMPTLZ_LIT_CTX_MAX * CMPTLZ_POS_STATE_MAX * CMPTLZ_LIT_POS_MAX))\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    decProt->litCtx = (unsigned char)(firstData % CMPTLZ_LIT_CTX_MAX);\n    firstData /= CMPTLZ_LIT_CTX_MAX;\n    decProt->posBits = (unsigned char)(firstData / CMPTLZ_POS_STATE_MAX);\n    decProt->litPos = (unsigned char)(firstData % CMPTLZ_LIT_POS_MAX);\n\n    return CMPT_OK;\n}": "112", "void CmptLzDecInit(CmptLzDecCtx *decCtx)\n{\n    decCtx->dictPos = 0;\n    decCtx->tempBufSize = 0;\n    decCtx->processedPos = 0;\n    decCtx->checkDicSize = 0;\n    decCtx->remainLen = CMPTLZ_MATCH_MAX_LEN + 2;\n}": "113", "static inline void *CmptLzDecMemAlloc(CmptLzMemHook *memHook, int32_t memHandle, size_t allocSize)\n{\n    return memHook->CmptLzAlloc(memHandle, allocSize);\n}": "114", "static inline void CmptLzDecMemFree(CmptLzMemHook *memHook, int32_t memHandle, void *freeAddress)\n{\n    memHook->CmptLzFree(memHandle, freeAddress);\n}": "115", "static inline void CmptLzDecFreeProbs(CmptLzDecCtx *decCtx, CmptLzMemHook *memHook)\n{\n    if (decCtx->probs != NULL)\n    {\n        CmptLzDecMemFree(memHook, CMPTLZ_PROB_HANDLE, decCtx->probs);\n        decCtx->probs = NULL;\n    }\n}": "116", "static inline void CmptLzFreeDict(CmptLzDecCtx *decCtx, CmptLzMemHook *memHook)\n{\n    if (decCtx->dict != NULL)\n    {\n        CmptLzDecMemFree(memHook, CMPTLZ_DICT_HANDLE, decCtx->dict);\n        decCtx->dict = NULL;\n    }\n}": "117", "static inline int CmptLzDecAllocateProbs(CmptLzDecCtx *decCtx, CmptLzDecProt *decProt, CmptLzMemHook *memHook)\n{\n    uint32_t numProbs = CmptLzGetNumProbs(decProt);\n\n    if (decCtx->probs == NULL)\n    {\n        decCtx->probs =\n            (CmptLzDecProb *)CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE, numProbs * sizeof(CmptLzDecProb));\n    }\n    else\n    {\n        if (numProbs != decCtx->numProbs)\n        {\n            CmptLzDecFreeProbs(decCtx, memHook);\n            decCtx->probs =\n                (CmptLzDecProb *)CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE, numProbs * sizeof(CmptLzDecProb));\n        }\n    }\n\n    if (decCtx->probs == NULL)\n    {\n        return CMPT_ERROR_MEM;\n    }\n\n    decCtx->probsPlus1664 = decCtx->probs + 1664;\n    decCtx->numProbs = numProbs;\n\n    return CMPT_OK;\n}": "118", "int CmptLzDecAllocate(CmptLzDecCtx *decCtx, const unsigned char *protData, unsigned protSize, CmptLzMemHook *memHook)\n{\n    int res;\n    uint32_t dictMask;\n    size_t dictBufSize;\n    CmptLzDecProt decProt;\n\n    if ((decCtx == NULL) || (protData == NULL) || (memHook == NULL))\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    res = CmptLzPropsDecode(protData, protSize, &decProt);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n    res = CmptLzDecAllocateProbs(decCtx, &decProt, memHook);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n\n    uint32_t dictSize = decProt.dicSize;\n    if (dictSize >= ((uint32_t)1 << CMPTLZ_BIG_DICT_LG_SIZE))\n    {\n        dictMask = ((uint32_t)1 << CMPTLZ_MID_DICT_LG_SIZE) - 1;\n    }\n    else if (dictSize >= ((uint32_t)1 << CMPTLZ_MID_DICT_LG_SIZE))\n    {\n        dictMask = ((uint32_t)1 << CMPTLZ_SMALL_DICT_LG_SIZE) - 1;\n    }\n    else\n    {\n        dictMask = CMPTLZ_DICT_MIN_LEN - 1;\n    }\n\n    dictBufSize = ((size_t)dictSize + dictMask) & ~dictMask;\n    if (dictBufSize < dictSize)\n    {\n        dictBufSize = dictSize;\n    }\n\n    if (decCtx->dict == NULL)\n    {\n        decCtx->dict = (unsigned char *)CmptLzDecMemAlloc(memHook, CMPTLZ_DICT_HANDLE, dictBufSize);\n    }\n    else\n    {\n        if (dictBufSize != decCtx->dictBufSize)\n        {\n            CmptLzFreeDict(decCtx, memHook);\n            decCtx->dict = (unsigned char *)CmptLzDecMemAlloc(memHook, CMPTLZ_DICT_HANDLE, dictBufSize);\n        }\n    }\n\n    if (decCtx->dict == NULL)\n    {\n        CmptLzDecFreeProbs(decCtx, memHook);\n        return CMPT_ERROR_MEM;\n    }\n\n    decCtx->dictBufSize = dictBufSize;\n    decCtx->prop = decProt;\n\n    return CMPT_OK;\n}": "119", "int CmptLzDecFree(CmptLzDecCtx *decCtx, CmptLzMemHook *memHook)\n{\n    if ((decCtx == NULL) || (memHook == NULL))\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    CmptLzDecFreeProbs(decCtx, memHook);\n    CmptLzFreeDict(decCtx, memHook);\n\n    return CMPT_OK;\n}": "120", "void CmptLzDecConstruct(CmptLzDecCtx *decCtx)\n{\n    decCtx->dict = NULL;\n    decCtx->probs = NULL;\n}": "121", "int CmptLzDecode(CmptLzDecIn *pDecIn, CmptLzDecOut *pDecOut, const unsigned char *protData, EnCmptLzFinMode finMode,\n                 EnCmptLzStatus *finStatus, CmptLzMemHook *memHook)\n{\n    int res;\n    size_t inSize = pDecIn->strInLen;\n    CmptLzDecProt decProt;\n    CmptLzDecCtx decCtx;\n    decCtx.numProbs = 0;\n\n    if (inSize < CMPTLZ_PROPS_SIZE)\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    CmptLzDecConstruct(&decCtx);\n    res = CmptLzPropsDecode(protData, CMPTLZ_PROPS_SIZE, &decProt);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n    res = CmptLzDecAllocateProbs(&decCtx, &decProt, memHook);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n\n    decCtx.prop = decProt;\n    decCtx.dict = pDecOut->pDestOut;\n    decCtx.dictBufSize = pDecOut->destOutLen;\n    CmptLzDecInit(&decCtx);\n\n    *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n    res = CmptLzDecDecodeToDic(&decCtx, pDecOut->destOutLen, pDecIn->pSrcIn, &inSize, finMode, finStatus);\n    pDecIn->strInCostLen = inSize;\n    pDecOut->destOutFillLen = decCtx.dictPos;\n    CmptLzDecFreeProbs(&decCtx, memHook);\n\n    return res;\n}": "122", "void CmptlzLogWrite(size_t errorCode, const char *funcName, unsigned short line, const char *fmt, ...)\n    {\n        va_list alist;\n        char output[LOG_BUF_SIZE];\n        int ret;\n        size_t len;\n        CmptlzLogFunc func = g_cmptlzLogFunc;\n\n        if (func == NULL)\n        {\n            return;\n        }\n\n        ret = snprintf_s(output, LOG_BUF_SIZE, LOG_BUF_SIZE - 1, \"\\n[Cmptlz-Log] Func=%s, Line=%u, Error=0x%zx\\n\",\n                         funcName, line, errorCode);\n        if (ret < 0)\n        {\n            return;\n        }\n        len = (size_t)ret;\n\n        va_start(alist, fmt);\n        ret = vsnprintf_s(output + len, LOG_BUF_SIZE - len, LOG_BUF_SIZE - len - 1, fmt, alist);\n        va_end(alist);\n        if (ret < 0)\n        {\n            return;\n        }\n\n        func(output, strlen(output) + 1);\n    }": "123", "void CmptlzLogRegister(CmptlzLogFunc func)\n    {\n        g_cmptlzLogFunc = func;\n    }": "124", "static inline int CmptlzIsLE(void)\n    {\n#if (defined(__GNUC__) || defined(__clang__))\n        return __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__;\n#endif\n        int n = 1;\n        return *(char *)(&n);\n    }": "125", "static inline uint32_t CmptlzSwap32(uint32_t val)\n    {\n#if (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)))\n        return (uint32_t)__builtin_bswap32(val);\n#endif\n        return ((0xff000000 & (val << 24)) | (0x000000ff & (val >> 24)) | (0x00ff0000 & (val << 8)) |\n                (0x0000ff00 & (val >> 8)));\n    }": "126", "static inline void CmptlzWriteLE32Bit(void *addr, uint32_t val)\n    {\n        if (CmptlzIsLE() != 0)\n        {\n            CMPTLZ_WRITE32BIT(addr, val);\n        }\n        else\n        {\n            CMPTLZ_WRITE32BIT(addr, CmptlzSwap32(val));\n        }\n    }": "127"}