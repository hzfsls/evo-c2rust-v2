{"void list_free(ListEntry *list)\n{\n    ListEntry *entry;\n\n    entry = list;\n\n    while (entry != NULL)\n    {\n        ListEntry *next;\n\n        next = entry->next;\n\n        free(entry);\n\n        entry = next;\n    }\n}": "0", "ListEntry *list_prepend(ListEntry **list, ListValue data)\n{\n    ListEntry *newentry;\n\n    if (list == NULL)\n    {\n\n        return NULL;\n    }\n\n    newentry = malloc(sizeof(ListEntry));\n\n    if (newentry == NULL)\n    {\n        return NULL;\n    }\n\n    newentry->data = data;\n\n    if (*list != NULL)\n    {\n        (*list)->prev = newentry;\n    }\n    newentry->prev = NULL;\n    newentry->next = *list;\n    *list = newentry;\n\n    return newentry;\n}": "1", "ListEntry *list_append(ListEntry **list, ListValue data)\n{\n    ListEntry *rover;\n    ListEntry *newentry;\n\n    if (list == NULL)\n    {\n        return NULL;\n    }\n\n    newentry = malloc(sizeof(ListEntry));\n\n    if (newentry == NULL)\n    {\n        return NULL;\n    }\n\n    newentry->data = data;\n    newentry->next = NULL;\n\n    if (*list == NULL)\n    {\n\n        *list = newentry;\n        newentry->prev = NULL;\n    }\n    else\n    {\n\n        for (rover = *list; rover->next != NULL; rover = rover->next)\n            ;\n\n        newentry->prev = rover;\n        rover->next = newentry;\n    }\n\n    return newentry;\n}": "2", "ListValue list_data(ListEntry *listentry)\n{\n    if (listentry == NULL)\n    {\n        return LIST_NULL;\n    }\n\n    return listentry->data;\n}": "3", "void list_set_data(ListEntry *listentry, ListValue value)\n{\n    if (listentry != NULL)\n    {\n        listentry->data = value;\n    }\n}": "4", "ListEntry *list_prev(ListEntry *listentry)\n{\n    if (listentry == NULL)\n    {\n        return NULL;\n    }\n\n    return listentry->prev;\n}": "5", "ListEntry *list_next(ListEntry *listentry)\n{\n    if (listentry == NULL)\n    {\n        return NULL;\n    }\n\n    return listentry->next;\n}": "6", "ListEntry *list_nth_entry(ListEntry *list, unsigned int n)\n{\n    ListEntry *entry;\n    unsigned int i;\n\n    entry = list;\n\n    for (i = 0; i < n; ++i)\n    {\n\n        if (entry == NULL)\n        {\n            return NULL;\n        }\n        entry = entry->next;\n    }\n\n    return entry;\n}": "7", "ListValue list_nth_data(ListEntry *list, unsigned int n)\n{\n    ListEntry *entry;\n\n    entry = list_nth_entry(list, n);\n\n    if (entry == NULL)\n    {\n        return LIST_NULL;\n    }\n    else\n    {\n        return entry->data;\n    }\n}": "8", "unsigned int list_length(ListEntry *list)\n{\n    ListEntry *entry;\n    unsigned int length;\n\n    length = 0;\n    entry = list;\n\n    while (entry != NULL)\n    {\n\n        ++length;\n\n        entry = entry->next;\n    }\n\n    return length;\n}": "9", "ListValue *list_to_array(ListEntry *list)\n{\n    ListEntry *rover;\n    ListValue *array;\n    unsigned int length;\n    unsigned int i;\n\n    length = list_length(list);\n\n    array = malloc(sizeof(ListValue) * length);\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    rover = list;\n\n    for (i = 0; i < length; ++i)\n    {\n\n        array[i] = rover->data;\n\n        rover = rover->next;\n    }\n\n    return array;\n}": "10", "int list_remove_entry(ListEntry **list, ListEntry *entry)\n{\n\n    if (list == NULL || *list == NULL || entry == NULL)\n    {\n        return 0;\n    }\n\n    if (entry->prev == NULL)\n    {\n\n        *list = entry->next;\n\n        if (entry->next != NULL)\n        {\n            entry->next->prev = NULL;\n        }\n    }\n    else\n    {\n\n        entry->prev->next = entry->next;\n\n        if (entry->next != NULL)\n        {\n            entry->next->prev = entry->prev;\n        }\n    }\n\n    free(entry);\n\n    return 1;\n}": "11", "unsigned int list_remove_data(ListEntry **list, ListEqualFunc callback, ListValue data)\n{\n    unsigned int entries_removed;\n    ListEntry *rover;\n    ListEntry *next;\n\n    if (list == NULL || callback == NULL)\n    {\n        return 0;\n    }\n\n    entries_removed = 0;\n\n    rover = *list;\n\n    while (rover != NULL)\n    {\n\n        next = rover->next;\n\n        if (callback(rover->data, data))\n        {\n\n            if (rover->prev == NULL)\n            {\n\n                *list = rover->next;\n            }\n            else\n            {\n\n                rover->prev->next = rover->next;\n            }\n\n            if (rover->next != NULL)\n            {\n                rover->next->prev = rover->prev;\n            }\n\n            free(rover);\n\n            ++entries_removed;\n        }\n\n        rover = next;\n    }\n\n    return entries_removed;\n}": "12", "static ListEntry *list_sort_internal(ListEntry **list, ListCompareFunc compare_func)\n{\n    ListEntry *pivot;\n    ListEntry *rover;\n    ListEntry *less_list, *more_list;\n    ListEntry *less_list_end, *more_list_end;\n\n    if (list == NULL || compare_func == NULL)\n    {\n        return NULL;\n    }\n\n    if (*list == NULL || (*list)->next == NULL)\n    {\n        return *list;\n    }\n\n    pivot = *list;\n\n    less_list = NULL;\n    more_list = NULL;\n    rover = (*list)->next;\n\n    while (rover != NULL)\n    {\n        ListEntry *next = rover->next;\n\n        if (compare_func(rover->data, pivot->data) < 0)\n        {\n\n            rover->prev = NULL;\n            rover->next = less_list;\n            if (less_list != NULL)\n            {\n                less_list->prev = rover;\n            }\n            less_list = rover;\n        }\n        else\n        {\n\n            rover->prev = NULL;\n            rover->next = more_list;\n            if (more_list != NULL)\n            {\n                more_list->prev = rover;\n            }\n            more_list = rover;\n        }\n\n        rover = next;\n    }\n\n    less_list_end = list_sort_internal(&less_list, compare_func);\n    more_list_end = list_sort_internal(&more_list, compare_func);\n\n    *list = less_list;\n\n    if (less_list == NULL)\n    {\n        pivot->prev = NULL;\n        *list = pivot;\n    }\n    else\n    {\n        pivot->prev = less_list_end;\n        less_list_end->next = pivot;\n    }\n\n    pivot->next = more_list;\n    if (more_list != NULL)\n    {\n        more_list->prev = pivot;\n    }\n\n    if (more_list == NULL)\n    {\n        return pivot;\n    }\n    else\n    {\n        return more_list_end;\n    }\n}": "13", "void list_sort(ListEntry **list, ListCompareFunc compare_func)\n{\n    list_sort_internal(list, compare_func);\n}": "14", "ListEntry *list_find_data(ListEntry *list, ListEqualFunc callback, ListValue data)\n{\n    ListEntry *rover;\n\n    for (rover = list; rover != NULL; rover = rover->next)\n    {\n        if (callback(rover->data, data) != 0)\n        {\n            return rover;\n        }\n    }\n\n    return NULL;\n}": "15", "void list_iterate(ListEntry **list, ListIterator *iter)\n{\n\n    iter->prev_next = list;\n\n    iter->current = NULL;\n}": "16", "int list_iter_has_more(ListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n\n        return *iter->prev_next != NULL;\n    }\n    else\n    {\n\n        return iter->current->next != NULL;\n    }\n}": "17", "ListValue list_iter_next(ListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n\n        iter->current = *iter->prev_next;\n    }\n    else\n    {\n\n        iter->prev_next = &iter->current->next;\n        iter->current = iter->current->next;\n    }\n\n    if (iter->current == NULL)\n    {\n        return LIST_NULL;\n    }\n    else\n    {\n        return iter->current->data;\n    }\n}": "18", "void list_iter_remove(ListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n    }\n    else\n    {\n\n        *iter->prev_next = iter->current->next;\n\n        if (iter->current->next != NULL)\n        {\n            iter->current->next->prev = iter->current->prev;\n        }\n\n        free(iter->current);\n        iter->current = NULL;\n    }\n}": "19", "static unsigned int sortedarray_first_index(SortedArray *sortedarray, SortedArrayValue data, unsigned int left,\n                                            unsigned int right)\n{\n    unsigned int index = left;\n\n    while (left < right)\n    {\n        index = (left + right) / 2;\n\n        int order = sortedarray->cmp_func(data, sortedarray->data[index]);\n        if (order > 0)\n        {\n            left = index + 1;\n        }\n        else\n        {\n            right = index;\n        }\n    }\n\n    return index;\n}": "20", "static unsigned int sortedarray_last_index(SortedArray *sortedarray, SortedArrayValue data, unsigned int left,\n                                           unsigned int right)\n{\n    unsigned int index = right;\n\n    while (left < right)\n    {\n        index = (left + right) / 2;\n\n        int order = sortedarray->cmp_func(data, sortedarray->data[index]);\n        if (order <= 0)\n        {\n            left = index + 1;\n        }\n        else\n        {\n            right = index;\n        }\n    }\n\n    return index;\n}": "21", "SortedArrayValue *sortedarray_get(SortedArray *array, unsigned int i)\n{\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    return array->data[i];\n}": "22", "unsigned int sortedarray_length(SortedArray *array)\n{\n    return array->length;\n}": "23", "SortedArray *sortedarray_new(unsigned int length, SortedArrayEqualFunc equ_func, SortedArrayCompareFunc cmp_func)\n{\n\n    if (equ_func == NULL || cmp_func == NULL)\n    {\n        return NULL;\n    }\n\n    if (length == 0)\n    {\n        length = 16;\n    }\n\n    SortedArrayValue *array = malloc(sizeof(SortedArrayValue) * length);\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    SortedArray *sortedarray = malloc(sizeof(SortedArray));\n\n    if (sortedarray == NULL)\n    {\n        free(array);\n        return NULL;\n    }\n\n    sortedarray->data = array;\n    sortedarray->length = 0;\n    sortedarray->_alloced = length;\n    sortedarray->equ_func = equ_func;\n    sortedarray->cmp_func = cmp_func;\n    return sortedarray;\n}": "24", "void sortedarray_free(SortedArray *sortedarray)\n{\n    if (sortedarray != NULL)\n    {\n        free(sortedarray->data);\n        free(sortedarray);\n    }\n}": "25", "void sortedarray_remove(SortedArray *sortedarray, unsigned int index)\n{\n\n    sortedarray_remove_range(sortedarray, index, 1);\n}": "26", "void sortedarray_remove_range(SortedArray *sortedarray, unsigned int index, unsigned int length)\n{\n\n    if (index > sortedarray->length || index + length > sortedarray->length)\n    {\n        return;\n    }\n\n    memmove(&sortedarray->data[index], &sortedarray->data[index + length],\n            (sortedarray->length - (index + length)) * sizeof(SortedArrayValue));\n\n    sortedarray->length -= length;\n}": "27", "int sortedarray_insert(SortedArray *sortedarray, SortedArrayValue data)\n{\n\n    unsigned int left = 0;\n    unsigned int right = sortedarray->length;\n    unsigned int index = 0;\n\n    right = (right > 1) ? right : 0;\n\n    while (left != right)\n    {\n        index = (left + right) / 2;\n\n        int order = sortedarray->cmp_func(data, sortedarray->data[index]);\n        if (order < 0)\n        {\n\n            right = index;\n        }\n        else if (order > 0)\n        {\n\n            left = index + 1;\n        }\n        else\n        {\n\n            break;\n        }\n    }\n\n    if (sortedarray->length > 0 && sortedarray->cmp_func(data, sortedarray->data[index]) > 0)\n    {\n        index++;\n    }\n\n    if (sortedarray->length + 1 > sortedarray->_alloced)\n    {\n\n        unsigned int newsize;\n        SortedArrayValue *data;\n\n        newsize = sortedarray->_alloced * 2;\n        data = realloc(sortedarray->data, sizeof(SortedArrayValue) * newsize);\n\n        if (data == NULL)\n        {\n            return 0;\n        }\n        else\n        {\n            sortedarray->data = data;\n            sortedarray->_alloced = newsize;\n        }\n    }\n\n    memmove(&sortedarray->data[index + 1], &sortedarray->data[index],\n            (sortedarray->length - index) * sizeof(SortedArrayValue));\n\n    sortedarray->data[index] = data;\n    ++(sortedarray->length);\n\n    return 1;\n}": "28", "int sortedarray_index_of(SortedArray *sortedarray, SortedArrayValue data)\n{\n    if (sortedarray == NULL)\n    {\n        return -1;\n    }\n\n    unsigned int left = 0;\n    unsigned int right = sortedarray->length;\n    unsigned int index = 0;\n\n    right = (right > 1) ? right : 0;\n\n    while (left != right)\n    {\n        index = (left + right) / 2;\n\n        int order = sortedarray->cmp_func(data, sortedarray->data[index]);\n        if (order < 0)\n        {\n\n            right = index;\n        }\n        else if (order > 0)\n        {\n\n            left = index + 1;\n        }\n        else\n        {\n\n            left = sortedarray_first_index(sortedarray, data, left, index);\n            right = sortedarray_last_index(sortedarray, data, index, right);\n\n            for (index = left; index <= right; index++)\n            {\n                if (sortedarray->equ_func(data, sortedarray->data[index]))\n                {\n                    return (int)index;\n                }\n            }\n\n            return -1;\n        }\n    }\n\n    return -1;\n}": "29", "void sortedarray_clear(SortedArray *sortedarray)\n{\n\n    sortedarray->length = 0;\n}": "30", "AVLTree *avl_tree_new(AVLTreeCompareFunc compare_func)\n{\n    AVLTree *new_tree;\n\n    new_tree = (AVLTree *)malloc(sizeof(AVLTree));\n\n    if (new_tree == NULL)\n    {\n        return NULL;\n    }\n\n    new_tree->root_node = NULL;\n    new_tree->compare_func = compare_func;\n    new_tree->num_nodes = 0;\n\n    return new_tree;\n}": "31", "static void avl_tree_free_subtree(AVLTree *tree, AVLTreeNode *node)\n{\n    if (node == NULL)\n    {\n        return;\n    }\n\n    avl_tree_free_subtree(tree, node->children[AVL_TREE_NODE_LEFT]);\n    avl_tree_free_subtree(tree, node->children[AVL_TREE_NODE_RIGHT]);\n\n    free(node);\n}": "32", "void avl_tree_free(AVLTree *tree)\n{\n\n    avl_tree_free_subtree(tree, tree->root_node);\n\n    free(tree);\n}": "33", "int avl_tree_subtree_height(AVLTreeNode *node)\n{\n    if (node == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        return node->height;\n    }\n}": "34", "static void avl_tree_update_height(AVLTreeNode *node)\n{\n    AVLTreeNode *left_subtree;\n    AVLTreeNode *right_subtree;\n    int left_height, right_height;\n\n    left_subtree = node->children[AVL_TREE_NODE_LEFT];\n    right_subtree = node->children[AVL_TREE_NODE_RIGHT];\n    left_height = avl_tree_subtree_height(left_subtree);\n    right_height = avl_tree_subtree_height(right_subtree);\n\n    if (left_height > right_height)\n    {\n        node->height = left_height + 1;\n    }\n    else\n    {\n        node->height = right_height + 1;\n    }\n}": "35", "static AVLTreeNodeSide avl_tree_node_parent_side(AVLTreeNode *node)\n{\n    if (node->parent->children[AVL_TREE_NODE_LEFT] == node)\n    {\n        return AVL_TREE_NODE_LEFT;\n    }\n    else\n    {\n        return AVL_TREE_NODE_RIGHT;\n    }\n}": "36", "static void avl_tree_node_replace(AVLTree *tree, AVLTreeNode *node1, AVLTreeNode *node2)\n{\n    int side;\n\n    if (node2 != NULL)\n    {\n        node2->parent = node1->parent;\n    }\n\n    if (node1->parent == NULL)\n    {\n        tree->root_node = node2;\n    }\n    else\n    {\n        side = avl_tree_node_parent_side(node1);\n        node1->parent->children[side] = node2;\n\n        avl_tree_update_height(node1->parent);\n    }\n}": "37", "static AVLTreeNode *avl_tree_rotate(AVLTree *tree, AVLTreeNode *node, AVLTreeNodeSide direction)\n{\n    AVLTreeNode *new_root;\n\n    new_root = node->children[1 - direction];\n\n    avl_tree_node_replace(tree, node, new_root);\n\n    node->children[1 - direction] = new_root->children[direction];\n    new_root->children[direction] = node;\n\n    node->parent = new_root;\n\n    if (node->children[1 - direction] != NULL)\n    {\n        node->children[1 - direction]->parent = node;\n    }\n\n    avl_tree_update_height(new_root);\n    avl_tree_update_height(node);\n\n    return new_root;\n}": "38", "static AVLTreeNode *avl_tree_node_balance(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *left_subtree;\n    AVLTreeNode *right_subtree;\n    AVLTreeNode *child;\n    int diff;\n\n    left_subtree = node->children[AVL_TREE_NODE_LEFT];\n    right_subtree = node->children[AVL_TREE_NODE_RIGHT];\n\n    diff = avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if (diff >= 2)\n    {\n\n        child = right_subtree;\n\n        if (avl_tree_subtree_height(child->children[AVL_TREE_NODE_RIGHT]) <\n            avl_tree_subtree_height(child->children[AVL_TREE_NODE_LEFT]))\n        {\n\n            avl_tree_rotate(tree, right_subtree, AVL_TREE_NODE_RIGHT);\n        }\n\n        node = avl_tree_rotate(tree, node, AVL_TREE_NODE_LEFT);\n    }\n    else if (diff <= -2)\n    {\n\n        child = node->children[AVL_TREE_NODE_LEFT];\n\n        if (avl_tree_subtree_height(child->children[AVL_TREE_NODE_LEFT]) <\n            avl_tree_subtree_height(child->children[AVL_TREE_NODE_RIGHT]))\n        {\n\n            avl_tree_rotate(tree, left_subtree, AVL_TREE_NODE_LEFT);\n        }\n\n        node = avl_tree_rotate(tree, node, AVL_TREE_NODE_RIGHT);\n    }\n\n    avl_tree_update_height(node);\n\n    return node;\n}": "39", "static void avl_tree_balance_to_root(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *rover;\n\n    rover = node;\n\n    while (rover != NULL)\n    {\n\n        rover = avl_tree_node_balance(tree, rover);\n\n        rover = rover->parent;\n    }\n}": "40", "AVLTreeNode *avl_tree_insert(AVLTree *tree, AVLTreeKey key, AVLTreeValue value)\n{\n    AVLTreeNode **rover;\n    AVLTreeNode *new_node;\n    AVLTreeNode *previous_node;\n\n    rover = &tree->root_node;\n    previous_node = NULL;\n\n    while (*rover != NULL)\n    {\n        previous_node = *rover;\n        if (tree->compare_func(key, (*rover)->key) < 0)\n        {\n            rover = &((*rover)->children[AVL_TREE_NODE_LEFT]);\n        }\n        else\n        {\n            rover = &((*rover)->children[AVL_TREE_NODE_RIGHT]);\n        }\n    }\n\n    new_node = (AVLTreeNode *)malloc(sizeof(AVLTreeNode));\n\n    if (new_node == NULL)\n    {\n        return NULL;\n    }\n\n    new_node->children[AVL_TREE_NODE_LEFT] = NULL;\n    new_node->children[AVL_TREE_NODE_RIGHT] = NULL;\n    new_node->parent = previous_node;\n    new_node->key = key;\n    new_node->value = value;\n    new_node->height = 1;\n\n    *rover = new_node;\n\n    avl_tree_balance_to_root(tree, previous_node);\n\n    ++tree->num_nodes;\n\n    return new_node;\n}": "41", "static AVLTreeNode *avl_tree_node_get_replacement(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *left_subtree;\n    AVLTreeNode *right_subtree;\n    AVLTreeNode *result;\n    AVLTreeNode *child;\n    int left_height, right_height;\n    int side;\n\n    left_subtree = node->children[AVL_TREE_NODE_LEFT];\n    right_subtree = node->children[AVL_TREE_NODE_RIGHT];\n\n    if (left_subtree == NULL && right_subtree == NULL)\n    {\n        return NULL;\n    }\n\n    left_height = avl_tree_subtree_height(left_subtree);\n    right_height = avl_tree_subtree_height(right_subtree);\n\n    if (left_height < right_height)\n    {\n        side = AVL_TREE_NODE_RIGHT;\n    }\n    else\n    {\n        side = AVL_TREE_NODE_LEFT;\n    }\n\n    result = node->children[side];\n\n    while (result->children[1 - side] != NULL)\n    {\n        result = result->children[1 - side];\n    }\n\n    child = result->children[side];\n    avl_tree_node_replace(tree, result, child);\n\n    avl_tree_update_height(result->parent);\n\n    return result;\n}": "42", "void avl_tree_remove_node(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *swap_node;\n    AVLTreeNode *balance_startpoint;\n    int i;\n\n    swap_node = avl_tree_node_get_replacement(tree, node);\n\n    if (swap_node == NULL)\n    {\n\n        avl_tree_node_replace(tree, node, NULL);\n\n        balance_startpoint = node->parent;\n    }\n    else\n    {\n\n        if (swap_node->parent == node)\n        {\n            balance_startpoint = swap_node;\n        }\n        else\n        {\n            balance_startpoint = swap_node->parent;\n        }\n\n        for (i = 0; i < 2; ++i)\n        {\n            swap_node->children[i] = node->children[i];\n\n            if (swap_node->children[i] != NULL)\n            {\n                swap_node->children[i]->parent = swap_node;\n            }\n        }\n\n        swap_node->height = node->height;\n\n        avl_tree_node_replace(tree, node, swap_node);\n    }\n\n    free(node);\n\n    --tree->num_nodes;\n\n    avl_tree_balance_to_root(tree, balance_startpoint);\n}": "43", "int avl_tree_remove(AVLTree *tree, AVLTreeKey key)\n{\n    AVLTreeNode *node;\n\n    node = avl_tree_lookup_node(tree, key);\n\n    if (node == NULL)\n    {\n\n        return 0;\n    }\n\n    avl_tree_remove_node(tree, node);\n\n    return 1;\n}": "44", "AVLTreeNode *avl_tree_lookup_node(AVLTree *tree, AVLTreeKey key)\n{\n    AVLTreeNode *node;\n    int diff;\n\n    node = tree->root_node;\n\n    while (node != NULL)\n    {\n\n        diff = tree->compare_func(key, node->key);\n\n        if (diff == 0)\n        {\n\n            return node;\n        }\n        else if (diff < 0)\n        {\n            node = node->children[AVL_TREE_NODE_LEFT];\n        }\n        else\n        {\n            node = node->children[AVL_TREE_NODE_RIGHT];\n        }\n    }\n\n    return NULL;\n}": "45", "AVLTreeValue avl_tree_lookup(AVLTree *tree, AVLTreeKey key)\n{\n    AVLTreeNode *node;\n\n    node = avl_tree_lookup_node(tree, key);\n\n    if (node == NULL)\n    {\n        return AVL_TREE_NULL;\n    }\n    else\n    {\n        return node->value;\n    }\n}": "46", "AVLTreeNode *avl_tree_root_node(AVLTree *tree)\n{\n    return tree->root_node;\n}": "47", "AVLTreeKey avl_tree_node_key(AVLTreeNode *node)\n{\n    return node->key;\n}": "48", "AVLTreeValue avl_tree_node_value(AVLTreeNode *node)\n{\n    return node->value;\n}": "49", "AVLTreeNode *avl_tree_node_child(AVLTreeNode *node, AVLTreeNodeSide side)\n{\n    if (side == AVL_TREE_NODE_LEFT || side == AVL_TREE_NODE_RIGHT)\n    {\n        return node->children[side];\n    }\n    else\n    {\n        return NULL;\n    }\n}": "50", "AVLTreeNode *avl_tree_node_parent(AVLTreeNode *node)\n{\n    return node->parent;\n}": "51", "unsigned int avl_tree_num_entries(AVLTree *tree)\n{\n    return tree->num_nodes;\n}": "52", "static void avl_tree_to_array_add_subtree(AVLTreeNode *subtree, AVLTreeValue *array, int *index)\n{\n    if (subtree == NULL)\n    {\n        return;\n    }\n\n    avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_LEFT], array, index);\n\n    array[*index] = subtree->key;\n    ++*index;\n\n    avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_RIGHT], array, index);\n}": "53", "AVLTreeValue *avl_tree_to_array(AVLTree *tree)\n{\n    AVLTreeValue *array;\n    int index;\n\n    array = malloc(sizeof(AVLTreeValue) * tree->num_nodes);\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    index = 0;\n\n    avl_tree_to_array_add_subtree(tree->root_node, array, &index);\n\n    return array;\n}": "54", "BloomFilter *bloom_filter_new(unsigned int table_size, BloomFilterHashFunc hash_func, unsigned int num_functions)\n{\n    BloomFilter *filter;\n\n    if (num_functions > sizeof(salts) / sizeof(*salts))\n    {\n        return NULL;\n    }\n\n    filter = malloc(sizeof(BloomFilter));\n\n    if (filter == NULL)\n    {\n        return NULL;\n    }\n\n    filter->table = calloc((table_size + 7) / 8, 1);\n\n    if (filter->table == NULL)\n    {\n        free(filter);\n        return NULL;\n    }\n\n    filter->hash_func = hash_func;\n    filter->num_functions = num_functions;\n    filter->table_size = table_size;\n\n    return filter;\n}": "55", "void bloom_filter_free(BloomFilter *bloomfilter)\n{\n    free(bloomfilter->table);\n    free(bloomfilter);\n}": "56", "void bloom_filter_insert(BloomFilter *bloomfilter, BloomFilterValue value)\n{\n    unsigned int hash;\n    unsigned int subhash;\n    unsigned int index;\n    unsigned int i;\n    unsigned char b;\n\n    hash = bloomfilter->hash_func(value);\n\n    for (i = 0; i < bloomfilter->num_functions; ++i)\n    {\n\n        subhash = hash ^ salts[i];\n\n        index = subhash % bloomfilter->table_size;\n\n        b = (unsigned char)(1 << (index % 8));\n        bloomfilter->table[index / 8] |= b;\n    }\n}": "57", "int bloom_filter_query(BloomFilter *bloomfilter, BloomFilterValue value)\n{\n    unsigned int hash;\n    unsigned int subhash;\n    unsigned int index;\n    unsigned int i;\n    unsigned char b;\n    int bit;\n\n    hash = bloomfilter->hash_func(value);\n\n    for (i = 0; i < bloomfilter->num_functions; ++i)\n    {\n\n        subhash = hash ^ salts[i];\n\n        index = subhash % bloomfilter->table_size;\n\n        b = bloomfilter->table[index / 8];\n        bit = 1 << (index % 8);\n\n        if ((b & bit) == 0)\n        {\n            return 0;\n        }\n    }\n\n    return 1;\n}": "58", "void bloom_filter_read(BloomFilter *bloomfilter, unsigned char *array)\n{\n    unsigned int array_size;\n\n    array_size = (bloomfilter->table_size + 7) / 8;\n\n    memcpy(array, bloomfilter->table, array_size);\n}": "59", "void bloom_filter_load(BloomFilter *bloomfilter, unsigned char *array)\n{\n    unsigned int array_size;\n\n    array_size = (bloomfilter->table_size + 7) / 8;\n\n    memcpy(bloomfilter->table, array, array_size);\n}": "60", "BloomFilter *bloom_filter_union(BloomFilter *filter1, BloomFilter *filter2)\n{\n    BloomFilter *result;\n    unsigned int i;\n    unsigned int array_size;\n\n    if (filter1->table_size != filter2->table_size || filter1->num_functions != filter2->num_functions ||\n        filter1->hash_func != filter2->hash_func)\n    {\n        return NULL;\n    }\n\n    result = bloom_filter_new(filter1->table_size, filter1->hash_func, filter1->num_functions);\n\n    if (result == NULL)\n    {\n        return NULL;\n    }\n\n    array_size = (filter1->table_size + 7) / 8;\n\n    for (i = 0; i < array_size; ++i)\n    {\n        result->table[i] = filter1->table[i] | filter2->table[i];\n    }\n\n    return result;\n}": "61", "BloomFilter *bloom_filter_intersection(BloomFilter *filter1, BloomFilter *filter2)\n{\n    BloomFilter *result;\n    unsigned int i;\n    unsigned int array_size;\n\n    if (filter1->table_size != filter2->table_size || filter1->num_functions != filter2->num_functions ||\n        filter1->hash_func != filter2->hash_func)\n    {\n        return NULL;\n    }\n\n    result = bloom_filter_new(filter1->table_size, filter1->hash_func, filter1->num_functions);\n\n    if (result == NULL)\n    {\n        return NULL;\n    }\n\n    array_size = (filter1->table_size + 7) / 8;\n\n    for (i = 0; i < array_size; ++i)\n    {\n        result->table[i] = filter1->table[i] & filter2->table[i];\n    }\n\n    return result;\n}": "62", "int string_equal(void *string1, void *string2)\n{\n    return strcmp((char *)string1, (char *)string2) == 0;\n}": "63", "int string_compare(void *string1, void *string2)\n{\n    int result;\n\n    result = strcmp((char *)string1, (char *)string2);\n\n    if (result < 0)\n    {\n        return -1;\n    }\n    else if (result > 0)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}": "64", "int string_nocase_equal(void *string1, void *string2)\n{\n    return string_nocase_compare((char *)string1, (char *)string2) == 0;\n}": "65", "int string_nocase_compare(void *string1, void *string2)\n{\n    char *p1;\n    char *p2;\n    int c1, c2;\n\n    p1 = (char *)string1;\n    p2 = (char *)string2;\n\n    for (;;)\n    {\n\n        c1 = tolower(*p1);\n        c2 = tolower(*p2);\n\n        if (c1 != c2)\n        {\n\n            if (c1 < c2)\n            {\n                return -1;\n            }\n            else\n            {\n                return 1;\n            }\n        }\n\n        if (c1 == '\\0')\n            break;\n\n        ++p1;\n        ++p2;\n    }\n\n    return 0;\n}": "66", "int pointer_equal(void *location1, void *location2)\n{\n    return location1 == location2;\n}": "67", "int pointer_compare(void *location1, void *location2)\n{\n    if (location1 < location2)\n    {\n        return -1;\n    }\n    else if (location1 > location2)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}": "68", "static int hash_table_allocate_table(HashTable *hash_table)\n{\n    unsigned int new_table_size;\n\n    if (hash_table->prime_index < hash_table_num_primes)\n    {\n        new_table_size = hash_table_primes[hash_table->prime_index];\n    }\n    else\n    {\n        new_table_size = hash_table->entries * 10;\n    }\n\n    hash_table->table_size = new_table_size;\n\n    hash_table->table = calloc(hash_table->table_size, sizeof(HashTableEntry *));\n\n    return hash_table->table != NULL;\n}": "69", "static void hash_table_free_entry(HashTable *hash_table, HashTableEntry *entry)\n{\n    HashTablePair *pair;\n\n    pair = &(entry->pair);\n\n    if (hash_table->key_free_func != NULL)\n    {\n        hash_table->key_free_func(pair->key);\n    }\n\n    if (hash_table->value_free_func != NULL)\n    {\n        hash_table->value_free_func(pair->value);\n    }\n\n    free(entry);\n}": "70", "HashTable *hash_table_new(HashTableHashFunc hash_func, HashTableEqualFunc equal_func)\n{\n    HashTable *hash_table;\n\n    hash_table = (HashTable *)malloc(sizeof(HashTable));\n\n    if (hash_table == NULL)\n    {\n        return NULL;\n    }\n\n    hash_table->hash_func = hash_func;\n    hash_table->equal_func = equal_func;\n    hash_table->key_free_func = NULL;\n    hash_table->value_free_func = NULL;\n    hash_table->entries = 0;\n    hash_table->prime_index = 0;\n\n    if (!hash_table_allocate_table(hash_table))\n    {\n        free(hash_table);\n\n        return NULL;\n    }\n\n    return hash_table;\n}": "71", "void hash_table_free(HashTable *hash_table)\n{\n    HashTableEntry *rover;\n    HashTableEntry *next;\n    unsigned int i;\n\n    for (i = 0; i < hash_table->table_size; ++i)\n    {\n        rover = hash_table->table[i];\n        while (rover != NULL)\n        {\n            next = rover->next;\n            hash_table_free_entry(hash_table, rover);\n            rover = next;\n        }\n    }\n\n    free(hash_table->table);\n\n    free(hash_table);\n}": "72", "void hash_table_register_free_functions(HashTable *hash_table, HashTableKeyFreeFunc key_free_func,\n                                        HashTableValueFreeFunc value_free_func)\n{\n    hash_table->key_free_func = key_free_func;\n    hash_table->value_free_func = value_free_func;\n}": "73", "static int hash_table_enlarge(HashTable *hash_table)\n{\n    HashTableEntry **old_table;\n    unsigned int old_table_size;\n    unsigned int old_prime_index;\n    HashTableEntry *rover;\n    HashTablePair *pair;\n    HashTableEntry *next;\n    unsigned int index;\n    unsigned int i;\n\n    old_table = hash_table->table;\n    old_table_size = hash_table->table_size;\n    old_prime_index = hash_table->prime_index;\n\n    ++hash_table->prime_index;\n\n    if (!hash_table_allocate_table(hash_table))\n    {\n\n        hash_table->table = old_table;\n        hash_table->table_size = old_table_size;\n        hash_table->prime_index = old_prime_index;\n\n        return 0;\n    }\n\n    for (i = 0; i < old_table_size; ++i)\n    {\n        rover = old_table[i];\n\n        while (rover != NULL)\n        {\n            next = rover->next;\n\n            pair = &(rover->pair);\n\n            index = hash_table->hash_func(pair->key) % hash_table->table_size;\n\n            rover->next = hash_table->table[index];\n            hash_table->table[index] = rover;\n\n            rover = next;\n        }\n    }\n\n    free(old_table);\n\n    return 1;\n}": "74", "int hash_table_insert(HashTable *hash_table, HashTableKey key, HashTableValue value)\n{\n    HashTableEntry *rover;\n    HashTablePair *pair;\n    HashTableEntry *newentry;\n    unsigned int index;\n\n    if ((hash_table->entries * 3) / hash_table->table_size > 0)\n    {\n\n        if (!hash_table_enlarge(hash_table))\n        {\n\n            return 0;\n        }\n    }\n\n    index = hash_table->hash_func(key) % hash_table->table_size;\n\n    rover = hash_table->table[index];\n\n    while (rover != NULL)\n    {\n\n        pair = &(rover->pair);\n\n        if (hash_table->equal_func(pair->key, key) != 0)\n        {\n\n            if (hash_table->value_free_func != NULL)\n            {\n                hash_table->value_free_func(pair->value);\n            }\n\n            if (hash_table->key_free_func != NULL)\n            {\n                hash_table->key_free_func(pair->key);\n            }\n\n            pair->key = key;\n            pair->value = value;\n\n            return 1;\n        }\n\n        rover = rover->next;\n    }\n\n    newentry = (HashTableEntry *)malloc(sizeof(HashTableEntry));\n\n    if (newentry == NULL)\n    {\n        return 0;\n    }\n\n    newentry->pair.key = key;\n    newentry->pair.value = value;\n\n    newentry->next = hash_table->table[index];\n    hash_table->table[index] = newentry;\n\n    ++hash_table->entries;\n\n    return 1;\n}": "75", "HashTableValue hash_table_lookup(HashTable *hash_table, HashTableKey key)\n{\n    HashTableEntry *rover;\n    HashTablePair *pair;\n    unsigned int index;\n\n    index = hash_table->hash_func(key) % hash_table->table_size;\n\n    rover = hash_table->table[index];\n\n    while (rover != NULL)\n    {\n        pair = &(rover->pair);\n\n        if (hash_table->equal_func(key, pair->key) != 0)\n        {\n\n            return pair->value;\n        }\n\n        rover = rover->next;\n    }\n\n    return HASH_TABLE_NULL;\n}": "76", "int hash_table_remove(HashTable *hash_table, HashTableKey key)\n{\n    HashTableEntry **rover;\n    HashTableEntry *entry;\n    HashTablePair *pair;\n    unsigned int index;\n    int result;\n\n    index = hash_table->hash_func(key) % hash_table->table_size;\n\n    result = 0;\n    rover = &hash_table->table[index];\n\n    while (*rover != NULL)\n    {\n\n        pair = &((*rover)->pair);\n\n        if (hash_table->equal_func(key, pair->key) != 0)\n        {\n\n            entry = *rover;\n\n            *rover = entry->next;\n\n            hash_table_free_entry(hash_table, entry);\n\n            --hash_table->entries;\n\n            result = 1;\n\n            break;\n        }\n\n        rover = &((*rover)->next);\n    }\n\n    return result;\n}": "77", "unsigned int hash_table_num_entries(HashTable *hash_table)\n{\n    return hash_table->entries;\n}": "78", "void hash_table_iterate(HashTable *hash_table, HashTableIterator *iterator)\n{\n    unsigned int chain;\n\n    iterator->hash_table = hash_table;\n\n    iterator->next_entry = NULL;\n\n    for (chain = 0; chain < hash_table->table_size; ++chain)\n    {\n\n        if (hash_table->table[chain] != NULL)\n        {\n            iterator->next_entry = hash_table->table[chain];\n            iterator->next_chain = chain;\n            break;\n        }\n    }\n}": "79", "int hash_table_iter_has_more(HashTableIterator *iterator)\n{\n    return iterator->next_entry != NULL;\n}": "80", "HashTablePair hash_table_iter_next(HashTableIterator *iterator)\n{\n    HashTableEntry *current_entry;\n    HashTable *hash_table;\n    HashTablePair pair = {NULL, NULL};\n    unsigned int chain;\n\n    hash_table = iterator->hash_table;\n\n    if (iterator->next_entry == NULL)\n    {\n        return pair;\n    }\n\n    current_entry = iterator->next_entry;\n    pair = current_entry->pair;\n\n    if (current_entry->next != NULL)\n    {\n\n        iterator->next_entry = current_entry->next;\n    }\n    else\n    {\n\n        chain = iterator->next_chain + 1;\n\n        iterator->next_entry = NULL;\n\n        while (chain < hash_table->table_size)\n        {\n\n            if (hash_table->table[chain] != NULL)\n            {\n                iterator->next_entry = hash_table->table[chain];\n                break;\n            }\n\n            ++chain;\n        }\n\n        iterator->next_chain = chain;\n    }\n\n    return pair;\n}": "81", "static int set_allocate_table(Set *set)\n{\n\n    if (set->prime_index < set_num_primes)\n    {\n        set->table_size = set_primes[set->prime_index];\n    }\n    else\n    {\n        set->table_size = set->entries * 10;\n    }\n\n    set->table = calloc(set->table_size, sizeof(SetEntry *));\n\n    return set->table != NULL;\n}": "82", "static void set_free_entry(Set *set, SetEntry *entry)\n{\n\n    if (set->free_func != NULL)\n    {\n        set->free_func(entry->data);\n    }\n\n    free(entry);\n}": "83", "Set *set_new(SetHashFunc hash_func, SetEqualFunc equal_func)\n{\n    Set *new_set;\n\n    new_set = (Set *)malloc(sizeof(Set));\n\n    if (new_set == NULL)\n    {\n        return NULL;\n    }\n\n    new_set->hash_func = hash_func;\n    new_set->equal_func = equal_func;\n    new_set->entries = 0;\n    new_set->prime_index = 0;\n    new_set->free_func = NULL;\n\n    if (!set_allocate_table(new_set))\n    {\n        free(new_set);\n        return NULL;\n    }\n\n    return new_set;\n}": "84", "void set_free(Set *set)\n{\n    SetEntry *rover;\n    SetEntry *next;\n    unsigned int i;\n\n    for (i = 0; i < set->table_size; ++i)\n    {\n        rover = set->table[i];\n\n        while (rover != NULL)\n        {\n            next = rover->next;\n\n            set_free_entry(set, rover);\n\n            rover = next;\n        }\n    }\n\n    free(set->table);\n\n    free(set);\n}": "85", "void set_register_free_function(Set *set, SetFreeFunc free_func)\n{\n    set->free_func = free_func;\n}": "86", "static int set_enlarge(Set *set)\n{\n    SetEntry *rover;\n    SetEntry *next;\n    SetEntry **old_table;\n    unsigned int old_table_size;\n    unsigned int old_prime_index;\n    unsigned int index;\n    unsigned int i;\n\n    old_table = set->table;\n    old_table_size = set->table_size;\n    old_prime_index = set->prime_index;\n\n    ++set->prime_index;\n\n    if (!set_allocate_table(set))\n    {\n        set->table = old_table;\n        set->table_size = old_table_size;\n        set->prime_index = old_prime_index;\n\n        return 0;\n    }\n\n    for (i = 0; i < old_table_size; ++i)\n    {\n\n        rover = old_table[i];\n\n        while (rover != NULL)\n        {\n\n            next = rover->next;\n\n            index = set->hash_func(rover->data) % set->table_size;\n            rover->next = set->table[index];\n            set->table[index] = rover;\n\n            rover = next;\n        }\n    }\n\n    free(old_table);\n\n    return 1;\n}": "87", "int set_insert(Set *set, SetValue data)\n{\n    SetEntry *newentry;\n    SetEntry *rover;\n    unsigned int index;\n\n    if ((set->entries * 3) / set->table_size > 0)\n    {\n\n        if (!set_enlarge(set))\n        {\n            return 0;\n        }\n    }\n\n    index = set->hash_func(data) % set->table_size;\n\n    rover = set->table[index];\n\n    while (rover != NULL)\n    {\n\n        if (set->equal_func(data, rover->data) != 0)\n        {\n\n            return 0;\n        }\n\n        rover = rover->next;\n    }\n\n    newentry = (SetEntry *)malloc(sizeof(SetEntry));\n\n    if (newentry == NULL)\n    {\n        return 0;\n    }\n\n    newentry->data = data;\n\n    newentry->next = set->table[index];\n    set->table[index] = newentry;\n\n    ++set->entries;\n\n    return 1;\n}": "88", "int set_remove(Set *set, SetValue data)\n{\n    SetEntry **rover;\n    SetEntry *entry;\n    unsigned int index;\n\n    index = set->hash_func(data) % set->table_size;\n\n    rover = &set->table[index];\n\n    while (*rover != NULL)\n    {\n        if (set->equal_func(data, (*rover)->data) != 0)\n        {\n\n            entry = *rover;\n\n            *rover = entry->next;\n\n            --set->entries;\n\n            set_free_entry(set, entry);\n\n            return 1;\n        }\n\n        rover = &((*rover)->next);\n    }\n\n    return 0;\n}": "89", "int set_query(Set *set, SetValue data)\n{\n    SetEntry *rover;\n    unsigned int index;\n\n    index = set->hash_func(data) % set->table_size;\n\n    rover = set->table[index];\n\n    while (rover != NULL)\n    {\n        if (set->equal_func(data, rover->data) != 0)\n        {\n\n            return 1;\n        }\n\n        rover = rover->next;\n    }\n\n    return 0;\n}": "90", "unsigned int set_num_entries(Set *set)\n{\n    return set->entries;\n}": "91", "SetValue *set_to_array(Set *set)\n{\n    SetValue *array;\n    int array_counter;\n    unsigned int i;\n    SetEntry *rover;\n\n    array = malloc(sizeof(SetValue) * set->entries);\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    array_counter = 0;\n\n    for (i = 0; i < set->table_size; ++i)\n    {\n\n        rover = set->table[i];\n\n        while (rover != NULL)\n        {\n\n            array[array_counter] = rover->data;\n            ++array_counter;\n\n            rover = rover->next;\n        }\n    }\n\n    return array;\n}": "92", "Set *set_union(Set *set1, Set *set2)\n{\n    SetIterator iterator;\n    Set *new_set;\n    SetValue value;\n\n    new_set = set_new(set1->hash_func, set1->equal_func);\n\n    if (new_set == NULL)\n    {\n        return NULL;\n    }\n\n    set_iterate(set1, &iterator);\n\n    while (set_iter_has_more(&iterator))\n    {\n\n        value = set_iter_next(&iterator);\n\n        if (!set_insert(new_set, value))\n        {\n\n            set_free(new_set);\n            return NULL;\n        }\n    }\n\n    set_iterate(set2, &iterator);\n\n    while (set_iter_has_more(&iterator))\n    {\n\n        value = set_iter_next(&iterator);\n\n        if (set_query(new_set, value) == 0)\n        {\n            if (!set_insert(new_set, value))\n            {\n\n                set_free(new_set);\n                return NULL;\n            }\n        }\n    }\n\n    return new_set;\n}": "93", "Set *set_intersection(Set *set1, Set *set2)\n{\n    Set *new_set;\n    SetIterator iterator;\n    SetValue value;\n\n    new_set = set_new(set1->hash_func, set2->equal_func);\n\n    if (new_set == NULL)\n    {\n        return NULL;\n    }\n\n    set_iterate(set1, &iterator);\n\n    while (set_iter_has_more(&iterator))\n    {\n\n        value = set_iter_next(&iterator);\n\n        if (set_query(set2, value) != 0)\n        {\n\n            if (!set_insert(new_set, value))\n            {\n                set_free(new_set);\n\n                return NULL;\n            }\n        }\n    }\n\n    return new_set;\n}": "94", "void set_iterate(Set *set, SetIterator *iter)\n{\n    unsigned int chain;\n\n    iter->set = set;\n    iter->next_entry = NULL;\n\n    for (chain = 0; chain < set->table_size; ++chain)\n    {\n\n        if (set->table[chain] != NULL)\n        {\n            iter->next_entry = set->table[chain];\n            break;\n        }\n    }\n\n    iter->next_chain = chain;\n}": "95", "SetValue set_iter_next(SetIterator *iterator)\n{\n    Set *set;\n    SetValue result;\n    SetEntry *current_entry;\n    unsigned int chain;\n\n    set = iterator->set;\n\n    if (iterator->next_entry == NULL)\n    {\n        return SET_NULL;\n    }\n\n    current_entry = iterator->next_entry;\n    result = current_entry->data;\n\n    if (current_entry->next != NULL)\n    {\n\n        iterator->next_entry = current_entry->next;\n    }\n    else\n    {\n\n        iterator->next_entry = NULL;\n\n        chain = iterator->next_chain + 1;\n\n        while (chain < set->table_size)\n        {\n\n            if (set->table[chain] != NULL)\n            {\n\n                iterator->next_entry = set->table[chain];\n\n                break;\n            }\n\n            ++chain;\n        }\n\n        iterator->next_chain = chain;\n    }\n\n    return result;\n}": "96", "int set_iter_has_more(SetIterator *iterator)\n{\n    return iterator->next_entry != NULL;\n}": "97", "unsigned int int_hash(void *vlocation)\n{\n    int *location;\n\n    location = (int *)vlocation;\n\n    return (unsigned int)*location;\n}": "98", "Queue *queue_new(void)\n{\n    Queue *queue;\n\n    queue = (Queue *)malloc(sizeof(Queue));\n\n    if (queue == NULL)\n    {\n        return NULL;\n    }\n\n    queue->head = NULL;\n    queue->tail = NULL;\n\n    return queue;\n}": "99", "void queue_free(Queue *queue)\n{\n\n    while (!queue_is_empty(queue))\n    {\n        queue_pop_head(queue);\n    }\n\n    free(queue);\n}": "100", "int queue_push_head(Queue *queue, QueueValue data)\n{\n    QueueEntry *new_entry;\n\n    new_entry = malloc(sizeof(QueueEntry));\n\n    if (new_entry == NULL)\n    {\n        return 0;\n    }\n\n    new_entry->data = data;\n    new_entry->prev = NULL;\n    new_entry->next = queue->head;\n\n    if (queue->head == NULL)\n    {\n\n        queue->head = new_entry;\n        queue->tail = new_entry;\n    }\n    else\n    {\n\n        queue->head->prev = new_entry;\n\n        queue->head = new_entry;\n    }\n\n    return 1;\n}": "101", "QueueValue queue_pop_head(Queue *queue)\n{\n    QueueEntry *entry;\n    QueueValue result;\n\n    if (queue_is_empty(queue))\n    {\n        return QUEUE_NULL;\n    }\n\n    entry = queue->head;\n    queue->head = entry->next;\n    result = entry->data;\n\n    if (queue->head == NULL)\n    {\n\n        queue->tail = NULL;\n    }\n    else\n    {\n\n        queue->head->prev = NULL;\n    }\n\n    free(entry);\n\n    return result;\n}": "102", "QueueValue queue_peek_head(Queue *queue)\n{\n    if (queue_is_empty(queue))\n    {\n        return QUEUE_NULL;\n    }\n    else\n    {\n        return queue->head->data;\n    }\n}": "103", "int queue_push_tail(Queue *queue, QueueValue data)\n{\n    QueueEntry *new_entry;\n\n    new_entry = malloc(sizeof(QueueEntry));\n\n    if (new_entry == NULL)\n    {\n        return 0;\n    }\n\n    new_entry->data = data;\n    new_entry->prev = queue->tail;\n    new_entry->next = NULL;\n\n    if (queue->tail == NULL)\n    {\n\n        queue->head = new_entry;\n        queue->tail = new_entry;\n    }\n    else\n    {\n\n        queue->tail->next = new_entry;\n\n        queue->tail = new_entry;\n    }\n\n    return 1;\n}": "104", "QueueValue queue_pop_tail(Queue *queue)\n{\n    QueueEntry *entry;\n    QueueValue result;\n\n    if (queue_is_empty(queue))\n    {\n        return QUEUE_NULL;\n    }\n\n    entry = queue->tail;\n    queue->tail = entry->prev;\n    result = entry->data;\n\n    if (queue->tail == NULL)\n    {\n\n        queue->head = NULL;\n    }\n    else\n    {\n\n        queue->tail->next = NULL;\n    }\n\n    free(entry);\n\n    return result;\n}": "105", "QueueValue queue_peek_tail(Queue *queue)\n{\n    if (queue_is_empty(queue))\n    {\n        return QUEUE_NULL;\n    }\n    else\n    {\n        return queue->tail->data;\n    }\n}": "106", "int queue_is_empty(Queue *queue)\n{\n    return queue->head == NULL;\n}": "107", "int int_equal(void *vlocation1, void *vlocation2)\n{\n    int *location1;\n    int *location2;\n\n    location1 = (int *)vlocation1;\n    location2 = (int *)vlocation2;\n\n    return *location1 == *location2;\n}": "108", "int int_compare(void *vlocation1, void *vlocation2)\n{\n    int *location1;\n    int *location2;\n\n    location1 = (int *)vlocation1;\n    location2 = (int *)vlocation2;\n\n    if (*location1 < *location2)\n    {\n        return -1;\n    }\n    else if (*location1 > *location2)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}": "109", "static int binary_heap_cmp(BinaryHeap *heap, BinaryHeapValue data1, BinaryHeapValue data2)\n{\n    if (heap->heap_type == BINARY_HEAP_TYPE_MIN)\n    {\n        return heap->compare_func(data1, data2);\n    }\n    else\n    {\n        return -heap->compare_func(data1, data2);\n    }\n}": "110", "BinaryHeap *binary_heap_new(BinaryHeapType heap_type, BinaryHeapCompareFunc compare_func)\n{\n    BinaryHeap *heap;\n\n    heap = malloc(sizeof(BinaryHeap));\n\n    if (heap == NULL)\n    {\n        return NULL;\n    }\n\n    heap->heap_type = heap_type;\n    heap->num_values = 0;\n    heap->compare_func = compare_func;\n\n    heap->alloced_size = 16;\n    heap->values = malloc(sizeof(BinaryHeapValue) * heap->alloced_size);\n\n    if (heap->values == NULL)\n    {\n        free(heap);\n        return NULL;\n    }\n\n    return heap;\n}": "111", "void binary_heap_free(BinaryHeap *heap)\n{\n    free(heap->values);\n    free(heap);\n}": "112", "int binary_heap_insert(BinaryHeap *heap, BinaryHeapValue value)\n{\n    BinaryHeapValue *new_values;\n    unsigned int index;\n    unsigned int new_size;\n    unsigned int parent;\n\n    if (heap->num_values >= heap->alloced_size)\n    {\n\n        new_size = heap->alloced_size * 2;\n        new_values = realloc(heap->values, sizeof(BinaryHeapValue) * new_size);\n\n        if (new_values == NULL)\n        {\n            return 0;\n        }\n\n        heap->alloced_size = new_size;\n        heap->values = new_values;\n    }\n\n    index = heap->num_values;\n    ++heap->num_values;\n\n    while (index > 0)\n    {\n\n        parent = (index - 1) / 2;\n\n        if (binary_heap_cmp(heap, heap->values[parent], value) < 0)\n        {\n\n            break;\n        }\n        else\n        {\n\n            heap->values[index] = heap->values[parent];\n\n            index = parent;\n        }\n    }\n\n    heap->values[index] = value;\n\n    return 1;\n}": "113", "BinaryHeapValue binary_heap_pop(BinaryHeap *heap)\n{\n    BinaryHeapValue result;\n    BinaryHeapValue new_value;\n    unsigned int index;\n    unsigned int next_index;\n    unsigned int child1, child2;\n\n    if (heap->num_values == 0)\n    {\n        return BINARY_HEAP_NULL;\n    }\n\n    result = heap->values[0];\n\n    new_value = heap->values[heap->num_values - 1];\n    --heap->num_values;\n\n    index = 0;\n\n    for (;;)\n    {\n\n        child1 = index * 2 + 1;\n        child2 = index * 2 + 2;\n\n        if (child1 < heap->num_values && binary_heap_cmp(heap, new_value, heap->values[child1]) > 0)\n        {\n\n            if (child2 < heap->num_values && binary_heap_cmp(heap, heap->values[child1], heap->values[child2]) > 0)\n            {\n                next_index = child2;\n            }\n            else\n            {\n                next_index = child1;\n            }\n        }\n        else if (child2 < heap->num_values && binary_heap_cmp(heap, new_value, heap->values[child2]) > 0)\n        {\n\n            next_index = child2;\n        }\n        else\n        {\n\n            heap->values[index] = new_value;\n            break;\n        }\n\n        heap->values[index] = heap->values[next_index];\n\n        index = next_index;\n    }\n\n    return result;\n}": "114", "unsigned int binary_heap_num_entries(BinaryHeap *heap)\n{\n    return heap->num_values;\n}": "115", "unsigned int pointer_hash(void *location)\n{\n    return (unsigned int)(unsigned long)location;\n}": "116", "Trie *trie_new(void)\n{\n    Trie *new_trie;\n\n    new_trie = (Trie *)malloc(sizeof(Trie));\n\n    if (new_trie == NULL)\n    {\n        return NULL;\n    }\n\n    new_trie->root_node = NULL;\n\n    return new_trie;\n}": "117", "static void trie_free_list_push(TrieNode **list, TrieNode *node)\n{\n    node->data = *list;\n    *list = node;\n}": "118", "static TrieNode *trie_free_list_pop(TrieNode **list)\n{\n    TrieNode *result;\n\n    result = *list;\n    *list = result->data;\n\n    return result;\n}": "119", "void trie_free(Trie *trie)\n{\n    TrieNode *free_list;\n    TrieNode *node;\n    int i;\n\n    free_list = NULL;\n\n    if (trie->root_node != NULL)\n    {\n        trie_free_list_push(&free_list, trie->root_node);\n    }\n\n    while (free_list != NULL)\n    {\n        node = trie_free_list_pop(&free_list);\n\n        for (i = 0; i < 256; ++i)\n        {\n            if (node->next[i] != NULL)\n            {\n                trie_free_list_push(&free_list, node->next[i]);\n            }\n        }\n\n        free(node);\n    }\n\n    free(trie);\n}": "120", "static TrieNode *trie_find_end(Trie *trie, char *key)\n{\n    TrieNode *node;\n    char *p;\n\n    node = trie->root_node;\n\n    for (p = key; *p != '\\0'; ++p)\n    {\n\n        if (node == NULL)\n        {\n\n            return NULL;\n        }\n\n        node = node->next[(unsigned char)*p];\n    }\n\n    return node;\n}": "121", "static TrieNode *trie_find_end_binary(Trie *trie, unsigned char *key, int key_length)\n{\n    TrieNode *node;\n    int j;\n    int c;\n\n    node = trie->root_node;\n\n    for (j = 0; j < key_length; j++)\n    {\n\n        if (node == NULL)\n        {\n\n            return NULL;\n        }\n\n        c = (unsigned char)key[j];\n\n        node = node->next[c];\n    }\n\n    return node;\n}": "122", "static void trie_insert_rollback(Trie *trie, unsigned char *key)\n{\n    TrieNode *node;\n    TrieNode **prev_ptr;\n    TrieNode *next_node;\n    TrieNode **next_prev_ptr;\n    unsigned char *p;\n\n    node = trie->root_node;\n    prev_ptr = &trie->root_node;\n    p = key;\n\n    while (node != NULL)\n    {\n\n        next_prev_ptr = &node->next[(unsigned char)*p];\n        next_node = *next_prev_ptr;\n        ++p;\n\n        --node->use_count;\n\n        if (node->use_count == 0)\n        {\n            free(node);\n\n            if (prev_ptr != NULL)\n            {\n                *prev_ptr = NULL;\n            }\n\n            next_prev_ptr = NULL;\n        }\n\n        node = next_node;\n        prev_ptr = next_prev_ptr;\n    }\n}": "123", "int trie_insert(Trie *trie, char *key, TrieValue value)\n{\n    TrieNode **rover;\n    TrieNode *node;\n    char *p;\n    int c;\n\n    if (value == TRIE_NULL)\n    {\n        return 0;\n    }\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = value;\n        return 1;\n    }\n\n    rover = &trie->root_node;\n    p = key;\n\n    for (;;)\n    {\n\n        node = *rover;\n\n        if (node == NULL)\n        {\n\n            node = (TrieNode *)calloc(1, sizeof(TrieNode));\n\n            if (node == NULL)\n            {\n\n                trie_insert_rollback(trie, (unsigned char *)key);\n\n                return 0;\n            }\n\n            node->data = TRIE_NULL;\n\n            *rover = node;\n        }\n\n        ++node->use_count;\n\n        c = (unsigned char)*p;\n\n        if (c == '\\0')\n        {\n\n            node->data = value;\n\n            break;\n        }\n\n        rover = &node->next[c];\n        ++p;\n    }\n\n    return 1;\n}": "124", "int trie_insert_binary(Trie *trie, unsigned char *key, int key_length, TrieValue value)\n{\n    TrieNode **rover;\n    TrieNode *node;\n    int p, c;\n\n    if (value == TRIE_NULL)\n    {\n        return 0;\n    }\n\n    node = trie_find_end_binary(trie, key, key_length);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = value;\n        return 1;\n    }\n\n    rover = &trie->root_node;\n    p = 0;\n\n    for (;;)\n    {\n\n        node = *rover;\n\n        if (node == NULL)\n        {\n\n            node = (TrieNode *)calloc(1, sizeof(TrieNode));\n\n            if (node == NULL)\n            {\n\n                trie_insert_rollback(trie, key);\n\n                return 0;\n            }\n\n            node->data = TRIE_NULL;\n\n            *rover = node;\n        }\n\n        ++node->use_count;\n\n        c = (unsigned char)key[p];\n\n        if (p == key_length)\n        {\n\n            node->data = value;\n\n            break;\n        }\n\n        rover = &node->next[c];\n        ++p;\n    }\n\n    return 1;\n}": "125", "int trie_remove_binary(Trie *trie, unsigned char *key, int key_length)\n{\n    TrieNode *node;\n    TrieNode *next;\n    TrieNode **last_next_ptr;\n    int p, c;\n\n    node = trie_find_end_binary(trie, key, key_length);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = TRIE_NULL;\n    }\n    else\n    {\n        return 0;\n    }\n\n    node = trie->root_node;\n    last_next_ptr = &trie->root_node;\n    p = 0;\n\n    for (;;)\n    {\n\n        c = (unsigned char)key[p];\n        next = node->next[c];\n\n        --node->use_count;\n\n        if (node->use_count <= 0)\n        {\n            free(node);\n\n            if (last_next_ptr != NULL)\n            {\n                *last_next_ptr = NULL;\n                last_next_ptr = NULL;\n            }\n        }\n\n        if (p == key_length)\n        {\n            break;\n        }\n        else\n        {\n            ++p;\n        }\n\n        if (last_next_ptr != NULL)\n        {\n            last_next_ptr = &node->next[c];\n        }\n\n        node = next;\n    }\n\n    return 1;\n}": "126", "int trie_remove(Trie *trie, char *key)\n{\n    TrieNode *node;\n    TrieNode *next;\n    TrieNode **last_next_ptr;\n    char *p;\n    int c;\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = TRIE_NULL;\n    }\n    else\n    {\n        return 0;\n    }\n\n    node = trie->root_node;\n    last_next_ptr = &trie->root_node;\n    p = key;\n\n    for (;;)\n    {\n\n        c = (unsigned char)*p;\n        next = node->next[c];\n\n        --node->use_count;\n\n        if (node->use_count <= 0)\n        {\n            free(node);\n\n            if (last_next_ptr != NULL)\n            {\n                *last_next_ptr = NULL;\n                last_next_ptr = NULL;\n            }\n        }\n\n        if (c == '\\0')\n        {\n            break;\n        }\n        else\n        {\n            ++p;\n        }\n\n        if (last_next_ptr != NULL)\n        {\n            last_next_ptr = &node->next[c];\n        }\n\n        node = next;\n    }\n\n    return 1;\n}": "127", "TrieValue trie_lookup(Trie *trie, char *key)\n{\n    TrieNode *node;\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL)\n    {\n        return node->data;\n    }\n    else\n    {\n        return TRIE_NULL;\n    }\n}": "128", "TrieValue trie_lookup_binary(Trie *trie, unsigned char *key, int key_length)\n{\n    TrieNode *node;\n\n    node = trie_find_end_binary(trie, key, key_length);\n\n    if (node != NULL)\n    {\n        return node->data;\n    }\n    else\n    {\n        return TRIE_NULL;\n    }\n}": "129", "unsigned int trie_num_entries(Trie *trie)\n{\n\n    if (trie->root_node == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        return trie->root_node->use_count;\n    }\n}": "130", "ArrayList *arraylist_new(unsigned int length)\n{\n    ArrayList *new_arraylist;\n\n    if (length <= 0)\n    {\n        length = 16;\n    }\n\n    new_arraylist = (ArrayList *)malloc(sizeof(ArrayList));\n\n    if (new_arraylist == NULL)\n    {\n        return NULL;\n    }\n\n    new_arraylist->_alloced = length;\n    new_arraylist->length = 0;\n\n    new_arraylist->data = malloc(length * sizeof(ArrayListValue));\n\n    if (new_arraylist->data == NULL)\n    {\n        free(new_arraylist);\n        return NULL;\n    }\n\n    return new_arraylist;\n}": "131", "void arraylist_free(ArrayList *arraylist)\n{\n\n    if (arraylist != NULL)\n    {\n        free(arraylist->data);\n        free(arraylist);\n    }\n}": "132", "static int arraylist_enlarge(ArrayList *arraylist)\n{\n    ArrayListValue *data;\n    unsigned int newsize;\n\n    newsize = arraylist->_alloced * 2;\n\n    data = realloc(arraylist->data, sizeof(ArrayListValue) * newsize);\n\n    if (data == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        arraylist->data = data;\n        arraylist->_alloced = newsize;\n\n        return 1;\n    }\n}": "133", "int arraylist_insert(ArrayList *arraylist, unsigned int index, ArrayListValue data)\n{\n\n    if (index > arraylist->length)\n    {\n        return 0;\n    }\n\n    if (arraylist->length + 1 > arraylist->_alloced)\n    {\n        if (!arraylist_enlarge(arraylist))\n        {\n            return 0;\n        }\n    }\n\n    memmove(&arraylist->data[index + 1], &arraylist->data[index], (arraylist->length - index) * sizeof(ArrayListValue));\n\n    arraylist->data[index] = data;\n    ++arraylist->length;\n\n    return 1;\n}": "134", "int arraylist_append(ArrayList *arraylist, ArrayListValue data)\n{\n    return arraylist_insert(arraylist, arraylist->length, data);\n}": "135", "int arraylist_prepend(ArrayList *arraylist, ArrayListValue data)\n{\n    return arraylist_insert(arraylist, 0, data);\n}": "136", "void arraylist_remove_range(ArrayList *arraylist, unsigned int index, unsigned int length)\n{\n\n    if (index > arraylist->length || index + length > arraylist->length)\n    {\n        return;\n    }\n\n    memmove(&arraylist->data[index], &arraylist->data[index + length],\n            (arraylist->length - (index + length)) * sizeof(ArrayListValue));\n\n    arraylist->length -= length;\n}": "137", "void arraylist_remove(ArrayList *arraylist, unsigned int index)\n{\n    arraylist_remove_range(arraylist, index, 1);\n}": "138", "int arraylist_index_of(ArrayList *arraylist, ArrayListEqualFunc callback, ArrayListValue data)\n{\n    unsigned int i;\n\n    for (i = 0; i < arraylist->length; ++i)\n    {\n        if (callback(arraylist->data[i], data) != 0)\n            return (int)i;\n    }\n\n    return -1;\n}": "139", "void arraylist_clear(ArrayList *arraylist)\n{\n\n    arraylist->length = 0;\n}": "140", "static void arraylist_sort_internal(ArrayListValue *list_data, unsigned int list_length,\n                                    ArrayListCompareFunc compare_func)\n{\n    ArrayListValue pivot;\n    ArrayListValue tmp;\n    unsigned int i;\n    unsigned int list1_length;\n    unsigned int list2_length;\n\n    if (list_length <= 1)\n    {\n        return;\n    }\n\n    pivot = list_data[list_length - 1];\n# 221 \".tmp/tmp_files/src/arraylist.c\"\n    list1_length = 0;\n\n    for (i = 0; i < list_length - 1; ++i)\n    {\n\n        if (compare_func(list_data[i], pivot) < 0)\n        {\n\n            tmp = list_data[i];\n            list_data[i] = list_data[list1_length];\n            list_data[list1_length] = tmp;\n\n            ++list1_length;\n        }\n        else\n        {\n        }\n    }\n\n    list2_length = list_length - list1_length - 1;\n# 255 \".tmp/tmp_files/src/arraylist.c\"\n    list_data[list_length - 1] = list_data[list1_length];\n    list_data[list1_length] = pivot;\n\n    arraylist_sort_internal(list_data, list1_length, compare_func);\n\n    arraylist_sort_internal(&list_data[list1_length + 1], list2_length, compare_func);\n}": "141", "void arraylist_sort(ArrayList *arraylist, ArrayListCompareFunc compare_func)\n{\n\n    arraylist_sort_internal(arraylist->data, arraylist->length, compare_func);\n}": "142", "static int binomial_heap_cmp(BinomialHeap *heap, BinomialHeapValue data1, BinomialHeapValue data2)\n{\n    if (heap->heap_type == BINOMIAL_HEAP_TYPE_MIN)\n    {\n        return heap->compare_func(data1, data2);\n    }\n    else\n    {\n        return -(heap->compare_func(data1, data2));\n    }\n}": "143", "static void binomial_tree_ref(BinomialTree *tree)\n{\n    if (tree != NULL)\n    {\n        ++tree->refcount;\n    }\n}": "144", "static void binomial_tree_unref(BinomialTree *tree)\n{\n    int i;\n\n    if (tree == NULL)\n    {\n        return;\n    }\n\n    --tree->refcount;\n\n    if (tree->refcount == 0)\n    {\n\n        for (i = 0; i < tree->order; ++i)\n        {\n            binomial_tree_unref(tree->subtrees[i]);\n        }\n\n        free(tree->subtrees);\n        free(tree);\n    }\n}": "145", "static BinomialTree *binomial_tree_merge(BinomialHeap *heap, BinomialTree *tree1, BinomialTree *tree2)\n{\n    BinomialTree *new_tree;\n    BinomialTree *tmp;\n    int i;\n\n    if (binomial_heap_cmp(heap, tree1->value, tree2->value) > 0)\n    {\n\n        tmp = tree1;\n        tree1 = tree2;\n        tree2 = tmp;\n    }\n\n    new_tree = malloc(sizeof(BinomialTree));\n\n    if (new_tree == NULL)\n    {\n        return NULL;\n    }\n\n    new_tree->refcount = 0;\n    new_tree->order = (unsigned short)(tree1->order + 1);\n\n    new_tree->value = tree1->value;\n\n    new_tree->subtrees = malloc(sizeof(BinomialTree *) * new_tree->order);\n\n    if (new_tree->subtrees == NULL)\n    {\n        free(new_tree);\n        return NULL;\n    }\n\n    memcpy(new_tree->subtrees, tree1->subtrees, sizeof(BinomialTree *) * tree1->order);\n    new_tree->subtrees[new_tree->order - 1] = tree2;\n\n    for (i = 0; i < new_tree->order; ++i)\n    {\n        binomial_tree_ref(new_tree->subtrees[i]);\n    }\n\n    return new_tree;\n}": "146", "static void binomial_heap_merge_undo(BinomialTree **new_roots, unsigned int count)\n{\n    unsigned int i;\n\n    for (i = 0; i <= count; ++i)\n    {\n        binomial_tree_unref(new_roots[i]);\n    }\n\n    free(new_roots);\n}": "147", "static int binomial_heap_merge(BinomialHeap *heap, BinomialHeap *other)\n{\n    BinomialTree **new_roots;\n    unsigned int new_roots_length;\n    BinomialTree *vals[3];\n    int num_vals;\n    BinomialTree *carry;\n    BinomialTree *new_carry;\n    unsigned int max;\n    unsigned int i;\n\n    if (heap->roots_length > other->roots_length)\n    {\n        max = heap->roots_length + 1;\n    }\n    else\n    {\n        max = other->roots_length + 1;\n    }\n\n    new_roots = malloc(sizeof(BinomialTree *) * max);\n\n    if (new_roots == NULL)\n    {\n        return 0;\n    }\n\n    new_roots_length = 0;\n    carry = NULL;\n\n    for (i = 0; i < max; ++i)\n    {\n\n        num_vals = 0;\n\n        if (i < heap->roots_length && heap->roots[i] != NULL)\n        {\n            vals[num_vals] = heap->roots[i];\n            ++num_vals;\n        }\n\n        if (i < other->roots_length && other->roots[i] != NULL)\n        {\n            vals[num_vals] = other->roots[i];\n            ++num_vals;\n        }\n\n        if (carry != NULL)\n        {\n            vals[num_vals] = carry;\n            ++num_vals;\n        }\n\n        if ((num_vals & 1) != 0)\n        {\n\n            new_roots[i] = vals[num_vals - 1];\n            binomial_tree_ref(new_roots[i]);\n            new_roots_length = i + 1;\n        }\n        else\n        {\n\n            new_roots[i] = NULL;\n        }\n\n        if ((num_vals & 2) != 0)\n        {\n\n            new_carry = binomial_tree_merge(heap, vals[0], vals[1]);\n\n            if (new_carry == NULL)\n            {\n\n                binomial_heap_merge_undo(new_roots, i);\n\n                binomial_tree_unref(carry);\n\n                return 0;\n            }\n        }\n        else\n        {\n\n            new_carry = NULL;\n        }\n\n        binomial_tree_unref(carry);\n\n        carry = new_carry;\n\n        binomial_tree_ref(carry);\n    }\n\n    for (i = 0; i < heap->roots_length; ++i)\n    {\n        if (heap->roots[i] != NULL)\n        {\n            binomial_tree_unref(heap->roots[i]);\n        }\n    }\n\n    free(heap->roots);\n    heap->roots = new_roots;\n    heap->roots_length = new_roots_length;\n\n    return 1;\n}": "148", "BinomialHeap *binomial_heap_new(BinomialHeapType heap_type, BinomialHeapCompareFunc compare_func)\n{\n    BinomialHeap *new_heap;\n\n    new_heap = calloc(1, sizeof(BinomialHeap));\n\n    if (new_heap == NULL)\n    {\n        return NULL;\n    }\n\n    new_heap->heap_type = heap_type;\n    new_heap->compare_func = compare_func;\n\n    return new_heap;\n}": "149", "void binomial_heap_free(BinomialHeap *heap)\n{\n    unsigned int i;\n\n    for (i = 0; i < heap->roots_length; ++i)\n    {\n        binomial_tree_unref(heap->roots[i]);\n    }\n\n    free(heap->roots);\n    free(heap);\n}": "150", "int binomial_heap_insert(BinomialHeap *heap, BinomialHeapValue value)\n{\n    BinomialHeap fake_heap;\n    BinomialTree *new_tree;\n    int result;\n\n    new_tree = malloc(sizeof(BinomialTree));\n\n    if (new_tree == NULL)\n    {\n        return 0;\n    }\n\n    new_tree->value = value;\n    new_tree->order = 0;\n    new_tree->refcount = 1;\n    new_tree->subtrees = NULL;\n\n    fake_heap.heap_type = heap->heap_type;\n    fake_heap.compare_func = heap->compare_func;\n    fake_heap.num_values = 1;\n    fake_heap.roots = &new_tree;\n    fake_heap.roots_length = 1;\n\n    result = binomial_heap_merge(heap, &fake_heap);\n\n    if (result != 0)\n    {\n        ++heap->num_values;\n    }\n\n    binomial_tree_unref(new_tree);\n\n    return result;\n}": "151", "BinomialHeapValue binomial_heap_pop(BinomialHeap *heap)\n{\n    BinomialTree *least_tree;\n    BinomialHeap fake_heap;\n    BinomialHeapValue result;\n    unsigned int i;\n    unsigned int least_index;\n\n    if (heap->num_values == 0)\n    {\n        return BINOMIAL_HEAP_NULL;\n    }\n\n    least_index = UINT_MAX;\n\n    for (i = 0; i < heap->roots_length; ++i)\n    {\n\n        if (heap->roots[i] == NULL)\n        {\n            continue;\n        }\n\n        if (least_index == UINT_MAX ||\n            binomial_heap_cmp(heap, heap->roots[i]->value, heap->roots[least_index]->value) < 0)\n        {\n            least_index = i;\n        }\n    }\n\n    least_tree = heap->roots[least_index];\n    heap->roots[least_index] = NULL;\n\n    fake_heap.heap_type = heap->heap_type;\n    fake_heap.compare_func = heap->compare_func;\n    fake_heap.roots = least_tree->subtrees;\n    fake_heap.roots_length = least_tree->order;\n\n    if (binomial_heap_merge(heap, &fake_heap))\n    {\n\n        result = least_tree->value;\n        binomial_tree_unref(least_tree);\n\n        --heap->num_values;\n\n        return result;\n    }\n    else\n    {\n\n        heap->roots[least_index] = least_tree;\n\n        return BINOMIAL_HEAP_NULL;\n    }\n}": "152", "unsigned int binomial_heap_num_entries(BinomialHeap *heap)\n{\n    return heap->num_values;\n}": "153", "void slist_free(SListEntry *list)\n{\n    SListEntry *entry;\n\n    entry = list;\n\n    while (entry != NULL)\n    {\n        SListEntry *next;\n\n        next = entry->next;\n\n        free(entry);\n\n        entry = next;\n    }\n}": "154", "SListEntry *slist_prepend(SListEntry **list, SListValue data)\n{\n    SListEntry *newentry;\n\n    newentry = malloc(sizeof(SListEntry));\n\n    if (newentry == NULL)\n    {\n        return NULL;\n    }\n\n    newentry->data = data;\n\n    newentry->next = *list;\n    *list = newentry;\n\n    return newentry;\n}": "155", "SListEntry *slist_append(SListEntry **list, SListValue data)\n{\n    SListEntry *rover;\n    SListEntry *newentry;\n\n    newentry = malloc(sizeof(SListEntry));\n\n    if (newentry == NULL)\n    {\n        return NULL;\n    }\n\n    newentry->data = data;\n    newentry->next = NULL;\n\n    if (*list == NULL)\n    {\n\n        *list = newentry;\n    }\n    else\n    {\n\n        for (rover = *list; rover->next != NULL; rover = rover->next)\n            ;\n\n        rover->next = newentry;\n    }\n\n    return newentry;\n}": "156", "SListValue slist_data(SListEntry *listentry)\n{\n    return listentry->data;\n}": "157", "void slist_set_data(SListEntry *listentry, SListValue data)\n{\n    if (listentry != NULL)\n    {\n        listentry->data = data;\n    }\n}": "158", "SListEntry *slist_next(SListEntry *listentry)\n{\n    return listentry->next;\n}": "159", "SListEntry *slist_nth_entry(SListEntry *list, unsigned int n)\n{\n    SListEntry *entry;\n    unsigned int i;\n\n    entry = list;\n\n    for (i = 0; i < n; ++i)\n    {\n\n        if (entry == NULL)\n        {\n            return NULL;\n        }\n        entry = entry->next;\n    }\n\n    return entry;\n}": "160", "SListValue slist_nth_data(SListEntry *list, unsigned int n)\n{\n    SListEntry *entry;\n\n    entry = slist_nth_entry(list, n);\n\n    if (entry == NULL)\n    {\n        return SLIST_NULL;\n    }\n    else\n    {\n        return entry->data;\n    }\n}": "161", "unsigned int slist_length(SListEntry *list)\n{\n    SListEntry *entry;\n    unsigned int length;\n\n    length = 0;\n    entry = list;\n\n    while (entry != NULL)\n    {\n\n        ++length;\n\n        entry = entry->next;\n    }\n\n    return length;\n}": "162", "SListValue *slist_to_array(SListEntry *list)\n{\n    SListEntry *rover;\n    SListValue *array;\n    unsigned int length;\n    unsigned int i;\n\n    length = slist_length(list);\n\n    array = malloc(sizeof(SListValue) * length);\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    rover = list;\n\n    for (i = 0; i < length; ++i)\n    {\n\n        array[i] = rover->data;\n\n        rover = rover->next;\n    }\n\n    return array;\n}": "163", "int slist_remove_entry(SListEntry **list, SListEntry *entry)\n{\n    SListEntry *rover;\n\n    if (*list == NULL || entry == NULL)\n    {\n        return 0;\n    }\n\n    if (*list == entry)\n    {\n\n        *list = entry->next;\n    }\n    else\n    {\n\n        rover = *list;\n\n        while (rover != NULL && rover->next != entry)\n        {\n            rover = rover->next;\n        }\n\n        if (rover == NULL)\n        {\n\n            return 0;\n        }\n        else\n        {\n\n            rover->next = entry->next;\n        }\n    }\n\n    free(entry);\n\n    return 1;\n}": "164", "unsigned int slist_remove_data(SListEntry **list, SListEqualFunc callback, SListValue data)\n{\n    SListEntry **rover;\n    SListEntry *next;\n    unsigned int entries_removed;\n\n    entries_removed = 0;\n\n    rover = list;\n\n    while (*rover != NULL)\n    {\n\n        if (callback((*rover)->data, data) != 0)\n        {\n\n            next = (*rover)->next;\n            free(*rover);\n            *rover = next;\n\n            ++entries_removed;\n        }\n        else\n        {\n\n            rover = &((*rover)->next);\n        }\n    }\n\n    return entries_removed;\n}": "165", "static SListEntry *slist_sort_internal(SListEntry **list, SListCompareFunc compare_func)\n{\n    SListEntry *pivot;\n    SListEntry *rover;\n    SListEntry *less_list, *more_list;\n    SListEntry *less_list_end, *more_list_end;\n\n    if (*list == NULL || (*list)->next == NULL)\n    {\n        return *list;\n    }\n\n    pivot = *list;\n\n    less_list = NULL;\n    more_list = NULL;\n    rover = (*list)->next;\n\n    while (rover != NULL)\n    {\n        SListEntry *next = rover->next;\n\n        if (compare_func(rover->data, pivot->data) < 0)\n        {\n\n            rover->next = less_list;\n            less_list = rover;\n        }\n        else\n        {\n\n            rover->next = more_list;\n            more_list = rover;\n        }\n\n        rover = next;\n    }\n\n    less_list_end = slist_sort_internal(&less_list, compare_func);\n    more_list_end = slist_sort_internal(&more_list, compare_func);\n\n    *list = less_list;\n\n    if (less_list == NULL)\n    {\n        *list = pivot;\n    }\n    else\n    {\n        less_list_end->next = pivot;\n    }\n\n    pivot->next = more_list;\n\n    if (more_list == NULL)\n    {\n        return pivot;\n    }\n    else\n    {\n        return more_list_end;\n    }\n}": "166", "void slist_sort(SListEntry **list, SListCompareFunc compare_func)\n{\n    slist_sort_internal(list, compare_func);\n}": "167", "SListEntry *slist_find_data(SListEntry *list, SListEqualFunc callback, SListValue data)\n{\n    SListEntry *rover;\n\n    for (rover = list; rover != NULL; rover = rover->next)\n    {\n        if (callback(rover->data, data) != 0)\n        {\n            return rover;\n        }\n    }\n\n    return NULL;\n}": "168", "void slist_iterate(SListEntry **list, SListIterator *iter)\n{\n\n    iter->prev_next = list;\n\n    iter->current = NULL;\n}": "169", "int slist_iter_has_more(SListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n\n        return *iter->prev_next != NULL;\n    }\n    else\n    {\n\n        return iter->current->next != NULL;\n    }\n}": "170", "SListValue slist_iter_next(SListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n\n        iter->current = *iter->prev_next;\n    }\n    else\n    {\n\n        iter->prev_next = &iter->current->next;\n        iter->current = iter->current->next;\n    }\n\n    if (iter->current == NULL)\n    {\n        return SLIST_NULL;\n    }\n    else\n    {\n        return iter->current->data;\n    }\n}": "171", "void slist_iter_remove(SListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n    }\n    else\n    {\n\n        *iter->prev_next = iter->current->next;\n        free(iter->current);\n        iter->current = NULL;\n    }\n}": "172", "unsigned int string_hash(void *string)\n{\n\n    unsigned int result = 5381;\n    unsigned char *p;\n\n    p = (unsigned char *)string;\n\n    while (*p != '\\0')\n    {\n        result = (result << 5) + result + *p;\n        ++p;\n    }\n\n    return result;\n}": "173", "unsigned int string_nocase_hash(void *string)\n{\n    unsigned int result = 5381;\n    unsigned char *p;\n\n    p = (unsigned char *)string;\n\n    while (*p != '\\0')\n    {\n        result = (result << 5) + result + (unsigned int)tolower(*p);\n        ++p;\n    }\n\n    return result;\n}": "174", "static RBTreeNodeSide rb_tree_node_side(RBTreeNode *node)\n{\n    if (node->parent->children[RB_TREE_NODE_LEFT] == node)\n    {\n        return RB_TREE_NODE_LEFT;\n    }\n    else\n    {\n        return RB_TREE_NODE_RIGHT;\n    }\n}": "175", "static RBTreeNode *rb_tree_node_sibling(RBTreeNode *node)\n{\n    RBTreeNodeSide side;\n\n    side = rb_tree_node_side(node);\n\n    return node->parent->children[1 - side];\n}": "176", "RBTreeNode *rb_tree_node_uncle(RBTreeNode *node)\n{\n    return rb_tree_node_sibling(node->parent);\n}": "177", "static void rb_tree_node_replace(RBTree *tree, RBTreeNode *node1, RBTreeNode *node2)\n{\n    int side;\n\n    if (node2 != NULL)\n    {\n        node2->parent = node1->parent;\n    }\n\n    if (node1->parent == NULL)\n    {\n        tree->root_node = node2;\n    }\n    else\n    {\n        side = rb_tree_node_side(node1);\n        node1->parent->children[side] = node2;\n    }\n}": "178", "static RBTreeNode *rb_tree_rotate(RBTree *tree, RBTreeNode *node, RBTreeNodeSide direction)\n{\n    RBTreeNode *new_root;\n\n    new_root = node->children[1 - direction];\n\n    rb_tree_node_replace(tree, node, new_root);\n\n    node->children[1 - direction] = new_root->children[direction];\n    new_root->children[direction] = node;\n\n    node->parent = new_root;\n\n    if (node->children[1 - direction] != NULL)\n    {\n        node->children[1 - direction]->parent = node;\n    }\n\n    return new_root;\n}": "179", "RBTree *rb_tree_new(RBTreeCompareFunc compare_func)\n{\n    RBTree *new_tree;\n\n    new_tree = malloc(sizeof(RBTree));\n\n    if (new_tree == NULL)\n    {\n        return NULL;\n    }\n\n    new_tree->root_node = NULL;\n    new_tree->num_nodes = 0;\n    new_tree->compare_func = compare_func;\n\n    return new_tree;\n}": "180", "static void rb_tree_free_subtree(RBTreeNode *node)\n{\n    if (node != NULL)\n    {\n\n        rb_tree_free_subtree(node->children[RB_TREE_NODE_LEFT]);\n        rb_tree_free_subtree(node->children[RB_TREE_NODE_RIGHT]);\n\n        free(node);\n    }\n}": "181", "void rb_tree_free(RBTree *tree)\n{\n\n    rb_tree_free_subtree(tree->root_node);\n\n    free(tree);\n}": "182", "static void rb_tree_insert_case1(RBTree *tree, RBTreeNode *node)\n{\n    if (node->parent == NULL)\n    {\n\n        node->color = RB_TREE_NODE_BLACK;\n    }\n    else\n    {\n\n        rb_tree_insert_case2(tree, node);\n    }\n}": "183", "static void rb_tree_insert_case2(RBTree *tree, RBTreeNode *node)\n{\n\n    if (node->parent->color != RB_TREE_NODE_BLACK)\n    {\n        rb_tree_insert_case3(tree, node);\n    }\n}": "184", "static void rb_tree_insert_case3(RBTree *tree, RBTreeNode *node)\n{\n    RBTreeNode *grandparent;\n    RBTreeNode *uncle;\n\n    grandparent = node->parent->parent;\n    uncle = rb_tree_node_uncle(node);\n\n    if (uncle != NULL && uncle->color == RB_TREE_NODE_RED)\n    {\n\n        node->parent->color = RB_TREE_NODE_BLACK;\n        uncle->color = RB_TREE_NODE_BLACK;\n        grandparent->color = RB_TREE_NODE_RED;\n\n        rb_tree_insert_case1(tree, grandparent);\n    }\n    else\n    {\n        rb_tree_insert_case4(tree, node);\n    }\n}": "185", "void rb_tree_insert_case4(RBTree *tree, RBTreeNode *node)\n{\n    RBTreeNode *next_node;\n    RBTreeNodeSide side;\n\n    side = rb_tree_node_side(node);\n\n    if (side != rb_tree_node_side(node->parent))\n    {\n\n        next_node = node->parent;\n\n        rb_tree_rotate(tree, node->parent, 1 - side);\n    }\n    else\n    {\n        next_node = node;\n    }\n\n    rb_tree_insert_case5(tree, next_node);\n}": "186", "void rb_tree_insert_case5(RBTree *tree, RBTreeNode *node)\n{\n    RBTreeNode *parent;\n    RBTreeNode *grandparent;\n    RBTreeNodeSide side;\n\n    parent = node->parent;\n    grandparent = parent->parent;\n\n    side = rb_tree_node_side(node);\n\n    rb_tree_rotate(tree, grandparent, 1 - side);\n\n    parent->color = RB_TREE_NODE_BLACK;\n    grandparent->color = RB_TREE_NODE_RED;\n}": "187", "RBTreeNode *rb_tree_insert(RBTree *tree, RBTreeKey key, RBTreeValue value)\n{\n    RBTreeNode *node;\n    RBTreeNode **rover;\n    RBTreeNode *parent;\n    RBTreeNodeSide side;\n\n    node = malloc(sizeof(RBTreeNode));\n\n    if (node == NULL)\n    {\n        return NULL;\n    }\n\n    node->key = key;\n    node->value = value;\n    node->color = RB_TREE_NODE_RED;\n    node->children[RB_TREE_NODE_LEFT] = NULL;\n    node->children[RB_TREE_NODE_RIGHT] = NULL;\n\n    parent = NULL;\n    rover = &tree->root_node;\n\n    while (*rover != NULL)\n    {\n\n        parent = *rover;\n\n        if (tree->compare_func(value, (*rover)->value) < 0)\n        {\n            side = RB_TREE_NODE_LEFT;\n        }\n        else\n        {\n            side = RB_TREE_NODE_RIGHT;\n        }\n\n        rover = &(*rover)->children[side];\n    }\n\n    *rover = node;\n    node->parent = parent;\n\n    rb_tree_insert_case1(tree, node);\n\n    ++tree->num_nodes;\n\n    return node;\n}": "188", "RBTreeNode *rb_tree_lookup_node(RBTree *tree, RBTreeKey key)\n{\n    RBTreeNode *node;\n    RBTreeNodeSide side;\n    int diff;\n\n    node = tree->root_node;\n\n    while (node != NULL)\n    {\n        diff = tree->compare_func(key, node->key);\n\n        if (diff == 0)\n        {\n            return node;\n        }\n        else if (diff < 0)\n        {\n            side = RB_TREE_NODE_LEFT;\n        }\n        else\n        {\n            side = RB_TREE_NODE_RIGHT;\n        }\n\n        node = node->children[side];\n    }\n\n    return NULL;\n}": "189", "RBTreeValue rb_tree_lookup(RBTree *tree, RBTreeKey key)\n{\n    RBTreeNode *node;\n\n    node = rb_tree_lookup_node(tree, key);\n\n    if (node == NULL)\n    {\n        return RB_TREE_NULL;\n    }\n    else\n    {\n        return node->value;\n    }\n}": "190", "void rb_tree_remove_node(RBTree *tree, RBTreeNode *node)\n{\n}": "191", "int rb_tree_remove(RBTree *tree, RBTreeKey key)\n{\n    RBTreeNode *node;\n\n    node = rb_tree_lookup_node(tree, key);\n\n    if (node == NULL)\n    {\n        return 0;\n    }\n\n    rb_tree_remove_node(tree, node);\n\n    return 1;\n}": "192", "RBTreeNode *rb_tree_root_node(RBTree *tree)\n{\n    return tree->root_node;\n}": "193", "RBTreeKey rb_tree_node_key(RBTreeNode *node)\n{\n    return node->key;\n}": "194", "RBTreeValue rb_tree_node_value(RBTreeNode *node)\n{\n    return node->value;\n}": "195", "RBTreeNode *rb_tree_node_child(RBTreeNode *node, RBTreeNodeSide side)\n{\n    if (side == RB_TREE_NODE_LEFT || side == RB_TREE_NODE_RIGHT)\n    {\n        return node->children[side];\n    }\n    else\n    {\n        return NULL;\n    }\n}": "196", "RBTreeNode *rb_tree_node_parent(RBTreeNode *node)\n{\n    return node->parent;\n}": "197", "RBTreeValue *rb_tree_to_array(RBTree *tree)\n{\n\n    return NULL;\n}": "198", "int rb_tree_num_entries(RBTree *tree)\n{\n    return tree->num_nodes;\n}": "199"}