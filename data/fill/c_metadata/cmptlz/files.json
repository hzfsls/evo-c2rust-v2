{
    "src/cmptlz.c": {
        "includes": [],
        "macros": [
            "#define CMPTLZ_MODULE (0x0A00 + 0x0D)",
            "#define CMPT_OK 0",
            "#define CMPT_ERROR_DATA CMPTLZ_ERROR_CONVERT(CMPTLZ_ERROR_DATA)",
            "#define CMPT_ERROR_MEM CMPTLZ_ERROR_CONVERT(CMPTLZ_ERROR_MEM)",
            "#define CMPT_ERROR_UNSUPPORTED CMPTLZ_ERROR_CONVERT(CMPTLZ_ERROR_UNSUPPORTED)",
            "#define CMPT_ENC_ERROR_FILESIZE CMPTLZ_ERROR_CONVERT(CMPTLZ_ENC_ERROR_FILESIZE)",
            "#define CMPT_ENC_CTX_INIT_FAIL CMPTLZ_ERROR_CONVERT(CMPTLZ_ENC_CTX_INIT_FAIL)",
            "#define CMPT_ENC_RC_INIT_FAIL CMPTLZ_ERROR_CONVERT(CMPTLZ_ENC_RC_INIT_FAIL)",
            "#define CMPT_ENC_MF_INIT_FAIL CMPTLZ_ERROR_CONVERT(CMPTLZ_ENC_MF_INIT_FAIL)",
            "#define CMPT_ENC_ERROR_WRITE CMPTLZ_ERROR_CONVERT(CMPTLZ_ENC_ERROR_WRITE)",
            "#define CMPT_ENC_ERROR_HEAD CMPTLZ_ERROR_CONVERT(CMPTLZ_ENC_ERROR_HEAD)",
            "#define CMPT_ENC_ERROR_PARAM CMPTLZ_ERROR_CONVERT(CMPTLZ_ENC_ERROR_PARAM)",
            "#define CMPTLZ_PROPS_SIZE 5",
            "#define CMPTLZ_REQUIRED_INPUT_MAX 20",
            "#define CMPTLZ_PROB_HANDLE CMPTLZ_HANDLE_CONVERT(CMPTLZ_PROB_MEM)",
            "#define CMPTLZ_ENC_CCTX_HANDLE CMPTLZ_HANDLE_CONVERT(CMPTLZ_ENC_CCTX)",
            "#define CMPTLZ_MF_CCTX_HANDLE CMPTLZ_HANDLE_CONVERT(CMPTLZ_MF_CCTX)",
            "#define CMPTLZ_MF_HASH_HANDLE CMPTLZ_HANDLE_CONVERT(CMPTLZ_MF_HASH)",
            "#define CMPTLZ_MF_SON_HANDLE CMPTLZ_HANDLE_CONVERT(CMPTLZ_MF_SON)",
            "#define CMPTLZ_RC_CCTX_HANDLE CMPTLZ_HANDLE_CONVERT(CMPTLZ_RC_CCTX)",
            "#define CMPTLZ_RC_BUF_HANDLE CMPTLZ_HANDLE_CONVERT(CMPTLZ_RC_BUF)",
            "#define LOG_BUF_SIZE 1024U",
            "#define CMPTLZ_LIT_CTX_MAX 9",
            "#define CMPTLZ_POS_STATE_MAX 5",
            "#define CMPTLZ_LIT_POS_MAX 5",
            "#define CMPTLZ_DEC_INPUT_EOF 1",
            "#define CMPTLZ_DICT_MIN_LEN (1 << 12)",
            "#define CMPTLZ_RANGE_CODE_SIZE 5",
            "#define CMPTLZ_MKSTATE_NUM 12",
            "#define CMPTLZ_LIT_STATES 7",
            "#define CMPTLZ_RANGE_DOWN_LIMIT ((uint32_t)1 << 24)",
            "#define CMPTLZ_ONE_BYTE_WIDTH 8",
            "#define CMPTLZ_PROB_LG_BIT 11",
            "#define CMPTLZ_PROB_LG (1 << CMPTLZ_PROB_LG_BIT)",
            "#define CMPTLZ_PB_STATE_NUM_ALIGN 16",
            "#define CMPTLZ_PB_BITS_MAX 4",
            "#define CMPTLZ_MATCH_MAX_LEN 274",
            "#define CMPTLZ_LOW_LEN_BIT 3",
            "#define CMPTLZ_LOW_LEN_CLASS (1 << CMPTLZ_LOW_LEN_BIT)",
            "#define CMPTLZ_HIGH_LEN_BIT 8",
            "#define CMPTLZ_HIGH_LEN_CLASS (1 << CMPTLZ_HIGH_LEN_BIT)",
            "#define CMPTLZ_LOW_LENPROB_OFFSET 0",
            "#define CMPTLZ_HIGH_LENPROB_OFFSET (CMPTLZ_LOW_LENPROB_OFFSET + ((1 << CMPTLZ_PB_BITS_MAX) << (CMPTLZ_LOW_LEN_BIT + 1)))",
            "#define CMPTLZ_LEN_CHOICE CMPTLZ_LOW_LENPROB_OFFSET",
            "#define CMPTLZ_LEN_CHOICE2 (CMPTLZ_LEN_CHOICE + CMPTLZ_LOW_LEN_CLASS)",
            "#define CMPTLZ_LENPROB_NUM (CMPTLZ_HIGH_LENPROB_OFFSET + CMPTLZ_HIGH_LEN_CLASS)",
            "#define CMPTLZ_LEN_CONDITION_TO_POSSLOT 4",
            "#define CMPTLZ_POS_SLOT_BITS 6",
            "#define CMPTLZ_LOW_POSSLOT 4",
            "#define CMPTLZ_HIGH_POSSLOT 14",
            "#define CMPTLZ_FULL_DISTANCE (1 << (CMPTLZ_HIGH_POSSLOT >> 1))",
            "#define CMPTLZ_LARGE_DIST_LOW_BITS 4",
            "#define CMPTLZ_ALIGN_TABLE_SIZE (1 << CMPTLZ_LARGE_DIST_LOW_BITS)",
            "#define CMPTLZ_OFFSET 1664",
            "#define CMPTLZ_SPEC_POS (-CMPTLZ_OFFSET)",
            "#define CMPTLZ_REP0_LONG (CMPTLZ_SPEC_POS + CMPTLZ_FULL_DISTANCE)",
            "#define CMPTLZ_REP_LEN_CODER (CMPTLZ_REP0_LONG + (CMPTLZ_PB_STATE_NUM_ALIGN << CMPTLZ_PB_BITS_MAX))",
            "#define CMPTLZ_MATCH_LEN_CODER (CMPTLZ_REP_LEN_CODER + CMPTLZ_LENPROB_NUM)",
            "#define CMPTLZ_IS_MATCH (CMPTLZ_MATCH_LEN_CODER + CMPTLZ_LENPROB_NUM)",
            "#define CMPTLZ_ALIGN (CMPTLZ_IS_MATCH + (CMPTLZ_PB_STATE_NUM_ALIGN << CMPTLZ_PB_BITS_MAX))",
            "#define CMPTLZ_ISREP (CMPTLZ_ALIGN + CMPTLZ_ALIGN_TABLE_SIZE)",
            "#define CMPTLZ_ISREPG0 (CMPTLZ_ISREP + CMPTLZ_MKSTATE_NUM)",
            "#define CMPTLZ_ISREPG1 (CMPTLZ_ISREPG0 + CMPTLZ_MKSTATE_NUM)",
            "#define CMPTLZ_ISREPG2 (CMPTLZ_ISREPG1 + CMPTLZ_MKSTATE_NUM)",
            "#define CMPTLZ_POSSLOT (CMPTLZ_ISREPG2 + CMPTLZ_MKSTATE_NUM)",
            "#define CMPTLZ_LITERAL (CMPTLZ_POSSLOT + (CMPTLZ_LEN_CONDITION_TO_POSSLOT << CMPTLZ_POS_SLOT_BITS))",
            "#define NUM_BASE_PROBS (CMPTLZ_LITERAL + CMPTLZ_OFFSET)",
            "#define CMPTLZ_REP4 4",
            "#define CMPTLZ_REP3 3",
            "#define CMPTLZ_REP2 2",
            "#define CMPTLZ_MIN_DICTSIZE (1024)",
            "#define CMPTLZ_MAX_DICTSIZE (128 * 1024 * 1024)",
            "#define CMPTLZ_UINT32_MAX (uint32_t)(-1)",
            "#define CMPT_EMPTY_HASH_VALUE 0",
            "#define CMPTLZ_HASH_2_SIZE (1 << 10)",
            "#define CMPTLZ_HASH_3_SIZE (1 << 16)",
            "#define CMPTLZ_HASH_2_MASK (CMPTLZ_HASH_2_SIZE - 1)",
            "#define CMPTLZ_HASH_3_MASK (CMPTLZ_HASH_3_SIZE - 1)",
            "#define CMPTLZ_FIX_3_HASH (CMPTLZ_HASH_2_SIZE)",
            "#define CMPTLZ_FIX_4_HASH (CMPTLZ_HASH_2_SIZE + CMPTLZ_HASH_3_SIZE)",
            "#define CMPT_RC_MIN_RANGE (1 << 24)",
            "#define CMPT_NUM_LEN_POS_STATE 4",
            "#define CMPTLZ_NUM_REPS 4",
            "#define CMPTLZ_NUM_STATES 12",
            "#define CMPTLZ_MATCH_LEN_MIN 2",
            "#define CMPTLZ_PB_MAX 4",
            "#define CMPTLZ_LC_MAX 8",
            "#define CMPTLZ_LP_MAX 4",
            "#define CMPTLZ_LCLP_MAX 4",
            "#define CMPTLZ_NUM_PB_STATES_MAX (1 << CMPTLZ_PB_MAX)",
            "#define CMPTLZ_LIT_MAX_SIZE 0x300",
            "#define CMPTLZ_PROB_MAX_NUM 2048",
            "#define CMPTLZ_PROB_INIT 1024",
            "#define CMPTLZ_RC_BUFFER_SIZE (1 << 16)",
            "#define CMPT_DIST_LIMIT_2 128",
            "#define CMPTLZ_DIST_STATE_TOTAL 4",
            "#define CMPTLZ_ALIGN_BITS 4",
            "#define CMPTLZ_DIST_SLOT_BITS 6",
            "#define CMPT_INFINITY_PRICE ((uint32_t)1 << 30)",
            "#define CMPT_PRICE_BITS_MOVING_NUM 4",
            "#define CMPT_PRIICE_TABLE_SIZE (CMPTLZ_PROB_MAX_NUM >> CMPT_PRICE_BITS_MOVING_NUM)",
            "#define CMPT_PRICE_COUNT 64",
            "#define CMPT_DOUBLE 2",
            "#define CMPT_LEN_LOW_BITS 3",
            "#define CMPT_LEN_MID_BITS 3",
            "#define CMPT_LEN_HIGH_BITS 8",
            "#define CMPT_LEN_BOUND 8",
            "#define CMPT_MF_LONGEST_MATCH 273",
            "#define CMPT_MF_HASH_TABLE_SIZE 256",
            "#define CMPT_MF_BASE_DEPTH 16",
            "#define CMPT_MF_MATCH_2_BYTES 2",
            "#define CMPT_MF_MATCH_3_BYTES 3",
            "#define CMPT_DP_OPTMAX (1 << 11)",
            "#define CMPT_ONE_BLOCK_MAX_SIZE (1 << 17)"
        ],
        "macro_functions": [
            "#define CMPTLZ_WRITE32BIT(ptr, val) (((CmptlzUnalignU32 *)(ptr))->v = (val))",
            "#define CMPTLZ_ERROR_CONVERT(x) (int32_t)((CMPTLZ_MODULE << 16) | (uint32_t)(x))",
            "#define CMPTLZ_HANDLE_CONVERT(x) (int32_t)((CMPTLZ_MODULE << 16) | ((uint32_t)(x) << 8))",
            "#define CMPTLZ_LIKELY(expr) __builtin_expect(expr, true)",
            "#define CMPTLZ_UNLIKELY(expr) __builtin_expect(expr, false)",
            "#define CMPTLZ_LOG(error_code, fmt, ...)                                                                               \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        CmptlzLogWrite((size_t)(error_code), __FUNCTION__, __LINE__, fmt, __VA_ARGS__);                                \\\n    } while (0)",
            "#define CMPTLZ_CALC_POS_STATE(procPos, pbMask) (((procPos) & (pbMask)) << 4)",
            "#define CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec)                                                             \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if ((range) < CMPTLZ_RANGE_DOWN_LIMIT)                                                                         \\\n        {                                                                                                              \\\n            (range) <<= CMPTLZ_ONE_BYTE_WIDTH;                                                                         \\\n            (rangeCode) <<= CMPTLZ_ONE_BYTE_WIDTH;                                                                     \\\n            (rangeCode) |= (*(bufToDec)++);                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
            "#define CMPTLZ_IS_THE_BIT_0(probSlot, range, rangeCode, rangeBound)                                                    \\\n    (rangeBound) = (range >> CMPTLZ_PROB_LG_BIT) * (*(probSlot));                                                      \\\n    if ((rangeCode) < (rangeBound))",
            "#define CMPTLZ_RANGE_UPDATE_0(prob, range, rangeBound)                                                                 \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (range) = (rangeBound);                                                                                        \\\n        *(prob) = (CmptLzDecProb)((*(prob)) + ((CMPTLZ_PROB_LG - (*(prob))) >> CMPTLZ_RANGE_CODE_SIZE));               \\\n    } while (0)",
            "#define CMPTLZ_RANGE_UPDATE_1(prob, range, rangeCode, rangeBound)                                                      \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (range) -= (rangeBound);                                                                                       \\\n        (rangeCode) -= (rangeBound);                                                                                   \\\n        *(prob) = (CmptLzDecProb)((*(prob)) - ((*(prob)) >> CMPTLZ_RANGE_CODE_SIZE));                                  \\\n    } while (0)",
            "#define CMPTLZ_NORMAL_BIT_DEC(probLit, range, rangeCode, rangeBound, decSym)                                           \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probLit));                                                 \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_0(probLit, range, rangeBound);                                                         \\\n            (decSym) = ((decSym) << 1);                                                                                \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_1(probLit, range, rangeCode, rangeBound);                                              \\\n            (decSym) = ((decSym) << 1) + 1;                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
            "#define CMPTLZ_MATCH_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec)          \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (matchSym) <<= 1;                                                                                              \\\n        (bit) = (offset);                                                                                              \\\n        (offset) &= (matchSym);                                                                                        \\\n        (probLit) = (probSlot) + ((offset) + (bit) + (decSym));                                                        \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probLit));                                                 \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_0(probLit, range, rangeBound);                                                         \\\n            (decSym) = ((decSym) << 1);                                                                                \\\n            (offset) ^= (bit);                                                                                         \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_1(probLit, range, rangeCode, rangeBound);                                              \\\n            (decSym) = ((decSym) << 1) + 1;                                                                            \\\n        }                                                                                                              \\\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);                                                            \\\n    } while (0)",
            "#define CMPTLZ_DIST_BIT_DEC(probDist, probSlot, range, rangeCode, rangeBound, decDist, decBit)                         \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (probDist) = (probSlot) + (decDist);                                                                           \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probDist));                                                \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_0(probDist, range, rangeBound);                                                        \\\n            (decDist) += (decBit);                                                                                     \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_1(probDist, range, rangeCode, rangeBound);                                             \\\n            (decDist) += (decBit) * 2;                                                                                 \\\n        }                                                                                                              \\\n    } while (0)",
            "#define CMPTLZ_LEN_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym, bufToDec)                                   \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        CMPTLZ_NORMAL_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym);                                         \\\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);                                                            \\\n    } while (0)",
            "#define CMPTLZ_POSSLOT_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym, bufToDec)                               \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        CMPTLZ_NORMAL_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym);                                         \\\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);                                                            \\\n    } while (0)",
            "#define CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound)                                                          \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (range) = (rangeBound);                                                                                        \\\n    } while (0)",
            "#define CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound)                                               \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (range) -= (rangeBound);                                                                                       \\\n        (rangeCode) -= (rangeBound);                                                                                   \\\n    } while (0)",
            "#define CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit)                                              \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if ((range) < CMPTLZ_RANGE_DOWN_LIMIT)                                                                         \\\n        {                                                                                                              \\\n            if ((bufTryDec) >= (bufLimit))                                                                             \\\n            {                                                                                                          \\\n                return CMPTLZ_DEC_INPUT_EOF;                                                                           \\\n            }                                                                                                          \\\n            (range) <<= CMPTLZ_ONE_BYTE_WIDTH;                                                                         \\\n            (rangeCode) <<= CMPTLZ_ONE_BYTE_WIDTH;                                                                     \\\n            (rangeCode) |= (*(bufTryDec)++);                                                                           \\\n        }                                                                                                              \\\n    } while (0)",
            "#define CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probSym)                                       \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probSym));                                                 \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);                                                     \\\n            (decSym) = ((decSym) << 1);                                                                                \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);                                          \\\n            (decSym) = ((decSym) << 1) + 1;                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
            "#define CMPTLZ_MATCH_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probSym)                                        \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probSym));                                                 \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);                                                     \\\n            (decSym) = ((decSym) << 1);                                                                                \\\n            (offset) ^= (bit);                                                                                         \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);                                          \\\n            (decSym) = ((decSym) << 1) + 1;                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
            "#define CMPTLZ_SET_DICTSIZE_BY_LEVEL(level, dictSize)                                                                  \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        dictSize = (level <= 5) ? (1 << (level * 2 + 14)) : ((level <= 7) ? (1 << 25) : (1 << 26));                    \\\n    } while (0)",
            "#define CMPTLZ_SET_FB_BY_LEVEL(level, fastBytes) (fastBytes = ((level < 7) ? 32 : 64))",
            "#define CMPTLZ_FIND_MIN(x, y) ((x) < (y) ? (x) : (y))",
            "#define CMPTLZ_FIND_MAX(x, y) ((x) > (y) ? (x) : (y))",
            "#define NOT_EQUAL_2_BYTES(a, b) ((a)[0] != (b)[0] || (a)[1] != (b)[1])",
            "#define CMPTLZ_RETURN_IF_NOT_OK(res)                                                                                   \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if (CMPTLZ_UNLIKELY(res != CMPT_OK))                                                                           \\\n        {                                                                                                              \\\n            return res;                                                                                                \\\n        }                                                                                                              \\\n    } while (0)",
            "#define CMPT_GET_DIST_STATE(len) (((len) < 4 + CMPTLZ_MATCH_LEN_MIN) ? (len) - CMPTLZ_MATCH_LEN_MIN : 4 - 1)",
            "#define CMPT_STATE_UPDATE_WHEN_LIT(state)                                                                              \\\n    (state) = (((state) <= SHORTREP_LIT_LIT) ? LIT_LIT : (((state) <= LIT_SHORTREP) ? (state) - 3 : (state) - 6))",
            "#define CMPT_STATE_UPDATE_WHEN_MATCH(state) (state) = (((state) < 7) ? LIT_MATCH : NOTLIT_MATCH)",
            "#define CMPT_STATE_UPDATE_WHEN_LONGREP(state) (state) = (((state) < 7) ? LIT_LONGREP : NOTLIT_REP)",
            "#define CMPT_STATE_UPDATE_WHEN_SHORTREP(state) (state) = (((state) < 7) ? LIT_SHORTREP : NOTLIT_REP)",
            "#define CMPT_HASH_MASK_CALC(hashMask)                                                                                  \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        hashMask |= hashMask >> 1;                                                                                     \\\n        hashMask |= hashMask >> 2;                                                                                     \\\n        hashMask |= hashMask >> 4;                                                                                     \\\n        hashMask |= hashMask >> 8;                                                                                     \\\n        hashMask >>= 1;                                                                                                \\\n        hashMask |= 0xFFFF;                                                                                            \\\n        if (hashMask > (1 << 24))                                                                                      \\\n        {                                                                                                              \\\n            hashMask >>= 1;                                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
            "#define CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue)                                             \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        temp = mf->hashRootTable[cur[0]] ^ cur[1];                                                                     \\\n        hash2Value = temp & CMPTLZ_HASH_2_MASK;                                                                        \\\n        hash3Value = (temp ^ ((uint32_t)(cur[2]) << 8)) & CMPTLZ_HASH_3_MASK;                                          \\\n        hashValue = (temp ^ ((uint32_t)(cur[2]) << 8) ^ (mf->hashRootTable[cur[3]] << 5)) & mf->hashMask;              \\\n    } while (0)",
            "#define CMPT_HASH_UPDATE(mf, hash2Value, hash3Value, hashValue, pos)                                                   \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        mf->hash[hash2Value] = pos;                                                                                    \\\n        mf->hash[CMPTLZ_FIX_3_HASH + hash3Value] = pos;                                                                \\\n        mf->hash[CMPTLZ_FIX_4_HASH + hashValue] = pos;                                                                 \\\n    } while (0)",
            "#define CMPT_HASH_FIND_2_BYTES(mf, delta2, longestLen, matchesCount, cur, matches)                                     \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if (delta2 < mf->cycleSize && *(cur - delta2) == *cur)                                                         \\\n        {                                                                                                              \\\n            longestLen = CMPT_MF_MATCH_2_BYTES;                                                                        \\\n            matches[0].len = CMPT_MF_MATCH_2_BYTES;                                                                    \\\n            matches[0].dist = delta2 - 1;                                                                              \\\n            matchesCount = 1;                                                                                          \\\n        }                                                                                                              \\\n    } while (0)",
            "#define CMPT_HASH_FIND_3_BYTES(mf, delta2, delta3, longestLen, matchesCount, cur, matches)                             \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if (delta2 != delta3 && delta3 < mf->cycleSize && *(cur - delta3) == *cur)                                     \\\n        {                                                                                                              \\\n            longestLen = CMPT_MF_MATCH_3_BYTES;                                                                        \\\n            matches[matchesCount++].dist = delta3 - 1;                                                                 \\\n            delta2 = delta3;                                                                                           \\\n        }                                                                                                              \\\n    } while (0)",
            "#define CMPT_MF_MOVE_POS(mf)                                                                                           \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        mf->readPos++;                                                                                                 \\\n        mf->cyclePos++;                                                                                                \\\n        mf->cyclePos = (mf->cyclePos == mf->cycleSize) ? 0 : mf->cyclePos;                                             \\\n        if (CMPTLZ_UNLIKELY(mf->readPos + mf->offset == CMPTLZ_UINT32_MAX))                                            \\\n        {                                                                                                              \\\n            CmptMfMovePos(mf);                                                                                         \\\n        }                                                                                                              \\\n    } while (0)",
            "#define CMPT_MF_LEFT_SON_UPDATE(ptr1, pair, curMatch, len1, len)                                                       \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        *ptr1 = curMatch;                                                                                              \\\n        ptr1 = pair + 1;                                                                                               \\\n        curMatch = *ptr1;                                                                                              \\\n        len1 = len;                                                                                                    \\\n    } while (0)",
            "#define CMPT_MF_RIGHT_SON_UPDATE(ptr0, pair, curMatch, len0, len)                                                      \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        *ptr0 = curMatch;                                                                                              \\\n        ptr0 = pair;                                                                                                   \\\n        curMatch = *ptr0;                                                                                              \\\n        len0 = len;                                                                                                    \\\n    } while (0)",
            "#define CMPT_LIT_SUBCODER(probs, litCtx, lpMask, pos, prevByte)                                                        \\\n    ((probs)[(((pos) & (lpMask)) << (litCtx)) + ((uint32_t)(prevByte) >> (8U - (litCtx)))])",
            "#define GET_LEN_TO_POS_STATE(len) (((len) < CMPT_NUM_LEN_POS_STATE + 1) ? (len) - 2 : CMPT_NUM_LEN_POS_STATE - 1)",
            "#define CMPT_RC_BREAK_CHECK(rcCtx, buf, res)                                                                           \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if ((buf) == (rcCtx->bufBase + CMPTLZ_RC_BUFFER_SIZE))                                                         \\\n        {                                                                                                              \\\n            (res) = CmptRcFlush64Kb(rcCtx);                                                                            \\\n            CMPTLZ_RETURN_IF_NOT_OK(res);                                                                              \\\n        }                                                                                                              \\\n    } while (0)",
            "#define CMPT_RC_BREAK_SHIFTING(rcCtx, buf, res)                                                                        \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        CMPT_RC_BREAK_CHECK(rcCtx, buf, res);                                                                          \\\n        if ((rcCtx)->cacheSize == 0)                                                                                   \\\n        {                                                                                                              \\\n            return CMPT_OK;                                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
            "#define CMPT_RC_NORMALIZE(rcCtx, range, shiftRes)                                                                      \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if ((range) < CMPT_RC_MIN_RANGE)                                                                               \\\n        {                                                                                                              \\\n            (range) <<= 8;                                                                                             \\\n            (shiftRes) = CmptRcShiftLow(rcCtx);                                                                        \\\n        }                                                                                                              \\\n    } while (0)",
            "#define CMPT_RC_GET_NEWBOUND(prob, bit0Prob, range, newBound)                                                          \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (bit0Prob) = *(prob);                                                                                          \\\n        newBound = ((range) >> 11) * (bit0Prob);                                                                       \\\n    } while (0)",
            "#define CMPT_RC_BIT_PROCESS(rcCtx, prob, bit, bit0Prob, range, newBound, shiftRes)                                     \\\n    {                                                                                                                  \\\n        do                                                                                                             \\\n        {                                                                                                              \\\n            uint32_t mask = 0 - (uint32_t)(bit);                                                                       \\\n            CMPT_RC_GET_NEWBOUND(prob, bit0Prob, range, newBound);                                                     \\\n            (range) &= mask;                                                                                           \\\n            mask &= (newBound);                                                                                        \\\n            (range) -= mask;                                                                                           \\\n            (rcCtx)->low += mask;                                                                                      \\\n            mask = (uint32_t)(bit) - 1;                                                                                \\\n            (range) += (newBound) & mask;                                                                              \\\n            mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));                                                            \\\n            mask += ((1 << 5) - 1);                                                                                    \\\n            (bit0Prob) += (int)(mask - (bit0Prob)) >> 5;                                                               \\\n            *(prob) = (CmptlzProb)(bit0Prob);                                                                          \\\n            CMPT_RC_NORMALIZE(rcCtx, range, shiftRes);                                                                 \\\n        } while (0);                                                                                                   \\\n    }",
            "#define CMPT_RC_BIT_0(prob, newBound, range, bit0Prob)                                                                 \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (range) = (newBound);                                                                                          \\\n        *(prob) = (CmptlzProb)((bit0Prob) + ((CMPTLZ_PROB_MAX_NUM - (bit0Prob)) >> 5));                                \\\n    } while (0)",
            "#define CMPT_RC_BIT_1(rcCtx, prob, newBound, range, bit0Prob)                                                          \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (range) -= (newBound);                                                                                         \\\n        (rcCtx)->low += (newBound);                                                                                    \\\n        *(prob) = (CmptlzProb)((bit0Prob) - ((bit0Prob) >> 5));                                                        \\\n    } while (0)",
            "#define CMPT_RC_BIT_0_PROCESS(rcCtx, prob, newBound, range, bit0Prob, shiftRes)                                        \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        CMPT_RC_BIT_0(prob, newBound, range, bit0Prob);                                                                \\\n        CMPT_RC_NORMALIZE(rcCtx, range, shiftRes);                                                                     \\\n    } while (0)",
            "#define CMPT_RC_BIT_1_PROCESS(rcCtx, prob, newBound, range, bit0Prob, shiftRes)                                        \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        CMPT_RC_BIT_1(rcCtx, prob, newBound, range, bit0Prob);                                                         \\\n        CMPT_RC_NORMALIZE(rcCtx, range, shiftRes);                                                                     \\\n    } while (0)",
            "#define CMPT_LIT_PROB_GET(encCtx, litProb, pos, prevByte)                                                              \\\n    (litProb + (uint32_t)3 * (((((pos) << 8) + (prevByte)) & encCtx->lpMask) << encCtx->litMarcov.lcBits))"
        ],
        "types": {
            "": [],
            "CmptlzUnalignU32": "typedef struct\n{\n    uint32_t v;\n} __attribute__((packed)) CmptlzUnalignU32;",
            "EnCmptErrNo": "typedef enum\n{\n    CMPTLZ_ERROR_DATA = 1,\n    CMPTLZ_ERROR_MEM,\n    CMPTLZ_ERROR_UNSUPPORTED,\n    CMPTLZ_ENC_ERROR_FILESIZE,\n    CMPTLZ_ENC_CTX_INIT_FAIL,\n    CMPTLZ_ENC_RC_INIT_FAIL,\n    CMPTLZ_ENC_MF_INIT_FAIL,\n    CMPTLZ_ENC_ERROR_WRITE,\n    CMPTLZ_ENC_ERROR_HEAD,\n    CMPTLZ_ENC_ERROR_PARAM,\n    CMPTLZ_ERROR_BUTT\n} EnCmptErrNo;",
            "CmptLzDecProb": "typedef uint16_t CmptLzDecProb;",
            "EnCmptLzMemType": "typedef enum\n{\n    CMPTLZ_DICT_MEM = 1,\n    CMPTLZ_PROB_MEM,\n    CMPTLZ_ENC_CCTX,\n    CMPTLZ_MF_CCTX,\n    CMPTLZ_MF_HASH,\n    CMPTLZ_MF_SON,\n    CMPTLZ_RC_CCTX,\n    CMPTLZ_RC_BUF,\n    CMPTLZ_MEM_TYPE_BUT\n} EnCmptLzMemType;",
            "enMemType": "typedef struct\n{\n    void *(*CmptLzAlloc)(int32_t enMemType, size_t size);\n    void (*CmptLzFree)(int32_t enMemType, void *address);\n} CmptLzMemHook;",
            "CmptlzLogFunc": "typedef void (*CmptlzLogFunc)(const char *message, size_t size);",
            "EnCmptLzFinMode": "typedef enum\n{\n    CMPTLZ_FINISH_ANY,\n    CMPTLZ_FINISH_END\n} EnCmptLzFinMode;",
            "EnCmptLzStatus": "typedef enum\n{\n    CMPTLZ_STATUS_NOT_SPECIFIED,\n    CMPTLZ_STATUS_FINISHED_WITH_MARK,\n    CMPTLZ_STATUS_NOT_FINISHED,\n    CMPTLZ_STATUS_NEEDS_MORE_INPUT,\n    CMPTLZ_STATUS_MAYBE_FINISHED_WITHOUT_MARK,\n    CMPTLZ_STATUS_BUT\n} EnCmptLzStatus;",
            "CmptLzDecProt": "typedef struct\n{\n    unsigned char litCtx;\n    unsigned char litPos;\n    unsigned char posBits;\n    unsigned char alignPad;\n    uint32_t dicSize;\n} CmptLzDecProt;",
            "CmptLzDecCtx": "typedef struct\n{\n    CmptLzDecProt prop;\n    CmptLzDecProb *probs;\n    CmptLzDecProb *probsPlus1664;\n    unsigned char *dict;\n    size_t dictBufSize;\n    size_t dictPos;\n    const unsigned char *buf;\n    uint32_t range;\n    uint32_t code;\n    uint32_t processedPos;\n    uint32_t checkDicSize;\n    uint32_t reps[4];\n    uint32_t state;\n    uint32_t remainLen;\n    uint32_t numProbs;\n    unsigned tempBufSize;\n    unsigned char tempBuf[CMPTLZ_REQUIRED_INPUT_MAX];\n} CmptLzDecCtx;",
            "CmptLzDecIn": "typedef struct\n{\n    const unsigned char *pSrcIn;\n    size_t strInLen;\n    size_t strInCostLen;\n} CmptLzDecIn;",
            "CmptLzDecOut": "typedef struct\n{\n    unsigned char *pDestOut;\n    size_t destOutLen;\n    size_t destOutFillLen;\n} CmptLzDecOut;",
            "CmptlzDecParam": "typedef struct\n{\n    const unsigned char *protData;\n    unsigned protSize;\n    CmptLzMemHook *memHook;\n} CmptlzDecParam;",
            "CmptLzEncCtx": "typedef struct TagCmptLzEncCtx CmptLzEncCtx;",
            "CmptlzCompParam": "typedef struct\n{\n    int level;\n    uint32_t dictSize;\n    int litCtx;\n    int litPos;\n    int posBits;\n    int fastBytes;\n    int numThreads;\n    unsigned char *protData;\n    size_t protSize;\n    CmptLzMemHook *memHook;\n} CmptlzCompParam;",
            "CmptlzProb": "typedef uint16_t CmptlzProb;",
            "CmptlzEncParam": "typedef struct\n{\n    int level;\n    uint32_t dictSize;\n    int litCtx;\n    int litPos;\n    int posBits;\n    int fastBytes;\n    int numThreads;\n} CmptlzEncParam;",
            "LitMarcov": "typedef struct\n{\n    uint32_t pos;\n    uint32_t prevByte;\n    CmptlzProb literal[1 << CMPTLZ_LCLP_MAX][CMPTLZ_LIT_MAX_SIZE];\n    uint32_t lcBits;\n    uint32_t posMask;\n} LitMarcov;",
            "CmptRcCtx": "typedef struct\n{\n    uint32_t range;\n    uint64_t cache;\n    uint64_t low;\n    uint64_t cacheSize;\n    uint8_t *buf;\n    uint8_t *bufBase;\n    uint8_t *outBuf;\n    size_t outBufLeft;\n} CmptRcCtx;",
            "CmptMfCtx": "typedef struct TagCmptMatchFinder CmptMfCtx;",
            "TagCmptMatchFinder": "struct TagCmptMatchFinder\n{\n    const uint8_t *srcStart;\n    size_t srcLen;\n    uint32_t hashRootTable[256];\n    uint32_t mfStart;\n    uint32_t niceLen;\n    uint32_t readAhead;\n    uint32_t readPos;\n    uint32_t cyclePos;\n    uint32_t cycleSize;\n    uint32_t offset;\n    uint32_t *hash;\n    uint32_t *son;\n    uint32_t depth;\n    uint32_t hashCount;\n    uint32_t sonsCount;\n    uint32_t hashMask;\n};",
            "CmptLenEncoder": "typedef struct\n{\n    CmptlzProb low[256];\n    CmptlzProb high[1 << CMPT_LEN_HIGH_BITS];\n    uint32_t prices[CMPTLZ_NUM_PB_STATES_MAX]\n                   [(1 << CMPT_LEN_HIGH_BITS) + (1 << CMPT_LEN_MID_BITS) + (1 << CMPT_LEN_LOW_BITS)];\n    uint32_t tableSize;\n} CmptLenEncoder;",
            "CmptlzState": "typedef enum\n{\n    LIT_LIT,\n    MATCH_LIT_LIT,\n    REP_LIT_LIT,\n    SHORTREP_LIT_LIT,\n    MATCH_LIT,\n    REP_LIT,\n    SHORTREP_LIT,\n    LIT_MATCH,\n    LIT_LONGREP,\n    LIT_SHORTREP,\n    NOTLIT_MATCH,\n    NOTLIT_REP,\n} CmptlzState;",
            "CmptlzMatchPair": "typedef struct\n{\n    uint32_t len;\n    uint32_t dist;\n} CmptlzMatchPair;",
            "CmptlzOpt": "typedef struct\n{\n    CmptlzState state;\n    uint32_t price;\n    uint32_t posPrev;\n    uint32_t backPrev;\n    uint32_t backs[CMPTLZ_NUM_REPS];\n} CmptlzOpt;",
            "TagCmptLzEncCtx": "struct TagCmptLzEncCtx\n{\n    int level;\n    int litCtx;\n    int litPos;\n    int posBits;\n    uint32_t dicSize;\n    int endMarker;\n    uint32_t numFastBytes;\n    bool encNeedFinish;\n    uint64_t nowpos64;\n    uint32_t cmptlzResponse;\n    CmptlzState state;\n    LitMarcov litMarcov;\n    uint32_t reps[CMPTLZ_NUM_REPS];\n    CmptlzProb isRep[CMPTLZ_NUM_STATES];\n    CmptlzProb isRepG0[CMPTLZ_NUM_STATES];\n    CmptlzProb isRepG1[CMPTLZ_NUM_STATES];\n    CmptlzProb isRepG2[CMPTLZ_NUM_STATES];\n    CmptlzProb isMatch[CMPTLZ_NUM_STATES][CMPTLZ_NUM_PB_STATES_MAX];\n    CmptlzProb isRep0Long[CMPTLZ_NUM_STATES][CMPTLZ_NUM_PB_STATES_MAX];\n    CmptlzProb probDistSlot[CMPTLZ_DIST_STATE_TOTAL][1 << CMPTLZ_DIST_SLOT_BITS];\n    CmptlzProb probDistSpecial[CMPT_DIST_LIMIT_2];\n    CmptlzProb probAlign[1 << CMPTLZ_ALIGN_BITS];\n    uint32_t posMask;\n    uint64_t pbMask;\n    uint64_t lpMask;\n    CmptRcCtx *rcCtx;\n    CmptMfCtx *mfCtx;\n    CmptlzMatchPair matches[CMPT_MF_LONGEST_MATCH + 1];\n    uint32_t matchesCount;\n    uint32_t longestMatchLen;\n    uint32_t backRes;\n    uint32_t lenRes;\n    uint32_t optEndIndex;\n    uint32_t optsCurIndex;\n    CmptlzOpt opts[CMPT_DP_OPTMAX];\n    CmptLenEncoder matchLenEncoder;\n    CmptLenEncoder repLenEncoder;\n    int repLenPriceCount;\n    int matchPriceCount;\n    uint32_t priceRootTable[CMPT_PRIICE_TABLE_SIZE];\n    uint32_t priceDistSlotTable[CMPTLZ_DIST_STATE_TOTAL][1 << CMPTLZ_DIST_SLOT_BITS];\n    uint32_t priceDistTable[CMPTLZ_DIST_STATE_TOTAL][1 << 7];\n    uint32_t priceAlignTable[1 << CMPTLZ_ALIGN_BITS];\n    uint32_t distTableSize;\n};"
        },
        "global_variables": {
            "g_cmptlzLogFunc": "static CmptlzLogFunc g_cmptlzLogFunc = NULL;"
        },
        "declarations": [
            "TagCmptLzEncCtx",
            "TagCmptMatchFinder"
        ],
        "functions": {
            "CmptlzIsLE": "static int CmptlzIsLE(void)\n{\n    int n = 1;\n    return *(char *)(&n);\n}",
            "CmptlzSwap32": "static uint32_t CmptlzSwap32(uint32_t val)\n{\n    return ((0xff000000 & (val << 24)) | (0x000000ff & (val >> 24)) | (0x00ff0000 & (val << 8)) |\n            (0x0000ff00 & (val >> 8)));\n}",
            "CmptlzWriteLE32Bit": "static void CmptlzWriteLE32Bit(void *addr, uint32_t val)\n{\n    if (CmptlzIsLE() != 0)\n    {\n        CMPTLZ_WRITE32BIT(addr, val);\n    }\n    else\n    {\n        CMPTLZ_WRITE32BIT(addr, CmptlzSwap32(val));\n    }\n}",
            "CmptlzLogWrite": "void CmptlzLogWrite(size_t errorCode, const char *funcName, unsigned short line, const char *fmt, ...)\n{\n    va_list alist;\n    char output[LOG_BUF_SIZE];\n    int ret;\n    size_t len;\n    CmptlzLogFunc func = g_cmptlzLogFunc;\n    if (func == NULL)\n    {\n        return;\n    }\n    ret = snprintf_s(output, LOG_BUF_SIZE, LOG_BUF_SIZE - 1, \"\\n[Cmptlz-Log] Func=%s, Line=%u, Error=0x%zx\\n\", funcName,\n                     line, errorCode);\n    if (ret < 0)\n    {\n        return;\n    }\n    len = (size_t)ret;\n    va_start(alist, fmt);\n    ret = vsnprintf_s(output + len, LOG_BUF_SIZE - len, LOG_BUF_SIZE - len - 1, fmt, alist);\n    va_end(alist);\n    if (ret < 0)\n    {\n        return;\n    }\n    func(output, strlen(output) + 1);\n}",
            "CmptlzLogRegister": "void CmptlzLogRegister(CmptlzLogFunc func)\n{\n    g_cmptlzLogFunc = func;\n}",
            "CmptLzPropsDecode": "static int CmptLzPropsDecode(const unsigned char *protData, unsigned protSize, CmptLzDecProt *decProt)\n{\n    uint32_t dictSize;\n    if (protSize < CMPTLZ_PROPS_SIZE)\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n    else\n    {\n        dictSize =\n            protData[1] | ((uint32_t)protData[2] << 8) | ((uint32_t)protData[3] << 16) | ((uint32_t)protData[4] << 24);\n    }\n    if (dictSize < CMPTLZ_DICT_MIN_LEN)\n    {\n        dictSize = CMPTLZ_DICT_MIN_LEN;\n    }\n    decProt->dicSize = dictSize;\n    unsigned char firstData = protData[0];\n    if (firstData >= (CMPTLZ_LIT_CTX_MAX * CMPTLZ_POS_STATE_MAX * CMPTLZ_LIT_POS_MAX))\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n    decProt->litCtx = (unsigned char)(firstData % CMPTLZ_LIT_CTX_MAX);\n    firstData /= CMPTLZ_LIT_CTX_MAX;\n    decProt->posBits = (unsigned char)(firstData / CMPTLZ_POS_STATE_MAX);\n    decProt->litPos = (unsigned char)(firstData % CMPTLZ_LIT_POS_MAX);\n    return CMPT_OK;\n}",
            "CmptLzDecInit": "void CmptLzDecInit(CmptLzDecCtx *decCtx)\n{\n    decCtx->dictPos = 0;\n    decCtx->tempBufSize = 0;\n    decCtx->processedPos = 0;\n    decCtx->checkDicSize = 0;\n    decCtx->remainLen = CMPTLZ_MATCH_MAX_LEN + 2;\n}",
            "CmptLzDecMemAlloc": "static void *CmptLzDecMemAlloc(CmptLzMemHook *memHook, int32_t memHandle, size_t allocSize)\n{\n    return memHook->CmptLzAlloc(memHandle, allocSize);\n}",
            "CmptLzDecMemFree": "static void CmptLzDecMemFree(CmptLzMemHook *memHook, int32_t memHandle, void *freeAddress)\n{\n    memHook->CmptLzFree(memHandle, freeAddress);\n}",
            "CmptLzDecFreeProbs": "static void CmptLzDecFreeProbs(CmptLzDecCtx *decCtx, CmptLzMemHook *memHook)\n{\n    if (decCtx->probs != NULL)\n    {\n        CmptLzDecMemFree(memHook, CMPTLZ_PROB_HANDLE, decCtx->probs);\n        decCtx->probs = NULL;\n    }\n}",
            "CmptLzDecAllocateProbs": "static int CmptLzDecAllocateProbs(CmptLzDecCtx *decCtx, CmptLzDecProt *decProt, CmptLzMemHook *memHook)\n{\n    uint32_t numProbs = CmptLzGetNumProbs(decProt);\n    if (decCtx->probs == NULL)\n    {\n        decCtx->probs =\n            (CmptLzDecProb *)CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE, numProbs * sizeof(CmptLzDecProb));\n    }\n    else\n    {\n        if (numProbs != decCtx->numProbs)\n        {\n            CmptLzDecFreeProbs(decCtx, memHook);\n            decCtx->probs =\n                (CmptLzDecProb *)CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE, numProbs * sizeof(CmptLzDecProb));\n        }\n    }\n    if (decCtx->probs == NULL)\n    {\n        return CMPT_ERROR_MEM;\n    }\n    decCtx->probsPlus1664 = decCtx->probs + 1664;\n    decCtx->numProbs = numProbs;\n    return CMPT_OK;\n}",
            "CmptLzDecConstruct": "void CmptLzDecConstruct(CmptLzDecCtx *decCtx)\n{\n    decCtx->dict = NULL;\n    decCtx->probs = NULL;\n}",
            "CmptLzDecode": "int CmptLzDecode(CmptLzDecIn *pDecIn, CmptLzDecOut *pDecOut, const unsigned char *protData, EnCmptLzFinMode finMode,\n                 EnCmptLzStatus *finStatus, CmptLzMemHook *memHook)\n{\n    int res;\n    size_t inSize = pDecIn->strInLen;\n    CmptLzDecProt decProt;\n    CmptLzDecCtx decCtx;\n    decCtx.numProbs = 0;\n    if (inSize < CMPTLZ_PROPS_SIZE)\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n    CmptLzDecConstruct(&decCtx);\n    res = CmptLzPropsDecode(protData, CMPTLZ_PROPS_SIZE, &decProt);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n    res = CmptLzDecAllocateProbs(&decCtx, &decProt, memHook);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n    decCtx.prop = decProt;\n    decCtx.dict = pDecOut->pDestOut;\n    decCtx.dictBufSize = pDecOut->destOutLen;\n    CmptLzDecInit(&decCtx);\n    *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n    res = CmptLzDecDecodeToDic(&decCtx, pDecOut->destOutLen, pDecIn->pSrcIn, &inSize, finMode, finStatus);\n    pDecIn->strInCostLen = inSize;\n    pDecOut->destOutFillLen = decCtx.dictPos;\n    CmptLzDecFreeProbs(&decCtx, memHook);\n    return res;\n}",
            "CmptLzGetProbsMatrix": "static CmptLzDecProb *CmptLzGetProbsMatrix(CmptLzDecCtx *decCtx)\n{\n    return decCtx->probsPlus1664;\n}",
            "CmptLzGetIsMatchProb": "static CmptLzDecProb *CmptLzGetIsMatchProb(CmptLzDecProb *probsMatrix)\n{\n    return probsMatrix + CMPTLZ_IS_MATCH;\n}",
            "CmptLzGetIsRepProb": "static CmptLzDecProb *CmptLzGetIsRepProb(CmptLzDecProb *probsMatrix)\n{\n    return probsMatrix + CMPTLZ_ISREP;\n}",
            "CmptLzGetIsRepG0Prob": "static CmptLzDecProb *CmptLzGetIsRepG0Prob(CmptLzDecProb *probsMatrix)\n{\n    return probsMatrix + CMPTLZ_ISREPG0;\n}",
            "CmptLzGetIsRepG1Prob": "static CmptLzDecProb *CmptLzGetIsRepG1Prob(CmptLzDecProb *probsMatrix)\n{\n    return probsMatrix + CMPTLZ_ISREPG1;\n}",
            "CmptLzGetIsRepG2Prob": "static CmptLzDecProb *CmptLzGetIsRepG2Prob(CmptLzDecProb *probsMatrix)\n{\n    return probsMatrix + CMPTLZ_ISREPG2;\n}",
            "CmptLzGetIsRepG0LongProb": "static CmptLzDecProb *CmptLzGetIsRepG0LongProb(CmptLzDecProb *probsMatrix)\n{\n    return probsMatrix + CMPTLZ_REP0_LONG;\n}",
            "CmptLzGetLiteralProb": "static CmptLzDecProb *CmptLzGetLiteralProb(CmptLzDecProb *probsMatrix)\n{\n    return probsMatrix + CMPTLZ_LITERAL;\n}",
            "CmptLzGetPosSlotProb": "static CmptLzDecProb *CmptLzGetPosSlotProb(CmptLzDecProb *probsMatrix)\n{\n    return probsMatrix + CMPTLZ_POSSLOT;\n}",
            "CmptLzGetSpecPosProb": "static CmptLzDecProb *CmptLzGetSpecPosProb(CmptLzDecProb *probsMatrix)\n{\n    return probsMatrix + CMPTLZ_SPEC_POS;\n}",
            "CmptLzGetAilgnProb": "static CmptLzDecProb *CmptLzGetAilgnProb(CmptLzDecProb *probsMatrix)\n{\n    return probsMatrix + CMPTLZ_ALIGN;\n}",
            "CmptLzGetRepLenCoderProb": "static CmptLzDecProb *CmptLzGetRepLenCoderProb(CmptLzDecProb *probsMatrix)\n{\n    return probsMatrix + CMPTLZ_REP_LEN_CODER;\n}",
            "CmptLzGetMatchLenCoderProb": "static CmptLzDecProb *CmptLzGetMatchLenCoderProb(CmptLzDecProb *probsMatrix)\n{\n    return probsMatrix + CMPTLZ_MATCH_LEN_CODER;\n}",
            "CmptLzGetLenCondition": "static uint32_t CmptLzGetLenCondition(uint32_t decLen)\n{\n    return ((decLen < CMPTLZ_LEN_CONDITION_TO_POSSLOT ? decLen : CMPTLZ_LEN_CONDITION_TO_POSSLOT - 1)\n            << CMPTLZ_POS_SLOT_BITS);\n}",
            "CmptLzGetBaseDistByPosSlot": "static uint32_t CmptLzGetBaseDistByPosSlot(uint32_t posSlot)\n{\n    return (2 | (posSlot & 1));\n}",
            "CmptLzGetNumProbs": "static uint32_t CmptLzGetNumProbs(CmptLzDecProt *decProt)\n{\n    return (NUM_BASE_PROBS + ((uint32_t)0x300 << (decProt->litCtx + decProt->litPos)));\n}",
            "CmptLzDistDecHelper": "static void CmptLzDistDecHelper(CmptLzDecCtx *decCtx, uint32_t distDec, const unsigned char *bufToDec, uint32_t *pRange,\n                                uint32_t *pRangeCode, uint32_t *pRangeBound, uint32_t range, uint32_t rangeCode,\n                                uint32_t rangeBound)\n{\n    decCtx->reps[CMPTLZ_REP3] = decCtx->reps[CMPTLZ_REP2];\n    decCtx->reps[CMPTLZ_REP2] = decCtx->reps[1];\n    decCtx->reps[1] = decCtx->reps[0];\n    decCtx->reps[0] = (distDec + 1);\n    decCtx->buf = bufToDec;\n    decCtx->state = (decCtx->state < CMPTLZ_LIT_STATES) ? CMPTLZ_LIT_STATES : CMPTLZ_LIT_STATES + CMPTLZ_REP3;\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n}",
            "CmptLzDistDec": "static size_t CmptLzDistDec(CmptLzDecCtx *decCtx, CmptLzDecProb *probsMatrix, uint32_t *pRange, uint32_t *pRangeCode,\n                            uint32_t *pRangeBound, uint32_t decLen)\n{\n    uint32_t assistBits;\n    uint32_t posSlot = 1;\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    const unsigned char *bufToDec = decCtx->buf;\n    uint32_t distDec;\n    CmptLzDecProb *probPosSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decLen);\n    int i = 0;\n    for (i = 0; i < CMPTLZ_POS_SLOT_BITS; i++)\n    {\n        CMPTLZ_POSSLOT_BIT_DEC((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    }\n    posSlot -= 64;\n    if (posSlot < CMPTLZ_LOW_POSSLOT)\n    {\n        distDec = posSlot;\n        CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n        if (distDec == (size_t)0xFFFFFFFF)\n        {\n            return distDec;\n        }\n        else\n        {\n            return (distDec + 1);\n        }\n    }\n    uint32_t directBitNum = ((posSlot >> 1) - 1);\n    distDec = CmptLzGetBaseDistByPosSlot(posSlot);\n    if (posSlot < CMPTLZ_HIGH_POSSLOT)\n    {\n        assistBits = 1;\n        distDec <<= directBitNum;\n        distDec += assistBits;\n        probPosSlot = CmptLzGetSpecPosProb(probsMatrix);\n        do\n        {\n            if CMPTLZ_IS_THE_BIT_0 ((probPosSlot + distDec), range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0((probPosSlot + distDec), range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                distDec += assistBits;\n                assistBits <<= 1;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1((probPosSlot + distDec), range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                assistBits <<= 1;\n                distDec += assistBits;\n            }\n        } while (--directBitNum);\n        distDec -= assistBits;\n    }\n    else\n    {\n        directBitNum -= CMPTLZ_REP4;\n        do\n        {\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            range >>= 1;\n            rangeCode -= range;\n            assistBits = (0 - ((uint32_t)rangeCode >> 31));\n            distDec = (distDec << 1) + (assistBits + 1);\n            rangeCode += range & assistBits;\n        } while (--directBitNum);\n        CmptLzDecProb *probDist;\n        probPosSlot = CmptLzGetAilgnProb(probsMatrix);\n        distDec <<= CMPTLZ_LARGE_DIST_LOW_BITS;\n        assistBits = 1;\n        uint32_t cycleSym = 1;\n        for (i = 0; i < 3; i++)\n        {\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            CMPTLZ_DIST_BIT_DEC(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n            cycleSym <<= 1;\n        }\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probDist = probPosSlot + assistBits;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probDist);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probDist, range, rangeBound);\n            assistBits -= 8;\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probDist, range, rangeCode, rangeBound);\n        }\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        distDec |= assistBits;\n    }\n    CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n    if (distDec == (size_t)0xFFFFFFFF)\n    {\n        return distDec;\n    }\n    else\n    {\n        return (distDec + 1);\n    }\n}",
            "CmptLzLenDec": "static uint32_t CmptLzLenDec(CmptLzDecCtx *decCtx, CmptLzDecProb *probSlot, uint32_t *pRange, uint32_t *pRangeCode,\n                             uint32_t *pRangeBound, uint32_t posState)\n{\n    uint32_t decLen = 1;\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    const unsigned char *bufToDec = decCtx->buf;\n    CmptLzDecProb *probLen = probSlot + CMPTLZ_LEN_CHOICE;\n    int i = 0;\n    if CMPTLZ_IS_THE_BIT_0 (probLen, range, rangeCode, rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET + posState;\n        for (i = 0; i < CMPTLZ_LOW_LEN_BIT; i++)\n        {\n            CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n        }\n        decLen -= 8;\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2;\n        if CMPTLZ_IS_THE_BIT_0 (probLen, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            probLen = probSlot + (CMPTLZ_LEN_CHOICE2 + posState);\n            for (i = 0; i < CMPTLZ_LOW_LEN_BIT; i++)\n            {\n                CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            }\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET;\n            for (i = 0; i < CMPTLZ_HIGH_LEN_BIT; i++)\n            {\n                CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            }\n            decLen -= CMPTLZ_HIGH_LEN_CLASS;\n            decLen += (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n    }\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx->buf = bufToDec;\n    return decLen;\n}",
            "CmptLzDecByDistAndLen": "static uint32_t CmptLzDecByDistAndLen(CmptLzDecCtx *decCtx, size_t matchDist, uint32_t matchLen, size_t dicPosLimit)\n{\n    size_t dicCopyPos;\n    size_t dicPos = decCtx->dictPos;\n    size_t dictBufSize = decCtx->dictBufSize;\n    uint32_t remainDicLen = (uint32_t)(dicPosLimit - dicPos);\n    unsigned char *dict = decCtx->dict;\n    if (remainDicLen == 0)\n    {\n        return CMPT_ERROR_DATA;\n    }\n    uint32_t decDicLen = ((remainDicLen < matchLen) ? remainDicLen : matchLen);\n    decCtx->processedPos += decDicLen;\n    decCtx->dictPos += decDicLen;\n    decCtx->remainLen = matchLen - decDicLen;\n    if (dicPos < matchDist)\n    {\n        dicCopyPos = dictBufSize - matchDist + dicPos;\n    }\n    else\n    {\n        dicCopyPos = dicPos - matchDist;\n    }\n    do\n    {\n        dict[dicPos++] = dict[dicCopyPos];\n        if (++dicCopyPos == dictBufSize)\n        {\n            dicCopyPos = 0;\n        }\n    } while (--decDicLen != 0);\n    return CMPT_OK;\n}",
            "CmptLzShortRepDec": "static void CmptLzShortRepDec(CmptLzDecCtx *decCtx)\n{\n    uint32_t rep0 = decCtx->reps[0];\n    unsigned char *dict = decCtx->dict;\n    size_t dictPos = decCtx->dictPos;\n    size_t dictBufSize = decCtx->dictBufSize;\n    dict[dictPos] = dict[dictPos - rep0 + (dictPos < rep0 ? dictBufSize : 0)];\n    decCtx->dictPos++;\n    decCtx->processedPos++;\n    if (decCtx->state < CMPTLZ_LIT_STATES)\n    {\n        decCtx->state = 9;\n    }\n    else\n    {\n        decCtx->state = 11;\n    }\n}",
            "CmptLzRepDec": "static uint32_t CmptLzRepDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound,\n                             size_t dicPosLimit, uint32_t posState)\n{\n    uint32_t repLen;\n    uint32_t repDist;\n    uint32_t mkState = decCtx->state;\n    const unsigned char *bufToDec = decCtx->buf;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    probSlot = CmptLzGetIsRepG0Prob(probsMatrix) + mkState;\n    if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probSlot = CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState;\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            *pRange = range;\n            *pRangeCode = rangeCode;\n            *pRangeBound = rangeBound;\n            decCtx->buf = bufToDec;\n            CmptLzShortRepDec(decCtx);\n            return CMPT_OK;\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            repDist = decCtx->reps[0];\n        }\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probSlot = CmptLzGetIsRepG1Prob(probsMatrix) + mkState;\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            repDist = decCtx->reps[1];\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            probSlot = CmptLzGetIsRepG2Prob(probsMatrix) + mkState;\n            if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                repDist = decCtx->reps[CMPTLZ_REP2];\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                repDist = decCtx->reps[CMPTLZ_REP3];\n                decCtx->reps[CMPTLZ_REP3] = decCtx->reps[CMPTLZ_REP2];\n            }\n            decCtx->reps[CMPTLZ_REP2] = decCtx->reps[1];\n        }\n        decCtx->reps[1] = decCtx->reps[0];\n        decCtx->reps[0] = repDist;\n    }\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx->buf = bufToDec;\n    decCtx->state = (mkState < CMPTLZ_LIT_STATES) ? 8 : 11;\n    probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n    repLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n    return CmptLzDecByDistAndLen(decCtx, repDist, repLen + 2, dicPosLimit);\n}",
            "CmptLzMatchDec": "static uint32_t CmptLzMatchDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound,\n                               size_t dicPosLimit, uint32_t posState)\n{\n    uint32_t matchLen;\n    size_t matchDist;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    probSlot = CmptLzGetMatchLenCoderProb(probsMatrix);\n    matchLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n\n    matchDist = CmptLzDistDec(decCtx, probsMatrix, pRange, pRangeCode, pRangeBound, matchLen);\n\n    if (matchDist > decCtx->dictBufSize)\n    {\n        if (matchDist == (size_t)0xFFFFFFFF)\n        {\n            decCtx->remainLen = CMPTLZ_MATCH_MAX_LEN;\n            decCtx->state -= CMPTLZ_MKSTATE_NUM;\n            return CMPT_OK;\n        }\n        else\n        {\n            return CMPT_ERROR_DATA;\n        }\n    }\n    return CmptLzDecByDistAndLen(decCtx, matchDist, matchLen + 2, dicPosLimit);\n}",
            "CmptLzLitDec": "static uint32_t CmptLzLitDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound)\n{\n    uint32_t decSym = 1;\n    uint32_t mkState = decCtx->state;\n    uint32_t procPos = decCtx->processedPos;\n    uint32_t checkDicSize = decCtx->checkDicSize;\n    uint32_t litCtx = decCtx->prop.litCtx;\n    uint32_t litPosMask = ((uint32_t)0x100 << decCtx->prop.litPos) - ((uint32_t)0x100 >> litCtx);\n    CmptLzDecProb *probLit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    const unsigned char *bufToDec = decCtx->buf;\n    unsigned char *dict = decCtx->dict;\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t dictPos = decCtx->dictPos;\n    uint32_t range = *pRange;\n    uint32_t rangeBound = *pRangeBound;\n    uint32_t rangeCode = *pRangeCode;\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0 || checkDicSize != 0)\n    {\n        probSlot += (uint32_t)CMPTLZ_REP3 *\n                    ((((procPos << 8) + dict[(dictPos == 0 ? dictBufSize : dictPos) - 1]) & litPosMask) << litCtx);\n    }\n    int i = 0;\n    if (mkState < CMPTLZ_LIT_STATES)\n    {\n        mkState -= (mkState < 4) ? mkState : 3;\n        for (i = 0; i < 8; i++)\n        {\n            CMPTLZ_NORMAL_BIT_DEC((probSlot + decSym), range, rangeCode, rangeBound, decSym);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        }\n    }\n    else\n    {\n        uint32_t bit;\n        uint32_t offset = 0x100;\n        uint32_t rep0 = decCtx->reps[0];\n        uint32_t matchSym = dict[dictPos - rep0 + ((dictPos < rep0) ? dictBufSize : 0)];\n        mkState -= (mkState < 10) ? CMPTLZ_REP3 : 6;\n        for (i = 0; i < 8; i++)\n        {\n            CMPTLZ_MATCH_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n        }\n    }\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    dict[dictPos++] = (uint8_t)decSym;\n    decCtx->processedPos += 1;\n    decCtx->state = mkState;\n    decCtx->dictPos = dictPos;\n    decCtx->buf = bufToDec;\n    return CMPT_OK;\n}",
            "CmptLzDecDirectProcess": "int CmptLzDecDirectProcess(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *bufLimit)\n{\n    uint32_t decRes;\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t procPos;\n    uint32_t mkState;\n    uint32_t posState;\n    uint32_t range = decCtx->range;\n    uint32_t rangeCode = decCtx->code;\n    uint32_t rangeBound = 0;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    do\n    {\n        procPos = decCtx->processedPos;\n        mkState = decCtx->state;\n        posState = CMPTLZ_CALC_POS_STATE(procPos, pbMask);\n        probSlot = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n            decRes = CmptLzLitDec(decCtx, &range, &rangeCode, &rangeBound);\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n            probSlot = CmptLzGetIsRepProb(probsMatrix) + mkState;\n            if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n                decRes = CmptLzMatchDec(decCtx, &range, &rangeCode, &rangeBound, dicPosLimit, posState);\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n                decRes = CmptLzRepDec(decCtx, &range, &rangeCode, &rangeBound, dicPosLimit, posState);\n            }\n            if (decRes != CMPT_OK)\n            {\n                break;\n            }\n        }\n    } while (decCtx->dictPos < dicPosLimit && decCtx->buf < bufLimit && decCtx->remainLen < CMPTLZ_MATCH_MAX_LEN);\n    decCtx->range = range;\n    decCtx->code = rangeCode;\n    return (int)decRes;\n}",
            "CmptLzTryDecLenAndDist": "static int CmptLzTryDecLenAndDist(CmptLzDecCtx *decCtx, uint32_t mkState, uint32_t range, uint32_t rangeCode,\n                                  uint32_t rangeBound, CmptLzDecProb *probSlot, const unsigned char *bufTryDec,\n                                  const unsigned char **pbufLimit)\n{\n    uint32_t offset;\n    uint32_t bits2BeDec;\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t posState = CMPTLZ_CALC_POS_STATE(decCtx->processedPos, pbMask);\n    const unsigned char *bufLimit = *pbufLimit;\n    CmptLzDecProb *probBit;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    CmptLzDecProb *probLen = probSlot + CMPTLZ_LEN_CHOICE;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probLen);\n    if (rangeCode < rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET + posState;\n        bits2BeDec = 3;\n        offset = 0;\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probLen);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            probLen = probSlot + CMPTLZ_LEN_CHOICE + CMPTLZ_LEN_CHOICE2 + posState;\n            bits2BeDec = 3;\n            offset = (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET;\n            bits2BeDec = 8;\n            offset = (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n    }\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    uint32_t decSym = 1;\n    do\n    {\n        probBit = probLen + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    } while (decSym < ((uint32_t)1 << bits2BeDec));\n    decSym -= ((uint32_t)1 << bits2BeDec);\n    decSym += offset;\n    if (mkState >= 4)\n    {\n        *pbufLimit = bufTryDec;\n        return CMPT_OK;\n    }\n    probSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decSym);\n    decSym = 1;\n    do\n    {\n        probBit = probSlot + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    } while (decSym < (1 << CMPTLZ_POS_SLOT_BITS));\n    decSym -= (1 << CMPTLZ_POS_SLOT_BITS);\n    bits2BeDec = ((decSym >> 1) - 1);\n    if (decSym >= CMPTLZ_LOW_POSSLOT)\n    {\n        if (decSym < CMPTLZ_HIGH_POSSLOT)\n        {\n            probSlot = CmptLzGetSpecPosProb(probsMatrix) + (CmptLzGetBaseDistByPosSlot(decSym) << bits2BeDec);\n        }\n        else\n        {\n            bits2BeDec -= CMPTLZ_LARGE_DIST_LOW_BITS;\n            do\n            {\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n                range >>= 1;\n                rangeCode -= range & (((rangeCode - range) >> 31) - 1);\n            } while (--bits2BeDec);\n            probSlot = CmptLzGetAilgnProb(probsMatrix);\n            bits2BeDec = CMPTLZ_LARGE_DIST_LOW_BITS;\n        }\n        decSym = 1;\n        offset = 1;\n        do\n        {\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n            probBit = probSlot + decSym;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probBit);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                decSym += offset;\n                offset <<= 1;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                offset <<= 1;\n                decSym += offset;\n            }\n        } while (--bits2BeDec);\n    }\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK;\n}",
            "CmptLzTryDecLitPacket": "static int CmptLzTryDecLitPacket(CmptLzDecCtx *decCtx, uint32_t range, uint32_t rangeCode, uint32_t rangeBound,\n                                 const unsigned char *bufTryDec, const unsigned char **pbufLimit)\n{\n    CmptLzDecProb *probBit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    uint32_t procPos = decCtx->processedPos;\n    uint32_t litPosMask = ((uint32_t)0x100 << decCtx->prop.litPos) - ((uint32_t)0x100 >> decCtx->prop.litCtx);\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t dicPos = decCtx->dictPos;\n    const unsigned char *dict = decCtx->dict;\n    const unsigned char *bufLimit = *pbufLimit;\n    if (decCtx->dictPos >= decCtx->dictBufSize)\n    {\n        return CMPT_ERROR_DATA;\n    }\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0 || decCtx->checkDicSize != 0)\n    {\n        probSlot += (uint32_t)3 * ((((procPos << 8) + dict[(dicPos == 0 ? dictBufSize : dicPos) - 1]) & litPosMask)\n                                   << decCtx->prop.litCtx);\n    }\n    uint32_t decSym = 1;\n    if (decCtx->state < CMPTLZ_LIT_STATES)\n    {\n        do\n        {\n            probBit = probSlot + decSym;\n            CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        } while (decSym < 0x100);\n    }\n    else\n    {\n        uint32_t bit;\n        uint32_t matchSym = dict[dicPos - decCtx->reps[0] + ((dicPos < decCtx->reps[0]) ? dictBufSize : 0)];\n        uint32_t offset = 0x100;\n        do\n        {\n            matchSym <<= 1;\n            bit = offset;\n            offset &= matchSym;\n            probBit = probSlot + (offset + bit + decSym);\n            CMPTLZ_MATCH_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        } while (decSym < 0x100);\n    }\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK;\n}",
            "CmptLzTryDecOnePacket": "int CmptLzTryDecOnePacket(CmptLzDecCtx *decCtx, const unsigned char *bufTryDec, const unsigned char **pbufLimit)\n{\n    uint32_t rangeBound = 0;\n    uint32_t range = decCtx->range;\n    uint32_t rangeCode = decCtx->code;\n    uint32_t mkState = decCtx->state;\n    const unsigned char *bufLimit = *pbufLimit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probSlot1;\n    CmptLzDecProb *probSlot2;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t posState = CMPTLZ_CALC_POS_STATE(decCtx->processedPos, pbMask);\n    probSlot1 = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot1);\n    if (rangeCode < rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        return CmptLzTryDecLitPacket(decCtx, range, rangeCode, rangeBound, bufTryDec, pbufLimit);\n    }\n    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    probSlot2 = CmptLzGetIsRepProb(probsMatrix) + mkState;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot2);\n    if (rangeCode < rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        probSlot = CmptLzGetMatchLenCoderProb(probsMatrix);\n        mkState = 0;\n    }\n    else\n    {\n        if (decCtx->dictPos >= decCtx->dictBufSize)\n        {\n            return CMPT_ERROR_DATA;\n        }\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        probSlot = CmptLzGetIsRepG0Prob(probsMatrix) + mkState;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n            probSlot = CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n                *pbufLimit = bufTryDec;\n                return CMPT_OK;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            }\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n            probSlot = CmptLzGetIsRepG1Prob(probsMatrix) + mkState;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n                probSlot = CmptLzGetIsRepG2Prob(probsMatrix) + mkState;\n                rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n                if (rangeCode < rangeBound)\n                {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                }\n                else\n                {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                }\n            }\n        }\n        probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n        mkState = CMPTLZ_MKSTATE_NUM;\n    }\n    return CmptLzTryDecLenAndDist(decCtx, mkState, range, rangeCode, rangeBound, probSlot, bufTryDec, pbufLimit);\n}",
            "CmptLzDecCarefulProcess": "int CmptLzDecCarefulProcess(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *bufLimit)\n{\n    int res = CMPT_OK;\n    uint32_t remainLen;\n    const unsigned char *bufLimitTmp;\n    const unsigned char *pSrcIn;\n    do\n    {\n        bufLimitTmp = bufLimit;\n        pSrcIn = decCtx->buf;\n        res = CmptLzTryDecOnePacket(decCtx, pSrcIn, &bufLimitTmp);\n        if (res == CMPTLZ_DEC_INPUT_EOF)\n        {\n            break;\n        }\n        res = CmptLzDecDirectProcess(decCtx, dicPosLimit, bufLimitTmp);\n        if ((res != CMPT_OK) || (decCtx->buf != bufLimitTmp))\n        {\n            return CMPT_ERROR_DATA;\n        }\n        if (decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN)\n        {\n            break;\n        }\n    } while (decCtx->dictPos < dicPosLimit);\n    if ((res == CMPTLZ_DEC_INPUT_EOF) && (decCtx->buf < bufLimit))\n    {\n        remainLen = (uint32_t)(bufLimit - decCtx->buf);\n        decCtx->tempBufSize = remainLen;\n        for (uint32_t idx = 0; idx < remainLen; idx++)\n        {\n            decCtx->tempBuf[idx] = decCtx->buf[idx];\n        }\n    }\n    return CMPT_OK;\n}",
            "CmptLzDecSinglePacket": "int CmptLzDecSinglePacket(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *pSrcIn, size_t srcInLen,\n                          size_t *psrcCostLen)\n{\n    int res;\n    size_t lookAheadLen = 0;\n    uint32_t newTempBufSize = decCtx->tempBufSize;\n    unsigned char *oldTmpBuf = &(decCtx->tempBuf[decCtx->tempBufSize]);\n    while (newTempBufSize < CMPTLZ_REQUIRED_INPUT_MAX && lookAheadLen < srcInLen)\n    {\n        decCtx->tempBuf[newTempBufSize++] = pSrcIn[lookAheadLen++];\n    }\n    const unsigned char *bufLimit = decCtx->tempBuf + newTempBufSize;\n    res = CmptLzTryDecOnePacket(decCtx, &(decCtx->tempBuf[0]), &bufLimit);\n    if (res == CMPTLZ_DEC_INPUT_EOF)\n    {\n        *psrcCostLen = lookAheadLen;\n        decCtx->tempBufSize = newTempBufSize;\n        return CMPTLZ_DEC_INPUT_EOF;\n    }\n    if (res == CMPT_ERROR_DATA)\n    {\n        return res;\n    }\n    decCtx->buf = &(decCtx->tempBuf[0]);\n    res = CmptLzDecDirectProcess(decCtx, dicPosLimit, bufLimit);\n    if ((res != CMPT_OK) || (bufLimit != decCtx->buf) || (bufLimit <= oldTmpBuf))\n    {\n        *psrcCostLen = 0;\n        return CMPT_ERROR_DATA;\n    }\n    *psrcCostLen = (size_t)(bufLimit - oldTmpBuf);\n    decCtx->tempBufSize = 0;\n    return res;\n}",
            "CmptLzDecCheckDictSizeUpdate": "static void CmptLzDecCheckDictSizeUpdate(CmptLzDecCtx *decCtx)\n{\n    if (decCtx->checkDicSize == 0 && decCtx->processedPos >= decCtx->prop.dicSize)\n    {\n        decCtx->checkDicSize = decCtx->prop.dicSize;\n    }\n}",
            "CmptLzDecRemWriteInDict": "static void CmptLzDecRemWriteInDict(CmptLzDecCtx *decCtx, size_t dicPosLimit)\n{\n    size_t dictPos = decCtx->dictPos;\n    size_t remainDecLen = decCtx->remainLen;\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t remainDicLen = dicPosLimit - dictPos;\n    if (remainDicLen < remainDecLen)\n    {\n        remainDecLen = remainDicLen;\n    }\n    if (remainDecLen == 0)\n    {\n        return;\n    }\n    decCtx->processedPos += (uint32_t)remainDecLen;\n    decCtx->remainLen -= (uint32_t)remainDecLen;\n    unsigned char *dict = decCtx->dict;\n    size_t rep0 = decCtx->reps[0];\n    while (remainDecLen != 0)\n    {\n        remainDecLen--;\n        dict[dictPos] = dict[dictPos - rep0 + (dictPos < rep0 ? dictBufSize : 0)];\n        dictPos++;\n    }\n    decCtx->dictPos = dictPos;\n    CmptLzDecCheckDictSizeUpdate(decCtx);\n}",
            "CmptLzDecGetProbsInit": "static void CmptLzDecGetProbsInit(CmptLzDecCtx *decCtx)\n{\n    uint32_t idx;\n    uint32_t numProbs = CmptLzGetNumProbs(&(decCtx->prop));\n    CmptLzDecProb *decProbs = decCtx->probs;\n    for (idx = 0; idx < numProbs; idx++)\n    {\n        decProbs[idx] = CMPTLZ_PROB_LG >> 1;\n    }\n    decCtx->state = 0;\n}",
            "CmptLzRangeCodeInit": "static void CmptLzRangeCodeInit(CmptLzDecCtx *decCtx)\n{\n    uint32_t rangeCode = (uint32_t)(decCtx->tempBuf[1]) << 24;\n    rangeCode |= (uint32_t)(decCtx->tempBuf[2]) << 16;\n    rangeCode |= (uint32_t)(decCtx->tempBuf[3]) << 8;\n    rangeCode |= (uint32_t)(decCtx->tempBuf[4]);\n    decCtx->code = rangeCode;\n    decCtx->range = 0xFFFFFFFF;\n}",
            "CmptLzDecCtxPrepare": "static int CmptLzDecCtxPrepare(CmptLzDecCtx *decCtx, const unsigned char *pSrcIn, size_t srcInLen,\n                               EnCmptLzStatus *finStatus)\n{\n    size_t readCodeLen = CMPTLZ_RANGE_CODE_SIZE - decCtx->tempBufSize;\n    readCodeLen = (srcInLen < readCodeLen) ? srcInLen : readCodeLen;\n    while (readCodeLen-- > 0)\n    {\n        decCtx->tempBuf[decCtx->tempBufSize++] = *pSrcIn++;\n    }\n    if (decCtx->tempBufSize != 0 && decCtx->tempBuf[0] != 0)\n    {\n        decCtx->tempBufSize = 0;\n        *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n        return CMPT_ERROR_DATA;\n    }\n    if (decCtx->tempBufSize < CMPTLZ_RANGE_CODE_SIZE)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    CmptLzRangeCodeInit(decCtx);\n    if (decCtx->remainLen > CMPTLZ_MATCH_MAX_LEN + 1)\n    {\n        CmptLzDecGetProbsInit(decCtx);\n        decCtx->reps[0] = 1;\n        decCtx->reps[1] = 1;\n        decCtx->reps[2] = 1;\n        decCtx->reps[3] = 1;\n    }\n    decCtx->remainLen = 0;\n    return CMPT_OK;\n}",
            "CmptLzDecDecodeToDic": "int CmptLzDecDecodeToDic(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *pSrcIn, size_t *pStrInLen,\n                         EnCmptLzFinMode finMode, EnCmptLzStatus *finStatus)\n{\n    int res;\n    bool carefulDecDone = false;\n    size_t srcDecLenTmp;\n    size_t srcDecLen = 0;\n    size_t srcInLen = *pStrInLen;\n    if (decCtx->remainLen > CMPTLZ_MATCH_MAX_LEN)\n    {\n        size_t oldTempBufSize = decCtx->tempBufSize;\n        res = CmptLzDecCtxPrepare(decCtx, pSrcIn, srcInLen, finStatus);\n        srcDecLenTmp = (decCtx->tempBufSize - oldTempBufSize);\n        if ((res != CMPT_OK) || (*finStatus == CMPTLZ_STATUS_NEEDS_MORE_INPUT))\n        {\n            *pStrInLen = srcDecLenTmp;\n            return res;\n        }\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n        decCtx->tempBufSize = 0;\n    }\n    if (decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN)\n    {\n        if (decCtx->code != 0)\n        {\n            return CMPT_ERROR_DATA;\n        }\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n    if (decCtx->remainLen != 0)\n    {\n        CmptLzDecRemWriteInDict(decCtx, dicPosLimit);\n    }\n    if (decCtx->tempBufSize != 0)\n    {\n        res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, &srcDecLenTmp);\n        *pStrInLen = srcDecLenTmp;\n        if (res == CMPT_ERROR_DATA)\n        {\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n            return CMPT_ERROR_DATA;\n        }\n        else if (res == CMPTLZ_DEC_INPUT_EOF)\n        {\n            *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n            return CMPT_OK;\n        }\n        else\n        {\n            srcDecLen += srcDecLenTmp;\n            pSrcIn += srcDecLenTmp;\n            srcInLen -= srcDecLenTmp;\n        }\n    }\n    while ((decCtx->dictPos < dicPosLimit) && (carefulDecDone == false))\n    {\n        decCtx->buf = pSrcIn;\n        if (srcInLen <= CMPTLZ_REQUIRED_INPUT_MAX)\n        {\n            res = CmptLzDecCarefulProcess(decCtx, dicPosLimit, pSrcIn + srcInLen);\n            carefulDecDone = true;\n        }\n        else\n        {\n            res = CmptLzDecDirectProcess(decCtx, dicPosLimit, pSrcIn + srcInLen - CMPTLZ_REQUIRED_INPUT_MAX);\n        }\n        srcDecLenTmp = (size_t)(decCtx->buf - pSrcIn) + decCtx->tempBufSize;\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n        if (res == CMPT_ERROR_DATA)\n        {\n            *pStrInLen = srcDecLen;\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n            return CMPT_ERROR_DATA;\n        }\n    }\n    *pStrInLen = srcDecLen;\n    if ((decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n    if (decCtx->dictPos < dicPosLimit)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    if ((decCtx->remainLen == 0) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_MAYBE_FINISHED_WITHOUT_MARK;\n        return CMPT_OK;\n    }\n    if (finMode == CMPTLZ_FINISH_ANY)\n    {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n        return CMPT_OK;\n    }\n    if (decCtx->remainLen != 0)\n    {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n        return CMPT_ERROR_DATA;\n    }\n    srcDecLenTmp = 0;\n    res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, &srcDecLenTmp);\n    srcDecLen += srcDecLenTmp;\n    *pStrInLen = srcDecLen;\n    if (res == CMPTLZ_DEC_INPUT_EOF)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    if ((decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n    *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n    return CMPT_ERROR_DATA;\n}",
            "CmptlzDecompress": "int CmptlzDecompress(void *src, size_t srcSize, void *dst, size_t *dstSize, CmptlzDecParam *param)\n{\n    if (src == NULL || dst == NULL || dstSize == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"The input parameter NULL is incorrect.\");\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n    if (srcSize > 0x7fffffff || *dstSize > 0x7fffffff)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"dstSize:0x%zx srcSize:0x%zx\", *dstSize, srcSize);\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n    if (param == NULL || param->memHook == NULL || param->protData == NULL || param->protSize != CMPTLZ_PROPS_SIZE)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"The compress param NULL is incorrect.\");\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n    CmptLzDecIn decIn = {.pSrcIn = src, .strInLen = srcSize, .strInCostLen = 0};\n    CmptLzDecOut decOut = {.pDestOut = dst, .destOutLen = *dstSize, .destOutFillLen = 0};\n    EnCmptLzStatus enFinStat = CMPTLZ_STATUS_BUT;\n    int ret = CmptLzDecode(&decIn, &decOut, param->protData, CMPTLZ_FINISH_ANY, &enFinStat, param->memHook);\n    *dstSize = decOut.destOutFillLen;\n    return ret;\n}",
            "CmptlzEndMarker": "static void CmptlzEndMarker(void)\n{\n    return;\n}",
            "CmptlzFlush": "static int CmptlzFlush(CmptLzEncCtx *encCtx)\n{\n    encCtx->encNeedFinish = true;\n    if (encCtx->endMarker != 0)\n    {\n        CmptlzEndMarker();\n    }\n    CmptRcFlushData(encCtx->rcCtx);\n    return CmptRcFlush64Kb(encCtx->rcCtx);\n}",
            "CmptPriceCheck": "static void CmptPriceCheck(CmptLzEncCtx *encCtx)\n{\n    if (encCtx->matchPriceCount >= CMPT_PRICE_COUNT)\n    {\n        CmptPriceGenDistTable(encCtx);\n        CmptPriceGenAlignTable(encCtx);\n        CmptPriceGenLenTable(encCtx, &encCtx->matchLenEncoder);\n    }\n    if (encCtx->repLenPriceCount <= 0)\n    {\n        encCtx->repLenPriceCount = CMPT_PRICE_COUNT;\n        CmptPriceGenLenTable(encCtx, &encCtx->repLenEncoder);\n    }\n}",
            "CmptEncShortOrRep0": "static int CmptEncShortOrRep0(CmptLzEncCtx *encCtx, uint32_t nowpos32, uint32_t lenRes)\n{\n    int shiftRes = CMPT_OK;\n    if (lenRes == 1)\n    {\n        shiftRes = CmptlzEncShortRep(encCtx, nowpos32);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    else\n    {\n        shiftRes = CmptlzEncLongRep(encCtx, 0, nowpos32, lenRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    return CMPT_OK;\n}",
            "CmptEncodeOneBlock": "int CmptEncodeOneBlock(CmptLzEncCtx *encCtx)\n{\n    CmptMfCtx *mf = encCtx->mfCtx;\n    uint32_t nowpos32 = encCtx->nowpos64;\n    uint32_t startpos = nowpos32;\n    uint32_t backRes, lenRes;\n    int shiftRes = CMPT_OK;\n    while (true)\n    {\n        CmptlzDp(encCtx, mf, nowpos32);\n        backRes = encCtx->backRes;\n        lenRes = encCtx->lenRes;\n        switch (backRes)\n        {\n        case CMPTLZ_UINT32_MAX:\n            shiftRes = CmptlzEncLit(encCtx, mf, nowpos32);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 0:\n            shiftRes = CmptEncShortOrRep0(encCtx, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 1:\n            shiftRes = CmptlzEncLongRep(encCtx, 1, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 2:\n            shiftRes = CmptlzEncLongRep(encCtx, 2, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 3:\n            shiftRes = CmptlzEncLongRep(encCtx, 3, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        default:\n            shiftRes = CmptlzEncNormalMatch(encCtx, nowpos32, backRes, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        }\n        nowpos32 += lenRes;\n        mf->mfStart += lenRes;\n        mf->readAhead -= lenRes;\n        if (mf->readAhead == 0)\n        {\n            CmptPriceCheck(encCtx);\n            if (mf->srcLen <= mf->mfStart)\n            {\n                break;\n            }\n            if (nowpos32 - startpos >= CMPT_ONE_BLOCK_MAX_SIZE)\n            {\n                encCtx->nowpos64 += nowpos32 - startpos;\n                return 0;\n            }\n        }\n    }\n    encCtx->nowpos64 += nowpos32 - startpos;\n    return CmptlzFlush(encCtx);\n}",
            "CmptEncodeAll": "int CmptEncodeAll(CmptLzEncCtx *encCtx)\n{\n    CmptRcCtx *rc = encCtx->rcCtx;\n    CmptMfCtx *mf = encCtx->mfCtx;\n    if (mf->srcLen == 0)\n    {\n        return CmptlzFlush(encCtx);\n    }\n    if (encCtx->nowpos64 == 0)\n    {\n        uint32_t range, bit0Prob, newBound;\n        range = rc->range;\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][0];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        int shiftRes = CMPT_OK;\n        CMPT_RC_BIT_0_PROCESS(rc, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        rc->range = range;\n        uint8_t curByte = *(mf->srcStart);\n        CmptlzProb *litProb = &encCtx->litMarcov.literal[0][0];\n        shiftRes = CmptRcLitProcess(rc, litProb, curByte);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        mf->mfStart++;\n        encCtx->nowpos64++;\n        mf->readPos++;\n        if (mf->srcLen == 1)\n        {\n            return CmptlzFlush(encCtx);\n        }\n    }\n    int res;\n    while (true)\n    {\n        res = CmptEncodeOneBlock(encCtx);\n        if (res != 0 || encCtx->encNeedFinish)\n        {\n            break;\n        }\n    }\n    return res;\n}",
            "CmptlzDpInitShortRep": "static void CmptlzDpInitShortRep(CmptLzEncCtx *encCtx, uint32_t repMatchPrice, const uint32_t posState)\n{\n    const uint32_t shortRepPrice = repMatchPrice + CmptPriceShortRep(encCtx, encCtx->state, posState);\n    if (shortRepPrice < encCtx->opts[1].price)\n    {\n        encCtx->opts[1].price = shortRepPrice;\n        encCtx->opts[1].backPrev = 0;\n    }\n}",
            "CmptlzDpInitLongRep": "static void CmptlzDpInitLongRep(CmptLzEncCtx *encCtx, uint32_t *repLens, const uint32_t repMatchPrice,\n                                const uint32_t posState)\n{\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        uint32_t repLen = repLens[i];\n        if (repLen < CMPTLZ_MATCH_LEN_MIN)\n        {\n            continue;\n        }\n        const uint32_t price = repMatchPrice + CmptPriceLongRep(encCtx, i, encCtx->state, posState);\n        do\n        {\n            const uint32_t curAndLenPrice = price + CmptPriceLen(&encCtx->repLenEncoder, repLen, posState);\n            if (curAndLenPrice < encCtx->opts[repLen].price)\n            {\n                encCtx->opts[repLen].price = curAndLenPrice;\n                encCtx->opts[repLen].posPrev = 0;\n                encCtx->opts[repLen].backPrev = i;\n            }\n            repLen--;\n        } while (repLen >= CMPTLZ_MATCH_LEN_MIN);\n    }\n}",
            "CmptlzDpInitMatch": "static void CmptlzDpInitMatch(CmptLzEncCtx *encCtx, uint32_t matchesCount, uint32_t normalMatchPrice, uint32_t posState,\n                              uint32_t len)\n{\n    uint32_t i = 0;\n    while (len > encCtx->matches[i].len)\n    {\n        i++;\n    }\n    for (;; len++)\n    {\n        const uint32_t dist = encCtx->matches[i].dist;\n        const uint32_t curAndLenPrice = normalMatchPrice + CmptPriceDistWithLen(encCtx, dist, len, posState);\n        if (curAndLenPrice < encCtx->opts[len].price)\n        {\n            encCtx->opts[len].price = curAndLenPrice;\n            encCtx->opts[len].posPrev = 0;\n            encCtx->opts[len].backPrev = dist + CMPTLZ_NUM_REPS;\n        }\n        if (len == encCtx->matches[i].len)\n        {\n            if (++i == matchesCount)\n            {\n                break;\n            }\n        }\n    }\n}",
            "CmptlzDpInit": "static uint32_t CmptlzDpInit(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t position)\n{\n    const uint32_t niceLen = mf->niceLen;\n    uint32_t lenMain;\n    uint32_t matchesCount = 0;\n    if (mf->readAhead == 0)\n    {\n        lenMain = CmptlzMatchFinder(mf, &matchesCount, encCtx->matches);\n    }\n    else\n    {\n        lenMain = encCtx->longestMatchLen;\n        matchesCount = encCtx->matchesCount;\n    }\n    const uint8_t *const buf = CmptMfGetPtr(mf) - 1;\n    const uint32_t bufAvail = CMPTLZ_FIND_MIN(CmptMfAvail(mf) + 1, CMPT_MF_LONGEST_MATCH);\n    if (bufAvail < CMPTLZ_MATCH_LEN_MIN)\n    {\n        encCtx->backRes = CMPTLZ_UINT32_MAX;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n    uint32_t repLens[CMPTLZ_NUM_REPS];\n    uint32_t repMaxIndex = 0;\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        const uint8_t *const bufBack = buf - encCtx->reps[i] - 1;\n        if (NOT_EQUAL_2_BYTES(buf, bufBack))\n        {\n            repLens[i] = 0;\n            continue;\n        }\n        repLens[i] = CmptMemCmpLenSafe(buf, bufBack, CMPTLZ_MATCH_LEN_MIN, bufAvail);\n        if (repLens[i] > repLens[repMaxIndex])\n        {\n            repMaxIndex = i;\n        }\n    }\n    if (repLens[repMaxIndex] >= niceLen)\n    {\n        encCtx->backRes = repMaxIndex;\n        encCtx->lenRes = repLens[repMaxIndex];\n        CmptlzMatchSkiper(mf, repLens[repMaxIndex] - 1);\n        return CMPTLZ_UINT32_MAX;\n    }\n    if (lenMain >= niceLen)\n    {\n        encCtx->backRes = encCtx->matches[matchesCount - 1].dist + CMPTLZ_NUM_REPS;\n        encCtx->lenRes = lenMain;\n        CmptlzMatchSkiper(mf, lenMain - 1);\n        return CMPTLZ_UINT32_MAX;\n    }\n    const uint8_t currentByte = *buf;\n    const uint8_t matchByte = *(buf - encCtx->reps[0] - 1);\n    const uint32_t lenEnd = CMPTLZ_FIND_MAX(lenMain, repLens[repMaxIndex]);\n    if ((lenEnd < CMPTLZ_MATCH_LEN_MIN) && (currentByte != matchByte))\n    {\n        encCtx->backRes = CMPTLZ_UINT32_MAX;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n    encCtx->opts[0].state = encCtx->state;\n    const uint32_t posState = position & encCtx->posMask;\n    encCtx->litMarcov.pos = position;\n    encCtx->litMarcov.prevByte = *(buf - 1);\n    bool isLiteralState = (encCtx->state < 7);\n    bool isMatchMode = !isLiteralState;\n    encCtx->opts[1].price = CmptPriceBit0(encCtx, encCtx->isMatch[encCtx->state][posState]) +\n                            CmptPriceLiteral(encCtx, isMatchMode, matchByte, currentByte);\n    encCtx->opts[1].backPrev = CMPTLZ_UINT32_MAX;\n    const uint32_t matchPrice = CmptPriceBit1(encCtx, encCtx->isMatch[encCtx->state][posState]);\n    const uint32_t repMatchPrice = matchPrice + CmptPriceBit1(encCtx, encCtx->isRep[encCtx->state]);\n    if (matchByte == currentByte)\n    {\n        CmptlzDpInitShortRep(encCtx, repMatchPrice, posState);\n    }\n    if (lenEnd < CMPTLZ_MATCH_LEN_MIN)\n    {\n        encCtx->backRes = encCtx->opts[1].backPrev;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n    encCtx->opts[1].posPrev = 0;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->opts[0].backs[i] = encCtx->reps[i];\n    }\n    uint32_t len = lenEnd;\n    do\n    {\n        encCtx->opts[len].price = CMPT_INFINITY_PRICE;\n        len--;\n    } while (len >= CMPTLZ_MATCH_LEN_MIN);\n    CmptlzDpInitLongRep(encCtx, repLens, repMatchPrice, posState);\n    const uint32_t normalMatchPrice = matchPrice + CmptPriceBit0(encCtx, encCtx->isRep[encCtx->state]);\n    len = (repLens[0] > CMPTLZ_MATCH_LEN_MIN) ? repLens[0] + 1 : CMPTLZ_MATCH_LEN_MIN;\n    if (len <= lenMain)\n    {\n        CmptlzDpInitMatch(encCtx, matchesCount, normalMatchPrice, posState, len);\n    }\n    return lenEnd;\n}",
            "CmptlzDpPre": "static void CmptlzDpPre(CmptLzEncCtx *encCtx, uint32_t *mainReps, const uint32_t cur)\n{\n    uint32_t posPointer = encCtx->opts[cur].posPrev;\n    CmptlzState state = encCtx->opts[posPointer].state;\n    if (posPointer == cur - 1)\n    {\n        if (encCtx->opts[cur].backPrev == 0)\n        {\n            CMPT_STATE_UPDATE_WHEN_SHORTREP(state);\n        }\n        else\n        {\n            CMPT_STATE_UPDATE_WHEN_LIT(state);\n        }\n    }\n    else\n    {\n        uint32_t backPointer;\n        backPointer = encCtx->opts[cur].backPrev;\n        if (backPointer < CMPTLZ_NUM_REPS)\n        {\n            CMPT_STATE_UPDATE_WHEN_LONGREP(state);\n        }\n        else\n        {\n            CMPT_STATE_UPDATE_WHEN_MATCH(state);\n        }\n        uint32_t i;\n        if (backPointer < CMPTLZ_NUM_REPS)\n        {\n            mainReps[0] = encCtx->opts[posPointer].backs[backPointer];\n            for (i = 1; i <= backPointer; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i - 1];\n            }\n            for (; i < CMPTLZ_NUM_REPS; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i];\n            }\n        }\n        else\n        {\n            mainReps[0] = backPointer - CMPTLZ_NUM_REPS;\n            for (i = 1; i < CMPTLZ_NUM_REPS; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i - 1];\n            }\n        }\n    }\n    encCtx->opts[cur].state = state;\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->opts[cur].backs[i] = mainReps[i];\n    }\n}",
            "CmptlzDpTryCurAndLit": "static void CmptlzDpTryCurAndLit(CmptLzEncCtx *encCtx, const uint32_t curPrice, CmptlzState curState,\n                                 const uint32_t posState, const uint32_t cur, const uint8_t latestMatchByte,\n                                 const uint8_t curByte)\n{\n    bool isLiteralState = (curState < 7);\n    bool isMatchMode = !isLiteralState;\n    const uint32_t curAndLitPrice = curPrice + CmptPriceBit0(encCtx, encCtx->isMatch[curState][posState]) +\n                                    CmptPriceLiteral(encCtx, isMatchMode, latestMatchByte, curByte);\n    if (curAndLitPrice < encCtx->opts[cur + 1].price)\n    {\n        encCtx->opts[cur + 1].price = curAndLitPrice;\n        encCtx->opts[cur + 1].posPrev = cur;\n        encCtx->opts[cur + 1].backPrev = CMPTLZ_UINT32_MAX;\n    }\n}",
            "CmptlzDpTryCurAndShort": "static void CmptlzDpTryCurAndShort(CmptLzEncCtx *encCtx, const uint32_t repMatchPrice, const uint32_t cur,\n                                   CmptlzState curState, const uint32_t posState)\n{\n    const uint32_t shortRepPrice = repMatchPrice + CmptPriceShortRep(encCtx, curState, posState);\n    if (shortRepPrice < encCtx->opts[cur + 1].price)\n    {\n        encCtx->opts[cur + 1].price = shortRepPrice;\n        encCtx->opts[cur + 1].posPrev = cur;\n        encCtx->opts[cur + 1].backPrev = 0;\n    }\n}",
            "CmptlzDpTryCurAndLong": "static void CmptlzDpTryCurAndLong(CmptLzEncCtx *encCtx, const uint32_t prefixPrice, const uint32_t cur,\n                                  uint32_t mainRepIndex, uint32_t lenEqual, const uint32_t posState)\n{\n    do\n    {\n        const uint32_t curLongRepPrice = prefixPrice + CmptPriceLen(&encCtx->repLenEncoder, lenEqual, posState);\n        if (curLongRepPrice < encCtx->opts[cur + lenEqual].price)\n        {\n            encCtx->opts[cur + lenEqual].price = curLongRepPrice;\n            encCtx->opts[cur + lenEqual].posPrev = cur;\n            encCtx->opts[cur + lenEqual].backPrev = mainRepIndex;\n        }\n    } while (--lenEqual >= CMPTLZ_MATCH_LEN_MIN);\n}",
            "CmptlzDpTryCurAndMatch": "static void CmptlzDpTryCurAndMatch(CmptLzEncCtx *encCtx, uint32_t startLen, uint32_t matchCount,\n                                   const uint32_t normalmatch_prefixPrice, const uint32_t cur, const uint32_t posState)\n{\n    uint32_t i = 0;\n    while (startLen > encCtx->matches[i].len)\n    {\n        i++;\n    }\n    uint32_t lenTest;\n    for (lenTest = startLen;; lenTest++)\n    {\n        const uint32_t curBack = encCtx->matches[i].dist;\n        uint32_t cur_normalmatchPrice =\n            normalmatch_prefixPrice + CmptPriceDistWithLen(encCtx, curBack, lenTest, posState);\n        if (cur_normalmatchPrice < encCtx->opts[cur + lenTest].price)\n        {\n            encCtx->opts[cur + lenTest].price = cur_normalmatchPrice;\n            encCtx->opts[cur + lenTest].posPrev = cur;\n            encCtx->opts[cur + lenTest].backPrev = curBack + CMPTLZ_NUM_REPS;\n        }\n        if (lenTest == encCtx->matches[i].len)\n        {\n            if (++i == matchCount)\n            {\n                break;\n            }\n        }\n    }\n}",
            "CmptlzDpProcess": "static uint32_t CmptlzDpProcess(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t *mainReps, uint32_t lenEnd,\n                                uint32_t position, const uint32_t cur)\n{\n    CmptlzState curState = encCtx->opts[cur].state;\n    const uint32_t bufAvailFull = CMPTLZ_FIND_MIN(CmptMfAvail(mf) + 1, CMPT_DP_OPTMAX - 1 - cur);\n    const uint8_t *buf = CmptMfGetPtr(mf) - 1;\n    const uint32_t niceLen = mf->niceLen;\n    const uint32_t curPrice = encCtx->opts[cur].price;\n    const uint8_t curByte = *buf;\n    const uint8_t latestMatchByte = *(buf - mainReps[0] - 1);\n    const uint32_t posState = position & encCtx->posMask;\n    encCtx->litMarcov.pos = position;\n    encCtx->litMarcov.prevByte = *(buf - 1);\n    CmptlzDpTryCurAndLit(encCtx, curPrice, curState, posState, cur, latestMatchByte, curByte);\n    const uint32_t matchPrice = curPrice + CmptPriceBit1(encCtx, encCtx->isMatch[curState][posState]);\n    const uint32_t repMatchPrice = matchPrice + CmptPriceBit1(encCtx, encCtx->isRep[curState]);\n    if (curByte == latestMatchByte && !(encCtx->opts[cur + 1].posPrev < cur && encCtx->opts[cur + 1].backPrev == 0))\n    {\n        CmptlzDpTryCurAndShort(encCtx, repMatchPrice, cur, curState, posState);\n    }\n    if (bufAvailFull < CMPTLZ_MATCH_LEN_MIN)\n    {\n        return lenEnd;\n    }\n    const uint32_t bufAvail = CMPTLZ_FIND_MIN(bufAvailFull, niceLen);\n    uint32_t startLen = CMPTLZ_MATCH_LEN_MIN;\n    uint32_t mainRepIndex;\n    for (mainRepIndex = 0; mainRepIndex < CMPTLZ_NUM_REPS; mainRepIndex++)\n    {\n        const uint8_t *const bufRepBack = buf - mainReps[mainRepIndex] - 1;\n        if (NOT_EQUAL_2_BYTES(buf, bufRepBack))\n        {\n            continue;\n        }\n        uint32_t lenEqual;\n        lenEqual = CmptMemCmpLenSafe(buf, bufRepBack, CMPTLZ_MATCH_LEN_MIN, bufAvail);\n        while (lenEnd < cur + lenEqual)\n        {\n            lenEnd++;\n            encCtx->opts[lenEnd].price = CMPT_INFINITY_PRICE;\n        }\n        const uint32_t lenEqualMem = lenEqual;\n        const uint32_t prefixPrice = repMatchPrice + CmptPriceLongRep(encCtx, mainRepIndex, curState, posState);\n        CmptlzDpTryCurAndLong(encCtx, prefixPrice, cur, mainRepIndex, lenEqual, posState);\n        lenEqual = lenEqualMem;\n        if (mainRepIndex == 0)\n        {\n            startLen = lenEqual + 1;\n        }\n    }\n    uint32_t newLongestLen = encCtx->longestMatchLen;\n    uint32_t matchCount = encCtx->matchesCount;\n    if (newLongestLen > bufAvail)\n    {\n        newLongestLen = bufAvail;\n        matchCount = 0;\n        while (newLongestLen > encCtx->matches[matchCount].len)\n        {\n            ++matchCount;\n        }\n        encCtx->matches[matchCount++].len = newLongestLen;\n    }\n    if (newLongestLen >= startLen)\n    {\n        const uint32_t normalmatch_prefixPrice = matchPrice + CmptPriceBit0(encCtx, encCtx->isRep[curState]);\n        while (lenEnd < cur + newLongestLen)\n        {\n            lenEnd++;\n            encCtx->opts[lenEnd].price = CMPT_INFINITY_PRICE;\n        }\n        CmptlzDpTryCurAndMatch(encCtx, startLen, matchCount, normalmatch_prefixPrice, cur, posState);\n    }\n    return lenEnd;\n}",
            "CmptlzDpReverse": "static void CmptlzDpReverse(CmptLzEncCtx *encCtx, uint32_t cur)\n{\n    encCtx->optEndIndex = cur;\n    uint32_t posTmp = encCtx->opts[cur].posPrev;\n    uint32_t backTmp = encCtx->opts[cur].backPrev;\n    uint32_t posPrev, backCurPacket;\n    do\n    {\n        posPrev = posTmp;\n        backCurPacket = backTmp;\n        backTmp = encCtx->opts[posPrev].backPrev;\n        posTmp = encCtx->opts[posPrev].posPrev;\n        encCtx->opts[posPrev].backPrev = backCurPacket;\n        encCtx->opts[posPrev].posPrev = cur;\n        cur = posPrev;\n    } while (cur != 0);\n    encCtx->lenRes = encCtx->opts[0].posPrev;\n    encCtx->backRes = encCtx->opts[0].backPrev;\n    encCtx->optsCurIndex = encCtx->opts[0].posPrev;\n}",
            "CmptlzDp": "void CmptlzDp(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t position)\n{\n    uint32_t curIndex = encCtx->optsCurIndex;\n    uint32_t endIndex = encCtx->optEndIndex;\n    if (endIndex != curIndex)\n    {\n        encCtx->lenRes = encCtx->opts[curIndex].posPrev - curIndex;\n        encCtx->backRes = encCtx->opts[curIndex].backPrev;\n        encCtx->optsCurIndex = encCtx->opts[curIndex].posPrev;\n        return;\n    }\n    uint32_t lenEnd = CmptlzDpInit(encCtx, mf, position);\n    if (lenEnd == CMPTLZ_UINT32_MAX)\n    {\n        return;\n    }\n    uint32_t mainReps[CMPTLZ_NUM_REPS];\n    memcpy_s(mainReps, sizeof(mainReps), encCtx->reps, sizeof(encCtx->reps));\n    uint32_t cur;\n    for (cur = 1; cur < lenEnd; cur++)\n    {\n        encCtx->longestMatchLen = CmptlzMatchFinder(mf, &encCtx->matchesCount, encCtx->matches);\n        if (encCtx->longestMatchLen >= mf->niceLen)\n        {\n            break;\n        }\n        CmptlzDpPre(encCtx, mainReps, cur);\n        lenEnd = CmptlzDpProcess(encCtx, mf, mainReps, lenEnd, position + cur, cur);\n    }\n    CmptlzDpReverse(encCtx, cur);\n    return;\n}",
            "CmptHeadWrite": "int CmptHeadWrite(CmptLzEncCtx *encCtx, uint8_t *protData, size_t *propsSize)\n{\n    if (protData == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_DATA, \"protData is NULL\");\n        return CMPT_ENC_ERROR_HEAD;\n    }\n    if (*propsSize < CMPTLZ_PROPS_SIZE)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_DATA, \"propsSize need 5 bytes, get %zu\", *propsSize);\n        return CMPT_ENC_ERROR_HEAD;\n    }\n    CmptlzWriteLE32Bit(protData + 1, encCtx->dicSize);\n    protData[0] = (encCtx->posBits * CMPTLZ_POS_STATE_MAX + encCtx->litPos) * CMPTLZ_LIT_CTX_MAX + encCtx->litCtx;\n    *propsSize = CMPTLZ_PROPS_SIZE;\n    return 0;\n}",
            "CmptlzParamNormalize": "void CmptlzParamNormalize(CmptlzEncParam *props)\n{\n    int level = props->level;\n    if (level < 0 || level > 9)\n    {\n        level = 5;\n    }\n    props->level = level;\n    if (props->dictSize < CMPTLZ_MIN_DICTSIZE || props->dictSize > CMPTLZ_MAX_DICTSIZE)\n    {\n        CMPTLZ_SET_DICTSIZE_BY_LEVEL(level, props->dictSize);\n    }\n    if (props->fastBytes < 5 || props->fastBytes > CMPT_MF_LONGEST_MATCH)\n    {\n        CMPTLZ_SET_FB_BY_LEVEL(level, props->fastBytes);\n    }\n    if (props->litCtx < 0 || props->litCtx > CMPTLZ_LC_MAX)\n    {\n        props->litCtx = 3;\n    }\n    if (props->litPos < 0 || props->litPos > CMPTLZ_LP_MAX)\n    {\n        props->litPos = 0;\n    }\n    if (props->posBits < 0 || props->posBits > CMPTLZ_PB_MAX)\n    {\n        props->posBits = 2;\n    }\n    props->numThreads = 1;\n}",
            "CmptlzSetParam": "void CmptlzSetParam(CmptLzEncCtx *encCtx, const CmptlzEncParam *props)\n{\n    CmptlzEncParam param = *props;\n    CmptlzParamNormalize(&param);\n    encCtx->dicSize = param.dictSize;\n    encCtx->numFastBytes = param.fastBytes;\n    encCtx->litCtx = param.litCtx;\n    encCtx->litPos = param.litPos;\n    encCtx->posBits = param.posBits;\n    uint32_t i;\n    for (i = 7; i < 32; i++)\n    {\n        if (encCtx->dicSize <= (uint32_t)(1 << i))\n        {\n            break;\n        }\n    }\n    encCtx->distTableSize = i * 2;\n}",
            "CmptlzPriceInit": "void CmptlzPriceInit(CmptLzEncCtx *encCtx)\n{\n    CmptPriceGenRootTable(encCtx);\n    CmptPriceGenDistTable(encCtx);\n    CmptPriceGenAlignTable(encCtx);\n}",
            "CmptlzEncPrepare": "void CmptlzEncPrepare(CmptLzEncCtx *encCtx)\n{\n    uint32_t i;\n    uint32_t j;\n    encCtx->encNeedFinish = false;\n    encCtx->cmptlzResponse = 0;\n    encCtx->nowpos64 = 0;\n    encCtx->state = 0;\n    encCtx->pbMask = (1 << encCtx->posBits) - 1;\n    encCtx->lpMask = ((uint32_t)0x100 << encCtx->litPos) - ((uint32_t)0x100 >> encCtx->litCtx);\n    encCtx->posMask = (1 << encCtx->posBits) - 1;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->reps[i] = 0;\n    }\n    encCtx->optsCurIndex = 0;\n    encCtx->optEndIndex = 0;\n    for (i = 0; i < CMPT_DP_OPTMAX; i++)\n    {\n        encCtx->opts[i].price = CMPT_INFINITY_PRICE;\n    }\n    for (i = 0; i < CMPTLZ_NUM_STATES; i++)\n    {\n        for (j = 0; j < CMPTLZ_NUM_PB_STATES_MAX; j++)\n        {\n            encCtx->isMatch[i][j] = CMPTLZ_PROB_INIT;\n            encCtx->isRep0Long[i][j] = CMPTLZ_PROB_INIT;\n        }\n        encCtx->isRep[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG0[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG1[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG2[i] = CMPTLZ_PROB_INIT;\n    }\n    for (i = 0; i < CMPTLZ_DIST_STATE_TOTAL; i++)\n    {\n        for (j = 0; j < (1 << CMPTLZ_DIST_SLOT_BITS); j++)\n        {\n            encCtx->probDistSlot[i][j] = CMPTLZ_PROB_INIT;\n        }\n    }\n    for (i = 0; i < CMPT_DIST_LIMIT_2; i++)\n    {\n        encCtx->probDistSpecial[i] = CMPTLZ_PROB_INIT;\n    }\n    for (i = 0; i < (1 << CMPTLZ_ALIGN_BITS); i++)\n    {\n        encCtx->probAlign[i] = CMPTLZ_PROB_INIT;\n    }\n    encCtx->litMarcov.lcBits = encCtx->litCtx;\n    encCtx->litMarcov.posMask = (1U << encCtx->litPos) - 1;\n    for (i = 0; i < (1 << CMPTLZ_LCLP_MAX); i++)\n    {\n        for (j = 0; j < CMPTLZ_LIT_MAX_SIZE; j++)\n        {\n            encCtx->litMarcov.literal[i][j] = CMPTLZ_PROB_INIT;\n        }\n    }\n    for (i = 0; i < (1 << CMPT_LEN_HIGH_BITS); i++)\n    {\n        encCtx->matchLenEncoder.high[i] = CMPTLZ_PROB_INIT;\n        encCtx->repLenEncoder.high[i] = CMPTLZ_PROB_INIT;\n        encCtx->matchLenEncoder.low[i] = CMPTLZ_PROB_INIT;\n        encCtx->repLenEncoder.low[i] = CMPTLZ_PROB_INIT;\n    }\n    CmptlzPriceInit(encCtx);\n    encCtx->repLenEncoder.tableSize = encCtx->numFastBytes - 1;\n    encCtx->matchLenEncoder.tableSize = encCtx->numFastBytes - 1;\n    CmptPriceGenLenTable(encCtx, &encCtx->matchLenEncoder);\n    CmptPriceGenLenTable(encCtx, &encCtx->repLenEncoder);\n}",
            "CmptInitCctx": "void *CmptInitCctx(CmptLzMemHook *alloc, int writeEndMark)\n{\n    void *handle = alloc->CmptLzAlloc(CMPTLZ_ENC_CCTX_HANDLE, sizeof(CmptLzEncCtx));\n    if (handle == NULL)\n    {\n        return NULL;\n    }\n    memset_s(handle, sizeof(CmptLzEncCtx), 0, sizeof(CmptLzEncCtx));\n    CmptLzEncCtx *encCtx = (CmptLzEncCtx *)handle;\n    encCtx->endMarker = writeEndMark;\n    encCtx->rcCtx = NULL;\n    encCtx->mfCtx = NULL;\n    return encCtx;\n}",
            "CmptMemCmpByOneByte": "static uint32_t CmptMemCmpByOneByte(const uint8_t *buf1, const uint8_t *buf2, uint32_t len, uint32_t limit)\n{\n    uint32_t lenIn = len;\n    while ((lenIn < limit) && (buf1[lenIn] == buf2[lenIn]))\n    {\n        lenIn++;\n    }\n    return lenIn;\n}",
            "CmptMemCmpLenSafe": "static uint32_t CmptMemCmpLenSafe(const uint8_t *buf1, const uint8_t *buf2, uint32_t len, uint32_t limit)\n{\n    return CmptMemCmpByOneByte(buf1, buf2, len, limit);\n}",
            "CmptMfAvail": "static uint32_t CmptMfAvail(const CmptMfCtx *mf)\n{\n    return mf->srcLen - mf->readPos;\n}",
            "CmptMfGetPtr": "static const uint8_t *CmptMfGetPtr(const CmptMfCtx *mf)\n{\n    return mf->srcStart + mf->readPos;\n}",
            "PosSlotHelper": "static uint32_t PosSlotHelper(uint32_t n)\n{\n    uint32_t i = 31;\n    if ((n & 0xFFFF0000) == 0)\n    {\n        n <<= 16;\n        i = 15;\n    }\n    if ((n & 0xFF000000) == 0)\n    {\n        n <<= 8;\n        i -= 8;\n    }\n    if ((n & 0xF0000000) == 0)\n    {\n        n <<= 4;\n        i -= 4;\n    }\n    if ((n & 0xC0000000) == 0)\n    {\n        n <<= 2;\n        i -= 2;\n    }\n    if ((n & 0x80000000) == 0)\n        --i;\n    return i;\n}",
            "PosSloter": "static uint32_t PosSloter(uint32_t dist)\n{\n    if (dist <= 4)\n    {\n        return dist;\n    }\n    uint32_t helper = PosSlotHelper(dist);\n    return (helper + helper + ((dist >> (helper - 1)) & 1));\n}",
            "CmptlzMfGenHashTable": "static void CmptlzMfGenHashTable(CmptMfCtx *mf)\n{\n    uint32_t *hashRootTable = mf->hashRootTable;\n    const uint32_t poly32 = 0xEDB88320;\n    uint32_t i, j;\n    for (i = 0; i < CMPT_MF_HASH_TABLE_SIZE; i++)\n    {\n        uint32_t value = i;\n        for (j = 0; j < 8; j++)\n        {\n            if (value & 1)\n            {\n                value = (value >> 1) ^ poly32;\n            }\n            else\n            {\n                value >>= 1;\n            }\n        }\n        hashRootTable[i] = value;\n    }\n    return;\n}",
            "CmptMfPrepare": "int CmptMfPrepare(CmptLzEncCtx *encCtx, const uint8_t *src, size_t srcLen, CmptLzMemHook *alloc)\n{\n    CmptMfCtx *mf = alloc->CmptLzAlloc(CMPTLZ_MF_CCTX_HANDLE, sizeof(CmptMfCtx));\n    if (mf == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    memset_s(mf, sizeof(CmptMfCtx), 0, sizeof(CmptMfCtx));\n    encCtx->mfCtx = mf;\n    mf->cycleSize = encCtx->dicSize + 1;\n    uint32_t hashMask = encCtx->dicSize - 1;\n    CMPT_HASH_MASK_CALC(hashMask);\n    mf->hashMask = hashMask;\n    ++hashMask;\n    hashMask += CMPTLZ_HASH_2_SIZE;\n    hashMask += CMPTLZ_HASH_3_SIZE;\n    mf->hashCount = hashMask;\n    mf->sonsCount = mf->cycleSize * 2;\n    mf->hash = NULL;\n    mf->son = NULL;\n    mf->hash = alloc->CmptLzAlloc(CMPTLZ_MF_HASH_HANDLE, mf->hashCount * sizeof(uint32_t));\n    memset_s(mf->hash, mf->hashCount * sizeof(uint32_t), 0, mf->hashCount * sizeof(uint32_t));\n    if (mf->hash == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    mf->son = alloc->CmptLzAlloc(CMPTLZ_MF_SON_HANDLE, mf->sonsCount * sizeof(uint32_t));\n    memset_s(mf->son, mf->sonsCount * sizeof(uint32_t), 0, mf->sonsCount * sizeof(uint32_t));\n    if (mf->son == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    CmptlzMfGenHashTable(mf);\n    mf->srcStart = src;\n    mf->srcLen = srcLen;\n    mf->offset = mf->cycleSize;\n    mf->niceLen = encCtx->numFastBytes;\n    mf->depth = CMPT_MF_BASE_DEPTH + mf->niceLen / 2;\n    return 0;\n}",
            "CmptMfMovePos": "static void CmptMfMovePos(CmptMfCtx *mf)\n{\n    const uint32_t subvalue = (CMPTLZ_UINT32_MAX - mf->cycleSize);\n    uint32_t i;\n    for (i = 0; i < mf->hashCount; i++)\n    {\n        if (mf->hash[i] <= subvalue)\n        {\n            mf->hash[i] = CMPT_EMPTY_HASH_VALUE;\n        }\n        else\n        {\n            mf->hash[i] -= subvalue;\n        }\n    }\n    for (i = 0; i < mf->sonsCount; ++i)\n    {\n        if (mf->son[i] <= subvalue)\n        {\n            mf->son[i] = CMPT_EMPTY_HASH_VALUE;\n        }\n        else\n        {\n            mf->son[i] -= subvalue;\n        }\n    }\n    mf->offset -= subvalue;\n}",
            "CmptBtFind": "static CmptlzMatchPair *CmptBtFind(CmptMfCtx *mf, uint32_t curMatch, CmptlzMatchPair *matches, uint32_t longestLen)\n{\n    uint32_t depth = mf->depth;\n    uint32_t *const son = mf->son;\n    const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n    const uint32_t niceLen = mf->niceLen;\n    const uint32_t cyclePos = mf->cyclePos;\n    const uint32_t cycleSize = mf->cycleSize;\n    const uint32_t pos = mf->readPos + mf->offset;\n    uint32_t *ptr0 = son + (cyclePos << 1) + 1;\n    uint32_t *ptr1 = son + (cyclePos << 1);\n    uint32_t len0 = 0;\n    uint32_t len1 = 0;\n    while (true)\n    {\n        const uint32_t delta = pos - curMatch;\n        if (depth-- == 0 || delta >= cycleSize)\n        {\n            *ptr0 = CMPT_EMPTY_HASH_VALUE;\n            *ptr1 = CMPT_EMPTY_HASH_VALUE;\n            return matches;\n        }\n        uint32_t *const pair = son + ((cyclePos - delta + ((delta > cyclePos) ? cycleSize : 0)) << 1);\n        const uint8_t *const pb = cur - delta;\n        uint32_t len = CMPTLZ_FIND_MIN(len0, len1);\n        if (pb[len] == cur[len])\n        {\n            len = CmptMemCmpLenSafe(pb, cur, len + 1, niceLen);\n            if (longestLen < len)\n            {\n                longestLen = len;\n                matches->len = len;\n                matches->dist = delta - 1;\n                ++matches;\n                if (len == niceLen)\n                {\n                    *ptr1 = pair[0];\n                    *ptr0 = pair[1];\n                    return matches;\n                }\n            }\n        }\n        if (pb[len] < cur[len])\n        {\n            CMPT_MF_LEFT_SON_UPDATE(ptr1, pair, curMatch, len1, len);\n        }\n        else\n        {\n            CMPT_MF_RIGHT_SON_UPDATE(ptr0, pair, curMatch, len0, len);\n        }\n    }\n}",
            "CmptBtSkip": "static void CmptBtSkip(CmptMfCtx *mf, const uint32_t lenLimit, const uint32_t pos, const uint8_t *const cur,\n                       uint32_t curMatch)\n{\n    uint32_t depth = mf->depth;\n    uint32_t *const son = mf->son;\n    const uint32_t cyclePos = mf->cyclePos;\n    const uint32_t cycleSize = mf->cycleSize;\n    uint32_t *ptr0 = son + (cyclePos << 1) + 1;\n    uint32_t *ptr1 = son + (cyclePos << 1);\n    uint32_t len0 = 0;\n    uint32_t len1 = 0;\n    while (true)\n    {\n        const uint32_t delta = pos - curMatch;\n        if (depth-- == 0 || delta >= cycleSize)\n        {\n            *ptr0 = CMPT_EMPTY_HASH_VALUE;\n            *ptr1 = CMPT_EMPTY_HASH_VALUE;\n            return;\n        }\n        uint32_t *pair = son + ((cyclePos - delta + ((delta > cyclePos) ? cycleSize : 0)) << 1);\n        const uint8_t *pb = cur - delta;\n        uint32_t len = CMPTLZ_FIND_MIN(len0, len1);\n        if (pb[len] == cur[len])\n        {\n            len = CmptMemCmpLenSafe(pb, cur, len + 1, lenLimit);\n            if (len == lenLimit)\n            {\n                *ptr1 = pair[0];\n                *ptr0 = pair[1];\n                return;\n            }\n        }\n        if (pb[len] < cur[len])\n        {\n            CMPT_MF_LEFT_SON_UPDATE(ptr1, pair, curMatch, len1, len);\n        }\n        else\n        {\n            CMPT_MF_RIGHT_SON_UPDATE(ptr0, pair, curMatch, len0, len);\n        }\n    }\n}",
            "CmptlzBt4Finder": "static uint32_t CmptlzBt4Finder(CmptMfCtx *mf, CmptlzMatchPair *matches)\n{\n    const uint32_t niceLen = mf->niceLen;\n    const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n    const uint32_t pos = mf->readPos + mf->offset;\n    uint32_t temp, hash2Value, hash3Value, hashValue;\n    uint32_t longestLen = 1, matchesCount = 0;\n    CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue);\n    uint32_t delta2 = pos - mf->hash[hash2Value];\n    uint32_t delta3 = pos - mf->hash[CMPTLZ_FIX_3_HASH + hash3Value];\n    uint32_t curMatch = mf->hash[CMPTLZ_FIX_4_HASH + hashValue];\n    CMPT_HASH_UPDATE(mf, hash2Value, hash3Value, hashValue, pos);\n    CMPT_HASH_FIND_2_BYTES(mf, delta2, longestLen, matchesCount, cur, matches);\n    CMPT_HASH_FIND_3_BYTES(mf, delta2, delta3, longestLen, matchesCount, cur, matches);\n    if (matchesCount != 0)\n    {\n        longestLen = CmptMemCmpLenSafe(cur, cur - delta2, longestLen, niceLen);\n        matches[matchesCount - 1].len = longestLen;\n        if (longestLen == niceLen)\n        {\n            CmptBtSkip(mf, niceLen, pos, cur, curMatch);\n            CMPT_MF_MOVE_POS(mf);\n            return matchesCount;\n        }\n    }\n    if (longestLen < CMPT_MF_MATCH_3_BYTES)\n    {\n        longestLen = CMPT_MF_MATCH_3_BYTES;\n    }\n    matchesCount = (uint32_t)(CmptBtFind(mf, curMatch, matches + matchesCount, longestLen) - matches);\n    CMPT_MF_MOVE_POS(mf);\n    return matchesCount;\n}",
            "CmptlzMatchSkiper": "void CmptlzMatchSkiper(CmptMfCtx *mf, uint32_t amount)\n{\n    mf->readAhead += amount;\n    uint32_t pos, temp, hash2Value, hash3Value, hashValue, curMatch;\n    const uint32_t niceLen = mf->niceLen;\n    do\n    {\n        uint32_t lenLimit = mf->srcLen - mf->readPos;\n        if (CMPTLZ_LIKELY(niceLen <= lenLimit))\n        {\n            lenLimit = niceLen;\n        }\n        else\n        {\n            mf->readPos++;\n            continue;\n        }\n        const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n        pos = mf->readPos + mf->offset;\n        CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue);\n        curMatch = mf->hash[CMPTLZ_FIX_4_HASH + hashValue];\n        CMPT_HASH_UPDATE(mf, hash2Value, hash3Value, hashValue, pos);\n        CmptBtSkip(mf, lenLimit, pos, cur, curMatch);\n        CMPT_MF_MOVE_POS(mf);\n    } while (--amount != 0);\n}",
            "CmptlzMatchFinder": "uint32_t CmptlzMatchFinder(CmptMfCtx *mf, uint32_t *pCount, CmptlzMatchPair *matches)\n{\n    if (CMPTLZ_UNLIKELY(mf->srcLen - mf->readPos < mf->niceLen))\n    {\n        *pCount = 0;\n        mf->readPos++;\n        mf->readAhead++;\n        return 0;\n    }\n    const uint32_t count = CmptlzBt4Finder(mf, matches);\n    if (count == 0)\n    {\n        *pCount = 0;\n        mf->readAhead++;\n        return 0;\n    }\n    uint32_t longestLen = matches[count - 1].len;\n    if (longestLen == mf->niceLen)\n    {\n        uint32_t bytesAvail = CMPTLZ_FIND_MIN(mf->srcLen - mf->readPos + 1, CMPT_MF_LONGEST_MATCH);\n        const uint8_t *p1 = (const uint8_t *)(mf->srcStart + mf->readPos - 1);\n        const uint8_t *p2 = p1 - matches[count - 1].dist - 1;\n        longestLen = CmptMemCmpLenSafe(p1, p2, longestLen, bytesAvail);\n    }\n    *pCount = count;\n    mf->readAhead++;\n    return longestLen;\n}",
            "CmptPriceOneBitDirect": "static uint32_t CmptPriceOneBitDirect(uint32_t bit)\n{\n    return (bit << CMPT_PRICE_BITS_MOVING_NUM);\n}",
            "CmptPriceOneBit": "static uint32_t CmptPriceOneBit(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob, uint32_t curbit)\n{\n    return encCtx->priceRootTable[(bit0Prob ^ ((uint32_t)(0 - curbit) & (CMPTLZ_PROB_MAX_NUM - 1))) >>\n                                  CMPT_PRICE_BITS_MOVING_NUM];\n}",
            "CmptPriceBit0": "static uint32_t CmptPriceBit0(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob)\n{\n    return encCtx->priceRootTable[bit0Prob >> CMPT_PRICE_BITS_MOVING_NUM];\n}",
            "CmptPriceBit1": "static uint32_t CmptPriceBit1(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob)\n{\n    return encCtx->priceRootTable[(bit0Prob ^ (CMPTLZ_PROB_MAX_NUM - 1)) >> CMPT_PRICE_BITS_MOVING_NUM];\n}",
            "CmptPriceSymbol": "static uint32_t CmptPriceSymbol(CmptLzEncCtx *encCtx, CmptlzProb *symbolProbs, uint32_t symbolBitsNum, uint32_t symbol)\n{\n    uint32_t price = 0;\n    symbol += (1U << symbolBitsNum);\n    do\n    {\n        uint32_t bit = symbol & 1;\n        symbol >>= 1;\n        price += CmptPriceOneBit(encCtx, symbolProbs[symbol], bit);\n    } while (symbol != 1);\n    return price;\n}",
            "CmptPriceSymbolReverse": "static uint32_t CmptPriceSymbolReverse(CmptLzEncCtx *encCtx, CmptlzProb *symbolProbs, uint32_t symbolBitsNum,\n                                       uint32_t symbol)\n{\n    uint32_t price = 0;\n    uint32_t i = 1;\n    do\n    {\n        uint32_t bit = symbol & 1;\n        symbol >>= 1;\n        price += CmptPriceOneBit(encCtx, symbolProbs[i], bit);\n        i = (i << 1) + bit;\n    } while (--symbolBitsNum);\n    return price;\n}",
            "CmptPriceGenRootTable": "void CmptPriceGenRootTable(CmptLzEncCtx *encCtx)\n{\n    uint32_t *rootTable = encCtx->priceRootTable;\n    const unsigned expandCycleNum = 4;\n    const unsigned bitsTotalModeNum = 11;\n    const unsigned valueForNormal = 15;\n    const unsigned wTopBoarder = 1 << 16;\n    for (unsigned i = 0; i < ((uint32_t)1 << bitsTotalModeNum >> CMPT_PRICE_BITS_MOVING_NUM); i++)\n    {\n        unsigned w = (i << CMPT_PRICE_BITS_MOVING_NUM) + (1 << (CMPT_PRICE_BITS_MOVING_NUM - 1));\n        unsigned dummyNormalizeCnt = 0;\n        for (unsigned j = 0; j < expandCycleNum; j++)\n        {\n            w = w * w;\n            dummyNormalizeCnt <<= 1;\n            while (w >= wTopBoarder)\n            {\n                w >>= 1;\n                dummyNormalizeCnt++;\n            }\n        }\n        rootTable[i] = (uint32_t)((bitsTotalModeNum << expandCycleNum) - valueForNormal - dummyNormalizeCnt);\n    }\n}",
            "CmptPriceGenDistTable": "void CmptPriceGenDistTable(CmptLzEncCtx *encCtx)\n{\n    uint32_t distState = 0;\n    do\n    {\n        uint32_t *const tmpPriceDistSlot = encCtx->priceDistSlotTable[distState];\n        for (uint32_t i = 0; i < encCtx->distTableSize; i++)\n        {\n            tmpPriceDistSlot[i] = CmptPriceSymbol(encCtx, encCtx->probDistSlot[distState], CMPTLZ_DIST_SLOT_BITS, i);\n        }\n        for (uint32_t i = 14; i < encCtx->distTableSize; i++)\n        {\n            tmpPriceDistSlot[i] += CmptPriceOneBitDirect((i >> 1) - 1 - CMPTLZ_ALIGN_BITS);\n        }\n        for (uint32_t i = 0; i < 4; i++)\n        {\n            encCtx->priceDistTable[distState][i] = tmpPriceDistSlot[i];\n        }\n        distState++;\n    } while (distState < CMPTLZ_DIST_STATE_TOTAL);\n    for (uint32_t i = 4; i < 128; i++)\n    {\n        uint32_t distSlot = PosSloter(i);\n        uint32_t footerBits = (distSlot >> 1) - 1;\n        uint32_t base = (2 | (distSlot & 1)) << footerBits;\n        uint32_t price =\n            CmptPriceSymbolReverse(encCtx, encCtx->probDistSpecial + base - distSlot - 1, footerBits, i - base);\n        for (distState = 0; distState < 4; distState++)\n        {\n            encCtx->priceDistTable[distState][i] = price + encCtx->priceDistSlotTable[distState][distSlot];\n        }\n    }\n    encCtx->matchPriceCount = 0;\n}",
            "CmptPriceGenAlignTable": "void CmptPriceGenAlignTable(CmptLzEncCtx *encCtx)\n{\n    for (uint32_t i = 0; i < (1 << CMPTLZ_ALIGN_BITS); i++)\n    {\n        encCtx->priceAlignTable[i] = CmptPriceSymbolReverse(encCtx, encCtx->probAlign, CMPTLZ_ALIGN_BITS, i);\n    }\n}",
            "CmptPriceLiteral": "uint32_t CmptPriceLiteral(CmptLzEncCtx *encCtx, bool matchMode, uint32_t matchByte, uint32_t symbol)\n{\n    uint32_t pos = encCtx->litMarcov.pos;\n    uint32_t prevByte = encCtx->litMarcov.prevByte;\n    uint32_t litCtx = encCtx->litMarcov.lcBits;\n    uint32_t lpMask = encCtx->litMarcov.posMask;\n    CmptlzProb *subCoder = CMPT_LIT_SUBCODER(encCtx->litMarcov.literal, litCtx, lpMask, pos, prevByte);\n    uint32_t price = 0;\n    if (!matchMode)\n    {\n        price = CmptPriceSymbol(encCtx, subCoder, 8, symbol);\n    }\n    else\n    {\n        uint32_t offset = 0x100;\n        symbol += 1 << 8;\n        do\n        {\n            matchByte <<= 1;\n            const uint32_t matchBit = matchByte & offset;\n            const uint32_t subCoderIndex = offset + matchBit + (symbol >> 8);\n            const uint32_t bit = (symbol >> 7) & 1;\n            price += CmptPriceOneBit(encCtx, subCoder[subCoderIndex], bit);\n            symbol <<= 1;\n            offset &= ~(matchByte ^ symbol);\n        } while (symbol < (1 << 16));\n    }\n    return price;\n}",
            "CmptPriceSet": "static void CmptPriceSet(CmptLzEncCtx *encCtx, const CmptlzProb *probs, uint32_t startPrice, uint32_t *prices)\n{\n    uint32_t i;\n    for (i = 0; i < 8; i += 2)\n    {\n        uint32_t price = startPrice;\n        uint32_t prob;\n        price += CmptPriceOneBit(encCtx, probs[1], (i >> 2));\n        price += CmptPriceOneBit(encCtx, probs[2 + (i >> 2)], (i >> 1) & 1);\n        prob = probs[4 + (i >> 1)];\n        prices[i] = price + CmptPriceBit0(encCtx, prob);\n        prices[i + 1] = price + CmptPriceBit1(encCtx, prob);\n    }\n}",
            "CmptPriceGenLenTable": "void CmptPriceGenLenTable(CmptLzEncCtx *encCtx, CmptLenEncoder *lenEncoder)\n{\n    const uint32_t numPosStates = 1 << encCtx->posBits;\n    uint32_t b;\n    uint32_t prob = lenEncoder->low[0];\n    uint32_t a, c;\n    uint32_t posState;\n    b = CmptPriceBit1(encCtx, prob);\n    a = CmptPriceBit0(encCtx, prob);\n    c = b + CmptPriceBit0(encCtx, lenEncoder->low[1 << CMPT_LEN_LOW_BITS]);\n    for (posState = 0; posState < numPosStates; posState++)\n    {\n        uint32_t *prices = lenEncoder->prices[posState];\n        const CmptlzProb *probs = lenEncoder->low + (posState << (1 + CMPT_LEN_LOW_BITS));\n        CmptPriceSet(encCtx, probs, a, prices);\n        CmptPriceSet(encCtx, probs + (1 << CMPT_LEN_LOW_BITS), c, prices + (1 << CMPT_LEN_LOW_BITS));\n    }\n    uint32_t i = lenEncoder->tableSize;\n    if (i > (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE)\n    {\n        const CmptlzProb *probs = lenEncoder->high;\n        uint32_t *prices = lenEncoder->prices[0] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE;\n        i -= (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE - 1;\n        i >>= 1;\n        b += CmptPriceBit1(encCtx, lenEncoder->low[(1 << CMPT_LEN_LOW_BITS)]);\n        do\n        {\n            uint32_t sym = --i + (1 << (CMPT_LEN_HIGH_BITS - 1));\n            uint32_t price = b;\n            do\n            {\n                uint32_t bit = sym & 1;\n                sym >>= 1;\n                price += CmptPriceOneBit(encCtx, probs[sym], bit);\n            } while (sym >= 2);\n            prob = probs[(size_t)i + (1 << (CMPT_LEN_HIGH_BITS - 1))];\n            prices[(size_t)i * CMPT_DOUBLE] = price + CmptPriceBit0(encCtx, prob);\n            prices[(size_t)i * CMPT_DOUBLE + 1] = price + CmptPriceBit1(encCtx, prob);\n        } while (i);\n        size_t num =\n            (lenEncoder->tableSize - (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE) * sizeof(lenEncoder->prices[0][0]);\n        for (posState = 1; posState < numPosStates; posState++)\n        {\n            memcpy_s(lenEncoder->prices[posState] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE, CMPT_MF_LONGEST_MATCH - 1,\n                     lenEncoder->prices[0] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE, num);\n        }\n    }\n}",
            "CmptPriceLen": "uint32_t CmptPriceLen(CmptLenEncoder *lenEncoder, uint32_t len, uint32_t posState)\n{\n    return lenEncoder->prices[posState][len - CMPTLZ_MATCH_LEN_MIN];\n}",
            "CmptPriceShortRep": "uint32_t CmptPriceShortRep(CmptLzEncCtx *encCtx, CmptlzState state, uint32_t posState)\n{\n    return CmptPriceBit0(encCtx, encCtx->isRepG0[state]) + CmptPriceBit0(encCtx, encCtx->isRep0Long[state][posState]);\n}",
            "CmptPriceLongRep": "uint32_t CmptPriceLongRep(CmptLzEncCtx *encCtx, uint32_t longRepIndex, CmptlzState state, uint32_t posState)\n{\n    uint32_t price = 0;\n    switch (longRepIndex)\n    {\n    case 0:\n        price =\n            CmptPriceBit0(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRep0Long[state][posState]);\n        break;\n    case 1:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit0(encCtx, encCtx->isRepG1[state]);\n        break;\n    case 2:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRepG1[state]) +\n                CmptPriceBit0(encCtx, encCtx->isRepG2[state]);\n        break;\n    case 3:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRepG1[state]) +\n                CmptPriceBit1(encCtx, encCtx->isRepG2[state]);\n        break;\n    default:\n        break;\n    }\n    return price;\n}",
            "CmptPriceDistWithLen": "uint32_t CmptPriceDistWithLen(CmptLzEncCtx *encCtx, uint32_t dist, uint32_t len, uint32_t posState)\n{\n    const uint32_t distState = CMPT_GET_DIST_STATE(len);\n    uint32_t price;\n    if (dist < 128)\n    {\n        price = encCtx->priceDistTable[distState][dist];\n    }\n    else\n    {\n        uint32_t distSlot = PosSloter(dist);\n        price = encCtx->priceDistSlotTable[distState][distSlot] +\n                encCtx->priceAlignTable[dist & ((1 << CMPTLZ_ALIGN_BITS) - 1)];\n    }\n    price += CmptPriceLen(&encCtx->matchLenEncoder, len, posState);\n    return price;\n}",
            "CmptRcLitProcess": "static int CmptRcLitProcess(CmptRcCtx *rcCtx, CmptlzProb *prob, uint32_t sym)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = rcCtx->range, bit0Prob, newBound, curBit;\n    for (sym |= 0x100; sym < 0x10000; sym <<= 1)\n    {\n        CmptlzProb *litProbTableIndex = prob + (sym >> 8);\n        curBit = (sym >> 7) & 1;\n        CMPT_RC_BIT_PROCESS(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    rcCtx->range = range;\n    return CMPT_OK;\n}",
            "CmptRcLitAfterMatch": "static int CmptRcLitAfterMatch(CmptRcCtx *rcCtx, CmptlzProb *prob, uint32_t sym, uint32_t matchByte)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = rcCtx->range, offs = 0x100, bit0Prob, newBound, curBit;\n    for (sym |= 0x100; sym < 0x10000;)\n    {\n        matchByte <<= 1;\n        CmptlzProb *litProbTableIndex = prob + (offs + (matchByte & offs) + (sym >> 8));\n        curBit = (sym >> 7) & 1;\n        sym <<= 1;\n        offs &= ~(matchByte ^ sym);\n        CMPT_RC_BIT_PROCESS(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    rcCtx->range = range;\n    return CMPT_OK;\n}",
            "CmptRcPrepare": "int CmptRcPrepare(CmptLzEncCtx *encCtx, uint8_t *dest, size_t *destLen, CmptLzMemHook *alloc)\n{\n    CmptRcCtx *rc = alloc->CmptLzAlloc(CMPTLZ_RC_CCTX_HANDLE, sizeof(CmptRcCtx));\n    if (rc == NULL)\n    {\n        return CMPT_ENC_RC_INIT_FAIL;\n    }\n    memset_s(rc, sizeof(CmptRcCtx), 0, sizeof(CmptRcCtx));\n    encCtx->rcCtx = rc;\n    rc->bufBase = alloc->CmptLzAlloc(CMPTLZ_RC_BUF_HANDLE, CMPTLZ_RC_BUFFER_SIZE);\n    memset_s(rc->bufBase, CMPTLZ_RC_BUFFER_SIZE, 0, CMPTLZ_RC_BUFFER_SIZE);\n    if (rc->bufBase == NULL)\n    {\n        return CMPT_ENC_RC_INIT_FAIL;\n    }\n    rc->outBufLeft = *destLen;\n    rc->outBuf = dest;\n    rc->buf = rc->bufBase;\n    rc->range = 0xFFFFFFFF;\n    rc->cacheSize = 0;\n    rc->cache = 0;\n    rc->low = 0;\n    return 0;\n}",
            "CmptRcFlush64Kb": "int CmptRcFlush64Kb(CmptRcCtx *rcCtx)\n{\n    size_t flushOutLen = rcCtx->buf - rcCtx->bufBase;\n    int res = memcpy_s(rcCtx->outBuf, rcCtx->outBufLeft, rcCtx->bufBase, flushOutLen);\n    if (res != 0)\n    {\n        return CMPT_ENC_ERROR_WRITE;\n    }\n    rcCtx->outBuf += flushOutLen;\n    rcCtx->outBufLeft -= flushOutLen;\n    rcCtx->buf = rcCtx->bufBase;\n    return CMPT_OK;\n}",
            "CmptRcShiftLow": "int CmptRcShiftLow(CmptRcCtx *rcCtx)\n{\n    int res = CMPT_OK;\n    uint32_t lowLow32 = (uint32_t)rcCtx->low;\n    uint64_t high = (uint32_t)(rcCtx->low >> 32);\n    rcCtx->low = (uint32_t)(lowLow32 << 8);\n    CMPT_RC_BREAK_CHECK(rcCtx, rcCtx->buf, res);\n    if (lowLow32 < 0xFF000000 || high != 0)\n    {\n        uint8_t *buf = rcCtx->buf;\n        *(buf) = (uint8_t)(rcCtx->cache + high);\n        buf++;\n        rcCtx->buf = buf;\n        rcCtx->cache = (uint8_t)(lowLow32 >> 24);\n        CMPT_RC_BREAK_SHIFTING(rcCtx, buf, res);\n        high += 0xFF;\n        while (1)\n        {\n            uint8_t *buf1 = rcCtx->buf;\n            CMPT_RC_BREAK_SHIFTING(rcCtx, buf1, res);\n            *(buf1++) = (uint8_t)(high);\n            rcCtx->buf = buf1;\n            rcCtx->cacheSize--;\n        }\n        CMPT_RC_BREAK_SHIFTING(rcCtx, buf, res);\n    }\n    else\n    {\n        rcCtx->cacheSize++;\n    }\n    return res;\n}",
            "CmptRcFlushData": "int CmptRcFlushData(CmptRcCtx *rcCtx)\n{\n    int i;\n    int res;\n    for (i = 0; i < 5; i++)\n    {\n        res = CmptRcShiftLow(rcCtx);\n        if (res != CMPT_OK)\n        {\n            break;\n        }\n    }\n    return res;\n}",
            "CmptRcLenProcess": "int CmptRcLenProcess(CmptLenEncoder *lenEncoder, CmptRcCtx *rcCtx, uint32_t len, uint64_t posState)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = rcCtx->range;\n    uint32_t newBound, bit0Prob;\n    len -= CMPTLZ_MATCH_LEN_MIN;\n    CmptlzProb *probs = lenEncoder->low;\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    if (len >= CMPT_LEN_BOUND)\n    {\n        CMPT_RC_BIT_1_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs += CMPT_LEN_BOUND;\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        if (len >= CMPT_LEN_BOUND * CMPT_DOUBLE)\n        {\n            CMPT_RC_BIT_1_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            rcCtx->range = range;\n            shiftRes = CmptRcLitProcess(rcCtx, lenEncoder->high, len - CMPT_LEN_BOUND * CMPT_DOUBLE);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            return CMPT_OK;\n        }\n        len -= CMPT_LEN_BOUND;\n    }\n    uint32_t m, bit;\n    CMPT_RC_BIT_0_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs += (posState << (1 + 3));\n    bit = (len >> 2);\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    m = (1 << 1) + bit;\n    bit = (len >> 1) & 1;\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    m = (m << 1) + bit;\n    bit = len & 1;\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    rcCtx->range = range;\n    return CMPT_OK;\n}",
            "CmptRcPosSlotProcess": "int CmptRcPosSlotProcess(CmptLzEncCtx *encCtx, uint32_t posSlot, uint32_t len)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = encCtx->rcCtx->range;\n    uint32_t sym = posSlot + (1 << 6);\n    uint32_t bit0Prob, newBound;\n    uint32_t bit;\n    CmptlzProb *probs = encCtx->probDistSlot[GET_LEN_TO_POS_STATE(len)];\n    do\n    {\n        CmptlzProb *posSlotProbTableIndex = probs + (sym >> CMPTLZ_DIST_SLOT_BITS);\n        bit = (sym >> (CMPTLZ_DIST_SLOT_BITS - 1)) & 1;\n        sym <<= 1;\n        CMPT_RC_BIT_PROCESS(encCtx->rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    } while (sym < (1 << (CMPTLZ_DIST_SLOT_BITS * 2)));\n    encCtx->rcCtx->range = range;\n    return CMPT_OK;\n}",
            "CmptRcReverseProcess": "static int CmptRcReverseProcess(CmptRcCtx *rcCtx, CmptlzProb *probs, uint32_t numBits, uint32_t sym)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = rcCtx->range;\n    uint32_t bit0Prob, newBound;\n    uint32_t bit;\n    uint32_t m = 1;\n    do\n    {\n        bit = sym & 1;\n        sym >>= 1;\n        CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        m = (m << 1) | bit;\n    } while (--numBits);\n\n    rcCtx->range = range;\n    return CMPT_OK;\n}",
            "CmptRcDistProcess": "int CmptRcDistProcess(CmptLzEncCtx *encCtx, uint32_t posSlot, uint32_t dist)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t footerBits = ((posSlot >> 1) - 1);\n    if (dist < CMPT_DIST_LIMIT_2)\n    {\n        uint32_t base = ((2 | (posSlot & 1)) << footerBits);\n        shiftRes = CmptRcReverseProcess(encCtx->rcCtx, encCtx->probDistSpecial + base, footerBits, dist);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    else\n    {\n        uint32_t pos2 = (dist | 0xF) << (32 - footerBits);\n        uint32_t range = encCtx->rcCtx->range;\n        do\n        {\n            range >>= 1;\n            encCtx->rcCtx->low += range & (0 - (pos2 >> 31));\n            pos2 += pos2;\n            CMPT_RC_NORMALIZE(encCtx->rcCtx, range, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        } while (pos2 != 0xF0000000);\n        uint32_t m = 1;\n        uint32_t bit;\n        uint32_t bit0Prob, newBound;\n        int k;\n        for (k = 0; k < CMPTLZ_ALIGN_BITS - 1; k++)\n        {\n            bit = dist & 1;\n            dist >>= 1;\n            CMPT_RC_BIT_PROCESS(encCtx->rcCtx, encCtx->probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            m = (m << 1) + bit;\n        }\n        bit = dist & 1;\n        CMPT_RC_BIT_PROCESS(encCtx->rcCtx, encCtx->probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n    }\n    return CMPT_OK;\n}",
            "CmptlzEncLit": "static int CmptlzEncLit(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t nowpos32)\n{\n    int shiftRes = CMPT_OK;\n    CmptRcCtx *rc = encCtx->rcCtx;\n    uint32_t posState = nowpos32 & encCtx->pbMask;\n    uint32_t range, bit0Prob, newBound;\n    range = rc->range;\n    CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS(rc, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    rc->range = range;\n    CmptlzProb *litProb = &encCtx->litMarcov.literal[0][0];\n    const uint8_t curByte = mf->srcStart[mf->readPos - mf->readAhead];\n    probs = CMPT_LIT_PROB_GET(encCtx, litProb, nowpos32, mf->srcStart[mf->readPos - mf->readAhead - 1]);\n    CmptlzState state = encCtx->state;\n    CMPT_STATE_UPDATE_WHEN_LIT(encCtx->state);\n    if (state < 7)\n    {\n        shiftRes = CmptRcLitProcess(rc, probs, curByte);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    else\n    {\n        const uint8_t match_byte = mf->srcStart[mf->readPos - encCtx->reps[0] - 1 - mf->readAhead];\n        shiftRes = CmptRcLitAfterMatch(rc, probs, curByte, match_byte);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    return CMPT_OK;\n}",
            "CmptlzEncShortRep": "static int CmptlzEncShortRep(CmptLzEncCtx *encCtx, uint32_t nowpos32)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t posState = nowpos32 & encCtx->pbMask;\n    uint32_t range, bit0Prob, newBound;\n    range = encCtx->rcCtx->range;\n    CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRep[encCtx->state];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRepG0[encCtx->state];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRep0Long[encCtx->state][posState];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    encCtx->rcCtx->range = range;\n    CmptlzState state = encCtx->state;\n    encCtx->state = CMPT_STATE_UPDATE_WHEN_SHORTREP(state);\n    return CMPT_OK;\n}",
            "CmptlzEncNormalMatch": "static int CmptlzEncNormalMatch(CmptLzEncCtx *encCtx, uint32_t nowpos32, uint32_t backRes, uint32_t lenRes)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t posState = nowpos32 & encCtx->pbMask;\n    uint32_t range, bit0Prob, newBound;\n    range = encCtx->rcCtx->range;\n    CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRep[encCtx->state];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    encCtx->rcCtx->range = range;\n    CmptlzState state = encCtx->state;\n    encCtx->state = CMPT_STATE_UPDATE_WHEN_MATCH(state);\n    shiftRes = CmptRcLenProcess(&encCtx->matchLenEncoder, encCtx->rcCtx, lenRes, posState);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    backRes -= CMPTLZ_NUM_REPS;\n    encCtx->reps[3] = encCtx->reps[2];\n    encCtx->reps[2] = encCtx->reps[1];\n    encCtx->reps[1] = encCtx->reps[0];\n    encCtx->reps[0] = backRes;\n    encCtx->matchPriceCount++;\n    uint32_t posSlot = PosSloter(backRes);\n    shiftRes = CmptRcPosSlotProcess(encCtx, posSlot, lenRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    if (backRes >= 4)\n    {\n        shiftRes = CmptRcDistProcess(encCtx, posSlot, backRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    return CMPT_OK;\n}",
            "CmptlzEncLongRep": "static int CmptlzEncLongRep(CmptLzEncCtx *encCtx, uint32_t repIndex, uint32_t nowpos32, uint32_t lenRes)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t posState = nowpos32 & encCtx->pbMask;\n    uint32_t range, bit0Prob, newBound;\n    uint32_t realDist;\n    range = encCtx->rcCtx->range;\n    CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRep[encCtx->state];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs = &encCtx->isRepG0[encCtx->state];\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    switch (repIndex)\n    {\n    case 0:\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRep0Long[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1(encCtx->rcCtx, probs, newBound, range, bit0Prob);\n        break;\n    case 1:\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRepG1[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0(probs, newBound, range, bit0Prob);\n        realDist = encCtx->reps[1];\n        encCtx->reps[1] = encCtx->reps[0];\n        encCtx->reps[0] = realDist;\n        break;\n    case 2:\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRepG1[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRepG2[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0(probs, newBound, range, bit0Prob);\n        realDist = encCtx->reps[2];\n        encCtx->reps[2] = encCtx->reps[1];\n        encCtx->reps[1] = encCtx->reps[0];\n        encCtx->reps[0] = realDist;\n        break;\n    case 3:\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRepG1[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs = &encCtx->isRepG2[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1(encCtx->rcCtx, probs, newBound, range, bit0Prob);\n        realDist = encCtx->reps[3];\n        encCtx->reps[3] = encCtx->reps[2];\n        encCtx->reps[2] = encCtx->reps[1];\n        encCtx->reps[1] = encCtx->reps[0];\n        encCtx->reps[0] = realDist;\n        break;\n    default:\n        break;\n    }\n    CMPT_RC_NORMALIZE(encCtx->rcCtx, range, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    encCtx->rcCtx->range = range;\n    shiftRes = CmptRcLenProcess(&encCtx->repLenEncoder, encCtx->rcCtx, lenRes, posState);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    --encCtx->repLenPriceCount;\n    CmptlzState state = encCtx->state;\n    encCtx->state = CMPT_STATE_UPDATE_WHEN_LONGREP(state);\n    return CMPT_OK;\n}",
            "CmptlzFreeAll": "void CmptlzFreeAll(CmptLzEncCtx *encCtx, CmptLzMemHook *alloc)\n{\n    if (encCtx == NULL)\n    {\n        return;\n    }\n    if (encCtx->mfCtx != NULL)\n    {\n        if (encCtx->mfCtx->hash != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_MF_HASH_HANDLE, encCtx->mfCtx->hash);\n            encCtx->mfCtx->hash = NULL;\n        }\n        if (encCtx->mfCtx->son != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_MF_SON_HANDLE, encCtx->mfCtx->son);\n            encCtx->mfCtx->son = NULL;\n        }\n        alloc->CmptLzFree(CMPTLZ_MF_CCTX_HANDLE, encCtx->mfCtx);\n        encCtx->mfCtx = NULL;\n    }\n    if (encCtx->rcCtx != NULL)\n    {\n        if (encCtx->rcCtx->bufBase != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_RC_BUF_HANDLE, encCtx->rcCtx->bufBase);\n            encCtx->rcCtx->bufBase = NULL;\n        }\n        alloc->CmptLzFree(CMPTLZ_RC_CCTX_HANDLE, encCtx->rcCtx);\n        encCtx->rcCtx = NULL;\n    }\n    alloc->CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE, encCtx);\n    encCtx = NULL;\n}",
            "CmptlzEncodeIO": "int CmptlzEncodeIO(CmptLzEncCtx *encCtx, uint8_t *dest, size_t *destLen, const uint8_t *src, size_t srcLen,\n                   CmptLzMemHook *alloc)\n{\n    int res;\n    res = CmptMfPrepare(encCtx, src, srcLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptMfPrepare Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n    res = CmptRcPrepare(encCtx, dest, destLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptRcPrepare Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n    CmptlzEncPrepare(encCtx);\n    res = CmptEncodeAll(encCtx);\n    if (res != 0)\n    {\n        CmptlzFreeAll(encCtx, alloc);\n        CMPTLZ_LOG(res, \"CmptEncode Process Fail!\");\n        return res;\n    }\n    *destLen -= encCtx->rcCtx->outBufLeft;\n    if (encCtx->nowpos64 != srcLen)\n    {\n        CMPTLZ_LOG(res, \"CmptEncode FileSize Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return CMPT_ENC_ERROR_FILESIZE;\n    }\n    CmptlzFreeAll(encCtx, alloc);\n    return res;\n}",
            "CmptlzEncode": "int CmptlzEncode(uint8_t *dest, size_t *destLen, const uint8_t *src, size_t srcLen, const CmptlzEncParam *props,\n                 uint8_t *propsEncoded, size_t *propsSize, int writeEndMark, CmptLzMemHook *alloc)\n{\n    int res;\n    if (alloc == NULL || alloc->CmptLzAlloc == NULL || alloc->CmptLzFree == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ENC_ERROR_PARAM, \"Cmptlz input wrong param!\");\n        return CMPT_ENC_ERROR_PARAM;\n    }\n    CmptLzEncCtx *encCtx = (CmptLzEncCtx *)CmptInitCctx(alloc, writeEndMark);\n    if (encCtx == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ENC_CTX_INIT_FAIL, \"CmptInitCctx Fail!\");\n        return CMPT_ENC_CTX_INIT_FAIL;\n    }\n    CmptlzSetParam(encCtx, props);\n    res = CmptHeadWrite(encCtx, propsEncoded, propsSize);\n    if (res != 0)\n    {\n        alloc->CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE, encCtx);\n        CMPTLZ_LOG(res, \"CmptHeadWrite Fail!\");\n        return res;\n    }\n    res = CmptlzEncodeIO(encCtx, dest, destLen, src, srcLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptlzEncode I / O Fail!\");\n    }\n    return res;\n}",
            "CmptlzCompress": "int CmptlzCompress(void *src, size_t srcSize, void *dst, size_t *dstSize, CmptlzCompParam *param)\n{\n    if ((src == NULL) && (srcSize != 0))\n    {\n        return CMPT_ENC_ERROR_PARAM;\n    }\n    const int endMarker = 0;\n    CmptlzEncParam props;\n    props.level = param->level;\n    props.dictSize = param->dictSize;\n    props.litCtx = param->litCtx;\n    props.litPos = param->litPos;\n    props.posBits = param->posBits;\n    props.fastBytes = param->fastBytes;\n    props.numThreads = param->numThreads;\n    CmptLzMemHook *alloc = param->memHook;\n    return CmptlzEncode((uint8_t *)dst, dstSize, (const uint8_t *)src, srcSize, &props, param->protData,\n                        &param->protSize, endMarker, alloc);\n}"
        }
    }
}