{
    "include": {
        "name": "include",
        "type": "folder",
        "children": {
            "cmptlz_enc_h.rs": {
                "name": "cmptlz_enc_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::include::cmptlz_base_h::*;",
                    "pub use crate::src::encode::cmptlz_enc_struct_h::TagCmptLzEncCtx;",
                    "pub use crate::src::encode::cmptlz_enc_c::CmptlzCompress;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef struct TagCmptLzEncCtx CmptLzEncCtx;",
                        "rust_code": "pub type CmptLzEncCtx = i32;"
                    },
                    {
                        "c_code": "typedef struct\n    {\n        int level;\n        uint32_t dictSize;\n        int litCtx;\n        int litPos;\n        int posBits;\n        int fastBytes;\n        int numThreads;\n        unsigned char *protData;\n        size_t protSize;\n        CmptLzMemHook *memHook;\n    } CmptlzCompParam;",
                        "rust_code": "pub type CmptlzCompParam = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define CMPTLZ_ENC_H",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "cmptlz_base_h.rs": {
                "name": "cmptlz_base_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::public::cmptlz_log_c::CmptlzLogRegister;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef enum\n    {\n        CMPTLZ_ERROR_DATA = 1,\n        CMPTLZ_ERROR_MEM,\n        CMPTLZ_ERROR_UNSUPPORTED,\n        CMPTLZ_ENC_ERROR_FILESIZE,\n        CMPTLZ_ENC_CTX_INIT_FAIL,\n        CMPTLZ_ENC_RC_INIT_FAIL,\n        CMPTLZ_ENC_MF_INIT_FAIL,\n        CMPTLZ_ENC_ERROR_WRITE,\n        CMPTLZ_ENC_ERROR_HEAD,\n        CMPTLZ_ENC_ERROR_PARAM,\n        CMPTLZ_ERROR_BUTT\n    } EnCmptErrNo;",
                        "rust_code": "pub type EnCmptErrNo = i32;"
                    },
                    {
                        "c_code": "typedef uint16_t CmptLzDecProb;",
                        "rust_code": "pub type CmptLzDecProb = i32;"
                    },
                    {
                        "c_code": "typedef enum\n    {\n        CMPTLZ_DICT_MEM = 1,\n        CMPTLZ_PROB_MEM,\n        CMPTLZ_ENC_CCTX,\n        CMPTLZ_MF_CCTX,\n        CMPTLZ_MF_HASH,\n        CMPTLZ_MF_SON,\n        CMPTLZ_RC_CCTX,\n        CMPTLZ_RC_BUF,\n        CMPTLZ_MEM_TYPE_BUT\n    } EnCmptLzMemType;",
                        "rust_code": "pub type EnCmptLzMemType = i32;"
                    },
                    {
                        "c_code": "typedef struct\n    {\n        void *(*CmptLzAlloc)(int32_t enMemType, size_t size);\n        void (*CmptLzFree)(int32_t enMemType, void *address);\n    } CmptLzMemHook;",
                        "rust_code": "pub type CmptLzMemHook = i32;"
                    },
                    {
                        "c_code": "typedef void (*CmptlzLogFunc)(const char *message, size_t size);",
                        "rust_code": "pub type CmptlzLogFunc = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define CMPTLZ_BASE_H",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPTLZ_MODULE (0x0A00 + 0x0D)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPT_OK 0",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPT_ERROR_DATA CMPTLZ_ERROR_CONVERT(CMPTLZ_ERROR_DATA)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPT_ERROR_MEM CMPTLZ_ERROR_CONVERT(CMPTLZ_ERROR_MEM)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPT_ERROR_UNSUPPORTED CMPTLZ_ERROR_CONVERT(CMPTLZ_ERROR_UNSUPPORTED)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPT_ENC_ERROR_FILESIZE CMPTLZ_ERROR_CONVERT(CMPTLZ_ENC_ERROR_FILESIZE)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPT_ENC_CTX_INIT_FAIL CMPTLZ_ERROR_CONVERT(CMPTLZ_ENC_CTX_INIT_FAIL)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPT_ENC_RC_INIT_FAIL CMPTLZ_ERROR_CONVERT(CMPTLZ_ENC_RC_INIT_FAIL)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPT_ENC_MF_INIT_FAIL CMPTLZ_ERROR_CONVERT(CMPTLZ_ENC_MF_INIT_FAIL)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPT_ENC_ERROR_WRITE CMPTLZ_ERROR_CONVERT(CMPTLZ_ENC_ERROR_WRITE)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPT_ENC_ERROR_HEAD CMPTLZ_ERROR_CONVERT(CMPTLZ_ENC_ERROR_HEAD)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPT_ENC_ERROR_PARAM CMPTLZ_ERROR_CONVERT(CMPTLZ_ENC_ERROR_PARAM)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPTLZ_PROPS_SIZE 5",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPTLZ_UNCOMP_SIZE 8",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPTLZ_REQUIRED_INPUT_MAX 20",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPTLZ_DICT_HANDLE CMPTLZ_HANDLE_CONVERT(CMPTLZ_DICT_MEM)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPTLZ_PROB_HANDLE CMPTLZ_HANDLE_CONVERT(CMPTLZ_PROB_MEM)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPTLZ_ENC_CCTX_HANDLE CMPTLZ_HANDLE_CONVERT(CMPTLZ_ENC_CCTX)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPTLZ_MF_CCTX_HANDLE CMPTLZ_HANDLE_CONVERT(CMPTLZ_MF_CCTX)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPTLZ_MF_HASH_HANDLE CMPTLZ_HANDLE_CONVERT(CMPTLZ_MF_HASH)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPTLZ_MF_SON_HANDLE CMPTLZ_HANDLE_CONVERT(CMPTLZ_MF_SON)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPTLZ_RC_CCTX_HANDLE CMPTLZ_HANDLE_CONVERT(CMPTLZ_RC_CCTX)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPTLZ_RC_BUF_HANDLE CMPTLZ_HANDLE_CONVERT(CMPTLZ_RC_BUF)",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [
                    {
                        "c_code": "#define CMPTLZ_ERROR_CONVERT(x) (int32_t)((CMPTLZ_MODULE << 16) | (uint32_t)(x))",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define CMPTLZ_HANDLE_CONVERT(x) (int32_t)((CMPTLZ_MODULE << 16) | ((uint32_t)(x) << 8))",
                        "rust_code": ""
                    }
                ],
                "functions": []
            },
            "cmptlz_dec_h.rs": {
                "name": "cmptlz_dec_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::include::cmptlz_base_h::*;",
                    "pub use crate::src::decode::cmptlz_dec_init_c::CmptLzDecConstruct;",
                    "pub use crate::src::decode::cmptlz_dec_c::CmptLzDecDecodeToBuf;",
                    "pub use crate::src::decode::cmptlz_dec_c::CmptlzDecompress;",
                    "pub use crate::src::decode::cmptlz_dec_init_c::CmptLzDecFree;",
                    "pub use crate::src::decode::cmptlz_dec_init_c::CmptLzDecode;",
                    "pub use crate::src::decode::cmptlz_dec_init_c::CmptLzDecAllocate;",
                    "pub use crate::src::decode::cmptlz_dec_init_c::CmptLzDecInit;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef enum\n    {\n        CMPTLZ_FINISH_ANY,\n        CMPTLZ_FINISH_END\n    } EnCmptLzFinMode;",
                        "rust_code": "pub type EnCmptLzFinMode = i32;"
                    },
                    {
                        "c_code": "typedef enum\n    {\n        CMPTLZ_STATUS_NOT_SPECIFIED,\n        CMPTLZ_STATUS_FINISHED_WITH_MARK,\n        CMPTLZ_STATUS_NOT_FINISHED,\n        CMPTLZ_STATUS_NEEDS_MORE_INPUT,\n        CMPTLZ_STATUS_MAYBE_FINISHED_WITHOUT_MARK,\n        CMPTLZ_STATUS_BUT\n    } EnCmptLzStatus;",
                        "rust_code": "pub type EnCmptLzStatus = i32;"
                    },
                    {
                        "c_code": "typedef struct\n    {\n        unsigned char litCtx;\n        unsigned char litPos;\n        unsigned char posBits;\n        unsigned char alignPad;\n        uint32_t dicSize;\n    } CmptLzDecProt;",
                        "rust_code": "pub type CmptLzDecProt = i32;"
                    },
                    {
                        "c_code": "typedef struct\n    {\n        CmptLzDecProt prop;\n        CmptLzDecProb *probs;\n        CmptLzDecProb *probsPlus1664;\n        unsigned char *dict;\n        size_t dictBufSize;\n        size_t dictPos;\n        const unsigned char *buf;\n        uint32_t range;\n        uint32_t code;\n        uint32_t processedPos;\n        uint32_t checkDicSize;\n        uint32_t reps[4];\n        uint32_t state;\n        uint32_t remainLen;\n        uint32_t numProbs;\n        unsigned tempBufSize;\n        unsigned char tempBuf[CMPTLZ_REQUIRED_INPUT_MAX];\n    } CmptLzDecCtx;",
                        "rust_code": "pub type CmptLzDecCtx = i32;"
                    },
                    {
                        "c_code": "typedef struct\n    {\n        const unsigned char *pSrcIn;\n        size_t strInLen;\n        size_t strInCostLen;\n    } CmptLzDecIn;",
                        "rust_code": "pub type CmptLzDecIn = i32;"
                    },
                    {
                        "c_code": "typedef struct\n    {\n        unsigned char *pDestOut;\n        size_t destOutLen;\n        size_t destOutFillLen;\n    } CmptLzDecOut;",
                        "rust_code": "pub type CmptLzDecOut = i32;"
                    },
                    {
                        "c_code": "typedef struct\n    {\n        const unsigned char *protData;\n        unsigned protSize;\n        CmptLzMemHook *memHook;\n    } CmptlzDecParam;",
                        "rust_code": "pub type CmptlzDecParam = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define CMPTLZ_DEC_H",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "mod.rs": {
                "name": "mod.rs",
                "type": "file",
                "declarations": [
                    "pub mod cmptlz_enc_h;",
                    "pub mod cmptlz_base_h;",
                    "pub mod cmptlz_dec_h;"
                ],
                "definitions": [],
                "macros": [],
                "macro_functions": [],
                "functions": []
            }
        }
    },
    "src": {
        "name": "src",
        "type": "folder",
        "children": {
            "encode": {
                "name": "encode",
                "type": "folder",
                "children": {
                    "cmptlz_enc_mf_c.rs": {
                        "name": "cmptlz_enc_mf_c.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::encode::cmptlz_enc_inner_h::*;"
                        ],
                        "definitions": [],
                        "macros": [
                            {
                                "c_code": "#define CMPT_EMPTY_HASH_VALUE 0",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_HASH_2_SIZE (1 << 10)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_HASH_3_SIZE (1 << 16)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_HASH_4_SIZE (1 << 20)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_HASH_2_MASK (CMPTLZ_HASH_2_SIZE - 1)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_HASH_3_MASK (CMPTLZ_HASH_3_SIZE - 1)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_FIX_3_HASH (CMPTLZ_HASH_2_SIZE)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_FIX_4_HASH (CMPTLZ_HASH_2_SIZE + CMPTLZ_HASH_3_SIZE)",
                                "rust_code": ""
                            }
                        ],
                        "macro_functions": [
                            {
                                "c_code": "#define CMPT_HASH_MASK_CALC(hashMask)                                                                                  \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        hashMask |= hashMask >> 1;                                                                                     \\\n        hashMask |= hashMask >> 2;                                                                                     \\\n        hashMask |= hashMask >> 4;                                                                                     \\\n        hashMask |= hashMask >> 8;                                                                                     \\\n        hashMask >>= 1;                                                                                                \\\n        hashMask |= 0xFFFF;                                                                                            \\\n        if (hashMask > (1 << 24))                                                                                      \\\n        {                                                                                                              \\\n            hashMask >>= 1;                                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue)                                             \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        temp = mf->hashRootTable[cur[0]] ^ cur[1];                                                                     \\\n        hash2Value = temp & CMPTLZ_HASH_2_MASK;                                                                        \\\n        hash3Value = (temp ^ ((uint32_t)(cur[2]) << 8)) & CMPTLZ_HASH_3_MASK;                                          \\\n        hashValue = (temp ^ ((uint32_t)(cur[2]) << 8) ^ (mf->hashRootTable[cur[3]] << 5)) & mf->hashMask;              \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_HASH_UPDATE(mf, hash2Value, hash3Value, hashValue, pos)                                                   \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        mf->hash[hash2Value] = pos;                                                                                    \\\n        mf->hash[CMPTLZ_FIX_3_HASH + hash3Value] = pos;                                                                \\\n        mf->hash[CMPTLZ_FIX_4_HASH + hashValue] = pos;                                                                 \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_HASH_FIND_2_BYTES(mf, delta2, longestLen, matchesCount, cur, matches)                                     \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if (delta2 < mf->cycleSize && *(cur - delta2) == *cur)                                                         \\\n        {                                                                                                              \\\n            longestLen = CMPT_MF_MATCH_2_BYTES;                                                                        \\\n            matches[0].len = CMPT_MF_MATCH_2_BYTES;                                                                    \\\n            matches[0].dist = delta2 - 1;                                                                              \\\n            matchesCount = 1;                                                                                          \\\n        }                                                                                                              \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_HASH_FIND_3_BYTES(mf, delta2, delta3, longestLen, matchesCount, cur, matches)                             \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if (delta2 != delta3 && delta3 < mf->cycleSize && *(cur - delta3) == *cur)                                     \\\n        {                                                                                                              \\\n            longestLen = CMPT_MF_MATCH_3_BYTES;                                                                        \\\n            matches[matchesCount++].dist = delta3 - 1;                                                                 \\\n            delta2 = delta3;                                                                                           \\\n        }                                                                                                              \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_MF_MOVE_POS(mf)                                                                                           \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        mf->readPos++;                                                                                                 \\\n        mf->cyclePos++;                                                                                                \\\n        mf->cyclePos = (mf->cyclePos == mf->cycleSize) ? 0 : mf->cyclePos;                                             \\\n        if (CMPTLZ_UNLIKELY(mf->readPos + mf->offset == CMPTLZ_UINT32_MAX))                                            \\\n        {                                                                                                              \\\n            CmptMfMovePos(mf);                                                                                         \\\n        }                                                                                                              \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_MF_LEFT_SON_UPDATE(ptr1, pair, curMatch, len1, len)                                                       \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        *ptr1 = curMatch;                                                                                              \\\n        ptr1 = pair + 1;                                                                                               \\\n        curMatch = *ptr1;                                                                                              \\\n        len1 = len;                                                                                                    \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_MF_RIGHT_SON_UPDATE(ptr0, pair, curMatch, len0, len)                                                      \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        *ptr0 = curMatch;                                                                                              \\\n        ptr0 = pair;                                                                                                   \\\n        curMatch = *ptr0;                                                                                              \\\n        len0 = len;                                                                                                    \\\n    } while (0)",
                                "rust_code": ""
                            }
                        ],
                        "functions": [
                            {
                                "c_code": "static void CmptlzMfGenHashTable(CmptMfCtx *mf)\n{\n    uint32_t *hashRootTable = mf->hashRootTable;\n    const uint32_t poly32 = 0xEDB88320;\n    uint32_t i, j;\n    for (i = 0; i < CMPT_MF_HASH_TABLE_SIZE; i++)\n    {\n        uint32_t value = i;\n        for (j = 0; j < 8; j++)\n        {\n            if (value & 1)\n            {\n                value = (value >> 1) ^ poly32;\n            }\n            else\n            {\n                value >>= 1;\n            }\n        }\n        hashRootTable[i] = value;\n    }\n    return;\n}",
                                "rust_code": "pub fn CmptlzMfGenHashTable() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptMfPrepare(CmptLzEncCtx *encCtx, const uint8_t *src, size_t srcLen, CmptLzMemHook *alloc)\n{\n\n    CmptMfCtx *mf = alloc->CmptLzAlloc(CMPTLZ_MF_CCTX_HANDLE, sizeof(CmptMfCtx));\n    if (mf == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    memset_s(mf, sizeof(CmptMfCtx), 0, sizeof(CmptMfCtx));\n\n    encCtx->mfCtx = mf;\n    mf->cycleSize = encCtx->dicSize + 1;\n    uint32_t hashMask = encCtx->dicSize - 1;\n    CMPT_HASH_MASK_CALC(hashMask);\n    mf->hashMask = hashMask;\n    ++hashMask;\n    hashMask += CMPTLZ_HASH_2_SIZE;\n    hashMask += CMPTLZ_HASH_3_SIZE;\n    mf->hashCount = hashMask;\n    mf->sonsCount = mf->cycleSize * 2;\n    mf->hash = NULL;\n    mf->son = NULL;\n    mf->hash = alloc->CmptLzAlloc(CMPTLZ_MF_HASH_HANDLE, mf->hashCount * sizeof(uint32_t));\n    memset_s(mf->hash, mf->hashCount * sizeof(uint32_t), 0, mf->hashCount * sizeof(uint32_t));\n    if (mf->hash == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n    mf->son = alloc->CmptLzAlloc(CMPTLZ_MF_SON_HANDLE, mf->sonsCount * sizeof(uint32_t));\n    memset_s(mf->son, mf->sonsCount * sizeof(uint32_t), 0, mf->sonsCount * sizeof(uint32_t));\n    if (mf->son == NULL)\n    {\n        return CMPT_ENC_MF_INIT_FAIL;\n    }\n\n    CmptlzMfGenHashTable(mf);\n    mf->srcStart = src;\n    mf->srcLen = srcLen;\n    mf->offset = mf->cycleSize;\n    mf->niceLen = encCtx->numFastBytes;\n    mf->depth = CMPT_MF_BASE_DEPTH + mf->niceLen / 2;\n    return 0;\n}",
                                "rust_code": "pub fn CmptMfPrepare() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static void CmptMfMovePos(CmptMfCtx *mf)\n{\n    const uint32_t subvalue = (CMPTLZ_UINT32_MAX - mf->cycleSize);\n    uint32_t i;\n    for (i = 0; i < mf->hashCount; i++)\n    {\n        if (mf->hash[i] <= subvalue)\n        {\n            mf->hash[i] = CMPT_EMPTY_HASH_VALUE;\n        }\n        else\n        {\n            mf->hash[i] -= subvalue;\n        }\n    }\n    for (i = 0; i < mf->sonsCount; ++i)\n    {\n        if (mf->son[i] <= subvalue)\n        {\n            mf->son[i] = CMPT_EMPTY_HASH_VALUE;\n        }\n        else\n        {\n            mf->son[i] -= subvalue;\n        }\n    }\n    mf->offset -= subvalue;\n}",
                                "rust_code": "pub fn CmptMfMovePos() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static CmptlzMatchPair *CmptBtFind(CmptMfCtx *mf, uint32_t curMatch, CmptlzMatchPair *matches, uint32_t longestLen)\n{\n\n    uint32_t depth = mf->depth;\n    uint32_t *const son = mf->son;\n    const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n    const uint32_t niceLen = mf->niceLen;\n    const uint32_t cyclePos = mf->cyclePos;\n    const uint32_t cycleSize = mf->cycleSize;\n    const uint32_t pos = mf->readPos + mf->offset;\n    uint32_t *ptr0 = son + (cyclePos << 1) + 1;\n    uint32_t *ptr1 = son + (cyclePos << 1);\n    uint32_t len0 = 0;\n    uint32_t len1 = 0;\n\n    while (true)\n    {\n        const uint32_t delta = pos - curMatch;\n        if (depth-- == 0 || delta >= cycleSize)\n        {\n            *ptr0 = CMPT_EMPTY_HASH_VALUE;\n            *ptr1 = CMPT_EMPTY_HASH_VALUE;\n            return matches;\n        }\n        uint32_t *const pair = son + ((cyclePos - delta + ((delta > cyclePos) ? cycleSize : 0)) << 1);\n        const uint8_t *const pb = cur - delta;\n        uint32_t len = CMPTLZ_FIND_MIN(len0, len1);\n        if (pb[len] == cur[len])\n        {\n            len = CmptMemCmpLenSafe(pb, cur, len + 1, niceLen);\n            if (longestLen < len)\n            {\n                longestLen = len;\n                matches->len = len;\n                matches->dist = delta - 1;\n                ++matches;\n                if (len == niceLen)\n                {\n                    *ptr1 = pair[0];\n                    *ptr0 = pair[1];\n                    return matches;\n                }\n            }\n        }\n        if (pb[len] < cur[len])\n        {\n            CMPT_MF_LEFT_SON_UPDATE(ptr1, pair, curMatch, len1, len);\n        }\n        else\n        {\n            CMPT_MF_RIGHT_SON_UPDATE(ptr0, pair, curMatch, len0, len);\n        }\n    }\n}",
                                "rust_code": "pub fn CmptBtFind() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static void CmptBtSkip(CmptMfCtx *mf, const uint32_t lenLimit, const uint32_t pos, const uint8_t *const cur,\n                       uint32_t curMatch)\n{\n    uint32_t depth = mf->depth;\n    uint32_t *const son = mf->son;\n    const uint32_t cyclePos = mf->cyclePos;\n    const uint32_t cycleSize = mf->cycleSize;\n\n    uint32_t *ptr0 = son + (cyclePos << 1) + 1;\n    uint32_t *ptr1 = son + (cyclePos << 1);\n    uint32_t len0 = 0;\n    uint32_t len1 = 0;\n\n    while (true)\n    {\n        const uint32_t delta = pos - curMatch;\n        if (depth-- == 0 || delta >= cycleSize)\n        {\n            *ptr0 = CMPT_EMPTY_HASH_VALUE;\n            *ptr1 = CMPT_EMPTY_HASH_VALUE;\n            return;\n        }\n        uint32_t *pair = son + ((cyclePos - delta + ((delta > cyclePos) ? cycleSize : 0)) << 1);\n        const uint8_t *pb = cur - delta;\n        uint32_t len = CMPTLZ_FIND_MIN(len0, len1);\n        if (pb[len] == cur[len])\n        {\n            len = CmptMemCmpLenSafe(pb, cur, len + 1, lenLimit);\n            if (len == lenLimit)\n            {\n                *ptr1 = pair[0];\n                *ptr0 = pair[1];\n                return;\n            }\n        }\n        if (pb[len] < cur[len])\n        {\n            CMPT_MF_LEFT_SON_UPDATE(ptr1, pair, curMatch, len1, len);\n        }\n        else\n        {\n            CMPT_MF_RIGHT_SON_UPDATE(ptr0, pair, curMatch, len0, len);\n        }\n    }\n}",
                                "rust_code": "pub fn CmptBtSkip() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static uint32_t CmptlzBt4Finder(CmptMfCtx *mf, CmptlzMatchPair *matches)\n{\n    const uint32_t niceLen = mf->niceLen;\n    const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n    const uint32_t pos = mf->readPos + mf->offset;\n    uint32_t temp, hash2Value, hash3Value, hashValue;\n    uint32_t longestLen = 1, matchesCount = 0;\n    CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue);\n\n    uint32_t delta2 = pos - mf->hash[hash2Value];\n    uint32_t delta3 = pos - mf->hash[CMPTLZ_FIX_3_HASH + hash3Value];\n    uint32_t curMatch = mf->hash[CMPTLZ_FIX_4_HASH + hashValue];\n    CMPT_HASH_UPDATE(mf, hash2Value, hash3Value, hashValue, pos);\n    CMPT_HASH_FIND_2_BYTES(mf, delta2, longestLen, matchesCount, cur, matches);\n    CMPT_HASH_FIND_3_BYTES(mf, delta2, delta3, longestLen, matchesCount, cur, matches);\n\n    if (matchesCount != 0)\n    {\n        longestLen = CmptMemCmpLenSafe(cur, cur - delta2, longestLen, niceLen);\n        matches[matchesCount - 1].len = longestLen;\n        if (longestLen == niceLen)\n        {\n            CmptBtSkip(mf, niceLen, pos, cur, curMatch);\n            CMPT_MF_MOVE_POS(mf);\n            return matchesCount;\n        }\n    }\n\n    if (longestLen < CMPT_MF_MATCH_3_BYTES)\n    {\n        longestLen = CMPT_MF_MATCH_3_BYTES;\n    }\n    matchesCount = (uint32_t)(CmptBtFind(mf, curMatch, matches + matchesCount, longestLen) - matches);\n\n    CMPT_MF_MOVE_POS(mf);\n    return matchesCount;\n}",
                                "rust_code": "pub fn CmptlzBt4Finder() { unimplemented!(); }"
                            },
                            {
                                "c_code": "void CmptlzMatchSkiper(CmptMfCtx *mf, uint32_t amount)\n{\n    mf->readAhead += amount;\n    uint32_t pos, temp, hash2Value, hash3Value, hashValue, curMatch;\n    const uint32_t niceLen = mf->niceLen;\n    do\n    {\n        uint32_t lenLimit = mf->srcLen - mf->readPos;\n        if (CMPTLZ_LIKELY(niceLen <= lenLimit))\n        {\n            lenLimit = niceLen;\n        }\n        else\n        {\n            mf->readPos++;\n            continue;\n        }\n        const uint8_t *cur = (const uint8_t *)(mf->srcStart + mf->readPos);\n        pos = mf->readPos + mf->offset;\n        CMPT_HASH_4_CALC(mf, cur, temp, hash2Value, hash3Value, hashValue);\n        curMatch = mf->hash[CMPTLZ_FIX_4_HASH + hashValue];\n        CMPT_HASH_UPDATE(mf, hash2Value, hash3Value, hashValue, pos);\n        CmptBtSkip(mf, lenLimit, pos, cur, curMatch);\n        CMPT_MF_MOVE_POS(mf);\n    } while (--amount != 0);\n}",
                                "rust_code": "pub fn CmptlzMatchSkiper() { unimplemented!(); }"
                            },
                            {
                                "c_code": "uint32_t CmptlzMatchFinder(CmptMfCtx *mf, uint32_t *pCount, CmptlzMatchPair *matches)\n{\n    if (CMPTLZ_UNLIKELY(mf->srcLen - mf->readPos < mf->niceLen))\n    {\n        *pCount = 0;\n        mf->readPos++;\n        mf->readAhead++;\n        return 0;\n    }\n    const uint32_t count = CmptlzBt4Finder(mf, matches);\n    if (count == 0)\n    {\n        *pCount = 0;\n        mf->readAhead++;\n        return 0;\n    }\n    uint32_t longestLen = matches[count - 1].len;\n    if (longestLen == mf->niceLen)\n    {\n        uint32_t bytesAvail = CMPTLZ_FIND_MIN(mf->srcLen - mf->readPos + 1, CMPT_MF_LONGEST_MATCH);\n        const uint8_t *p1 = (const uint8_t *)(mf->srcStart + mf->readPos - 1);\n        const uint8_t *p2 = p1 - matches[count - 1].dist - 1;\n        longestLen = CmptMemCmpLenSafe(p1, p2, longestLen, bytesAvail);\n    }\n    *pCount = count;\n    mf->readAhead++;\n    return longestLen;\n}",
                                "rust_code": "pub fn CmptlzMatchFinder() { unimplemented!(); }"
                            }
                        ]
                    },
                    "cmptlz_enc_struct_h.rs": {
                        "name": "cmptlz_enc_struct_h.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::include::cmptlz_enc_h::*;"
                        ],
                        "definitions": [
                            {
                                "c_code": "typedef uint16_t CmptlzProb;",
                                "rust_code": "pub type CmptlzProb = i32;"
                            },
                            {
                                "c_code": "typedef struct\n    {\n        int level;\n        uint32_t dictSize;\n        int litCtx;\n        int litPos;\n        int posBits;\n        int fastBytes;\n        int numThreads;\n    } CmptlzEncParam;",
                                "rust_code": "pub type CmptlzEncParam = i32;"
                            },
                            {
                                "c_code": "typedef struct\n    {\n        uint32_t pos;\n        uint32_t prevByte;\n        CmptlzProb literal[1 << CMPTLZ_LCLP_MAX][CMPTLZ_LIT_MAX_SIZE];\n        uint32_t lcBits;\n        uint32_t posMask;\n    } LitMarcov;",
                                "rust_code": "pub type LitMarcov = i32;"
                            },
                            {
                                "c_code": "typedef struct\n    {\n        uint32_t range;\n        uint64_t cache;\n        uint64_t low;\n        uint64_t cacheSize;\n        uint8_t *buf;\n        uint8_t *bufBase;\n        uint8_t *outBuf;\n        size_t outBufLeft;\n    } CmptRcCtx;",
                                "rust_code": "pub type CmptRcCtx = i32;"
                            },
                            {
                                "c_code": "typedef struct TagCmptMatchFinder CmptMfCtx;",
                                "rust_code": "pub type CmptMfCtx = i32;"
                            },
                            {
                                "c_code": "struct TagCmptMatchFinder\n    {\n\n        const uint8_t *srcStart;\n        size_t srcLen;\n\n        uint32_t hashRootTable[256];\n        uint32_t mfStart;\n        uint32_t niceLen;\n        uint32_t readAhead;\n        uint32_t readPos;\n        uint32_t cyclePos;\n        uint32_t cycleSize;\n        uint32_t offset;\n        uint32_t *hash;\n        uint32_t *son;\n        uint32_t depth;\n        uint32_t hashCount;\n        uint32_t sonsCount;\n        uint32_t hashMask;\n    };",
                                "rust_code": "pub type TagCmptMatchFinder = i32;"
                            },
                            {
                                "c_code": "typedef struct\n    {\n        CmptlzProb low[256];\n        CmptlzProb high[1 << CMPT_LEN_HIGH_BITS];\n        uint32_t prices[CMPTLZ_NUM_PB_STATES_MAX]\n                       [(1 << CMPT_LEN_HIGH_BITS) + (1 << CMPT_LEN_MID_BITS) + (1 << CMPT_LEN_LOW_BITS)];\n        uint32_t tableSize;\n    } CmptLenEncoder;",
                                "rust_code": "pub type CmptLenEncoder = i32;"
                            },
                            {
                                "c_code": "typedef enum\n    {\n        LIT_LIT,\n        MATCH_LIT_LIT,\n        REP_LIT_LIT,\n        SHORTREP_LIT_LIT,\n        MATCH_LIT,\n        REP_LIT,\n        SHORTREP_LIT,\n        LIT_MATCH,\n        LIT_LONGREP,\n        LIT_SHORTREP,\n        NOTLIT_MATCH,\n        NOTLIT_REP,\n    } CmptlzState;",
                                "rust_code": "pub type CmptlzState = i32;"
                            },
                            {
                                "c_code": "typedef struct\n    {\n        uint32_t len;\n        uint32_t dist;\n    } CmptlzMatchPair;",
                                "rust_code": "pub type CmptlzMatchPair = i32;"
                            },
                            {
                                "c_code": "typedef struct\n    {\n        CmptlzState state;\n        uint32_t price;\n        uint32_t posPrev;\n        uint32_t backPrev;\n        uint32_t backs[CMPTLZ_NUM_REPS];\n    } CmptlzOpt;",
                                "rust_code": "pub type CmptlzOpt = i32;"
                            },
                            {
                                "c_code": "struct TagCmptLzEncCtx\n    {\n\n        int level;\n        int litCtx;\n        int litPos;\n        int posBits;\n        uint32_t dicSize;\n        int endMarker;\n        uint32_t numFastBytes;\n\n        bool encNeedFinish;\n        uint64_t nowpos64;\n        uint32_t cmptlzResponse;\n\n        CmptlzState state;\n        LitMarcov litMarcov;\n        uint32_t reps[CMPTLZ_NUM_REPS];\n\n        CmptlzProb isRep[CMPTLZ_NUM_STATES];\n        CmptlzProb isRepG0[CMPTLZ_NUM_STATES];\n        CmptlzProb isRepG1[CMPTLZ_NUM_STATES];\n        CmptlzProb isRepG2[CMPTLZ_NUM_STATES];\n        CmptlzProb isMatch[CMPTLZ_NUM_STATES][CMPTLZ_NUM_PB_STATES_MAX];\n        CmptlzProb isRep0Long[CMPTLZ_NUM_STATES][CMPTLZ_NUM_PB_STATES_MAX];\n        CmptlzProb probDistSlot[CMPTLZ_DIST_STATE_TOTAL][1 << CMPTLZ_DIST_SLOT_BITS];\n        CmptlzProb probDistSpecial[CMPT_DIST_LIMIT_2];\n        CmptlzProb probAlign[1 << CMPTLZ_ALIGN_BITS];\n\n        uint32_t posMask;\n        uint64_t pbMask;\n        uint64_t lpMask;\n\n        CmptRcCtx *rcCtx;\n\n        CmptMfCtx *mfCtx;\n        CmptlzMatchPair matches[CMPT_MF_LONGEST_MATCH + 1];\n        uint32_t matchesCount;\n        uint32_t longestMatchLen;\n\n        uint32_t backRes;\n        uint32_t lenRes;\n        uint32_t optEndIndex;\n        uint32_t optsCurIndex;\n        CmptlzOpt opts[CMPT_DP_OPTMAX];\n\n        CmptLenEncoder matchLenEncoder;\n        CmptLenEncoder repLenEncoder;\n        int repLenPriceCount;\n\n        int matchPriceCount;\n        uint32_t priceRootTable[CMPT_PRIICE_TABLE_SIZE];\n        uint32_t priceDistSlotTable[CMPTLZ_DIST_STATE_TOTAL][1 << CMPTLZ_DIST_SLOT_BITS];\n        uint32_t priceDistTable[CMPTLZ_DIST_STATE_TOTAL][1 << 7];\n        uint32_t priceAlignTable[1 << CMPTLZ_ALIGN_BITS];\n        uint32_t distTableSize;\n    };",
                                "rust_code": "pub type TagCmptLzEncCtx = i32;"
                            }
                        ],
                        "macros": [
                            {
                                "c_code": "#define CMPTLZ_ENC_STRUCT_H",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_NUM_REPS 4",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_NUM_STATES 12",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_MATCH_LEN_MIN 2",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_PB_MAX 4",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LC_MAX 8",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LP_MAX 4",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LCLP_MAX 4",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_NUM_PB_STATES_MAX (1 << CMPTLZ_PB_MAX)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LIT_MAX_SIZE 0x300",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_PROB_MAX_NUM 2048",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_PROB_INIT 1024",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_RC_BUFFER_SIZE (1 << 16)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_DIST_LIMIT_1 4",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_DIST_LIMIT_2 128",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_DIST_STATE_TOTAL 4",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_ALIGN_BITS 4",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_DIST_SLOT_BITS 6",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_INFINITY_PRICE ((uint32_t)1 << 30)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_PRICE_BITS_MOVING_NUM 4",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_PRIICE_TABLE_SIZE (CMPTLZ_PROB_MAX_NUM >> CMPT_PRICE_BITS_MOVING_NUM)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_PRICE_COUNT 64",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_DOUBLE 2",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_LEN_LOW_BITS 3",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_LEN_MID_BITS 3",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_LEN_HIGH_BITS 8",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_LEN_BOUND 8",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_MF_LONGEST_MATCH 273",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_MEM_COMPARE_SAFE_DIST 8",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_MF_LONGEST_MATCH_SAFE (CMPT_MF_LONGEST_MATCH + CMPTLZ_MEM_COMPARE_SAFE_DIST)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_MF_HASH_TABLE_SIZE 256",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_MF_BASE_DEPTH 16",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_MF_MATCH_2_BYTES 2",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_MF_MATCH_3_BYTES 3",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_DP_OPTMAX (1 << 11)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_ONE_BLOCK_MAX_SIZE (1 << 17)",
                                "rust_code": ""
                            }
                        ],
                        "macro_functions": [],
                        "functions": []
                    },
                    "cmptlz_enc_blocks_c.rs": {
                        "name": "cmptlz_enc_blocks_c.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::encode::cmptlz_enc_inner_h::*;",
                            "pub use crate::src::encode::cmptlz_enc_symbol_h::*;"
                        ],
                        "definitions": [],
                        "macros": [],
                        "macro_functions": [],
                        "functions": [
                            {
                                "c_code": "static void CmptlzEndMarker(void)\n{\n\n    return;\n}",
                                "rust_code": "pub fn CmptlzEndMarker() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static int CmptlzFlush(CmptLzEncCtx *encCtx)\n{\n    encCtx->encNeedFinish = true;\n    if (encCtx->endMarker != 0)\n    {\n        CmptlzEndMarker();\n    }\n\n    CmptRcFlushData(encCtx->rcCtx);\n    return CmptRcFlush64Kb(encCtx->rcCtx);\n}",
                                "rust_code": "pub fn CmptlzFlush() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptPriceCheck(CmptLzEncCtx *encCtx)\n{\n\n    if (encCtx->matchPriceCount >= CMPT_PRICE_COUNT)\n    {\n        CmptPriceGenDistTable(encCtx);\n        CmptPriceGenAlignTable(encCtx);\n        CmptPriceGenLenTable(encCtx, &encCtx->matchLenEncoder);\n    }\n    if (encCtx->repLenPriceCount <= 0)\n    {\n        encCtx->repLenPriceCount = CMPT_PRICE_COUNT;\n        CmptPriceGenLenTable(encCtx, &encCtx->repLenEncoder);\n    }\n}",
                                "rust_code": "pub fn CmptPriceCheck() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline int CmptEncShortOrRep0(CmptLzEncCtx *encCtx, uint32_t nowpos32, uint32_t lenRes)\n{\n    int shiftRes = CMPT_OK;\n    if (lenRes == 1)\n    {\n        shiftRes = CmptlzEncShortRep(encCtx, nowpos32);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    else\n    {\n        shiftRes = CmptlzEncLongRep(encCtx, 0, nowpos32, lenRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    return CMPT_OK;\n}",
                                "rust_code": "pub fn CmptEncShortOrRep0() { unimplemented!(); }"
                            },
                            {
                                "c_code": "CMPTLZ_static int CmptEncodeOneBlock(CmptLzEncCtx *encCtx)\n{\n    CmptMfCtx *mf = encCtx->mfCtx;\n    uint32_t nowpos32 = encCtx->nowpos64;\n    uint32_t startpos = nowpos32;\n    uint32_t backRes, lenRes;\n    int shiftRes = CMPT_OK;\n    while (true)\n    {\n        CmptlzDp(encCtx, mf, nowpos32);\n        backRes = encCtx->backRes;\n        lenRes = encCtx->lenRes;\n#ifdef CMPTLZ_PRINTF_ENC_PROCESS\n        printf(\" now in CmptEncodeOneBlock process, backRes is %u, lenRes is %u\\n\", backRes, lenRes);\n        printf(\" nowpos32 is %u\\n\", nowpos32);\n#endif\n\n        switch (backRes)\n        {\n        case CMPTLZ_UINT32_MAX:\n            shiftRes = CmptlzEncLit(encCtx, mf, nowpos32);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 0:\n            shiftRes = CmptEncShortOrRep0(encCtx, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 1:\n            shiftRes = CmptlzEncLongRep(encCtx, 1, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 2:\n            shiftRes = CmptlzEncLongRep(encCtx, 2, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        case 3:\n            shiftRes = CmptlzEncLongRep(encCtx, 3, nowpos32, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        default:\n            shiftRes = CmptlzEncNormalMatch(encCtx, nowpos32, backRes, lenRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            break;\n        }\n\n        nowpos32 += lenRes;\n        mf->mfStart += lenRes;\n        mf->readAhead -= lenRes;\n\n        if (mf->readAhead == 0)\n        {\n\n            CmptPriceCheck(encCtx);\n            if (mf->srcLen <= mf->mfStart)\n            {\n                break;\n            }\n            if (nowpos32 - startpos >= CMPT_ONE_BLOCK_MAX_SIZE)\n            {\n                encCtx->nowpos64 += nowpos32 - startpos;\n                return 0;\n            }\n        }\n    }\n    encCtx->nowpos64 += nowpos32 - startpos;\n    return CmptlzFlush(encCtx);\n}",
                                "rust_code": "pub fn CmptEncodeOneBlock() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptEncodeAll(CmptLzEncCtx *encCtx)\n{\n    CmptRcCtx *rc = encCtx->rcCtx;\n    CmptMfCtx *mf = encCtx->mfCtx;\n\n    if (mf->srcLen == 0)\n    {\n        return CmptlzFlush(encCtx);\n    }\n\n    if (encCtx->nowpos64 == 0)\n    {\n        uint32_t range, bit0Prob, newBound;\n        range = rc->range;\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][0];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        int shiftRes = CMPT_OK;\n        CMPT_RC_BIT_0_PROCESS(rc, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        rc->range = range;\n        uint8_t curByte = *(mf->srcStart);\n        CmptlzProb *litProb = &encCtx->litMarcov.literal[0][0];\n        shiftRes = CmptRcLitProcess(rc, litProb, curByte);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        mf->mfStart++;\n        encCtx->nowpos64++;\n        mf->readPos++;\n        if (mf->srcLen == 1)\n        {\n            return CmptlzFlush(encCtx);\n        }\n    }\n\n    int res;\n    while (true)\n    {\n        res = CmptEncodeOneBlock(encCtx);\n        if (res != 0 || encCtx->encNeedFinish)\n        {\n            break;\n        }\n    }\n    return res;\n}",
                                "rust_code": "pub fn CmptEncodeAll() { unimplemented!(); }"
                            }
                        ]
                    },
                    "cmptlz_enc_rc_h.rs": {
                        "name": "cmptlz_enc_rc_h.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::encode::cmptlz_enc_inner_h::*;",
                            "pub use crate::src::encode::cmptlz_enc_price_h::*;",
                            "pub use crate::src::encode::cmptlz_enc_rc_c::CmptRcFlush64Kb;",
                            "pub use crate::src::encode::cmptlz_enc_rc_c::CmptRcFlushData;",
                            "pub use crate::src::encode::cmptlz_enc_rc_c::CmptRcPosSlotProcess;",
                            "pub use crate::src::encode::cmptlz_enc_rc_c::CmptRcLenProcess;",
                            "pub use crate::src::encode::cmptlz_enc_rc_c::CmptRcDistProcess;",
                            "pub use crate::src::encode::cmptlz_enc_rc_c::CmptRcShiftLow;",
                            "pub use crate::src::encode::cmptlz_enc_rc_c::CmptRcCtxInit;"
                        ],
                        "definitions": [],
                        "macros": [
                            {
                                "c_code": "#define CMPTLZ_ENC_RC_H",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_RC_MIN_RANGE (1 << 24)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_NUM_LEN_POS_STATE 4",
                                "rust_code": ""
                            }
                        ],
                        "macro_functions": [
                            {
                                "c_code": "#define GET_LEN_TO_POS_STATE(len) (((len) < CMPT_NUM_LEN_POS_STATE + 1) ? (len) - 2 : CMPT_NUM_LEN_POS_STATE - 1)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_RC_BREAK_CHECK(rcCtx, buf, res)                                                                           \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if ((buf) == (rcCtx->bufBase + CMPTLZ_RC_BUFFER_SIZE))                                                         \\\n        {                                                                                                              \\\n            (res) = CmptRcFlush64Kb(rcCtx);                                                                            \\\n            CMPTLZ_RETURN_IF_NOT_OK(res);                                                                              \\\n        }                                                                                                              \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_RC_BREAK_SHIFTING(rcCtx, buf, res)                                                                        \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        CMPT_RC_BREAK_CHECK(rcCtx, buf, res);                                                                          \\\n        if ((rcCtx)->cacheSize == 0)                                                                                   \\\n        {                                                                                                              \\\n            return CMPT_OK;                                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_RC_NORMALIZE(rcCtx, range, shiftRes)                                                                      \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if ((range) < CMPT_RC_MIN_RANGE)                                                                               \\\n        {                                                                                                              \\\n            (range) <<= 8;                                                                                             \\\n            (shiftRes) = CmptRcShiftLow(rcCtx);                                                                        \\\n        }                                                                                                              \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_RC_GET_NEWBOUND(prob, bit0Prob, range, newBound)                                                          \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (bit0Prob) = *(prob);                                                                                          \\\n        newBound = ((range) >> 11) * (bit0Prob);                                                                       \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_RC_BIT_PROCESS(rcCtx, prob, bit, bit0Prob, range, newBound, shiftRes)                                     \\\n    {                                                                                                                  \\\n        do                                                                                                             \\\n        {                                                                                                              \\\n            uint32_t mask = 0 - (uint32_t)(bit);                                                                       \\\n            CMPT_RC_GET_NEWBOUND(prob, bit0Prob, range, newBound);                                                     \\\n            (range) &= mask;                                                                                           \\\n            mask &= (newBound);                                                                                        \\\n            (range) -= mask;                                                                                           \\\n            (rcCtx)->low += mask;                                                                                      \\\n            mask = (uint32_t)(bit) - 1;                                                                                \\\n            (range) += (newBound) & mask;                                                                              \\\n            mask &= (CMPTLZ_PROB_MAX_NUM - ((1 << 5) - 1));                                                            \\\n            mask += ((1 << 5) - 1);                                                                                    \\\n            (bit0Prob) += (int)(mask - (bit0Prob)) >> 5;                                                               \\\n            *(prob) = (CmptlzProb)(bit0Prob);                                                                          \\\n            CMPT_RC_NORMALIZE(rcCtx, range, shiftRes);                                                                 \\\n        } while (0);                                                                                                   \\\n    }",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_RC_BIT_0(prob, newBound, range, bit0Prob)                                                                 \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (range) = (newBound);                                                                                          \\\n        *(prob) = (CmptlzProb)((bit0Prob) + ((CMPTLZ_PROB_MAX_NUM - (bit0Prob)) >> 5));                                \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_RC_BIT_1(rcCtx, prob, newBound, range, bit0Prob)                                                          \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (range) -= (newBound);                                                                                         \\\n        (rcCtx)->low += (newBound);                                                                                    \\\n        *(prob) = (CmptlzProb)((bit0Prob) - ((bit0Prob) >> 5));                                                        \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_RC_BIT_0_PROCESS(rcCtx, prob, newBound, range, bit0Prob, shiftRes)                                        \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        CMPT_RC_BIT_0(prob, newBound, range, bit0Prob);                                                                \\\n        CMPT_RC_NORMALIZE(rcCtx, range, shiftRes);                                                                     \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_RC_BIT_1_PROCESS(rcCtx, prob, newBound, range, bit0Prob, shiftRes)                                        \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        CMPT_RC_BIT_1(rcCtx, prob, newBound, range, bit0Prob);                                                         \\\n        CMPT_RC_NORMALIZE(rcCtx, range, shiftRes);                                                                     \\\n    } while (0)",
                                "rust_code": ""
                            }
                        ],
                        "functions": [
                            {
                                "c_code": "static inline int CmptRcLitProcess(CmptRcCtx *rcCtx, CmptlzProb *prob, uint32_t sym)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t range = rcCtx->range, bit0Prob, newBound, curBit;\n\n        for (sym |= 0x100; sym < 0x10000; sym <<= 1)\n        {\n            CmptlzProb *litProbTableIndex = prob + (sym >> 8);\n            curBit = (sym >> 7) & 1;\n            CMPT_RC_BIT_PROCESS(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        rcCtx->range = range;\n        return CMPT_OK;\n    }",
                                "rust_code": "pub fn CmptRcLitProcess() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline int CmptRcLitAfterMatch(CmptRcCtx *rcCtx, CmptlzProb *prob, uint32_t sym, uint32_t matchByte)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t range = rcCtx->range, offs = 0x100, bit0Prob, newBound, curBit;\n        for (sym |= 0x100; sym < 0x10000;)\n        {\n            matchByte <<= 1;\n            CmptlzProb *litProbTableIndex = prob + (offs + (matchByte & offs) + (sym >> 8));\n            curBit = (sym >> 7) & 1;\n            sym <<= 1;\n            offs &= ~(matchByte ^ sym);\n            CMPT_RC_BIT_PROCESS(rcCtx, litProbTableIndex, curBit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        rcCtx->range = range;\n        return CMPT_OK;\n    }",
                                "rust_code": "pub fn CmptRcLitAfterMatch() { unimplemented!(); }"
                            }
                        ]
                    },
                    "cmptlz_enc_dp_c.rs": {
                        "name": "cmptlz_enc_dp_c.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::encode::cmptlz_enc_inner_h::*;",
                            "pub use crate::src::encode::cmptlz_enc_price_h::*;"
                        ],
                        "definitions": [],
                        "macros": [],
                        "macro_functions": [],
                        "functions": [
                            {
                                "c_code": "static inline void CmptlzDpInitShortRep(CmptLzEncCtx *encCtx, uint32_t repMatchPrice, const uint32_t posState)\n{\n    const uint32_t shortRepPrice = repMatchPrice + CmptPriceShortRep(encCtx, encCtx->state, posState);\n    if (shortRepPrice < encCtx->opts[1].price)\n    {\n        encCtx->opts[1].price = shortRepPrice;\n        encCtx->opts[1].backPrev = 0;\n    }\n}",
                                "rust_code": "pub fn CmptlzDpInitShortRep() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptlzDpInitLongRep(CmptLzEncCtx *encCtx, uint32_t *repLens, const uint32_t repMatchPrice,\n                                       const uint32_t posState)\n{\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        uint32_t repLen = repLens[i];\n        if (repLen < CMPTLZ_MATCH_LEN_MIN)\n        {\n            continue;\n        }\n        const uint32_t price = repMatchPrice + CmptPriceLongRep(encCtx, i, encCtx->state, posState);\n        do\n        {\n            const uint32_t curAndLenPrice = price + CmptPriceLen(&encCtx->repLenEncoder, repLen, posState);\n            if (curAndLenPrice < encCtx->opts[repLen].price)\n            {\n                encCtx->opts[repLen].price = curAndLenPrice;\n                encCtx->opts[repLen].posPrev = 0;\n                encCtx->opts[repLen].backPrev = i;\n            }\n            repLen--;\n        } while (repLen >= CMPTLZ_MATCH_LEN_MIN);\n    }\n}",
                                "rust_code": "pub fn CmptlzDpInitLongRep() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptlzDpInitMatch(CmptLzEncCtx *encCtx, uint32_t matchesCount, uint32_t normalMatchPrice,\n                                     uint32_t posState, uint32_t len)\n{\n    uint32_t i = 0;\n    while (len > encCtx->matches[i].len)\n    {\n        i++;\n    }\n    for (;; len++)\n    {\n        const uint32_t dist = encCtx->matches[i].dist;\n        const uint32_t curAndLenPrice = normalMatchPrice + CmptPriceDistWithLen(encCtx, dist, len, posState);\n        if (curAndLenPrice < encCtx->opts[len].price)\n        {\n            encCtx->opts[len].price = curAndLenPrice;\n            encCtx->opts[len].posPrev = 0;\n            encCtx->opts[len].backPrev = dist + CMPTLZ_NUM_REPS;\n        }\n        if (len == encCtx->matches[i].len)\n        {\n            if (++i == matchesCount)\n            {\n                break;\n            }\n        }\n    }\n}",
                                "rust_code": "pub fn CmptlzDpInitMatch() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static uint32_t CmptlzDpInit(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t position)\n{\n    const uint32_t niceLen = mf->niceLen;\n    uint32_t lenMain;\n    uint32_t matchesCount = 0;\n\n    if (mf->readAhead == 0)\n    {\n        lenMain = CmptlzMatchFinder(mf, &matchesCount, encCtx->matches);\n    }\n    else\n    {\n        lenMain = encCtx->longestMatchLen;\n        matchesCount = encCtx->matchesCount;\n    }\n\n    const uint8_t *const buf = CmptMfGetPtr(mf) - 1;\n    const uint32_t bufAvail = CMPTLZ_FIND_MIN(CmptMfAvail(mf) + 1, CMPT_MF_LONGEST_MATCH);\n\n    if (bufAvail < CMPTLZ_MATCH_LEN_MIN)\n    {\n        encCtx->backRes = CMPTLZ_UINT32_MAX;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    uint32_t repLens[CMPTLZ_NUM_REPS];\n    uint32_t repMaxIndex = 0;\n\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        const uint8_t *const bufBack = buf - encCtx->reps[i] - 1;\n\n        if (NOT_EQUAL_2_BYTES(buf, bufBack))\n        {\n            repLens[i] = 0;\n            continue;\n        }\n        repLens[i] = CmptMemCmpLenSafe(buf, bufBack, CMPTLZ_MATCH_LEN_MIN, bufAvail);\n        if (repLens[i] > repLens[repMaxIndex])\n        {\n            repMaxIndex = i;\n        }\n    }\n\n    if (repLens[repMaxIndex] >= niceLen)\n    {\n        encCtx->backRes = repMaxIndex;\n        encCtx->lenRes = repLens[repMaxIndex];\n        CmptlzMatchSkiper(mf, repLens[repMaxIndex] - 1);\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    if (lenMain >= niceLen)\n    {\n        encCtx->backRes = encCtx->matches[matchesCount - 1].dist + CMPTLZ_NUM_REPS;\n        encCtx->lenRes = lenMain;\n        CmptlzMatchSkiper(mf, lenMain - 1);\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    const uint8_t currentByte = *buf;\n    const uint8_t matchByte = *(buf - encCtx->reps[0] - 1);\n    const uint32_t lenEnd = CMPTLZ_FIND_MAX(lenMain, repLens[repMaxIndex]);\n    if ((lenEnd < CMPTLZ_MATCH_LEN_MIN) && (currentByte != matchByte))\n    {\n        encCtx->backRes = CMPTLZ_UINT32_MAX;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    encCtx->opts[0].state = encCtx->state;\n\n    const uint32_t posState = position & encCtx->posMask;\n\n    encCtx->litMarcov.pos = position;\n    encCtx->litMarcov.prevByte = *(buf - 1);\n    bool isLiteralState = (encCtx->state < 7);\n    bool isMatchMode = !isLiteralState;\n\n    encCtx->opts[1].price = CmptPriceBit0(encCtx, encCtx->isMatch[encCtx->state][posState]) +\n                            CmptPriceLiteral(encCtx, isMatchMode, matchByte, currentByte);\n    encCtx->opts[1].backPrev = CMPTLZ_UINT32_MAX;\n\n    const uint32_t matchPrice = CmptPriceBit1(encCtx, encCtx->isMatch[encCtx->state][posState]);\n    const uint32_t repMatchPrice = matchPrice + CmptPriceBit1(encCtx, encCtx->isRep[encCtx->state]);\n\n    if (matchByte == currentByte)\n    {\n        CmptlzDpInitShortRep(encCtx, repMatchPrice, posState);\n    }\n\n    if (lenEnd < CMPTLZ_MATCH_LEN_MIN)\n    {\n        encCtx->backRes = encCtx->opts[1].backPrev;\n        encCtx->lenRes = 1;\n        return CMPTLZ_UINT32_MAX;\n    }\n\n    encCtx->opts[1].posPrev = 0;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->opts[0].backs[i] = encCtx->reps[i];\n    }\n\n    uint32_t len = lenEnd;\n    do\n    {\n        encCtx->opts[len].price = CMPT_INFINITY_PRICE;\n        len--;\n    } while (len >= CMPTLZ_MATCH_LEN_MIN);\n\n    CmptlzDpInitLongRep(encCtx, repLens, repMatchPrice, posState);\n\n    const uint32_t normalMatchPrice = matchPrice + CmptPriceBit0(encCtx, encCtx->isRep[encCtx->state]);\n    len = (repLens[0] > CMPTLZ_MATCH_LEN_MIN) ? repLens[0] + 1 : CMPTLZ_MATCH_LEN_MIN;\n\n    if (len <= lenMain)\n    {\n        CmptlzDpInitMatch(encCtx, matchesCount, normalMatchPrice, posState, len);\n    }\n    return lenEnd;\n}",
                                "rust_code": "pub fn CmptlzDpInit() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptlzDpPre(CmptLzEncCtx *encCtx, uint32_t *mainReps, const uint32_t cur)\n{\n    uint32_t posPointer = encCtx->opts[cur].posPrev;\n    CmptlzState state = encCtx->opts[posPointer].state;\n\n    if (posPointer == cur - 1)\n    {\n        if (encCtx->opts[cur].backPrev == 0)\n        {\n            CMPT_STATE_UPDATE_WHEN_SHORTREP(state);\n        }\n        else\n        {\n            CMPT_STATE_UPDATE_WHEN_LIT(state);\n        }\n    }\n    else\n    {\n        uint32_t backPointer;\n        backPointer = encCtx->opts[cur].backPrev;\n\n        if (backPointer < CMPTLZ_NUM_REPS)\n        {\n            CMPT_STATE_UPDATE_WHEN_LONGREP(state);\n        }\n        else\n        {\n            CMPT_STATE_UPDATE_WHEN_MATCH(state);\n        }\n\n        uint32_t i;\n        if (backPointer < CMPTLZ_NUM_REPS)\n        {\n            mainReps[0] = encCtx->opts[posPointer].backs[backPointer];\n\n            for (i = 1; i <= backPointer; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i - 1];\n            }\n            for (; i < CMPTLZ_NUM_REPS; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i];\n            }\n        }\n        else\n        {\n            mainReps[0] = backPointer - CMPTLZ_NUM_REPS;\n            for (i = 1; i < CMPTLZ_NUM_REPS; i++)\n            {\n                mainReps[i] = encCtx->opts[posPointer].backs[i - 1];\n            }\n        }\n    }\n\n    encCtx->opts[cur].state = state;\n\n    uint32_t i;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->opts[cur].backs[i] = mainReps[i];\n    }\n}",
                                "rust_code": "pub fn CmptlzDpPre() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptlzDpTryCurAndLit(CmptLzEncCtx *encCtx, const uint32_t curPrice, CmptlzState curState,\n                                        const uint32_t posState, const uint32_t cur, const uint8_t latestMatchByte,\n                                        const uint8_t curByte)\n{\n    bool isLiteralState = (curState < 7);\n    bool isMatchMode = !isLiteralState;\n    const uint32_t curAndLitPrice = curPrice + CmptPriceBit0(encCtx, encCtx->isMatch[curState][posState]) +\n                                    CmptPriceLiteral(encCtx, isMatchMode, latestMatchByte, curByte);\n    if (curAndLitPrice < encCtx->opts[cur + 1].price)\n    {\n        encCtx->opts[cur + 1].price = curAndLitPrice;\n        encCtx->opts[cur + 1].posPrev = cur;\n        encCtx->opts[cur + 1].backPrev = CMPTLZ_UINT32_MAX;\n    }\n}",
                                "rust_code": "pub fn CmptlzDpTryCurAndLit() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptlzDpTryCurAndShort(CmptLzEncCtx *encCtx, const uint32_t repMatchPrice, const uint32_t cur,\n                                          CmptlzState curState, const uint32_t posState)\n{\n    const uint32_t shortRepPrice = repMatchPrice + CmptPriceShortRep(encCtx, curState, posState);\n    if (shortRepPrice < encCtx->opts[cur + 1].price)\n    {\n        encCtx->opts[cur + 1].price = shortRepPrice;\n        encCtx->opts[cur + 1].posPrev = cur;\n        encCtx->opts[cur + 1].backPrev = 0;\n    }\n}",
                                "rust_code": "pub fn CmptlzDpTryCurAndShort() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptlzDpTryCurAndLong(CmptLzEncCtx *encCtx, const uint32_t prefixPrice, const uint32_t cur,\n                                         uint32_t mainRepIndex, uint32_t lenEqual, const uint32_t posState)\n{\n    do\n    {\n        const uint32_t curLongRepPrice = prefixPrice + CmptPriceLen(&encCtx->repLenEncoder, lenEqual, posState);\n\n        if (curLongRepPrice < encCtx->opts[cur + lenEqual].price)\n        {\n            encCtx->opts[cur + lenEqual].price = curLongRepPrice;\n            encCtx->opts[cur + lenEqual].posPrev = cur;\n            encCtx->opts[cur + lenEqual].backPrev = mainRepIndex;\n        }\n    } while (--lenEqual >= CMPTLZ_MATCH_LEN_MIN);\n}",
                                "rust_code": "pub fn CmptlzDpTryCurAndLong() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptlzDpTryCurAndMatch(CmptLzEncCtx *encCtx, uint32_t startLen, uint32_t matchCount,\n                                          const uint32_t normalmatch_prefixPrice, const uint32_t cur,\n                                          const uint32_t posState)\n{\n    uint32_t i = 0;\n    while (startLen > encCtx->matches[i].len)\n    {\n        i++;\n    }\n    uint32_t lenTest;\n    for (lenTest = startLen;; lenTest++)\n    {\n        const uint32_t curBack = encCtx->matches[i].dist;\n        uint32_t cur_normalmatchPrice =\n            normalmatch_prefixPrice + CmptPriceDistWithLen(encCtx, curBack, lenTest, posState);\n        if (cur_normalmatchPrice < encCtx->opts[cur + lenTest].price)\n        {\n            encCtx->opts[cur + lenTest].price = cur_normalmatchPrice;\n            encCtx->opts[cur + lenTest].posPrev = cur;\n            encCtx->opts[cur + lenTest].backPrev = curBack + CMPTLZ_NUM_REPS;\n        }\n        if (lenTest == encCtx->matches[i].len)\n        {\n            if (++i == matchCount)\n            {\n                break;\n            }\n        }\n    }\n}",
                                "rust_code": "pub fn CmptlzDpTryCurAndMatch() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t CmptlzDpProcess(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t *mainReps, uint32_t lenEnd,\n                                       uint32_t position, const uint32_t cur)\n{\n\n    CmptlzState curState = encCtx->opts[cur].state;\n    const uint32_t bufAvailFull = CMPTLZ_FIND_MIN(CmptMfAvail(mf) + 1, CMPT_DP_OPTMAX - 1 - cur);\n    const uint8_t *buf = CmptMfGetPtr(mf) - 1;\n    const uint32_t niceLen = mf->niceLen;\n    const uint32_t curPrice = encCtx->opts[cur].price;\n    const uint8_t curByte = *buf;\n    const uint8_t latestMatchByte = *(buf - mainReps[0] - 1);\n    const uint32_t posState = position & encCtx->posMask;\n\n    encCtx->litMarcov.pos = position;\n    encCtx->litMarcov.prevByte = *(buf - 1);\n\n    CmptlzDpTryCurAndLit(encCtx, curPrice, curState, posState, cur, latestMatchByte, curByte);\n\n    const uint32_t matchPrice = curPrice + CmptPriceBit1(encCtx, encCtx->isMatch[curState][posState]);\n    const uint32_t repMatchPrice = matchPrice + CmptPriceBit1(encCtx, encCtx->isRep[curState]);\n\n    if (curByte == latestMatchByte && !(encCtx->opts[cur + 1].posPrev < cur && encCtx->opts[cur + 1].backPrev == 0))\n    {\n\n        CmptlzDpTryCurAndShort(encCtx, repMatchPrice, cur, curState, posState);\n    }\n\n    if (bufAvailFull < CMPTLZ_MATCH_LEN_MIN)\n    {\n        return lenEnd;\n    }\n    const uint32_t bufAvail = CMPTLZ_FIND_MIN(bufAvailFull, niceLen);\n    uint32_t startLen = CMPTLZ_MATCH_LEN_MIN;\n\n    uint32_t mainRepIndex;\n    for (mainRepIndex = 0; mainRepIndex < CMPTLZ_NUM_REPS; mainRepIndex++)\n    {\n        const uint8_t *const bufRepBack = buf - mainReps[mainRepIndex] - 1;\n\n        if (NOT_EQUAL_2_BYTES(buf, bufRepBack))\n        {\n            continue;\n        }\n\n        uint32_t lenEqual;\n        lenEqual = CmptMemCmpLenSafe(buf, bufRepBack, CMPTLZ_MATCH_LEN_MIN, bufAvail);\n        while (lenEnd < cur + lenEqual)\n        {\n\n            lenEnd++;\n            encCtx->opts[lenEnd].price = CMPT_INFINITY_PRICE;\n        }\n\n        const uint32_t lenEqualMem = lenEqual;\n\n        const uint32_t prefixPrice = repMatchPrice + CmptPriceLongRep(encCtx, mainRepIndex, curState, posState);\n\n        CmptlzDpTryCurAndLong(encCtx, prefixPrice, cur, mainRepIndex, lenEqual, posState);\n\n        lenEqual = lenEqualMem;\n\n        if (mainRepIndex == 0)\n        {\n            startLen = lenEqual + 1;\n        }\n    }\n\n    uint32_t newLongestLen = encCtx->longestMatchLen;\n    uint32_t matchCount = encCtx->matchesCount;\n\n    if (newLongestLen > bufAvail)\n    {\n        newLongestLen = bufAvail;\n        matchCount = 0;\n        while (newLongestLen > encCtx->matches[matchCount].len)\n        {\n            ++matchCount;\n        }\n        encCtx->matches[matchCount++].len = newLongestLen;\n    }\n\n    if (newLongestLen >= startLen)\n    {\n        const uint32_t normalmatch_prefixPrice = matchPrice + CmptPriceBit0(encCtx, encCtx->isRep[curState]);\n\n        while (lenEnd < cur + newLongestLen)\n        {\n            lenEnd++;\n            encCtx->opts[lenEnd].price = CMPT_INFINITY_PRICE;\n        }\n        CmptlzDpTryCurAndMatch(encCtx, startLen, matchCount, normalmatch_prefixPrice, cur, posState);\n    }\n    return lenEnd;\n}",
                                "rust_code": "pub fn CmptlzDpProcess() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptlzDpReverse(CmptLzEncCtx *encCtx, uint32_t cur)\n{\n    encCtx->optEndIndex = cur;\n    uint32_t posTmp = encCtx->opts[cur].posPrev;\n    uint32_t backTmp = encCtx->opts[cur].backPrev;\n    uint32_t posPrev, backCurPacket;\n    do\n    {\n        posPrev = posTmp;\n        backCurPacket = backTmp;\n\n        backTmp = encCtx->opts[posPrev].backPrev;\n        posTmp = encCtx->opts[posPrev].posPrev;\n\n        encCtx->opts[posPrev].backPrev = backCurPacket;\n        encCtx->opts[posPrev].posPrev = cur;\n        cur = posPrev;\n    } while (cur != 0);\n\n    encCtx->lenRes = encCtx->opts[0].posPrev;\n    encCtx->backRes = encCtx->opts[0].backPrev;\n    encCtx->optsCurIndex = encCtx->opts[0].posPrev;\n}",
                                "rust_code": "pub fn CmptlzDpReverse() { unimplemented!(); }"
                            },
                            {
                                "c_code": "void CmptlzDp(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t position)\n{\n    uint32_t curIndex = encCtx->optsCurIndex;\n    uint32_t endIndex = encCtx->optEndIndex;\n\n    if (endIndex != curIndex)\n    {\n        encCtx->lenRes = encCtx->opts[curIndex].posPrev - curIndex;\n        encCtx->backRes = encCtx->opts[curIndex].backPrev;\n        encCtx->optsCurIndex = encCtx->opts[curIndex].posPrev;\n        return;\n    }\n    uint32_t lenEnd = CmptlzDpInit(encCtx, mf, position);\n\n    if (lenEnd == CMPTLZ_UINT32_MAX)\n    {\n        return;\n    }\n    uint32_t mainReps[CMPTLZ_NUM_REPS];\n    memcpy_s(mainReps, sizeof(mainReps), encCtx->reps, sizeof(encCtx->reps));\n\n    uint32_t cur;\n    for (cur = 1; cur < lenEnd; cur++)\n    {\n        encCtx->longestMatchLen = CmptlzMatchFinder(mf, &encCtx->matchesCount, encCtx->matches);\n        if (encCtx->longestMatchLen >= mf->niceLen)\n        {\n            break;\n        }\n        CmptlzDpPre(encCtx, mainReps, cur);\n        lenEnd = CmptlzDpProcess(encCtx, mf, mainReps, lenEnd, position + cur, cur);\n    }\n    CmptlzDpReverse(encCtx, cur);\n    return;\n}",
                                "rust_code": "pub fn CmptlzDp() { unimplemented!(); }"
                            }
                        ]
                    },
                    "cmptlz_enc_rc_c.rs": {
                        "name": "cmptlz_enc_rc_c.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::encode::cmptlz_enc_rc_h::*;"
                        ],
                        "definitions": [],
                        "macros": [
                            {
                                "c_code": "#define CMPT_RC_LEN_LIMIT_1 8",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_RC_LEN_LIMIT_2 16",
                                "rust_code": ""
                            }
                        ],
                        "macro_functions": [],
                        "functions": [
                            {
                                "c_code": "int CmptRcPrepare(CmptLzEncCtx *encCtx, uint8_t *dest, size_t *destLen, CmptLzMemHook *alloc)\n{\n\n    CmptRcCtx *rc = alloc->CmptLzAlloc(CMPTLZ_RC_CCTX_HANDLE, sizeof(CmptRcCtx));\n    if (rc == NULL)\n    {\n        return CMPT_ENC_RC_INIT_FAIL;\n    }\n    memset_s(rc, sizeof(CmptRcCtx), 0, sizeof(CmptRcCtx));\n\n    encCtx->rcCtx = rc;\n\n    rc->bufBase = alloc->CmptLzAlloc(CMPTLZ_RC_BUF_HANDLE, CMPTLZ_RC_BUFFER_SIZE);\n    memset_s(rc->bufBase, CMPTLZ_RC_BUFFER_SIZE, 0, CMPTLZ_RC_BUFFER_SIZE);\n    if (rc->bufBase == NULL)\n    {\n        return CMPT_ENC_RC_INIT_FAIL;\n    }\n\n    rc->outBufLeft = *destLen;\n    rc->outBuf = dest;\n\n    rc->buf = rc->bufBase;\n    rc->range = 0xFFFFFFFF;\n    rc->cacheSize = 0;\n    rc->cache = 0;\n    rc->low = 0;\n    return 0;\n}",
                                "rust_code": "pub fn CmptRcPrepare() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptRcFlush64Kb(CmptRcCtx *rcCtx)\n{\n    size_t flushOutLen = rcCtx->buf - rcCtx->bufBase;\n    int res = memcpy_s(rcCtx->outBuf, rcCtx->outBufLeft, rcCtx->bufBase, flushOutLen);\n    if (res != 0)\n    {\n        return CMPT_ENC_ERROR_WRITE;\n    }\n    rcCtx->outBuf += flushOutLen;\n    rcCtx->outBufLeft -= flushOutLen;\n    rcCtx->buf = rcCtx->bufBase;\n    return CMPT_OK;\n}",
                                "rust_code": "pub fn CmptRcFlush64Kb() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptRcShiftLow(CmptRcCtx *rcCtx)\n{\n    int res = CMPT_OK;\n    uint32_t lowLow32 = (uint32_t)rcCtx->low;\n    uint64_t high = (uint32_t)(rcCtx->low >> 32);\n    rcCtx->low = (uint32_t)(lowLow32 << 8);\n    CMPT_RC_BREAK_CHECK(rcCtx, rcCtx->buf, res);\n    if (lowLow32 < 0xFF000000 || high != 0)\n    {\n        uint8_t *buf = rcCtx->buf;\n        *(buf) = (uint8_t)(rcCtx->cache + high);\n        buf++;\n        rcCtx->buf = buf;\n        rcCtx->cache = (uint8_t)(lowLow32 >> 24);\n        CMPT_RC_BREAK_SHIFTING(rcCtx, buf, res);\n        high += 0xFF;\n        while (1)\n        {\n            uint8_t *buf1 = rcCtx->buf;\n            CMPT_RC_BREAK_SHIFTING(rcCtx, buf1, res);\n            *(buf1++) = (uint8_t)(high);\n            rcCtx->buf = buf1;\n            rcCtx->cacheSize--;\n        }\n        CMPT_RC_BREAK_SHIFTING(rcCtx, buf, res);\n    }\n    else\n    {\n        rcCtx->cacheSize++;\n    }\n    return res;\n}",
                                "rust_code": "pub fn CmptRcShiftLow() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptRcFlushData(CmptRcCtx *rcCtx)\n{\n    int i;\n    int res;\n    for (i = 0; i < 5; i++)\n    {\n        res = CmptRcShiftLow(rcCtx);\n        if (res != CMPT_OK)\n        {\n            break;\n        }\n    }\n    return res;\n}",
                                "rust_code": "pub fn CmptRcFlushData() { unimplemented!(); }"
                            },
                            {
                                "c_code": "void CmptRcCtxInit(CmptRcCtx *rcCtx)\n{\n    rcCtx->range = 0xFFFFFFFF;\n    rcCtx->cache = 0;\n    rcCtx->low = 0;\n    rcCtx->cacheSize = 0;\n    rcCtx->buf = rcCtx->bufBase;\n}",
                                "rust_code": "pub fn CmptRcCtxInit() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptRcLenProcess(CmptLenEncoder *lenEncoder, CmptRcCtx *rcCtx, uint32_t len, uint64_t posState)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = rcCtx->range;\n    uint32_t newBound, bit0Prob;\n    len -= CMPTLZ_MATCH_LEN_MIN;\n\n    CmptlzProb *probs = lenEncoder->low;\n    CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n    if (len >= CMPT_LEN_BOUND)\n    {\n        CMPT_RC_BIT_1_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        probs += CMPT_LEN_BOUND;\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        if (len >= CMPT_LEN_BOUND * CMPT_DOUBLE)\n        {\n            CMPT_RC_BIT_1_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            rcCtx->range = range;\n            shiftRes = CmptRcLitProcess(rcCtx, lenEncoder->high, len - CMPT_LEN_BOUND * CMPT_DOUBLE);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            return CMPT_OK;\n        }\n        len -= CMPT_LEN_BOUND;\n    }\n\n    uint32_t m, bit;\n    CMPT_RC_BIT_0_PROCESS(rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    probs += (posState << (1 + 3));\n    bit = (len >> 2);\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + 1, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    m = (1 << 1) + bit;\n    bit = (len >> 1) & 1;\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    m = (m << 1) + bit;\n    bit = len & 1;\n    CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n    CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    rcCtx->range = range;\n    return CMPT_OK;\n}",
                                "rust_code": "pub fn CmptRcLenProcess() { unimplemented!(); }"
                            },
                            {
                                "c_code": "inline int CmptRcPosSlotProcess(CmptLzEncCtx *encCtx, uint32_t posSlot, uint32_t len)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = encCtx->rcCtx->range;\n    uint32_t sym = posSlot + (1 << 6);\n    uint32_t bit0Prob, newBound;\n    uint32_t bit;\n    CmptlzProb *probs = encCtx->probDistSlot[GET_LEN_TO_POS_STATE(len)];\n    do\n    {\n        CmptlzProb *posSlotProbTableIndex = probs + (sym >> CMPTLZ_DIST_SLOT_BITS);\n        bit = (sym >> (CMPTLZ_DIST_SLOT_BITS - 1)) & 1;\n        sym <<= 1;\n        CMPT_RC_BIT_PROCESS(encCtx->rcCtx, posSlotProbTableIndex, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    } while (sym < (1 << (CMPTLZ_DIST_SLOT_BITS * 2)));\n    encCtx->rcCtx->range = range;\n    return CMPT_OK;\n}",
                                "rust_code": "pub fn CmptRcPosSlotProcess() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline int CmptRcReverseProcess(CmptRcCtx *rcCtx, CmptlzProb *probs, uint32_t numBits, uint32_t sym)\n{\n    int shiftRes = CMPT_OK;\n    uint32_t range = rcCtx->range;\n    uint32_t bit0Prob, newBound;\n    uint32_t bit;\n    uint32_t m = 1;\n    do\n    {\n        bit = sym & 1;\n        sym >>= 1;\n        CMPT_RC_BIT_PROCESS(rcCtx, probs + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        m = (m << 1) | bit;\n    } while (--numBits);\n\n    rcCtx->range = range;\n    return CMPT_OK;\n}",
                                "rust_code": "pub fn CmptRcReverseProcess() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptRcDistProcess(CmptLzEncCtx *encCtx, uint32_t posSlot, uint32_t dist)\n{\n    int shiftRes = CMPT_OK;\n\n    uint32_t footerBits = ((posSlot >> 1) - 1);\n    if (dist < CMPT_DIST_LIMIT_2)\n    {\n        uint32_t base = ((2 | (posSlot & 1)) << footerBits);\n        shiftRes = CmptRcReverseProcess(encCtx->rcCtx, encCtx->probDistSpecial + base, footerBits, dist);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n    }\n    else\n    {\n        uint32_t pos2 = (dist | 0xF) << (32 - footerBits);\n        uint32_t range = encCtx->rcCtx->range;\n        do\n        {\n            range >>= 1;\n            encCtx->rcCtx->low += range & (0 - (pos2 >> 31));\n            pos2 += pos2;\n            CMPT_RC_NORMALIZE(encCtx->rcCtx, range, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        } while (pos2 != 0xF0000000);\n\n        uint32_t m = 1;\n        uint32_t bit;\n        uint32_t bit0Prob, newBound;\n        int k;\n        for (k = 0; k < CMPTLZ_ALIGN_BITS - 1; k++)\n        {\n            bit = dist & 1;\n            dist >>= 1;\n            CMPT_RC_BIT_PROCESS(encCtx->rcCtx, encCtx->probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n            m = (m << 1) + bit;\n        }\n        bit = dist & 1;\n        CMPT_RC_BIT_PROCESS(encCtx->rcCtx, encCtx->probAlign + m, bit, bit0Prob, range, newBound, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n    }\n    return CMPT_OK;\n}",
                                "rust_code": "pub fn CmptRcDistProcess() { unimplemented!(); }"
                            }
                        ]
                    },
                    "cmptlz_enc_c.rs": {
                        "name": "cmptlz_enc_c.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::encode::cmptlz_enc_inner_h::*;",
                            "pub use crate::src::public::cmptlz_log_h::*;"
                        ],
                        "definitions": [],
                        "macros": [],
                        "macro_functions": [],
                        "functions": [
                            {
                                "c_code": "void CmptlzFreeAll(CmptLzEncCtx *encCtx, CmptLzMemHook *alloc)\n{\n    if (encCtx == NULL)\n    {\n        return;\n    }\n\n    if (encCtx->mfCtx != NULL)\n    {\n        if (encCtx->mfCtx->hash != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_MF_HASH_HANDLE, encCtx->mfCtx->hash);\n            encCtx->mfCtx->hash = NULL;\n        }\n        if (encCtx->mfCtx->son != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_MF_SON_HANDLE, encCtx->mfCtx->son);\n            encCtx->mfCtx->son = NULL;\n        }\n        alloc->CmptLzFree(CMPTLZ_MF_CCTX_HANDLE, encCtx->mfCtx);\n        encCtx->mfCtx = NULL;\n    }\n\n    if (encCtx->rcCtx != NULL)\n    {\n        if (encCtx->rcCtx->bufBase != NULL)\n        {\n            alloc->CmptLzFree(CMPTLZ_RC_BUF_HANDLE, encCtx->rcCtx->bufBase);\n            encCtx->rcCtx->bufBase = NULL;\n        }\n        alloc->CmptLzFree(CMPTLZ_RC_CCTX_HANDLE, encCtx->rcCtx);\n        encCtx->rcCtx = NULL;\n    }\n\n    alloc->CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE, encCtx);\n    encCtx = NULL;\n}",
                                "rust_code": "pub fn CmptlzFreeAll() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptlzEncodeIO(CmptLzEncCtx *encCtx, uint8_t *dest, size_t *destLen, const uint8_t *src, size_t srcLen,\n                   CmptLzMemHook *alloc)\n{\n    int res;\n\n    res = CmptMfPrepare(encCtx, src, srcLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptMfPrepare Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n\n    res = CmptRcPrepare(encCtx, dest, destLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptRcPrepare Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return res;\n    }\n\n    CmptlzEncPrepare(encCtx);\n\n    res = CmptEncodeAll(encCtx);\n\n    if (res != 0)\n    {\n        CmptlzFreeAll(encCtx, alloc);\n        CMPTLZ_LOG(res, \"CmptEncode Process Fail!\");\n        return res;\n    }\n\n    *destLen -= encCtx->rcCtx->outBufLeft;\n\n    if (encCtx->nowpos64 != srcLen)\n    {\n        CMPTLZ_LOG(res, \"CmptEncode FileSize Fail!\");\n        CmptlzFreeAll(encCtx, alloc);\n        return CMPT_ENC_ERROR_FILESIZE;\n    }\n\n    CmptlzFreeAll(encCtx, alloc);\n    return res;\n}",
                                "rust_code": "pub fn CmptlzEncodeIO() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptlzEncode(uint8_t *dest, size_t *destLen, const uint8_t *src, size_t srcLen, const CmptlzEncParam *props,\n                 uint8_t *propsEncoded, size_t *propsSize, int writeEndMark, CmptLzMemHook *alloc)\n{\n    int res;\n    if (alloc == NULL || alloc->CmptLzAlloc == NULL || alloc->CmptLzFree == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ENC_ERROR_PARAM, \"Cmptlz input wrong param!\");\n        return CMPT_ENC_ERROR_PARAM;\n    }\n\n    CmptLzEncCtx *encCtx = (CmptLzEncCtx *)CmptInitCctx(alloc, writeEndMark);\n    if (encCtx == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ENC_CTX_INIT_FAIL, \"CmptInitCctx Fail!\");\n        return CMPT_ENC_CTX_INIT_FAIL;\n    }\n    CmptlzSetParam(encCtx, props);\n    res = CmptHeadWrite(encCtx, propsEncoded, propsSize);\n    if (res != 0)\n    {\n        alloc->CmptLzFree(CMPTLZ_ENC_CCTX_HANDLE, encCtx);\n        CMPTLZ_LOG(res, \"CmptHeadWrite Fail!\");\n        return res;\n    }\n    res = CmptlzEncodeIO(encCtx, dest, destLen, src, srcLen, alloc);\n    if (res != 0)\n    {\n        CMPTLZ_LOG(res, \"CmptlzEncode I / O Fail!\");\n    }\n    return res;\n}",
                                "rust_code": "pub fn CmptlzEncode() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptlzCompress(void *src, size_t srcSize, void *dst, size_t *dstSize, CmptlzCompParam *param)\n{\n    if ((src == NULL) && (srcSize != 0))\n    {\n        return CMPT_ENC_ERROR_PARAM;\n    }\n\n    const int endMarker = 0;\n\n    CmptlzEncParam props;\n    props.level = param->level;\n    props.dictSize = param->dictSize;\n    props.litCtx = param->litCtx;\n    props.litPos = param->litPos;\n    props.posBits = param->posBits;\n    props.fastBytes = param->fastBytes;\n    props.numThreads = param->numThreads;\n    CmptLzMemHook *alloc = param->memHook;\n    return CmptlzEncode((uint8_t *)dst, dstSize, (const uint8_t *)src, srcSize, &props, param->protData,\n                        &param->protSize, endMarker, alloc);\n}",
                                "rust_code": "pub fn CmptlzCompress() { unimplemented!(); }"
                            }
                        ]
                    },
                    "cmptlz_enc_inner_h.rs": {
                        "name": "cmptlz_enc_inner_h.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::public::cmptlz_def_h::*;",
                            "pub use crate::src::encode::cmptlz_enc_struct_h::*;",
                            "pub use crate::src::encode::cmptlz_enc_blocks_c::CmptEncodeAll;",
                            "pub use crate::src::encode::cmptlz_enc_init_c::CmptlzEncPrepare;",
                            "pub use crate::src::encode::cmptlz_enc_mf_c::CmptlzMatchSkiper;",
                            "pub use crate::src::encode::cmptlz_enc_init_c::CmptlzSetParam;",
                            "pub use crate::src::encode::cmptlz_enc_head_c::CmptHeadWrite;",
                            "pub use crate::src::encode::cmptlz_enc_init_c::CmptInitCctx;",
                            "pub use crate::src::encode::cmptlz_enc_mf_c::CmptlzMatchFinder;",
                            "pub use crate::src::encode::cmptlz_enc_rc_c::CmptRcPrepare;",
                            "pub use crate::src::encode::cmptlz_enc_mf_c::CmptMfPrepare;",
                            "pub use crate::src::encode::cmptlz_enc_dp_c::CmptlzDp;",
                            "pub use crate::src::encode::cmptlz_enc_init_c::CmptlzPriceInit;",
                            "pub use crate::src::encode::cmptlz_enc_init_c::CmptlzParamNormalize;"
                        ],
                        "definitions": [],
                        "macros": [
                            {
                                "c_code": "#define CMPTLZ_ENC_INNER_H",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_UINT32_MAX (uint32_t)(-1)",
                                "rust_code": ""
                            }
                        ],
                        "macro_functions": [
                            {
                                "c_code": "#define CMPTLZ_FIND_MIN(x, y) ((x) < (y) ? (x) : (y))",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_FIND_MAX(x, y) ((x) > (y) ? (x) : (y))",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define NOT_EQUAL_2_BYTES(a, b) ((a)[0] != (b)[0] || (a)[1] != (b)[1])",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_RETURN_IF_NOT_OK(res)                                                                                   \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if (CMPTLZ_UNLIKELY(res != CMPT_OK))                                                                           \\\n        {                                                                                                              \\\n            return res;                                                                                                \\\n        }                                                                                                              \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_GET_DIST_STATE(len) (((len) < 4 + CMPTLZ_MATCH_LEN_MIN) ? (len) - CMPTLZ_MATCH_LEN_MIN : 4 - 1)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_STATE_UPDATE_WHEN_LIT(state)                                                                              \\\n    (state) = (((state) <= SHORTREP_LIT_LIT) ? LIT_LIT : (((state) <= LIT_SHORTREP) ? (state) - 3 : (state) - 6))",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_STATE_UPDATE_WHEN_MATCH(state) (state) = (((state) < 7) ? LIT_MATCH : NOTLIT_MATCH)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_STATE_UPDATE_WHEN_LONGREP(state) (state) = (((state) < 7) ? LIT_LONGREP : NOTLIT_REP)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPT_STATE_UPDATE_WHEN_SHORTREP(state) (state) = (((state) < 7) ? LIT_SHORTREP : NOTLIT_REP)",
                                "rust_code": ""
                            }
                        ],
                        "functions": [
                            {
                                "c_code": "static inline uint32_t CmptMemCmpByOneByte(const uint8_t *buf1, const uint8_t *buf2, uint32_t len, uint32_t limit)\n    {\n        uint32_t lenIn = len;\n        while ((lenIn < limit) && (buf1[lenIn] == buf2[lenIn]))\n        {\n            lenIn++;\n        }\n        return lenIn;\n    }",
                                "rust_code": "pub fn CmptMemCmpByOneByte() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t CmptMemCmpLenSafe(const uint8_t *buf1, const uint8_t *buf2, uint32_t len, uint32_t limit)\n    {\n        return CmptMemCmpByOneByte(buf1, buf2, len, limit);\n    }",
                                "rust_code": "pub fn CmptMemCmpLenSafe() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t CmptMemCmpLen(const uint8_t *buf1, const uint8_t *buf2, uint32_t len, uint32_t limit)\n    {\n        return CmptMemCmpByOneByte(buf1, buf2, len, limit);\n    }",
                                "rust_code": "pub fn CmptMemCmpLen() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t CmptMfAvail(const CmptMfCtx *mf)\n    {\n        return mf->srcLen - mf->readPos;\n    }",
                                "rust_code": "pub fn CmptMfAvail() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline const uint8_t *CmptMfGetPtr(const CmptMfCtx *mf)\n    {\n        return mf->srcStart + mf->readPos;\n    }",
                                "rust_code": "pub fn CmptMfGetPtr() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t PosSlotHelper(uint32_t n)\n    {\n#if (defined(__GNUC__) && (__GNUC__ >= 3))\n        return 31 - (uint32_t)__builtin_clz(n);\n#else\n    uint32_t i = 31;\n    if ((n & 0xFFFF0000) == 0)\n    {\n        n <<= 16;\n        i = 15;\n    }\n    if ((n & 0xFF000000) == 0)\n    {\n        n <<= 8;\n        i -= 8;\n    }\n    if ((n & 0xF0000000) == 0)\n    {\n        n <<= 4;\n        i -= 4;\n    }\n    if ((n & 0xC0000000) == 0)\n    {\n        n <<= 2;\n        i -= 2;\n    }\n    if ((n & 0x80000000) == 0)\n        --i;\n    return i;\n#endif\n    }",
                                "rust_code": "pub fn PosSlotHelper() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t PosSloter(uint32_t dist)\n    {\n        if (dist <= 4)\n        {\n            return dist;\n        }\n        uint32_t helper = PosSlotHelper(dist);\n        return (helper + helper + ((dist >> (helper - 1)) & 1));\n    }",
                                "rust_code": "pub fn PosSloter() { unimplemented!(); }"
                            }
                        ]
                    },
                    "cmptlz_enc_init_c.rs": {
                        "name": "cmptlz_enc_init_c.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::encode::cmptlz_enc_inner_h::*;",
                            "pub use crate::src::encode::cmptlz_enc_price_h::*;",
                            "pub use crate::src::encode::cmptlz_enc_rc_h::*;"
                        ],
                        "definitions": [],
                        "macros": [
                            {
                                "c_code": "#define CMPTLZ_MIN_DICTSIZE (1024)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_MAX_DICTSIZE (128 * 1024 * 1024)",
                                "rust_code": ""
                            }
                        ],
                        "macro_functions": [
                            {
                                "c_code": "#define CMPTLZ_SET_DICTSIZE_BY_LEVEL(level, dictSize)                                                                  \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        dictSize = (level <= 5) ? (1 << (level * 2 + 14)) : ((level <= 7) ? (1 << 25) : (1 << 26));                    \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_SET_FB_BY_LEVEL(level, fastBytes) (fastBytes = ((level < 7) ? 32 : 64))",
                                "rust_code": ""
                            }
                        ],
                        "functions": [
                            {
                                "c_code": "void CmptlzParamNormalize(CmptlzEncParam *props)\n{\n\n    int level = props->level;\n    if (level < 0 || level > 9)\n    {\n        level = 5;\n    }\n    props->level = level;\n\n    if (props->dictSize < CMPTLZ_MIN_DICTSIZE || props->dictSize > CMPTLZ_MAX_DICTSIZE)\n    {\n        CMPTLZ_SET_DICTSIZE_BY_LEVEL(level, props->dictSize);\n    }\n    if (props->fastBytes < 5 || props->fastBytes > CMPT_MF_LONGEST_MATCH)\n    {\n        CMPTLZ_SET_FB_BY_LEVEL(level, props->fastBytes);\n    }\n\n    if (props->litCtx < 0 || props->litCtx > CMPTLZ_LC_MAX)\n    {\n        props->litCtx = 3;\n    }\n    if (props->litPos < 0 || props->litPos > CMPTLZ_LP_MAX)\n    {\n        props->litPos = 0;\n    }\n    if (props->posBits < 0 || props->posBits > CMPTLZ_PB_MAX)\n    {\n        props->posBits = 2;\n    }\n\n    props->numThreads = 1;\n}",
                                "rust_code": "pub fn CmptlzParamNormalize() { unimplemented!(); }"
                            },
                            {
                                "c_code": "void CmptlzSetParam(CmptLzEncCtx *encCtx, const CmptlzEncParam *props)\n{\n    CmptlzEncParam param = *props;\n\n    CmptlzParamNormalize(&param);\n\n    encCtx->dicSize = param.dictSize;\n    encCtx->numFastBytes = param.fastBytes;\n    encCtx->litCtx = param.litCtx;\n    encCtx->litPos = param.litPos;\n    encCtx->posBits = param.posBits;\n    uint32_t i;\n    for (i = 7; i < 32; i++)\n    {\n        if (encCtx->dicSize <= (uint32_t)(1 << i))\n        {\n            break;\n        }\n    }\n    encCtx->distTableSize = i * 2;\n}",
                                "rust_code": "pub fn CmptlzSetParam() { unimplemented!(); }"
                            },
                            {
                                "c_code": "void CmptlzPriceInit(CmptLzEncCtx *encCtx)\n{\n    CmptPriceGenRootTable(encCtx);\n    CmptPriceGenDistTable(encCtx);\n    CmptPriceGenAlignTable(encCtx);\n}",
                                "rust_code": "pub fn CmptlzPriceInit() { unimplemented!(); }"
                            },
                            {
                                "c_code": "void CmptlzEncPrepare(CmptLzEncCtx *encCtx)\n{\n    uint32_t i;\n    uint32_t j;\n\n    encCtx->encNeedFinish = false;\n    encCtx->cmptlzResponse = 0;\n    encCtx->nowpos64 = 0;\n\n    encCtx->state = 0;\n    encCtx->pbMask = (1 << encCtx->posBits) - 1;\n    encCtx->lpMask = ((uint32_t)0x100 << encCtx->litPos) - ((uint32_t)0x100 >> encCtx->litCtx);\n    encCtx->posMask = (1 << encCtx->posBits) - 1;\n    for (i = 0; i < CMPTLZ_NUM_REPS; i++)\n    {\n        encCtx->reps[i] = 0;\n    }\n\n    encCtx->optsCurIndex = 0;\n    encCtx->optEndIndex = 0;\n    for (i = 0; i < CMPT_DP_OPTMAX; i++)\n    {\n        encCtx->opts[i].price = CMPT_INFINITY_PRICE;\n    }\n\n    for (i = 0; i < CMPTLZ_NUM_STATES; i++)\n    {\n        for (j = 0; j < CMPTLZ_NUM_PB_STATES_MAX; j++)\n        {\n            encCtx->isMatch[i][j] = CMPTLZ_PROB_INIT;\n            encCtx->isRep0Long[i][j] = CMPTLZ_PROB_INIT;\n        }\n        encCtx->isRep[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG0[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG1[i] = CMPTLZ_PROB_INIT;\n        encCtx->isRepG2[i] = CMPTLZ_PROB_INIT;\n    }\n\n    for (i = 0; i < CMPTLZ_DIST_STATE_TOTAL; i++)\n    {\n        for (j = 0; j < (1 << CMPTLZ_DIST_SLOT_BITS); j++)\n        {\n            encCtx->probDistSlot[i][j] = CMPTLZ_PROB_INIT;\n        }\n    }\n    for (i = 0; i < CMPT_DIST_LIMIT_2; i++)\n    {\n        encCtx->probDistSpecial[i] = CMPTLZ_PROB_INIT;\n    }\n    for (i = 0; i < (1 << CMPTLZ_ALIGN_BITS); i++)\n    {\n        encCtx->probAlign[i] = CMPTLZ_PROB_INIT;\n    }\n\n    encCtx->litMarcov.lcBits = encCtx->litCtx;\n    encCtx->litMarcov.posMask = (1U << encCtx->litPos) - 1;\n\n    for (i = 0; i < (1 << CMPTLZ_LCLP_MAX); i++)\n    {\n        for (j = 0; j < CMPTLZ_LIT_MAX_SIZE; j++)\n        {\n            encCtx->litMarcov.literal[i][j] = CMPTLZ_PROB_INIT;\n        }\n    }\n\n    for (i = 0; i < (1 << CMPT_LEN_HIGH_BITS); i++)\n    {\n        encCtx->matchLenEncoder.high[i] = CMPTLZ_PROB_INIT;\n        encCtx->repLenEncoder.high[i] = CMPTLZ_PROB_INIT;\n        encCtx->matchLenEncoder.low[i] = CMPTLZ_PROB_INIT;\n        encCtx->repLenEncoder.low[i] = CMPTLZ_PROB_INIT;\n    }\n\n    CmptlzPriceInit(encCtx);\n\n    encCtx->repLenEncoder.tableSize = encCtx->numFastBytes - 1;\n    encCtx->matchLenEncoder.tableSize = encCtx->numFastBytes - 1;\n    CmptPriceGenLenTable(encCtx, &encCtx->matchLenEncoder);\n    CmptPriceGenLenTable(encCtx, &encCtx->repLenEncoder);\n}",
                                "rust_code": "pub fn CmptlzEncPrepare() { unimplemented!(); }"
                            },
                            {
                                "c_code": "void *CmptInitCctx(CmptLzMemHook *alloc, int writeEndMark)\n{\n    void *handle = alloc->CmptLzAlloc(CMPTLZ_ENC_CCTX_HANDLE, sizeof(CmptLzEncCtx));\n    if (handle == NULL)\n    {\n        return NULL;\n    }\n    memset_s(handle, sizeof(CmptLzEncCtx), 0, sizeof(CmptLzEncCtx));\n    CmptLzEncCtx *encCtx = (CmptLzEncCtx *)handle;\n    encCtx->endMarker = writeEndMark;\n    encCtx->rcCtx = NULL;\n    encCtx->mfCtx = NULL;\n    return encCtx;\n}",
                                "rust_code": "pub fn CmptInitCctx() { unimplemented!(); }"
                            }
                        ]
                    },
                    "cmptlz_enc_head_c.rs": {
                        "name": "cmptlz_enc_head_c.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::encode::cmptlz_enc_inner_h::*;",
                            "pub use crate::src::public::cmptlz_log_h::*;",
                            "pub use crate::src::public::cmptlz_utils_h::*;"
                        ],
                        "definitions": [],
                        "macros": [
                            {
                                "c_code": "#define CMPTLZ_LIT_CTX_MAX 9",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_POS_STATE_MAX 5",
                                "rust_code": ""
                            }
                        ],
                        "macro_functions": [],
                        "functions": [
                            {
                                "c_code": "int CmptHeadWrite(CmptLzEncCtx *encCtx, uint8_t *protData, size_t *propsSize)\n{\n    if (protData == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_DATA, \"protData is NULL\");\n        return CMPT_ENC_ERROR_HEAD;\n    }\n\n    if (*propsSize < CMPTLZ_PROPS_SIZE)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_DATA, \"propsSize need 5 bytes, get %zu\", *propsSize);\n        return CMPT_ENC_ERROR_HEAD;\n    }\n\n    CmptlzWriteLE32Bit(protData + 1, encCtx->dicSize);\n    protData[0] = (encCtx->posBits * CMPTLZ_POS_STATE_MAX + encCtx->litPos) * CMPTLZ_LIT_CTX_MAX + encCtx->litCtx;\n    *propsSize = CMPTLZ_PROPS_SIZE;\n    return 0;\n}",
                                "rust_code": "pub fn CmptHeadWrite() { unimplemented!(); }"
                            }
                        ]
                    },
                    "cmptlz_enc_price_h.rs": {
                        "name": "cmptlz_enc_price_h.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::encode::cmptlz_enc_inner_h::*;",
                            "pub use crate::src::encode::cmptlz_enc_price_c::CmptPriceLen;",
                            "pub use crate::src::encode::cmptlz_enc_price_c::CmptPriceGenRootTable;",
                            "pub use crate::src::encode::cmptlz_enc_price_c::CmptPriceLongRep;",
                            "pub use crate::src::encode::cmptlz_enc_price_c::CmptPriceDistWithLen;",
                            "pub use crate::src::encode::cmptlz_enc_price_c::CmptPriceGenAlignTable;",
                            "pub use crate::src::encode::cmptlz_enc_price_c::CmptPriceShortRep;",
                            "pub use crate::src::encode::cmptlz_enc_price_c::CmptPriceGenDistTable;",
                            "pub use crate::src::encode::cmptlz_enc_price_c::CmptPriceLiteral;",
                            "pub use crate::src::encode::cmptlz_enc_price_c::CmptPriceGenLenTable;"
                        ],
                        "definitions": [],
                        "macros": [
                            {
                                "c_code": "#define CMPTLZ_ENC_PRICE_H",
                                "rust_code": ""
                            }
                        ],
                        "macro_functions": [],
                        "functions": [
                            {
                                "c_code": "static inline uint32_t CmptPriceOneBitDirect(uint32_t bit)\n    {\n        return (bit << CMPT_PRICE_BITS_MOVING_NUM);\n    }",
                                "rust_code": "pub fn CmptPriceOneBitDirect() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t CmptPriceOneBit(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob, uint32_t curbit)\n    {\n        return encCtx->priceRootTable[(bit0Prob ^ ((uint32_t)(0 - curbit) & (CMPTLZ_PROB_MAX_NUM - 1))) >>\n                                      CMPT_PRICE_BITS_MOVING_NUM];\n    }",
                                "rust_code": "pub fn CmptPriceOneBit() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t CmptPriceBit0(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob)\n    {\n        return encCtx->priceRootTable[bit0Prob >> CMPT_PRICE_BITS_MOVING_NUM];\n    }",
                                "rust_code": "pub fn CmptPriceBit0() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t CmptPriceBit1(CmptLzEncCtx *encCtx, CmptlzProb bit0Prob)\n    {\n        return encCtx->priceRootTable[(bit0Prob ^ (CMPTLZ_PROB_MAX_NUM - 1)) >> CMPT_PRICE_BITS_MOVING_NUM];\n    }",
                                "rust_code": "pub fn CmptPriceBit1() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t CmptPriceSymbol(CmptLzEncCtx *encCtx, CmptlzProb *symbolProbs, uint32_t symbolBitsNum,\n                                           uint32_t symbol)\n    {\n        uint32_t price = 0;\n        symbol += (1U << symbolBitsNum);\n        do\n        {\n            uint32_t bit = symbol & 1;\n            symbol >>= 1;\n            price += CmptPriceOneBit(encCtx, symbolProbs[symbol], bit);\n        } while (symbol != 1);\n        return price;\n    }",
                                "rust_code": "pub fn CmptPriceSymbol() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t CmptPriceSymbolReverse(CmptLzEncCtx *encCtx, CmptlzProb *symbolProbs, uint32_t symbolBitsNum,\n                                                  uint32_t symbol)\n    {\n        uint32_t price = 0;\n        uint32_t i = 1;\n        do\n        {\n            uint32_t bit = symbol & 1;\n            symbol >>= 1;\n            price += CmptPriceOneBit(encCtx, symbolProbs[i], bit);\n            i = (i << 1) + bit;\n        } while (--symbolBitsNum);\n\n        return price;\n    }",
                                "rust_code": "pub fn CmptPriceSymbolReverse() { unimplemented!(); }"
                            }
                        ]
                    },
                    "cmptlz_enc_symbol_h.rs": {
                        "name": "cmptlz_enc_symbol_h.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::encode::cmptlz_enc_inner_h::*;",
                            "pub use crate::src::encode::cmptlz_enc_rc_h::*;"
                        ],
                        "definitions": [],
                        "macros": [
                            {
                                "c_code": "#define CMPTLZ_ENC_SYMBOL_H",
                                "rust_code": ""
                            }
                        ],
                        "macro_functions": [
                            {
                                "c_code": "#define CMPT_LIT_PROB_GET(encCtx, litProb, pos, prevByte)                                                              \\\n    (litProb + (uint32_t)3 * (((((pos) << 8) + (prevByte)) & encCtx->lpMask) << encCtx->litMarcov.lcBits))",
                                "rust_code": ""
                            }
                        ],
                        "functions": [
                            {
                                "c_code": "static inline int CmptlzEncLit(CmptLzEncCtx *encCtx, CmptMfCtx *mf, uint32_t nowpos32)\n    {\n        int shiftRes = CMPT_OK;\n        CmptRcCtx *rc = encCtx->rcCtx;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n        uint32_t range, bit0Prob, newBound;\n        range = rc->range;\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(rc, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        rc->range = range;\n        CmptlzProb *litProb = &encCtx->litMarcov.literal[0][0];\n        const uint8_t curByte = mf->srcStart[mf->readPos - mf->readAhead];\n        probs = CMPT_LIT_PROB_GET(encCtx, litProb, nowpos32, mf->srcStart[mf->readPos - mf->readAhead - 1]);\n        CmptlzState state = encCtx->state;\n        CMPT_STATE_UPDATE_WHEN_LIT(encCtx->state);\n        if (state < 7)\n        {\n            shiftRes = CmptRcLitProcess(rc, probs, curByte);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        else\n        {\n            const uint8_t match_byte = mf->srcStart[mf->readPos - encCtx->reps[0] - 1 - mf->readAhead];\n            shiftRes = CmptRcLitAfterMatch(rc, probs, curByte, match_byte);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        return CMPT_OK;\n    }",
                                "rust_code": "pub fn CmptlzEncLit() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline int CmptlzEncShortRep(CmptLzEncCtx *encCtx, uint32_t nowpos32)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n        uint32_t range, bit0Prob, newBound;\n        range = encCtx->rcCtx->range;\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRepG0[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep0Long[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n\n        CmptlzState state = encCtx->state;\n        encCtx->state = CMPT_STATE_UPDATE_WHEN_SHORTREP(state);\n        return CMPT_OK;\n    }",
                                "rust_code": "pub fn CmptlzEncShortRep() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline int CmptlzEncNormalMatch(CmptLzEncCtx *encCtx, uint32_t nowpos32, uint32_t backRes, uint32_t lenRes)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n        uint32_t range, bit0Prob, newBound;\n        range = encCtx->rcCtx->range;\n\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        encCtx->rcCtx->range = range;\n        CmptlzState state = encCtx->state;\n        encCtx->state = CMPT_STATE_UPDATE_WHEN_MATCH(state);\n\n        shiftRes = CmptRcLenProcess(&encCtx->matchLenEncoder, encCtx->rcCtx, lenRes, posState);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        backRes -= CMPTLZ_NUM_REPS;\n        encCtx->reps[3] = encCtx->reps[2];\n        encCtx->reps[2] = encCtx->reps[1];\n        encCtx->reps[1] = encCtx->reps[0];\n        encCtx->reps[0] = backRes;\n\n        encCtx->matchPriceCount++;\n\n        uint32_t posSlot = PosSloter(backRes);\n        shiftRes = CmptRcPosSlotProcess(encCtx, posSlot, lenRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        if (backRes >= 4)\n        {\n            shiftRes = CmptRcDistProcess(encCtx, posSlot, backRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        }\n        return CMPT_OK;\n    }",
                                "rust_code": "pub fn CmptlzEncNormalMatch() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline int CmptlzEncLongRep(CmptLzEncCtx *encCtx, uint32_t repIndex, uint32_t nowpos32, uint32_t lenRes)\n    {\n        int shiftRes = CMPT_OK;\n        uint32_t posState = nowpos32 & encCtx->pbMask;\n\n        uint32_t range, bit0Prob, newBound;\n        uint32_t realDist;\n        range = encCtx->rcCtx->range;\n\n        CmptlzProb *probs = &encCtx->isMatch[encCtx->state][posState];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRep[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n        CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n        probs = &encCtx->isRepG0[encCtx->state];\n        CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n\n        switch (repIndex)\n        {\n        case 0:\n            CMPT_RC_BIT_0_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRep0Long[encCtx->state][posState];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1(encCtx->rcCtx, probs, newBound, range, bit0Prob);\n            break;\n        case 1:\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG1[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0(probs, newBound, range, bit0Prob);\n\n            realDist = encCtx->reps[1];\n            encCtx->reps[1] = encCtx->reps[0];\n            encCtx->reps[0] = realDist;\n            break;\n        case 2:\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG1[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG2[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_0(probs, newBound, range, bit0Prob);\n\n            realDist = encCtx->reps[2];\n            encCtx->reps[2] = encCtx->reps[1];\n            encCtx->reps[1] = encCtx->reps[0];\n            encCtx->reps[0] = realDist;\n            break;\n        case 3:\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG1[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1_PROCESS(encCtx->rcCtx, probs, newBound, range, bit0Prob, shiftRes);\n            CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n\n            probs = &encCtx->isRepG2[encCtx->state];\n            CMPT_RC_GET_NEWBOUND(probs, bit0Prob, range, newBound);\n            CMPT_RC_BIT_1(encCtx->rcCtx, probs, newBound, range, bit0Prob);\n            realDist = encCtx->reps[3];\n            encCtx->reps[3] = encCtx->reps[2];\n            encCtx->reps[2] = encCtx->reps[1];\n            encCtx->reps[1] = encCtx->reps[0];\n            encCtx->reps[0] = realDist;\n            break;\n        default:\n            break;\n        }\n        CMPT_RC_NORMALIZE(encCtx->rcCtx, range, shiftRes);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        encCtx->rcCtx->range = range;\n\n        shiftRes = CmptRcLenProcess(&encCtx->repLenEncoder, encCtx->rcCtx, lenRes, posState);\n        CMPTLZ_RETURN_IF_NOT_OK(shiftRes);\n        --encCtx->repLenPriceCount;\n\n        CmptlzState state = encCtx->state;\n        encCtx->state = CMPT_STATE_UPDATE_WHEN_LONGREP(state);\n        return CMPT_OK;\n    }",
                                "rust_code": "pub fn CmptlzEncLongRep() { unimplemented!(); }"
                            }
                        ]
                    },
                    "cmptlz_enc_price_c.rs": {
                        "name": "cmptlz_enc_price_c.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::encode::cmptlz_enc_price_h::*;"
                        ],
                        "definitions": [],
                        "macros": [],
                        "macro_functions": [
                            {
                                "c_code": "#define CMPT_LIT_SUBCODER(probs, litCtx, lpMask, pos, prevByte)                                                        \\\n    ((probs)[(((pos) & (lpMask)) << (litCtx)) + ((uint32_t)(prevByte) >> (8U - (litCtx)))])",
                                "rust_code": ""
                            }
                        ],
                        "functions": [
                            {
                                "c_code": "void CmptPriceGenRootTable(CmptLzEncCtx *encCtx)\n{\n    uint32_t *rootTable = encCtx->priceRootTable;\n\n    const unsigned expandCycleNum = 4;\n    const unsigned bitsTotalModeNum = 11;\n    const unsigned valueForNormal = 15;\n    const unsigned wTopBoarder = 1 << 16;\n\n    for (unsigned i = 0; i < ((uint32_t)1 << bitsTotalModeNum >> CMPT_PRICE_BITS_MOVING_NUM); i++)\n    {\n        unsigned w = (i << CMPT_PRICE_BITS_MOVING_NUM) + (1 << (CMPT_PRICE_BITS_MOVING_NUM - 1));\n        unsigned dummyNormalizeCnt = 0;\n        for (unsigned j = 0; j < expandCycleNum; j++)\n        {\n            w = w * w;\n            dummyNormalizeCnt <<= 1;\n            while (w >= wTopBoarder)\n            {\n                w >>= 1;\n                dummyNormalizeCnt++;\n            }\n        }\n        rootTable[i] = (uint32_t)((bitsTotalModeNum << expandCycleNum) - valueForNormal - dummyNormalizeCnt);\n    }\n}",
                                "rust_code": "pub fn CmptPriceGenRootTable() { unimplemented!(); }"
                            },
                            {
                                "c_code": "void CmptPriceGenDistTable(CmptLzEncCtx *encCtx)\n{\n    uint32_t distState = 0;\n\n    do\n    {\n        uint32_t *const tmpPriceDistSlot = encCtx->priceDistSlotTable[distState];\n\n        for (uint32_t i = 0; i < encCtx->distTableSize; i++)\n        {\n            tmpPriceDistSlot[i] = CmptPriceSymbol(encCtx, encCtx->probDistSlot[distState], CMPTLZ_DIST_SLOT_BITS, i);\n        }\n\n        for (uint32_t i = 14; i < encCtx->distTableSize; i++)\n        {\n            tmpPriceDistSlot[i] += CmptPriceOneBitDirect((i >> 1) - 1 - CMPTLZ_ALIGN_BITS);\n        }\n\n        for (uint32_t i = 0; i < 4; i++)\n        {\n            encCtx->priceDistTable[distState][i] = tmpPriceDistSlot[i];\n        }\n\n        distState++;\n    } while (distState < CMPTLZ_DIST_STATE_TOTAL);\n\n    for (uint32_t i = 4; i < 128; i++)\n    {\n        uint32_t distSlot = PosSloter(i);\n        uint32_t footerBits = (distSlot >> 1) - 1;\n        uint32_t base = (2 | (distSlot & 1)) << footerBits;\n        uint32_t price =\n            CmptPriceSymbolReverse(encCtx, encCtx->probDistSpecial + base - distSlot - 1, footerBits, i - base);\n\n        for (distState = 0; distState < 4; distState++)\n        {\n            encCtx->priceDistTable[distState][i] = price + encCtx->priceDistSlotTable[distState][distSlot];\n        }\n    }\n\n    encCtx->matchPriceCount = 0;\n}",
                                "rust_code": "pub fn CmptPriceGenDistTable() { unimplemented!(); }"
                            },
                            {
                                "c_code": "void CmptPriceGenAlignTable(CmptLzEncCtx *encCtx)\n{\n    for (uint32_t i = 0; i < (1 << CMPTLZ_ALIGN_BITS); i++)\n    {\n        encCtx->priceAlignTable[i] = CmptPriceSymbolReverse(encCtx, encCtx->probAlign, CMPTLZ_ALIGN_BITS, i);\n    }\n}",
                                "rust_code": "pub fn CmptPriceGenAlignTable() { unimplemented!(); }"
                            },
                            {
                                "c_code": "uint32_t CmptPriceLiteral(CmptLzEncCtx *encCtx, bool matchMode, uint32_t matchByte, uint32_t symbol)\n{\n    uint32_t pos = encCtx->litMarcov.pos;\n    uint32_t prevByte = encCtx->litMarcov.prevByte;\n    uint32_t litCtx = encCtx->litMarcov.lcBits;\n    uint32_t lpMask = encCtx->litMarcov.posMask;\n    CmptlzProb *subCoder = CMPT_LIT_SUBCODER(encCtx->litMarcov.literal, litCtx, lpMask, pos, prevByte);\n\n    uint32_t price = 0;\n    if (!matchMode)\n    {\n        price = CmptPriceSymbol(encCtx, subCoder, 8, symbol);\n    }\n    else\n    {\n        uint32_t offset = 0x100;\n        symbol += 1 << 8;\n        do\n        {\n            matchByte <<= 1;\n            const uint32_t matchBit = matchByte & offset;\n            const uint32_t subCoderIndex = offset + matchBit + (symbol >> 8);\n            const uint32_t bit = (symbol >> 7) & 1;\n            price += CmptPriceOneBit(encCtx, subCoder[subCoderIndex], bit);\n            symbol <<= 1;\n            offset &= ~(matchByte ^ symbol);\n        } while (symbol < (1 << 16));\n    }\n    return price;\n}",
                                "rust_code": "pub fn CmptPriceLiteral() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static void CmptPriceSet(CmptLzEncCtx *encCtx, const CmptlzProb *probs, uint32_t startPrice, uint32_t *prices)\n{\n    uint32_t i;\n    for (i = 0; i < 8; i += 2)\n    {\n        uint32_t price = startPrice;\n        uint32_t prob;\n        price += CmptPriceOneBit(encCtx, probs[1], (i >> 2));\n        price += CmptPriceOneBit(encCtx, probs[2 + (i >> 2)], (i >> 1) & 1);\n        prob = probs[4 + (i >> 1)];\n        prices[i] = price + CmptPriceBit0(encCtx, prob);\n        prices[i + 1] = price + CmptPriceBit1(encCtx, prob);\n    }\n}",
                                "rust_code": "pub fn CmptPriceSet() { unimplemented!(); }"
                            },
                            {
                                "c_code": "void CmptPriceGenLenTable(CmptLzEncCtx *encCtx, CmptLenEncoder *lenEncoder)\n{\n    const uint32_t numPosStates = 1 << encCtx->posBits;\n\n    uint32_t b;\n\n    uint32_t prob = lenEncoder->low[0];\n    uint32_t a, c;\n    uint32_t posState;\n\n    b = CmptPriceBit1(encCtx, prob);\n    a = CmptPriceBit0(encCtx, prob);\n    c = b + CmptPriceBit0(encCtx, lenEncoder->low[1 << CMPT_LEN_LOW_BITS]);\n\n    for (posState = 0; posState < numPosStates; posState++)\n    {\n        uint32_t *prices = lenEncoder->prices[posState];\n        const CmptlzProb *probs = lenEncoder->low + (posState << (1 + CMPT_LEN_LOW_BITS));\n        CmptPriceSet(encCtx, probs, a, prices);\n        CmptPriceSet(encCtx, probs + (1 << CMPT_LEN_LOW_BITS), c, prices + (1 << CMPT_LEN_LOW_BITS));\n    }\n\n    uint32_t i = lenEncoder->tableSize;\n    if (i > (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE)\n    {\n        const CmptlzProb *probs = lenEncoder->high;\n        uint32_t *prices = lenEncoder->prices[0] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE;\n        i -= (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE - 1;\n        i >>= 1;\n        b += CmptPriceBit1(encCtx, lenEncoder->low[(1 << CMPT_LEN_LOW_BITS)]);\n        do\n        {\n            uint32_t sym = --i + (1 << (CMPT_LEN_HIGH_BITS - 1));\n            uint32_t price = b;\n            do\n            {\n                uint32_t bit = sym & 1;\n                sym >>= 1;\n                price += CmptPriceOneBit(encCtx, probs[sym], bit);\n            } while (sym >= 2);\n\n            prob = probs[(size_t)i + (1 << (CMPT_LEN_HIGH_BITS - 1))];\n            prices[(size_t)i * CMPT_DOUBLE] = price + CmptPriceBit0(encCtx, prob);\n            prices[(size_t)i * CMPT_DOUBLE + 1] = price + CmptPriceBit1(encCtx, prob);\n        } while (i);\n        size_t num =\n            (lenEncoder->tableSize - (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE) * sizeof(lenEncoder->prices[0][0]);\n\n        for (posState = 1; posState < numPosStates; posState++)\n        {\n            memcpy_s(lenEncoder->prices[posState] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE, CMPT_MF_LONGEST_MATCH - 1,\n                     lenEncoder->prices[0] + (1 << CMPT_LEN_LOW_BITS) * CMPT_DOUBLE, num);\n        }\n    }\n}",
                                "rust_code": "pub fn CmptPriceGenLenTable() { unimplemented!(); }"
                            },
                            {
                                "c_code": "uint32_t CmptPriceLen(CmptLenEncoder *lenEncoder, uint32_t len, uint32_t posState)\n{\n\n    return lenEncoder->prices[posState][len - CMPTLZ_MATCH_LEN_MIN];\n}",
                                "rust_code": "pub fn CmptPriceLen() { unimplemented!(); }"
                            },
                            {
                                "c_code": "uint32_t CmptPriceShortRep(CmptLzEncCtx *encCtx, CmptlzState state, uint32_t posState)\n{\n    return CmptPriceBit0(encCtx, encCtx->isRepG0[state]) + CmptPriceBit0(encCtx, encCtx->isRep0Long[state][posState]);\n}",
                                "rust_code": "pub fn CmptPriceShortRep() { unimplemented!(); }"
                            },
                            {
                                "c_code": "uint32_t CmptPriceLongRep(CmptLzEncCtx *encCtx, uint32_t longRepIndex, CmptlzState state, uint32_t posState)\n{\n    uint32_t price = 0;\n    switch (longRepIndex)\n    {\n    case 0:\n        price =\n            CmptPriceBit0(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRep0Long[state][posState]);\n        break;\n    case 1:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit0(encCtx, encCtx->isRepG1[state]);\n        break;\n    case 2:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRepG1[state]) +\n                CmptPriceBit0(encCtx, encCtx->isRepG2[state]);\n        break;\n    case 3:\n        price = CmptPriceBit1(encCtx, encCtx->isRepG0[state]) + CmptPriceBit1(encCtx, encCtx->isRepG1[state]) +\n                CmptPriceBit1(encCtx, encCtx->isRepG2[state]);\n        break;\n    default:\n        break;\n    }\n    return price;\n}",
                                "rust_code": "pub fn CmptPriceLongRep() { unimplemented!(); }"
                            },
                            {
                                "c_code": "uint32_t CmptPriceDistWithLen(CmptLzEncCtx *encCtx, uint32_t dist, uint32_t len, uint32_t posState)\n{\n    const uint32_t distState = CMPT_GET_DIST_STATE(len);\n    uint32_t price;\n    if (dist < 128)\n    {\n        price = encCtx->priceDistTable[distState][dist];\n    }\n    else\n    {\n\n        uint32_t distSlot = PosSloter(dist);\n        price = encCtx->priceDistSlotTable[distState][distSlot] +\n                encCtx->priceAlignTable[dist & ((1 << CMPTLZ_ALIGN_BITS) - 1)];\n    }\n\n    price += CmptPriceLen(&encCtx->matchLenEncoder, len, posState);\n\n    return price;\n}",
                                "rust_code": "pub fn CmptPriceDistWithLen() { unimplemented!(); }"
                            }
                        ]
                    },
                    "mod.rs": {
                        "name": "mod.rs",
                        "type": "file",
                        "declarations": [
                            "pub mod cmptlz_enc_mf_c;",
                            "pub mod cmptlz_enc_struct_h;",
                            "pub mod cmptlz_enc_blocks_c;",
                            "pub mod cmptlz_enc_rc_h;",
                            "pub mod cmptlz_enc_dp_c;",
                            "pub mod cmptlz_enc_rc_c;",
                            "pub mod cmptlz_enc_c;",
                            "pub mod cmptlz_enc_inner_h;",
                            "pub mod cmptlz_enc_init_c;",
                            "pub mod cmptlz_enc_head_c;",
                            "pub mod cmptlz_enc_price_h;",
                            "pub mod cmptlz_enc_symbol_h;",
                            "pub mod cmptlz_enc_price_c;"
                        ],
                        "definitions": [],
                        "macros": [],
                        "macro_functions": [],
                        "functions": []
                    }
                }
            },
            "decode": {
                "name": "decode",
                "type": "folder",
                "children": {
                    "cmptlz_dec_inner_h.rs": {
                        "name": "cmptlz_dec_inner_h.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::include::cmptlz_base_h::*;",
                            "pub use crate::include::cmptlz_dec_h::*;",
                            "pub use crate::src::public::cmptlz_def_h::*;",
                            "pub use crate::src::decode::cmptlz_dec_process_c::CmptLzDecDirectProcess;",
                            "pub use crate::src::decode::cmptlz_dec_try_c::CmptLzDecCarefulProcess;",
                            "pub use crate::src::decode::cmptlz_dec_try_c::CmptLzDecSinglePacket;",
                            "pub use crate::src::decode::cmptlz_dec_c::CmptLzDecDecodeToDic;"
                        ],
                        "definitions": [],
                        "macros": [
                            {
                                "c_code": "#define CMPTLZ_INNER_H",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_DEC_INPUT_EOF 1",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_DICT_MIN_LEN (1 << 12)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_RANGE_CODE_SIZE 5",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_REQUIRED_INPUT_MAX 20",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_MKSTATE_NUM 12",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LIT_STATES 7",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_RANGE_DOWN_LIMIT ((uint32_t)1 << 24)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_ONE_BYTE_WIDTH 8",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_PROB_LG_BIT 11",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_PROB_LG (1 << CMPTLZ_PROB_LG_BIT)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_PB_STATE_NUM_ALIGN 16",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_PB_BITS_MAX 4",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_MATCH_MAX_LEN 274",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_MATCH_LEN_INIT 274",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LOW_LEN_BIT 3",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LOW_LEN_CLASS (1 << CMPTLZ_LOW_LEN_BIT)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_HIGH_LEN_BIT 8",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_HIGH_LEN_CLASS (1 << CMPTLZ_HIGH_LEN_BIT)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LOW_LENPROB_OFFSET 0",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_HIGH_LENPROB_OFFSET (CMPTLZ_LOW_LENPROB_OFFSET + ((1 << CMPTLZ_PB_BITS_MAX) << (CMPTLZ_LOW_LEN_BIT + 1)))",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LEN_CHOICE CMPTLZ_LOW_LENPROB_OFFSET",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LEN_CHOICE2 (CMPTLZ_LEN_CHOICE + CMPTLZ_LOW_LEN_CLASS)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LENPROB_NUM (CMPTLZ_HIGH_LENPROB_OFFSET + CMPTLZ_HIGH_LEN_CLASS)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LEN_CONDITION_TO_POSSLOT 4",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_POS_SLOT_BITS 6",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LOW_POSSLOT 4",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_HIGH_POSSLOT 14",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_FULL_DISTANCE (1 << (CMPTLZ_HIGH_POSSLOT >> 1))",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LARGE_DIST_LOW_BITS 4",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_ALIGN_TABLE_SIZE (1 << CMPTLZ_LARGE_DIST_LOW_BITS)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_OFFSET 1664",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_SPEC_POS (-CMPTLZ_OFFSET)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_REP0_LONG (CMPTLZ_SPEC_POS + CMPTLZ_FULL_DISTANCE)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_REP_LEN_CODER (CMPTLZ_REP0_LONG + (CMPTLZ_PB_STATE_NUM_ALIGN << CMPTLZ_PB_BITS_MAX))",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_MATCH_LEN_CODER (CMPTLZ_REP_LEN_CODER + CMPTLZ_LENPROB_NUM)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_IS_MATCH (CMPTLZ_MATCH_LEN_CODER + CMPTLZ_LENPROB_NUM)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_ALIGN (CMPTLZ_IS_MATCH + (CMPTLZ_PB_STATE_NUM_ALIGN << CMPTLZ_PB_BITS_MAX))",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_ISREP (CMPTLZ_ALIGN + CMPTLZ_ALIGN_TABLE_SIZE)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_ISREPG0 (CMPTLZ_ISREP + CMPTLZ_MKSTATE_NUM)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_ISREPG1 (CMPTLZ_ISREPG0 + CMPTLZ_MKSTATE_NUM)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_ISREPG2 (CMPTLZ_ISREPG1 + CMPTLZ_MKSTATE_NUM)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_POSSLOT (CMPTLZ_ISREPG2 + CMPTLZ_MKSTATE_NUM)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LITERAL (CMPTLZ_POSSLOT + (CMPTLZ_LEN_CONDITION_TO_POSSLOT << CMPTLZ_POS_SLOT_BITS))",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define NUM_BASE_PROBS (CMPTLZ_LITERAL + CMPTLZ_OFFSET)",
                                "rust_code": ""
                            }
                        ],
                        "macro_functions": [
                            {
                                "c_code": "#define CMPTLZ_CALC_POS_STATE(procPos, pbMask) (((procPos) & (pbMask)) << 4)",
                                "rust_code": ""
                            }
                        ],
                        "functions": [
                            {
                                "c_code": "static inline CmptLzDecProb *CmptLzGetProbsMatrix(CmptLzDecCtx *decCtx)\n    {\n\n        return decCtx->probsPlus1664;\n    }",
                                "rust_code": "pub fn CmptLzGetProbsMatrix() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline CmptLzDecProb *CmptLzGetIsMatchProb(CmptLzDecProb *probsMatrix)\n    {\n\n        return probsMatrix + CMPTLZ_IS_MATCH;\n    }",
                                "rust_code": "pub fn CmptLzGetIsMatchProb() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline CmptLzDecProb *CmptLzGetIsRepProb(CmptLzDecProb *probsMatrix)\n    {\n\n        return probsMatrix + CMPTLZ_ISREP;\n    }",
                                "rust_code": "pub fn CmptLzGetIsRepProb() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline CmptLzDecProb *CmptLzGetIsRepG0Prob(CmptLzDecProb *probsMatrix)\n    {\n\n        return probsMatrix + CMPTLZ_ISREPG0;\n    }",
                                "rust_code": "pub fn CmptLzGetIsRepG0Prob() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline CmptLzDecProb *CmptLzGetIsRepG1Prob(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_ISREPG1;\n    }",
                                "rust_code": "pub fn CmptLzGetIsRepG1Prob() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline CmptLzDecProb *CmptLzGetIsRepG2Prob(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_ISREPG2;\n    }",
                                "rust_code": "pub fn CmptLzGetIsRepG2Prob() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline CmptLzDecProb *CmptLzGetIsRepG0LongProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_REP0_LONG;\n    }",
                                "rust_code": "pub fn CmptLzGetIsRepG0LongProb() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline CmptLzDecProb *CmptLzGetLiteralProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_LITERAL;\n    }",
                                "rust_code": "pub fn CmptLzGetLiteralProb() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline CmptLzDecProb *CmptLzGetPosSlotProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_POSSLOT;\n    }",
                                "rust_code": "pub fn CmptLzGetPosSlotProb() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline CmptLzDecProb *CmptLzGetSpecPosProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_SPEC_POS;\n    }",
                                "rust_code": "pub fn CmptLzGetSpecPosProb() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline CmptLzDecProb *CmptLzGetAilgnProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_ALIGN;\n    }",
                                "rust_code": "pub fn CmptLzGetAilgnProb() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline CmptLzDecProb *CmptLzGetRepLenCoderProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_REP_LEN_CODER;\n    }",
                                "rust_code": "pub fn CmptLzGetRepLenCoderProb() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline CmptLzDecProb *CmptLzGetMatchLenCoderProb(CmptLzDecProb *probsMatrix)\n    {\n        return probsMatrix + CMPTLZ_MATCH_LEN_CODER;\n    }",
                                "rust_code": "pub fn CmptLzGetMatchLenCoderProb() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t CmptLzGetLenCondition(uint32_t decLen)\n    {\n        return ((decLen < CMPTLZ_LEN_CONDITION_TO_POSSLOT ? decLen : CMPTLZ_LEN_CONDITION_TO_POSSLOT - 1)\n                << CMPTLZ_POS_SLOT_BITS);\n    }",
                                "rust_code": "pub fn CmptLzGetLenCondition() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t CmptLzGetBaseDistByPosSlot(uint32_t posSlot)\n    {\n        return (2 | (posSlot & 1));\n    }",
                                "rust_code": "pub fn CmptLzGetBaseDistByPosSlot() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t CmptLzGetNumProbs(CmptLzDecProt *decProt)\n    {\n\n        return (NUM_BASE_PROBS + ((uint32_t)0x300 << (decProt->litCtx + decProt->litPos)));\n    }",
                                "rust_code": "pub fn CmptLzGetNumProbs() { unimplemented!(); }"
                            }
                        ]
                    },
                    "cmptlz_dec_process_c.rs": {
                        "name": "cmptlz_dec_process_c.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::decode::cmptlz_dec_inner_h::*;"
                        ],
                        "definitions": [],
                        "macros": [
                            {
                                "c_code": "#define CMPTLZ_REP4 4",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_REP3 3",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_REP2 2",
                                "rust_code": ""
                            }
                        ],
                        "macro_functions": [
                            {
                                "c_code": "#define CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec)                                                             \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if ((range) < CMPTLZ_RANGE_DOWN_LIMIT)                                                                         \\\n        {                                                                                                              \\\n            (range) <<= CMPTLZ_ONE_BYTE_WIDTH;                                                                         \\\n            (rangeCode) <<= CMPTLZ_ONE_BYTE_WIDTH;                                                                     \\\n            (rangeCode) |= (*(bufToDec)++);                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_IS_THE_BIT_0(probSlot, range, rangeCode, rangeBound)                                                    \\\n    (rangeBound) = (range >> CMPTLZ_PROB_LG_BIT) * (*(probSlot));                                                      \\\n    if ((rangeCode) < (rangeBound))",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_RANGE_UPDATE_0(prob, range, rangeBound)                                                                 \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (range) = (rangeBound);                                                                                        \\\n        *(prob) = (CmptLzDecProb)((*(prob)) + ((CMPTLZ_PROB_LG - (*(prob))) >> CMPTLZ_RANGE_CODE_SIZE));               \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_RANGE_UPDATE_1(prob, range, rangeCode, rangeBound)                                                      \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (range) -= (rangeBound);                                                                                       \\\n        (rangeCode) -= (rangeBound);                                                                                   \\\n        *(prob) = (CmptLzDecProb)((*(prob)) - ((*(prob)) >> CMPTLZ_RANGE_CODE_SIZE));                                  \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_NORMAL_BIT_DEC(probLit, range, rangeCode, rangeBound, decSym)                                           \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probLit));                                                 \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_0(probLit, range, rangeBound);                                                         \\\n            (decSym) = ((decSym) << 1);                                                                                \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_1(probLit, range, rangeCode, rangeBound);                                              \\\n            (decSym) = ((decSym) << 1) + 1;                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_MATCH_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec)          \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (matchSym) <<= 1;                                                                                              \\\n        (bit) = (offset);                                                                                              \\\n        (offset) &= (matchSym);                                                                                        \\\n        (probLit) = (probSlot) + ((offset) + (bit) + (decSym));                                                        \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probLit));                                                 \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_0(probLit, range, rangeBound);                                                         \\\n            (decSym) = ((decSym) << 1);                                                                                \\\n            (offset) ^= (bit);                                                                                         \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_1(probLit, range, rangeCode, rangeBound);                                              \\\n            (decSym) = ((decSym) << 1) + 1;                                                                            \\\n        }                                                                                                              \\\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);                                                            \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_DIST_BIT_DEC(probDist, probSlot, range, rangeCode, rangeBound, decDist, decBit)                         \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (probDist) = (probSlot) + (decDist);                                                                           \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probDist));                                                \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_0(probDist, range, rangeBound);                                                        \\\n            (decDist) += (decBit);                                                                                     \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_1(probDist, range, rangeCode, rangeBound);                                             \\\n            (decDist) += (decBit) * 2;                                                                                 \\\n        }                                                                                                              \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LEN_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym, bufToDec)                                   \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        CMPTLZ_NORMAL_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym);                                         \\\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);                                                            \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_POSSLOT_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym, bufToDec)                               \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        CMPTLZ_NORMAL_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym);                                         \\\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);                                                            \\\n    } while (0)",
                                "rust_code": ""
                            }
                        ],
                        "functions": [
                            {
                                "c_code": "static inline void CmptLzDistDecHelper(CmptLzDecCtx *decCtx, uint32_t distDec, const unsigned char *bufToDec,\n                                       uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound, uint32_t range,\n                                       uint32_t rangeCode, uint32_t rangeBound)\n{\n    decCtx->reps[CMPTLZ_REP3] = decCtx->reps[CMPTLZ_REP2];\n    decCtx->reps[CMPTLZ_REP2] = decCtx->reps[1];\n    decCtx->reps[1] = decCtx->reps[0];\n    decCtx->reps[0] = (distDec + 1);\n\n    decCtx->buf = bufToDec;\n    decCtx->state = (decCtx->state < CMPTLZ_LIT_STATES) ? CMPTLZ_LIT_STATES : CMPTLZ_LIT_STATES + CMPTLZ_REP3;\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n}",
                                "rust_code": "pub fn CmptLzDistDecHelper() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static size_t CmptLzDistDec(CmptLzDecCtx *decCtx, CmptLzDecProb *probsMatrix, uint32_t *pRange, uint32_t *pRangeCode,\n                            uint32_t *pRangeBound, uint32_t decLen)\n{\n    uint32_t assistBits;\n    uint32_t posSlot = 1;\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    const unsigned char *bufToDec = decCtx->buf;\n    uint32_t distDec;\n\n    CmptLzDecProb *probPosSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decLen);\n\n    int i = 0;\n    for (i = 0; i < CMPTLZ_POS_SLOT_BITS; i++)\n    {\n        CMPTLZ_POSSLOT_BIT_DEC((probPosSlot + posSlot), range, rangeCode, rangeBound, posSlot, bufToDec);\n    }\n    posSlot -= 64;\n\n    if (posSlot < CMPTLZ_LOW_POSSLOT)\n    {\n        distDec = posSlot;\n        CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n\n        if (distDec == (size_t)0xFFFFFFFF)\n        {\n            return distDec;\n        }\n        else\n        {\n            return (distDec + 1);\n        }\n    }\n\n    uint32_t directBitNum = ((posSlot >> 1) - 1);\n    distDec = CmptLzGetBaseDistByPosSlot(posSlot);\n    if (posSlot < CMPTLZ_HIGH_POSSLOT)\n    {\n        assistBits = 1;\n        distDec <<= directBitNum;\n\n        distDec += assistBits;\n        probPosSlot = CmptLzGetSpecPosProb(probsMatrix);\n        do\n        {\n\n            if CMPTLZ_IS_THE_BIT_0 ((probPosSlot + distDec), range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0((probPosSlot + distDec), range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                distDec += assistBits;\n                assistBits <<= 1;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1((probPosSlot + distDec), range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                assistBits <<= 1;\n                distDec += assistBits;\n            }\n        } while (--directBitNum);\n        distDec -= assistBits;\n    }\n    else\n    {\n        directBitNum -= CMPTLZ_REP4;\n        do\n        {\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            range >>= 1;\n            rangeCode -= range;\n            assistBits = (0 - ((uint32_t)rangeCode >> 31));\n            distDec = (distDec << 1) + (assistBits + 1);\n            rangeCode += range & assistBits;\n        } while (--directBitNum);\n\n        CmptLzDecProb *probDist;\n        probPosSlot = CmptLzGetAilgnProb(probsMatrix);\n\n        distDec <<= CMPTLZ_LARGE_DIST_LOW_BITS;\n        assistBits = 1;\n\n        uint32_t cycleSym = 1;\n        for (i = 0; i < 3; i++)\n        {\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            CMPTLZ_DIST_BIT_DEC(probDist, probPosSlot, range, rangeCode, rangeBound, assistBits, cycleSym);\n            cycleSym <<= 1;\n        }\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probDist = probPosSlot + assistBits;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probDist);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probDist, range, rangeBound);\n            assistBits -= 8;\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probDist, range, rangeCode, rangeBound);\n        }\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        distDec |= assistBits;\n    }\n\n    CmptLzDistDecHelper(decCtx, distDec, bufToDec, pRange, pRangeCode, pRangeBound, range, rangeCode, rangeBound);\n\n    if (distDec == (size_t)0xFFFFFFFF)\n    {\n        return distDec;\n    }\n    else\n    {\n        return (distDec + 1);\n    }\n}",
                                "rust_code": "pub fn CmptLzDistDec() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static uint32_t CmptLzLenDec(CmptLzDecCtx *decCtx, CmptLzDecProb *probSlot, uint32_t *pRange, uint32_t *pRangeCode,\n                             uint32_t *pRangeBound, uint32_t posState)\n{\n    uint32_t decLen = 1;\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n    const unsigned char *bufToDec = decCtx->buf;\n    CmptLzDecProb *probLen = probSlot + CMPTLZ_LEN_CHOICE;\n\n    int i = 0;\n    if CMPTLZ_IS_THE_BIT_0 (probLen, range, rangeCode, rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET + posState;\n        for (i = 0; i < CMPTLZ_LOW_LEN_BIT; i++)\n        {\n            CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n        }\n        decLen -= 8;\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2;\n        if CMPTLZ_IS_THE_BIT_0 (probLen, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probLen, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n            probLen = probSlot + (CMPTLZ_LEN_CHOICE2 + posState);\n            for (i = 0; i < CMPTLZ_LOW_LEN_BIT; i++)\n            {\n                CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            }\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probLen, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET;\n            for (i = 0; i < CMPTLZ_HIGH_LEN_BIT; i++)\n            {\n                CMPTLZ_LEN_BIT_DEC((probLen + decLen), range, rangeCode, rangeBound, decLen, bufToDec);\n            }\n            decLen -= CMPTLZ_HIGH_LEN_CLASS;\n            decLen += (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx->buf = bufToDec;\n\n    return decLen;\n}",
                                "rust_code": "pub fn CmptLzLenDec() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static uint32_t CmptLzDecByDistAndLen(CmptLzDecCtx *decCtx, size_t matchDist, uint32_t matchLen, size_t dicPosLimit)\n{\n    size_t dicCopyPos;\n    size_t dicPos = decCtx->dictPos;\n    size_t dictBufSize = decCtx->dictBufSize;\n    uint32_t remainDicLen = (uint32_t)(dicPosLimit - dicPos);\n    unsigned char *dict = decCtx->dict;\n\n    if (remainDicLen == 0)\n    {\n        return CMPT_ERROR_DATA;\n    }\n\n    uint32_t decDicLen = ((remainDicLen < matchLen) ? remainDicLen : matchLen);\n    decCtx->processedPos += decDicLen;\n    decCtx->dictPos += decDicLen;\n    decCtx->remainLen = matchLen - decDicLen;\n\n    if (dicPos < matchDist)\n    {\n        dicCopyPos = dictBufSize - matchDist + dicPos;\n    }\n    else\n    {\n        dicCopyPos = dicPos - matchDist;\n    }\n\n    do\n    {\n        dict[dicPos++] = dict[dicCopyPos];\n        if (++dicCopyPos == dictBufSize)\n        {\n            dicCopyPos = 0;\n        }\n    } while (--decDicLen != 0);\n\n    return CMPT_OK;\n}",
                                "rust_code": "pub fn CmptLzDecByDistAndLen() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptLzShortRepDec(CmptLzDecCtx *decCtx)\n{\n    uint32_t rep0 = decCtx->reps[0];\n    unsigned char *dict = decCtx->dict;\n    size_t dictPos = decCtx->dictPos;\n    size_t dictBufSize = decCtx->dictBufSize;\n\n    dict[dictPos] = dict[dictPos - rep0 + (dictPos < rep0 ? dictBufSize : 0)];\n    decCtx->dictPos++;\n    decCtx->processedPos++;\n    if (decCtx->state < CMPTLZ_LIT_STATES)\n    {\n        decCtx->state = 9;\n    }\n    else\n    {\n        decCtx->state = 11;\n    }\n}",
                                "rust_code": "pub fn CmptLzShortRepDec() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t CmptLzRepDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound,\n                                    size_t dicPosLimit, uint32_t posState)\n{\n    uint32_t repLen;\n    uint32_t repDist;\n    uint32_t mkState = decCtx->state;\n    const unsigned char *bufToDec = decCtx->buf;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    uint32_t range = *pRange;\n    uint32_t rangeCode = *pRangeCode;\n    uint32_t rangeBound = *pRangeBound;\n\n    probSlot = CmptLzGetIsRepG0Prob(probsMatrix) + mkState;\n    if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n        probSlot = CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState;\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            *pRange = range;\n            *pRangeCode = rangeCode;\n            *pRangeBound = rangeBound;\n            decCtx->buf = bufToDec;\n            CmptLzShortRepDec(decCtx);\n            return CMPT_OK;\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            repDist = decCtx->reps[0];\n        }\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n        probSlot = CmptLzGetIsRepG1Prob(probsMatrix) + mkState;\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n            repDist = decCtx->reps[1];\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n\n            probSlot = CmptLzGetIsRepG2Prob(probsMatrix) + mkState;\n            if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                repDist = decCtx->reps[CMPTLZ_REP2];\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n                repDist = decCtx->reps[CMPTLZ_REP3];\n                decCtx->reps[CMPTLZ_REP3] = decCtx->reps[CMPTLZ_REP2];\n            }\n            decCtx->reps[CMPTLZ_REP2] = decCtx->reps[1];\n        }\n        decCtx->reps[1] = decCtx->reps[0];\n        decCtx->reps[0] = repDist;\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n    decCtx->buf = bufToDec;\n\n    decCtx->state = (mkState < CMPTLZ_LIT_STATES) ? 8 : 11;\n    probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n    repLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n\n    return CmptLzDecByDistAndLen(decCtx, repDist, repLen + 2, dicPosLimit);\n}",
                                "rust_code": "pub fn CmptLzRepDec() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t CmptLzMatchDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode,\n                                      uint32_t *pRangeBound, size_t dicPosLimit, uint32_t posState)\n{\n    uint32_t matchLen;\n    size_t matchDist;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    probSlot = CmptLzGetMatchLenCoderProb(probsMatrix);\n    matchLen = CmptLzLenDec(decCtx, probSlot, pRange, pRangeCode, pRangeBound, posState);\n    matchDist = CmptLzDistDec(decCtx, probsMatrix, pRange, pRangeCode, pRangeBound, matchLen);\n    if (matchDist > decCtx->dictBufSize)\n    {\n        if (matchDist == (size_t)0xFFFFFFFF)\n        {\n            decCtx->remainLen = CMPTLZ_MATCH_MAX_LEN;\n            decCtx->state -= CMPTLZ_MKSTATE_NUM;\n            return CMPT_OK;\n        }\n        else\n        {\n            return CMPT_ERROR_DATA;\n        }\n    }\n    return CmptLzDecByDistAndLen(decCtx, matchDist, matchLen + 2, dicPosLimit);\n}",
                                "rust_code": "pub fn CmptLzMatchDec() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t CmptLzLitDec(CmptLzDecCtx *decCtx, uint32_t *pRange, uint32_t *pRangeCode, uint32_t *pRangeBound)\n{\n    uint32_t decSym = 1;\n    uint32_t mkState = decCtx->state;\n    uint32_t procPos = decCtx->processedPos;\n    uint32_t checkDicSize = decCtx->checkDicSize;\n    uint32_t litCtx = decCtx->prop.litCtx;\n    uint32_t litPosMask = ((uint32_t)0x100 << decCtx->prop.litPos) - ((uint32_t)0x100 >> litCtx);\n\n    CmptLzDecProb *probLit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    const unsigned char *bufToDec = decCtx->buf;\n    unsigned char *dict = decCtx->dict;\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t dictPos = decCtx->dictPos;\n\n    uint32_t range = *pRange;\n    uint32_t rangeBound = *pRangeBound;\n    uint32_t rangeCode = *pRangeCode;\n\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0 || checkDicSize != 0)\n    {\n        probSlot += (uint32_t)CMPTLZ_REP3 *\n                    ((((procPos << 8) + dict[(dictPos == 0 ? dictBufSize : dictPos) - 1]) & litPosMask) << litCtx);\n    }\n\n    int i = 0;\n    if (mkState < CMPTLZ_LIT_STATES)\n    {\n        mkState -= (mkState < 4) ? mkState : 3;\n        for (i = 0; i < 8; i++)\n        {\n            CMPTLZ_NORMAL_BIT_DEC((probSlot + decSym), range, rangeCode, rangeBound, decSym);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, bufToDec);\n        }\n    }\n    else\n    {\n        uint32_t bit;\n        uint32_t offset = 0x100;\n        uint32_t rep0 = decCtx->reps[0];\n        uint32_t matchSym = dict[dictPos - rep0 + ((dictPos < rep0) ? dictBufSize : 0)];\n        mkState -= (mkState < 10) ? CMPTLZ_REP3 : 6;\n        for (i = 0; i < 8; i++)\n        {\n            CMPTLZ_MATCH_BIT_DEC(probSlot, range, rangeCode, rangeBound, decSym, matchSym, offset, bit, bufToDec);\n        }\n    }\n\n    *pRange = range;\n    *pRangeCode = rangeCode;\n    *pRangeBound = rangeBound;\n\n    dict[dictPos++] = (uint8_t)decSym;\n    decCtx->processedPos += 1;\n    decCtx->state = mkState;\n    decCtx->dictPos = dictPos;\n    decCtx->buf = bufToDec;\n\n    return CMPT_OK;\n}",
                                "rust_code": "pub fn CmptLzLitDec() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptLzDecDirectProcess(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *bufLimit)\n{\n    uint32_t decRes;\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t procPos;\n    uint32_t mkState;\n    uint32_t posState;\n\n    uint32_t range = decCtx->range;\n    uint32_t rangeCode = decCtx->code;\n    uint32_t rangeBound = 0;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    do\n    {\n        procPos = decCtx->processedPos;\n        mkState = decCtx->state;\n        posState = CMPTLZ_CALC_POS_STATE(procPos, pbMask);\n        probSlot = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n\n        CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n        if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n            decRes = CmptLzLitDec(decCtx, &range, &rangeCode, &rangeBound);\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n\n            probSlot = CmptLzGetIsRepProb(probsMatrix) + mkState;\n\n            if CMPTLZ_IS_THE_BIT_0 (probSlot, range, rangeCode, rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_0(probSlot, range, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n                decRes = CmptLzMatchDec(decCtx, &range, &rangeCode, &rangeBound, dicPosLimit, posState);\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_1(probSlot, range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_NORMALIZE(range, rangeCode, decCtx->buf);\n                decRes = CmptLzRepDec(decCtx, &range, &rangeCode, &rangeBound, dicPosLimit, posState);\n            }\n            if (decRes != CMPT_OK)\n            {\n                break;\n            }\n        }\n    } while (decCtx->dictPos < dicPosLimit && decCtx->buf < bufLimit && decCtx->remainLen < CMPTLZ_MATCH_MAX_LEN);\n\n    decCtx->range = range;\n    decCtx->code = rangeCode;\n\n    return (int)decRes;\n}",
                                "rust_code": "pub fn CmptLzDecDirectProcess() { unimplemented!(); }"
                            }
                        ]
                    },
                    "cmptlz_dec_c.rs": {
                        "name": "cmptlz_dec_c.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::decode::cmptlz_dec_inner_h::*;",
                            "pub use crate::src::public::cmptlz_log_h::*;"
                        ],
                        "definitions": [],
                        "macros": [],
                        "macro_functions": [],
                        "functions": [
                            {
                                "c_code": "static inline void CmptLzDecCheckDictSizeUpdate(CmptLzDecCtx *decCtx)\n{\n    if (decCtx->checkDicSize == 0 && decCtx->processedPos >= decCtx->prop.dicSize)\n    {\n        decCtx->checkDicSize = decCtx->prop.dicSize;\n    }\n}",
                                "rust_code": "pub fn CmptLzDecCheckDictSizeUpdate() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptLzDecRemWriteInDict(CmptLzDecCtx *decCtx, size_t dicPosLimit)\n{\n    size_t dictPos = decCtx->dictPos;\n    size_t remainDecLen = decCtx->remainLen;\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t remainDicLen = dicPosLimit - dictPos;\n    if (remainDicLen < remainDecLen)\n    {\n        remainDecLen = remainDicLen;\n    }\n\n    if (remainDecLen == 0)\n    {\n        return;\n    }\n\n    decCtx->processedPos += (uint32_t)remainDecLen;\n    decCtx->remainLen -= (uint32_t)remainDecLen;\n\n    unsigned char *dict = decCtx->dict;\n    size_t rep0 = decCtx->reps[0];\n    while (remainDecLen != 0)\n    {\n        remainDecLen--;\n        dict[dictPos] = dict[dictPos - rep0 + (dictPos < rep0 ? dictBufSize : 0)];\n        dictPos++;\n    }\n    decCtx->dictPos = dictPos;\n\n    CmptLzDecCheckDictSizeUpdate(decCtx);\n}",
                                "rust_code": "pub fn CmptLzDecRemWriteInDict() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptLzDecGetProbsInit(CmptLzDecCtx *decCtx)\n{\n    uint32_t idx;\n    uint32_t numProbs = CmptLzGetNumProbs(&(decCtx->prop));\n    CmptLzDecProb *decProbs = decCtx->probs;\n\n    for (idx = 0; idx < numProbs; idx++)\n    {\n        decProbs[idx] = CMPTLZ_PROB_LG >> 1;\n    }\n    decCtx->state = 0;\n}",
                                "rust_code": "pub fn CmptLzDecGetProbsInit() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptLzRangeCodeInit(CmptLzDecCtx *decCtx)\n{\n    uint32_t rangeCode = (uint32_t)(decCtx->tempBuf[1]) << 24;\n    rangeCode |= (uint32_t)(decCtx->tempBuf[2]) << 16;\n    rangeCode |= (uint32_t)(decCtx->tempBuf[3]) << 8;\n    rangeCode |= (uint32_t)(decCtx->tempBuf[4]);\n    decCtx->code = rangeCode;\n    decCtx->range = 0xFFFFFFFF;\n}",
                                "rust_code": "pub fn CmptLzRangeCodeInit() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline int CmptLzDecCtxPrepare(CmptLzDecCtx *decCtx, const unsigned char *pSrcIn, size_t srcInLen,\n                                      EnCmptLzStatus *finStatus)\n{\n    size_t readCodeLen = CMPTLZ_RANGE_CODE_SIZE - decCtx->tempBufSize;\n    readCodeLen = (srcInLen < readCodeLen) ? srcInLen : readCodeLen;\n    while (readCodeLen-- > 0)\n    {\n        decCtx->tempBuf[decCtx->tempBufSize++] = *pSrcIn++;\n    }\n\n    if (decCtx->tempBufSize != 0 && decCtx->tempBuf[0] != 0)\n    {\n        decCtx->tempBufSize = 0;\n        *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n        return CMPT_ERROR_DATA;\n    }\n    if (decCtx->tempBufSize < CMPTLZ_RANGE_CODE_SIZE)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    CmptLzRangeCodeInit(decCtx);\n\n    if (decCtx->remainLen > CMPTLZ_MATCH_MAX_LEN + 1)\n    {\n        CmptLzDecGetProbsInit(decCtx);\n        decCtx->reps[0] = 1;\n        decCtx->reps[1] = 1;\n        decCtx->reps[2] = 1;\n        decCtx->reps[3] = 1;\n    }\n\n    decCtx->remainLen = 0;\n\n    return CMPT_OK;\n}",
                                "rust_code": "pub fn CmptLzDecCtxPrepare() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptLzDecDecodeToDic(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *pSrcIn, size_t *pStrInLen,\n                         EnCmptLzFinMode finMode, EnCmptLzStatus *finStatus)\n{\n    int res;\n    bool carefulDecDone = false;\n    size_t srcDecLenTmp;\n    size_t srcDecLen = 0;\n    size_t srcInLen = *pStrInLen;\n\n    if (decCtx->remainLen > CMPTLZ_MATCH_MAX_LEN)\n    {\n        size_t oldTempBufSize = decCtx->tempBufSize;\n        res = CmptLzDecCtxPrepare(decCtx, pSrcIn, srcInLen, finStatus);\n        srcDecLenTmp = (decCtx->tempBufSize - oldTempBufSize);\n        if ((res != CMPT_OK) || (*finStatus == CMPTLZ_STATUS_NEEDS_MORE_INPUT))\n        {\n            *pStrInLen = srcDecLenTmp;\n            return res;\n        }\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n        decCtx->tempBufSize = 0;\n    }\n\n    if (decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN)\n    {\n        if (decCtx->code != 0)\n        {\n            return CMPT_ERROR_DATA;\n        }\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n\n    if (decCtx->remainLen != 0)\n    {\n        CmptLzDecRemWriteInDict(decCtx, dicPosLimit);\n    }\n\n    if (decCtx->tempBufSize != 0)\n    {\n        res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, &srcDecLenTmp);\n        *pStrInLen = srcDecLenTmp;\n        if (res == CMPT_ERROR_DATA)\n        {\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n            return CMPT_ERROR_DATA;\n        }\n        else if (res == CMPTLZ_DEC_INPUT_EOF)\n        {\n            *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n            return CMPT_OK;\n        }\n        else\n        {\n            srcDecLen += srcDecLenTmp;\n            pSrcIn += srcDecLenTmp;\n            srcInLen -= srcDecLenTmp;\n        }\n    }\n\n    while ((decCtx->dictPos < dicPosLimit) && (carefulDecDone == false))\n    {\n        decCtx->buf = pSrcIn;\n        if (srcInLen <= CMPTLZ_REQUIRED_INPUT_MAX)\n        {\n            res = CmptLzDecCarefulProcess(decCtx, dicPosLimit, pSrcIn + srcInLen);\n            carefulDecDone = true;\n        }\n        else\n        {\n            res = CmptLzDecDirectProcess(decCtx, dicPosLimit, pSrcIn + srcInLen - CMPTLZ_REQUIRED_INPUT_MAX);\n        }\n        srcDecLenTmp = (size_t)(decCtx->buf - pSrcIn) + decCtx->tempBufSize;\n        srcDecLen += srcDecLenTmp;\n        pSrcIn += srcDecLenTmp;\n        srcInLen -= srcDecLenTmp;\n\n        if (res == CMPT_ERROR_DATA)\n        {\n            *pStrInLen = srcDecLen;\n            *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n            return CMPT_ERROR_DATA;\n        }\n    }\n\n    *pStrInLen = srcDecLen;\n    if ((decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n    if (decCtx->dictPos < dicPosLimit)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    if ((decCtx->remainLen == 0) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_MAYBE_FINISHED_WITHOUT_MARK;\n        return CMPT_OK;\n    }\n    if (finMode == CMPTLZ_FINISH_ANY)\n    {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n        return CMPT_OK;\n    }\n    if (decCtx->remainLen != 0)\n    {\n        *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n        return CMPT_ERROR_DATA;\n    }\n\n    srcDecLenTmp = 0;\n    res = CmptLzDecSinglePacket(decCtx, dicPosLimit, pSrcIn, srcInLen, &srcDecLenTmp);\n    srcDecLen += srcDecLenTmp;\n    *pStrInLen = srcDecLen;\n    if (res == CMPTLZ_DEC_INPUT_EOF)\n    {\n        *finStatus = CMPTLZ_STATUS_NEEDS_MORE_INPUT;\n        return CMPT_OK;\n    }\n    if ((decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN) && (decCtx->code == 0))\n    {\n        *finStatus = CMPTLZ_STATUS_FINISHED_WITH_MARK;\n        return CMPT_OK;\n    }\n\n    *finStatus = CMPTLZ_STATUS_NOT_FINISHED;\n    return CMPT_ERROR_DATA;\n}",
                                "rust_code": "pub fn CmptLzDecDecodeToDic() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptLzDecDecodeToBuf(CmptLzDecCtx *decCtx, CmptLzDecIn *pDecIn, CmptLzDecOut *pDecOut, EnCmptLzFinMode finMode,\n                         EnCmptLzStatus *finStatus)\n{\n    int res = CMPT_OK;\n    size_t dictPos;\n    size_t dictPosLimit;\n    size_t srcCostSize;\n\n    size_t leftSrcSize = pDecIn->strInLen;\n    size_t leftDestSize = pDecOut->destOutLen;\n    const unsigned char *pSrcIn = pDecIn->pSrcIn;\n    unsigned char *pDestOut = pDecOut->pDestOut;\n    EnCmptLzFinMode tmpFinMode;\n\n    do\n    {\n        if (decCtx->dictPos == decCtx->dictBufSize)\n        {\n            decCtx->dictPos = 0;\n        }\n        dictPos = decCtx->dictPos;\n        if (leftDestSize > decCtx->dictBufSize - dictPos)\n        {\n            dictPosLimit = decCtx->dictBufSize;\n            tmpFinMode = CMPTLZ_FINISH_ANY;\n        }\n        else\n        {\n            dictPosLimit = dictPos + leftDestSize;\n            tmpFinMode = finMode;\n        }\n        srcCostSize = leftSrcSize;\n        res = CmptLzDecDecodeToDic(decCtx, dictPosLimit, pSrcIn, &srcCostSize, tmpFinMode, finStatus);\n        if (res != CMPT_OK)\n        {\n            break;\n        }\n        pSrcIn += srcCostSize;\n        leftSrcSize -= srcCostSize;\n        dictPosLimit = decCtx->dictPos - dictPos;\n        leftDestSize -= dictPosLimit;\n        if (dictPosLimit == 0)\n        {\n            break;\n        }\n        if (memcpy_s(pDestOut, (pDecOut->destOutLen - leftDestSize), decCtx->dict + dictPos, dictPosLimit) != EOK)\n        {\n            return CMPT_ERROR_MEM;\n        }\n        pDestOut += dictPosLimit;\n    } while (leftDestSize != 0);\n\n    pDecIn->strInCostLen = pDecIn->strInLen - leftSrcSize;\n    pDecOut->destOutFillLen = pDecOut->destOutLen - leftDestSize;\n\n    return res;\n}",
                                "rust_code": "pub fn CmptLzDecDecodeToBuf() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptlzDecompress(void *src, size_t srcSize, void *dst, size_t *dstSize, CmptlzDecParam *param)\n{\n    if (src == NULL || dst == NULL || dstSize == NULL)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"The input parameter NULL is incorrect.\");\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    if (srcSize > 0x7fffffff || *dstSize > 0x7fffffff)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"dstSize:0x%zx srcSize:0x%zx\", *dstSize, srcSize);\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    if (param == NULL || param->memHook == NULL || param->protData == NULL || param->protSize != CMPTLZ_PROPS_SIZE)\n    {\n        CMPTLZ_LOG(CMPT_ERROR_UNSUPPORTED, \"The compress param NULL is incorrect.\");\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    CmptLzDecIn decIn = {.pSrcIn = src, .strInLen = srcSize, .strInCostLen = 0};\n    CmptLzDecOut decOut = {.pDestOut = dst, .destOutLen = *dstSize, .destOutFillLen = 0};\n    EnCmptLzStatus enFinStat = CMPTLZ_STATUS_BUT;\n    int ret = CmptLzDecode(&decIn, &decOut, param->protData, CMPTLZ_FINISH_ANY, &enFinStat, param->memHook);\n\n    *dstSize = decOut.destOutFillLen;\n    return ret;\n}",
                                "rust_code": "pub fn CmptlzDecompress() { unimplemented!(); }"
                            }
                        ]
                    },
                    "cmptlz_dec_try_c.rs": {
                        "name": "cmptlz_dec_try_c.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::decode::cmptlz_dec_inner_h::*;"
                        ],
                        "definitions": [],
                        "macros": [],
                        "macro_functions": [
                            {
                                "c_code": "#define CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound)                                                          \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (range) = (rangeBound);                                                                                        \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound)                                               \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (range) -= (rangeBound);                                                                                       \\\n        (rangeCode) -= (rangeBound);                                                                                   \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit)                                              \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        if ((range) < CMPTLZ_RANGE_DOWN_LIMIT)                                                                         \\\n        {                                                                                                              \\\n            if ((bufTryDec) >= (bufLimit))                                                                             \\\n            {                                                                                                          \\\n                return CMPTLZ_DEC_INPUT_EOF;                                                                           \\\n            }                                                                                                          \\\n            (range) <<= CMPTLZ_ONE_BYTE_WIDTH;                                                                         \\\n            (rangeCode) <<= CMPTLZ_ONE_BYTE_WIDTH;                                                                     \\\n            (rangeCode) |= (*(bufTryDec)++);                                                                           \\\n        }                                                                                                              \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probSym)                                       \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probSym));                                                 \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);                                                     \\\n            (decSym) = ((decSym) << 1);                                                                                \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);                                          \\\n            (decSym) = ((decSym) << 1) + 1;                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_MATCH_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probSym)                                        \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (rangeBound) = ((range) >> CMPTLZ_PROB_LG_BIT) * (*(probSym));                                                 \\\n        if ((rangeCode) < (rangeBound))                                                                                \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);                                                     \\\n            (decSym) = ((decSym) << 1);                                                                                \\\n            (offset) ^= (bit);                                                                                         \\\n        }                                                                                                              \\\n        else                                                                                                           \\\n        {                                                                                                              \\\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);                                          \\\n            (decSym) = ((decSym) << 1) + 1;                                                                            \\\n        }                                                                                                              \\\n    } while (0)",
                                "rust_code": ""
                            }
                        ],
                        "functions": [
                            {
                                "c_code": "static inline int CmptLzTryDecLenAndDist(CmptLzDecCtx *decCtx, uint32_t mkState, uint32_t range, uint32_t rangeCode,\n                                         uint32_t rangeBound, CmptLzDecProb *probSlot, const unsigned char *bufTryDec,\n                                         const unsigned char **pbufLimit)\n{\n    uint32_t offset;\n    uint32_t bits2BeDec;\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t posState = CMPTLZ_CALC_POS_STATE(decCtx->processedPos, pbMask);\n    const unsigned char *bufLimit = *pbufLimit;\n    CmptLzDecProb *probBit;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    CmptLzDecProb *probLen = probSlot + CMPTLZ_LEN_CHOICE;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probLen);\n    if (rangeCode < rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        probLen = probSlot + CMPTLZ_LOW_LENPROB_OFFSET + posState;\n        bits2BeDec = 3;\n        offset = 0;\n    }\n    else\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n        probLen = probSlot + CMPTLZ_LEN_CHOICE2;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probLen);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            probLen = probSlot + CMPTLZ_LEN_CHOICE + CMPTLZ_LEN_CHOICE2 + posState;\n            bits2BeDec = 3;\n            offset = (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            probLen = probSlot + CMPTLZ_HIGH_LENPROB_OFFSET;\n            bits2BeDec = 8;\n            offset = (CMPTLZ_LOW_LEN_CLASS << 1);\n        }\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n    uint32_t decSym = 1;\n    do\n    {\n        probBit = probLen + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    } while (decSym < ((uint32_t)1 << bits2BeDec));\n    decSym -= ((uint32_t)1 << bits2BeDec);\n    decSym += offset;\n\n    if (mkState >= 4)\n    {\n        *pbufLimit = bufTryDec;\n        return CMPT_OK;\n    }\n\n    probSlot = CmptLzGetPosSlotProb(probsMatrix) + CmptLzGetLenCondition(decSym);\n\n    decSym = 1;\n    do\n    {\n        probBit = probSlot + decSym;\n        CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    } while (decSym < (1 << CMPTLZ_POS_SLOT_BITS));\n    decSym -= (1 << CMPTLZ_POS_SLOT_BITS);\n\n    bits2BeDec = ((decSym >> 1) - 1);\n    if (decSym >= CMPTLZ_LOW_POSSLOT)\n    {\n        if (decSym < CMPTLZ_HIGH_POSSLOT)\n        {\n            probSlot = CmptLzGetSpecPosProb(probsMatrix) + (CmptLzGetBaseDistByPosSlot(decSym) << bits2BeDec);\n        }\n        else\n        {\n            bits2BeDec -= CMPTLZ_LARGE_DIST_LOW_BITS;\n            do\n            {\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n                range >>= 1;\n                rangeCode -= range & (((rangeCode - range) >> 31) - 1);\n            } while (--bits2BeDec);\n            probSlot = CmptLzGetAilgnProb(probsMatrix);\n            bits2BeDec = CMPTLZ_LARGE_DIST_LOW_BITS;\n        }\n\n        decSym = 1;\n        offset = 1;\n        do\n        {\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n            probBit = probSlot + decSym;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probBit);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                decSym += offset;\n                offset <<= 1;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                offset <<= 1;\n                decSym += offset;\n            }\n        } while (--bits2BeDec);\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK;\n}",
                                "rust_code": "pub fn CmptLzTryDecLenAndDist() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline int CmptLzTryDecLitPacket(CmptLzDecCtx *decCtx, uint32_t range, uint32_t rangeCode, uint32_t rangeBound,\n                                        const unsigned char *bufTryDec, const unsigned char **pbufLimit)\n{\n    CmptLzDecProb *probBit;\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n    uint32_t procPos = decCtx->processedPos;\n    uint32_t litPosMask = ((uint32_t)0x100 << decCtx->prop.litPos) - ((uint32_t)0x100 >> decCtx->prop.litCtx);\n\n    size_t dictBufSize = decCtx->dictBufSize;\n    size_t dicPos = decCtx->dictPos;\n    const unsigned char *dict = decCtx->dict;\n    const unsigned char *bufLimit = *pbufLimit;\n\n    if (decCtx->dictPos >= decCtx->dictBufSize)\n    {\n        return CMPT_ERROR_DATA;\n    }\n\n    probSlot = CmptLzGetLiteralProb(probsMatrix);\n    if (procPos != 0 || decCtx->checkDicSize != 0)\n    {\n        probSlot += (uint32_t)3 * ((((procPos << 8) + dict[(dicPos == 0 ? dictBufSize : dicPos) - 1]) & litPosMask)\n                                   << decCtx->prop.litCtx);\n    }\n\n    uint32_t decSym = 1;\n    if (decCtx->state < CMPTLZ_LIT_STATES)\n    {\n        do\n        {\n            probBit = probSlot + decSym;\n            CMPTLZ_SINGLE_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        } while (decSym < 0x100);\n    }\n    else\n    {\n        uint32_t bit;\n        uint32_t matchSym = dict[dicPos - decCtx->reps[0] + ((dicPos < decCtx->reps[0]) ? dictBufSize : 0)];\n        uint32_t offset = 0x100;\n        do\n        {\n            matchSym <<= 1;\n            bit = offset;\n            offset &= matchSym;\n            probBit = probSlot + (offset + bit + decSym);\n            CMPTLZ_MATCH_BIT_TRY_DEC(range, rangeCode, rangeBound, decSym, probBit);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        } while (decSym < 0x100);\n    }\n\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n    *pbufLimit = bufTryDec;\n    return CMPT_OK;\n}",
                                "rust_code": "pub fn CmptLzTryDecLitPacket() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptLzTryDecOnePacket(CmptLzDecCtx *decCtx, const unsigned char *bufTryDec, const unsigned char **pbufLimit)\n{\n    uint32_t rangeBound = 0;\n    uint32_t range = decCtx->range;\n    uint32_t rangeCode = decCtx->code;\n    uint32_t mkState = decCtx->state;\n    const unsigned char *bufLimit = *pbufLimit;\n\n    CmptLzDecProb *probSlot;\n    CmptLzDecProb *probSlot1;\n    CmptLzDecProb *probSlot2;\n    CmptLzDecProb *probsMatrix = CmptLzGetProbsMatrix(decCtx);\n\n    uint32_t pbMask = ((uint32_t)1 << (decCtx->prop.posBits)) - 1;\n    uint32_t posState = CMPTLZ_CALC_POS_STATE(decCtx->processedPos, pbMask);\n\n    probSlot1 = CmptLzGetIsMatchProb(probsMatrix) + posState + mkState;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot1);\n    if (rangeCode < rangeBound)\n    {\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n        return CmptLzTryDecLitPacket(decCtx, range, rangeCode, rangeBound, bufTryDec, pbufLimit);\n    }\n\n    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n    CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n    probSlot2 = CmptLzGetIsRepProb(probsMatrix) + mkState;\n    rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot2);\n    if (rangeCode < rangeBound)\n    {\n\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n        probSlot = CmptLzGetMatchLenCoderProb(probsMatrix);\n        mkState = 0;\n    }\n    else\n    {\n        if (decCtx->dictPos >= decCtx->dictBufSize)\n        {\n            return CMPT_ERROR_DATA;\n        }\n        CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n        CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n        probSlot = CmptLzGetIsRepG0Prob(probsMatrix) + mkState;\n        rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n        if (rangeCode < rangeBound)\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n            probSlot = CmptLzGetIsRepG0LongProb(probsMatrix) + posState + mkState;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n                *pbufLimit = bufTryDec;\n                return CMPT_OK;\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            }\n        }\n        else\n        {\n            CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n            CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n            probSlot = CmptLzGetIsRepG1Prob(probsMatrix) + mkState;\n            rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n            if (rangeCode < rangeBound)\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n            }\n            else\n            {\n                CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                CMPTLZ_RANGE_TRY_NORMALIZE(range, rangeCode, bufTryDec, bufLimit);\n\n                probSlot = CmptLzGetIsRepG2Prob(probsMatrix) + mkState;\n                rangeBound = (range >> CMPTLZ_PROB_LG_BIT) * (*probSlot);\n                if (rangeCode < rangeBound)\n                {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT0(range, rangeBound);\n                }\n                else\n                {\n                    CMPTLZ_RANGE_UPDATE_AFTER_DEC_BIT1(range, rangeCode, rangeBound);\n                }\n            }\n        }\n\n        probSlot = CmptLzGetRepLenCoderProb(probsMatrix);\n        mkState = CMPTLZ_MKSTATE_NUM;\n    }\n    return CmptLzTryDecLenAndDist(decCtx, mkState, range, rangeCode, rangeBound, probSlot, bufTryDec, pbufLimit);\n}",
                                "rust_code": "pub fn CmptLzTryDecOnePacket() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptLzDecCarefulProcess(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *bufLimit)\n{\n    int res = CMPT_OK;\n    uint32_t remainLen;\n    const unsigned char *bufLimitTmp;\n    const unsigned char *pSrcIn;\n\n    do\n    {\n        bufLimitTmp = bufLimit;\n        pSrcIn = decCtx->buf;\n\n        res = CmptLzTryDecOnePacket(decCtx, pSrcIn, &bufLimitTmp);\n        if (res == CMPTLZ_DEC_INPUT_EOF)\n        {\n            break;\n        }\n        res = CmptLzDecDirectProcess(decCtx, dicPosLimit, bufLimitTmp);\n        if ((res != CMPT_OK) || (decCtx->buf != bufLimitTmp))\n        {\n            return CMPT_ERROR_DATA;\n        }\n        if (decCtx->remainLen == CMPTLZ_MATCH_MAX_LEN)\n        {\n            break;\n        }\n    } while (decCtx->dictPos < dicPosLimit);\n\n    if ((res == CMPTLZ_DEC_INPUT_EOF) && (decCtx->buf < bufLimit))\n    {\n        remainLen = (uint32_t)(bufLimit - decCtx->buf);\n        decCtx->tempBufSize = remainLen;\n        for (uint32_t idx = 0; idx < remainLen; idx++)\n        {\n            decCtx->tempBuf[idx] = decCtx->buf[idx];\n        }\n    }\n\n    return CMPT_OK;\n}",
                                "rust_code": "pub fn CmptLzDecCarefulProcess() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptLzDecSinglePacket(CmptLzDecCtx *decCtx, size_t dicPosLimit, const unsigned char *pSrcIn, size_t srcInLen,\n                          size_t *psrcCostLen)\n{\n    int res;\n    size_t lookAheadLen = 0;\n    uint32_t newTempBufSize = decCtx->tempBufSize;\n    unsigned char *oldTmpBuf = &(decCtx->tempBuf[decCtx->tempBufSize]);\n\n    while (newTempBufSize < CMPTLZ_REQUIRED_INPUT_MAX && lookAheadLen < srcInLen)\n    {\n        decCtx->tempBuf[newTempBufSize++] = pSrcIn[lookAheadLen++];\n    }\n\n    const unsigned char *bufLimit = decCtx->tempBuf + newTempBufSize;\n    res = CmptLzTryDecOnePacket(decCtx, &(decCtx->tempBuf[0]), &bufLimit);\n    if (res == CMPTLZ_DEC_INPUT_EOF)\n    {\n        *psrcCostLen = lookAheadLen;\n        decCtx->tempBufSize = newTempBufSize;\n        return CMPTLZ_DEC_INPUT_EOF;\n    }\n\n    if (res == CMPT_ERROR_DATA)\n    {\n        return res;\n    }\n\n    decCtx->buf = &(decCtx->tempBuf[0]);\n\n    res = CmptLzDecDirectProcess(decCtx, dicPosLimit, bufLimit);\n    if ((res != CMPT_OK) || (bufLimit != decCtx->buf) || (bufLimit <= oldTmpBuf))\n    {\n        *psrcCostLen = 0;\n        return CMPT_ERROR_DATA;\n    }\n    *psrcCostLen = (size_t)(bufLimit - oldTmpBuf);\n    decCtx->tempBufSize = 0;\n    return res;\n}",
                                "rust_code": "pub fn CmptLzDecSinglePacket() { unimplemented!(); }"
                            }
                        ]
                    },
                    "cmptlz_dec_init_c.rs": {
                        "name": "cmptlz_dec_init_c.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::decode::cmptlz_dec_inner_h::*;"
                        ],
                        "definitions": [],
                        "macros": [
                            {
                                "c_code": "#define CMPTLZ_LIT_CTX_MAX 9",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_POS_STATE_MAX 5",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_LIT_POS_MAX 5",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_BIG_DICT_LG_SIZE 30",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_MID_DICT_LG_SIZE 22",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_SMALL_DICT_LG_SIZE 20",
                                "rust_code": ""
                            }
                        ],
                        "macro_functions": [],
                        "functions": [
                            {
                                "c_code": "static inline int CmptLzPropsDecode(const unsigned char *protData, unsigned protSize, CmptLzDecProt *decProt)\n{\n    uint32_t dictSize;\n\n    if (protSize < CMPTLZ_PROPS_SIZE)\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n    else\n    {\n\n        dictSize =\n            protData[1] | ((uint32_t)protData[2] << 8) | ((uint32_t)protData[3] << 16) | ((uint32_t)protData[4] << 24);\n    }\n\n    if (dictSize < CMPTLZ_DICT_MIN_LEN)\n    {\n        dictSize = CMPTLZ_DICT_MIN_LEN;\n    }\n    decProt->dicSize = dictSize;\n\n    unsigned char firstData = protData[0];\n    if (firstData >= (CMPTLZ_LIT_CTX_MAX * CMPTLZ_POS_STATE_MAX * CMPTLZ_LIT_POS_MAX))\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    decProt->litCtx = (unsigned char)(firstData % CMPTLZ_LIT_CTX_MAX);\n    firstData /= CMPTLZ_LIT_CTX_MAX;\n    decProt->posBits = (unsigned char)(firstData / CMPTLZ_POS_STATE_MAX);\n    decProt->litPos = (unsigned char)(firstData % CMPTLZ_LIT_POS_MAX);\n\n    return CMPT_OK;\n}",
                                "rust_code": "pub fn CmptLzPropsDecode() { unimplemented!(); }"
                            },
                            {
                                "c_code": "void CmptLzDecInit(CmptLzDecCtx *decCtx)\n{\n    decCtx->dictPos = 0;\n    decCtx->tempBufSize = 0;\n    decCtx->processedPos = 0;\n    decCtx->checkDicSize = 0;\n    decCtx->remainLen = CMPTLZ_MATCH_MAX_LEN + 2;\n}",
                                "rust_code": "pub fn CmptLzDecInit() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void *CmptLzDecMemAlloc(CmptLzMemHook *memHook, int32_t memHandle, size_t allocSize)\n{\n    return memHook->CmptLzAlloc(memHandle, allocSize);\n}",
                                "rust_code": "pub fn CmptLzDecMemAlloc() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptLzDecMemFree(CmptLzMemHook *memHook, int32_t memHandle, void *freeAddress)\n{\n    memHook->CmptLzFree(memHandle, freeAddress);\n}",
                                "rust_code": "pub fn CmptLzDecMemFree() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptLzDecFreeProbs(CmptLzDecCtx *decCtx, CmptLzMemHook *memHook)\n{\n    if (decCtx->probs != NULL)\n    {\n        CmptLzDecMemFree(memHook, CMPTLZ_PROB_HANDLE, decCtx->probs);\n        decCtx->probs = NULL;\n    }\n}",
                                "rust_code": "pub fn CmptLzDecFreeProbs() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptLzFreeDict(CmptLzDecCtx *decCtx, CmptLzMemHook *memHook)\n{\n    if (decCtx->dict != NULL)\n    {\n        CmptLzDecMemFree(memHook, CMPTLZ_DICT_HANDLE, decCtx->dict);\n        decCtx->dict = NULL;\n    }\n}",
                                "rust_code": "pub fn CmptLzFreeDict() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline int CmptLzDecAllocateProbs(CmptLzDecCtx *decCtx, CmptLzDecProt *decProt, CmptLzMemHook *memHook)\n{\n    uint32_t numProbs = CmptLzGetNumProbs(decProt);\n\n    if (decCtx->probs == NULL)\n    {\n        decCtx->probs =\n            (CmptLzDecProb *)CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE, numProbs * sizeof(CmptLzDecProb));\n    }\n    else\n    {\n        if (numProbs != decCtx->numProbs)\n        {\n            CmptLzDecFreeProbs(decCtx, memHook);\n            decCtx->probs =\n                (CmptLzDecProb *)CmptLzDecMemAlloc(memHook, CMPTLZ_PROB_HANDLE, numProbs * sizeof(CmptLzDecProb));\n        }\n    }\n\n    if (decCtx->probs == NULL)\n    {\n        return CMPT_ERROR_MEM;\n    }\n\n    decCtx->probsPlus1664 = decCtx->probs + 1664;\n    decCtx->numProbs = numProbs;\n\n    return CMPT_OK;\n}",
                                "rust_code": "pub fn CmptLzDecAllocateProbs() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptLzDecAllocate(CmptLzDecCtx *decCtx, const unsigned char *protData, unsigned protSize, CmptLzMemHook *memHook)\n{\n    int res;\n    uint32_t dictMask;\n    size_t dictBufSize;\n    CmptLzDecProt decProt;\n\n    if ((decCtx == NULL) || (protData == NULL) || (memHook == NULL))\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    res = CmptLzPropsDecode(protData, protSize, &decProt);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n    res = CmptLzDecAllocateProbs(decCtx, &decProt, memHook);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n\n    uint32_t dictSize = decProt.dicSize;\n    if (dictSize >= ((uint32_t)1 << CMPTLZ_BIG_DICT_LG_SIZE))\n    {\n        dictMask = ((uint32_t)1 << CMPTLZ_MID_DICT_LG_SIZE) - 1;\n    }\n    else if (dictSize >= ((uint32_t)1 << CMPTLZ_MID_DICT_LG_SIZE))\n    {\n        dictMask = ((uint32_t)1 << CMPTLZ_SMALL_DICT_LG_SIZE) - 1;\n    }\n    else\n    {\n        dictMask = CMPTLZ_DICT_MIN_LEN - 1;\n    }\n\n    dictBufSize = ((size_t)dictSize + dictMask) & ~dictMask;\n    if (dictBufSize < dictSize)\n    {\n        dictBufSize = dictSize;\n    }\n\n    if (decCtx->dict == NULL)\n    {\n        decCtx->dict = (unsigned char *)CmptLzDecMemAlloc(memHook, CMPTLZ_DICT_HANDLE, dictBufSize);\n    }\n    else\n    {\n        if (dictBufSize != decCtx->dictBufSize)\n        {\n            CmptLzFreeDict(decCtx, memHook);\n            decCtx->dict = (unsigned char *)CmptLzDecMemAlloc(memHook, CMPTLZ_DICT_HANDLE, dictBufSize);\n        }\n    }\n\n    if (decCtx->dict == NULL)\n    {\n        CmptLzDecFreeProbs(decCtx, memHook);\n        return CMPT_ERROR_MEM;\n    }\n\n    decCtx->dictBufSize = dictBufSize;\n    decCtx->prop = decProt;\n\n    return CMPT_OK;\n}",
                                "rust_code": "pub fn CmptLzDecAllocate() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptLzDecFree(CmptLzDecCtx *decCtx, CmptLzMemHook *memHook)\n{\n    if ((decCtx == NULL) || (memHook == NULL))\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    CmptLzDecFreeProbs(decCtx, memHook);\n    CmptLzFreeDict(decCtx, memHook);\n\n    return CMPT_OK;\n}",
                                "rust_code": "pub fn CmptLzDecFree() { unimplemented!(); }"
                            },
                            {
                                "c_code": "void CmptLzDecConstruct(CmptLzDecCtx *decCtx)\n{\n    decCtx->dict = NULL;\n    decCtx->probs = NULL;\n}",
                                "rust_code": "pub fn CmptLzDecConstruct() { unimplemented!(); }"
                            },
                            {
                                "c_code": "int CmptLzDecode(CmptLzDecIn *pDecIn, CmptLzDecOut *pDecOut, const unsigned char *protData, EnCmptLzFinMode finMode,\n                 EnCmptLzStatus *finStatus, CmptLzMemHook *memHook)\n{\n    int res;\n    size_t inSize = pDecIn->strInLen;\n    CmptLzDecProt decProt;\n    CmptLzDecCtx decCtx;\n    decCtx.numProbs = 0;\n\n    if (inSize < CMPTLZ_PROPS_SIZE)\n    {\n        return CMPT_ERROR_UNSUPPORTED;\n    }\n\n    CmptLzDecConstruct(&decCtx);\n    res = CmptLzPropsDecode(protData, CMPTLZ_PROPS_SIZE, &decProt);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n    res = CmptLzDecAllocateProbs(&decCtx, &decProt, memHook);\n    if (res != CMPT_OK)\n    {\n        return res;\n    }\n\n    decCtx.prop = decProt;\n    decCtx.dict = pDecOut->pDestOut;\n    decCtx.dictBufSize = pDecOut->destOutLen;\n    CmptLzDecInit(&decCtx);\n\n    *finStatus = CMPTLZ_STATUS_NOT_SPECIFIED;\n    res = CmptLzDecDecodeToDic(&decCtx, pDecOut->destOutLen, pDecIn->pSrcIn, &inSize, finMode, finStatus);\n    pDecIn->strInCostLen = inSize;\n    pDecOut->destOutFillLen = decCtx.dictPos;\n    CmptLzDecFreeProbs(&decCtx, memHook);\n\n    return res;\n}",
                                "rust_code": "pub fn CmptLzDecode() { unimplemented!(); }"
                            }
                        ]
                    },
                    "mod.rs": {
                        "name": "mod.rs",
                        "type": "file",
                        "declarations": [
                            "pub mod cmptlz_dec_inner_h;",
                            "pub mod cmptlz_dec_process_c;",
                            "pub mod cmptlz_dec_c;",
                            "pub mod cmptlz_dec_try_c;",
                            "pub mod cmptlz_dec_init_c;"
                        ],
                        "definitions": [],
                        "macros": [],
                        "macro_functions": [],
                        "functions": []
                    }
                }
            },
            "public": {
                "name": "public",
                "type": "folder",
                "children": {
                    "cmptlz_log_h.rs": {
                        "name": "cmptlz_log_h.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::include::cmptlz_base_h::*;",
                            "pub use crate::src::public::cmptlz_log_c::CmptlzLogWrite;"
                        ],
                        "definitions": [],
                        "macros": [
                            {
                                "c_code": "#define CMPTLZ_LOG_H",
                                "rust_code": ""
                            }
                        ],
                        "macro_functions": [
                            {
                                "c_code": "#define CMPTLZ_LOG(error_code, fmt, ...)                                                                               \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        CmptlzLogWrite((size_t)(error_code), __FUNCTION__, __LINE__, fmt, __VA_ARGS__);                                \\\n    } while (0)",
                                "rust_code": ""
                            }
                        ],
                        "functions": []
                    },
                    "cmptlz_def_h.rs": {
                        "name": "cmptlz_def_h.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;"
                        ],
                        "definitions": [],
                        "macros": [
                            {
                                "c_code": "#define CMPTLZ_DEF_H",
                                "rust_code": ""
                            }
                        ],
                        "macro_functions": [
                            {
                                "c_code": "#define CMPTLZ_LIKELY(expr) __builtin_expect(expr, true)",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_UNLIKELY(expr) __builtin_expect(expr, false)",
                                "rust_code": ""
                            }
                        ],
                        "functions": []
                    },
                    "cmptlz_log_c.rs": {
                        "name": "cmptlz_log_c.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::public::cmptlz_log_h::*;"
                        ],
                        "definitions": [
                            {
                                "c_code": "static CmptlzLogFunc g_cmptlzLogFunc = NULL;",
                                "rust_code": "pub static g_cmptlzLogFunc: i32 = 0;"
                            }
                        ],
                        "macros": [
                            {
                                "c_code": "#define LOG_BUF_SIZE 1024U",
                                "rust_code": ""
                            }
                        ],
                        "macro_functions": [],
                        "functions": [
                            {
                                "c_code": "void CmptlzLogWrite(size_t errorCode, const char *funcName, unsigned short line, const char *fmt, ...)\n    {\n        va_list alist;\n        char output[LOG_BUF_SIZE];\n        int ret;\n        size_t len;\n        CmptlzLogFunc func = g_cmptlzLogFunc;\n\n        if (func == NULL)\n        {\n            return;\n        }\n\n        ret = snprintf_s(output, LOG_BUF_SIZE, LOG_BUF_SIZE - 1, \"\\n[Cmptlz-Log] Func=%s, Line=%u, Error=0x%zx\\n\",\n                         funcName, line, errorCode);\n        if (ret < 0)\n        {\n            return;\n        }\n        len = (size_t)ret;\n\n        va_start(alist, fmt);\n        ret = vsnprintf_s(output + len, LOG_BUF_SIZE - len, LOG_BUF_SIZE - len - 1, fmt, alist);\n        va_end(alist);\n        if (ret < 0)\n        {\n            return;\n        }\n\n        func(output, strlen(output) + 1);\n    }",
                                "rust_code": "pub fn CmptlzLogWrite() { unimplemented!(); }"
                            },
                            {
                                "c_code": "void CmptlzLogRegister(CmptlzLogFunc func)\n    {\n        g_cmptlzLogFunc = func;\n    }",
                                "rust_code": "pub fn CmptlzLogRegister() { unimplemented!(); }"
                            }
                        ]
                    },
                    "cmptlz_utils_h.rs": {
                        "name": "cmptlz_utils_h.rs",
                        "type": "file",
                        "declarations": [
                            "use crate::translation_utils::*;",
                            "pub use crate::src::public::cmptlz_def_h::*;"
                        ],
                        "definitions": [
                            {
                                "c_code": "typedef struct\n{\n    uint32_t v;\n} __attribute__((packed)) CmptlzUnalignU32;",
                                "rust_code": "pub type CmptlzUnalignU32 = i32;"
                            }
                        ],
                        "macros": [
                            {
                                "c_code": "#define CMPTLZ_UTILS_H",
                                "rust_code": ""
                            }
                        ],
                        "macro_functions": [
                            {
                                "c_code": "#define CMPTLZ_WRITE32BIT(ptr, val) (((CmptlzUnalignU32 *)(ptr))->v = (val))",
                                "rust_code": ""
                            },
                            {
                                "c_code": "#define CMPTLZ_READ32BIT(ptr) (((const CmptlzUnalignU32 *)(ptr))->v)",
                                "rust_code": ""
                            }
                        ],
                        "functions": [
                            {
                                "c_code": "static inline int CmptlzIsLE(void)\n    {\n#if (defined(__GNUC__) || defined(__clang__))\n        return __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__;\n#endif\n        int n = 1;\n        return *(char *)(&n);\n    }",
                                "rust_code": "pub fn CmptlzIsLE() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline uint32_t CmptlzSwap32(uint32_t val)\n    {\n#if (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)))\n        return (uint32_t)__builtin_bswap32(val);\n#endif\n        return ((0xff000000 & (val << 24)) | (0x000000ff & (val >> 24)) | (0x00ff0000 & (val << 8)) |\n                (0x0000ff00 & (val >> 8)));\n    }",
                                "rust_code": "pub fn CmptlzSwap32() { unimplemented!(); }"
                            },
                            {
                                "c_code": "static inline void CmptlzWriteLE32Bit(void *addr, uint32_t val)\n    {\n        if (CmptlzIsLE() != 0)\n        {\n            CMPTLZ_WRITE32BIT(addr, val);\n        }\n        else\n        {\n            CMPTLZ_WRITE32BIT(addr, CmptlzSwap32(val));\n        }\n    }",
                                "rust_code": "pub fn CmptlzWriteLE32Bit() { unimplemented!(); }"
                            }
                        ]
                    },
                    "mod.rs": {
                        "name": "mod.rs",
                        "type": "file",
                        "declarations": [
                            "pub mod cmptlz_log_h;",
                            "pub mod cmptlz_def_h;",
                            "pub mod cmptlz_log_c;",
                            "pub mod cmptlz_utils_h;"
                        ],
                        "definitions": [],
                        "macros": [],
                        "macro_functions": [],
                        "functions": []
                    }
                }
            },
            "mod.rs": {
                "name": "mod.rs",
                "type": "file",
                "declarations": [
                    "pub mod encode;",
                    "pub mod decode;",
                    "pub mod public;"
                ],
                "definitions": [],
                "macros": [],
                "macro_functions": [],
                "functions": []
            }
        }
    },
    "lib.rs": {
        "name": "lib.rs",
        "type": "file",
        "declarations": [
            "pub(crate) mod translation_utils;",
            "pub(crate) mod include;",
            "pub(crate) mod src;"
        ],
        "definitions": [],
        "macros": [],
        "macro_functions": [],
        "functions": []
    }
}