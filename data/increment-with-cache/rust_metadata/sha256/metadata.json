{
    "include": {
        "name": "include",
        "type": "folder",
        "children": {
            "sha256_h.rs": {
                "name": "sha256_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::sha256_c::vosSha256Hash;",
                    "pub use crate::src::sha256_c::VOS_Sha256Calc;",
                    "pub use crate::src::sha256_c::vosSha256Begin;",
                    "pub use crate::src::sha256_c::vosSha256End;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef struct\n    {\n        uint32_t h[8];\n        uint32_t N[2];\n        uint32_t block[SHA256_BLOCK_SIZE / sizeof(uint32_t)];\n        uint32_t blocklen;\n        uint32_t outlen;\n        uint32_t computed : 1;\n        uint32_t corrupted : 1;\n    } VOS_SHA256_CTX;",
                        "rust_code": "pub type VOS_SHA256_CTX = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define SHA256_H",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define VOS_SHA256_CTX_HASH_LEN 8",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define VOS_SHA256_CTX_BUF_LEN 16",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define SHA256_BLOCK_SIZE 64",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define SHA256_DIGEST_SIZE 32",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "mod.rs": {
                "name": "mod.rs",
                "type": "file",
                "declarations": [
                    "pub mod sha256_h;"
                ],
                "definitions": [],
                "macros": [],
                "macro_functions": [],
                "functions": []
            }
        }
    },
    "src": {
        "name": "src",
        "type": "folder",
        "children": {
            "sha256_c.rs": {
                "name": "sha256_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::include::sha256_h::*;"
                ],
                "definitions": [
                    {
                        "c_code": "static const uint32_t K256[64] = {\n        0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL, 0x3956c25bUL, 0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL,\n        0xd807aa98UL, 0x12835b01UL, 0x243185beUL, 0x550c7dc3UL, 0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL, 0xc19bf174UL,\n        0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL, 0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL,\n        0x983e5152UL, 0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL, 0xc6e00bf3UL, 0xd5a79147UL, 0x06ca6351UL, 0x14292967UL,\n        0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL, 0x53380d13UL, 0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,\n        0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL, 0xd192e819UL, 0xd6990624UL, 0xf40e3585UL, 0x106aa070UL,\n        0x19a4c116UL, 0x1e376c08UL, 0x2748774cUL, 0x34b0bcb5UL, 0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL, 0x682e6ff3UL,\n        0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL, 0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL,\n    };",
                        "rust_code": "pub static K256: i32 = 0;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define SHA256_OK 0",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define SHA256_ERROR ((uint32_t)(~0))",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define BITS_PRE_BYTE 8",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define SHIFTS_PER_BYTE 3",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [
                    {
                        "c_code": "#define BITSIZE(t) (sizeof(t) * BITS_PRE_BYTE)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define PUT_UINT32_BE(v, p, i)                                                                                         \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (p)[(i) + 0] = (uint8_t)((v) >> 24);                                                                           \\\n        (p)[(i) + 1] = (uint8_t)((v) >> 16);                                                                           \\\n        (p)[(i) + 2] = (uint8_t)((v) >> 8);                                                                            \\\n        (p)[(i) + 3] = (uint8_t)((v) >> 0);                                                                            \\\n    } while (0)",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define GET_UINT32_BE(p, i)                                                                                            \\\n    (((uint32_t)(p)[(i) + 0] << 24) | ((uint32_t)(p)[(i) + 1] << 16) | ((uint32_t)(p)[(i) + 2] << 8) |                 \\\n     ((uint32_t)(p)[(i) + 3] << 0))",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define VOS_ROTR32(x, uiBlcLen) (((x) << (32 - (uiBlcLen))) | ((x) >> (uiBlcLen)))",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define VOS_ROUND(a, b, c, d, e, f, g, h, i, k, W)                                                                     \\\n    do                                                                                                                 \\\n    {                                                                                                                  \\\n        (h) += (VOS_ROTR32((e), 6) ^ VOS_ROTR32((e), 11) ^ VOS_ROTR32((e), 25)) + ((g) ^ ((e) & ((f) ^ (g)))) + (k) +  \\\n               (W)[(i)];                                                                                               \\\n        (d) += (h);                                                                                                    \\\n        (h) += (VOS_ROTR32((a), 2) ^ VOS_ROTR32((a), 13) ^ VOS_ROTR32((a), 22)) + (((a) & ((b) | (c))) | ((b) & (c))); \\\n    } while (0)",
                        "rust_code": ""
                    }
                ],
                "functions": [
                    {
                        "c_code": "void vosSha256Begin(VOS_SHA256_CTX *pstCtx)\n    {\n        if (pstCtx == NULL)\n        {\n            return;\n        }\n\n        (void)memset_s(pstCtx, sizeof(VOS_SHA256_CTX), 0, sizeof(VOS_SHA256_CTX));\n        pstCtx->h[0] = 0x6a09e667UL;\n        pstCtx->h[1] = 0xbb67ae85UL;\n        pstCtx->h[2] = 0x3c6ef372UL;\n        pstCtx->h[3] = 0xa54ff53aUL;\n        pstCtx->h[4] = 0x510e527fUL;\n        pstCtx->h[5] = 0x9b05688cUL;\n        pstCtx->h[6] = 0x1f83d9abUL;\n        pstCtx->h[7] = 0x5be0cd19UL;\n        pstCtx->outlen = SHA256_DIGEST_SIZE;\n    }",
                        "rust_code": "pub fn vosSha256Begin() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static uint32_t vosSha256CtxPrepare(VOS_SHA256_CTX *pstCtx, uint32_t uiLen)\n    {\n        uint32_t uiCntFirst;\n        uint32_t uiCntSec;\n\n        uiCntFirst = (pstCtx->N[0] + (uiLen << SHIFTS_PER_BYTE)) & 0xffffffffUL;\n        if (uiCntFirst < pstCtx->N[0])\n        {\n            ++pstCtx->N[1];\n            if (pstCtx->N[1] == 0)\n            {\n                pstCtx->corrupted = 1;\n                return SHA256_ERROR;\n            }\n        }\n\n        uiCntSec = pstCtx->N[1] + (uiLen >> (BITSIZE(uint32_t) - SHIFTS_PER_BYTE));\n        if (uiCntSec < pstCtx->N[1])\n        {\n            pstCtx->corrupted = 1;\n            return SHA256_ERROR;\n        }\n\n        pstCtx->N[1] = uiCntSec;\n        pstCtx->N[0] = uiCntFirst;\n        return SHA256_OK;\n    }",
                        "rust_code": "pub fn vosSha256CtxPrepare() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static uint32_t vosSha256LastPadding(const uint8_t *pucData, uint32_t uiLen, VOS_SHA256_CTX *pstCtx,\n                                         uint32_t *puiPaddingLen)\n    {\n        errno_t err;\n        uint32_t uiBlcLen = pstCtx->blocklen;\n        uint8_t *pucBlock = (uint8_t *)pstCtx->block;\n\n        if ((uiLen >= SHA256_BLOCK_SIZE) || (uiLen + uiBlcLen >= SHA256_BLOCK_SIZE))\n        {\n            err = memcpy_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, pucData, SHA256_BLOCK_SIZE - uiBlcLen);\n            if (err != EOK)\n            {\n                pstCtx->corrupted = 1;\n                return SHA256_ERROR;\n            }\n            vosSha256CompressMul(pstCtx, pucBlock, 1);\n            *puiPaddingLen = SHA256_BLOCK_SIZE - uiBlcLen;\n            pstCtx->blocklen = 0;\n            (void)memset_s(pucBlock, SHA256_BLOCK_SIZE, 0, SHA256_BLOCK_SIZE);\n        }\n        else\n        {\n            err = memcpy_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, pucData, uiLen);\n            if (err != EOK)\n            {\n                pstCtx->corrupted = 1;\n                return SHA256_ERROR;\n            }\n            pstCtx->blocklen += (uint32_t)uiLen;\n            return SHA256_ERROR;\n        }\n\n        return SHA256_OK;\n    }",
                        "rust_code": "pub fn vosSha256LastPadding() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void vosSha256HashByBlcMulti(const uint8_t *pucData, uint32_t uiLen, VOS_SHA256_CTX *pstCtx)\n    {\n        errno_t err;\n        uint32_t uiBlcLen;\n        uint32_t uiLenTmp = uiLen;\n        const uint8_t *pucSrc = pucData;\n\n        uiBlcLen = (uint32_t)(uiLenTmp / SHA256_BLOCK_SIZE);\n        if (uiBlcLen > 0)\n        {\n            vosSha256CompressMul(pstCtx, pucSrc, uiBlcLen);\n            uiBlcLen *= SHA256_BLOCK_SIZE;\n            pucSrc += uiBlcLen;\n            uiLenTmp -= uiBlcLen;\n        }\n\n        if (uiLenTmp != 0)\n        {\n            pstCtx->blocklen = (uint32_t)uiLenTmp;\n            err = memcpy_s((uint8_t *)pstCtx->block, SHA256_BLOCK_SIZE, pucSrc, uiLenTmp);\n            if (err != EOK)\n            {\n                pstCtx->corrupted = 1;\n                return;\n            }\n        }\n        return;\n    }",
                        "rust_code": "pub fn vosSha256HashByBlcMulti() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void vosSha256Hash(const uint8_t *pucData, uint32_t uiLen, VOS_SHA256_CTX *pstCtx)\n    {\n        uint32_t uiBlcLen = 0;\n        uint32_t uiLenTmp = uiLen;\n        const uint8_t *pucSrc = pucData;\n\n        if ((pucSrc == NULL) || (uiLenTmp == 0) || (pstCtx == NULL) || (pstCtx->corrupted == 1) ||\n            (pstCtx->computed == 1) || (vosSha256CtxPrepare(pstCtx, uiLenTmp) != SHA256_OK))\n        {\n            return;\n        }\n\n        if (pstCtx->blocklen != 0)\n        {\n            if (vosSha256LastPadding(pucSrc, uiLenTmp, pstCtx, &uiBlcLen) == SHA256_OK)\n            {\n                pucSrc += uiBlcLen;\n                uiLenTmp -= uiBlcLen;\n            }\n            else\n            {\n                return;\n            }\n        }\n\n        vosSha256HashByBlcMulti(pucSrc, uiLenTmp, pstCtx);\n        return;\n    }",
                        "rust_code": "pub fn vosSha256Hash() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void vosSha256End(uint8_t *pucOut, uint32_t uiOutSize, VOS_SHA256_CTX *pstCtx)\n    {\n        uint32_t uiIndex;\n        uint8_t *pucBlock = NULL;\n        uint32_t uiBlcLen;\n\n        if (pstCtx == NULL)\n        {\n            return;\n        }\n\n        pucBlock = (uint8_t *)pstCtx->block;\n        uiBlcLen = pstCtx->blocklen;\n\n        if ((pstCtx->corrupted == 1) || (uiOutSize < pstCtx->outlen))\n        {\n            (void)memset_s(pstCtx, sizeof(VOS_SHA256_CTX), 0, sizeof(VOS_SHA256_CTX));\n            return;\n        }\n\n        if (pstCtx->computed == 0)\n        {\n            pucBlock[uiBlcLen++] = 0x80;\n            if (uiBlcLen > (SHA256_BLOCK_SIZE - 8))\n            {\n                (void)memset_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, 0, SHA256_BLOCK_SIZE - uiBlcLen);\n                uiBlcLen = 0;\n                vosSha256CompressMul(pstCtx, pucBlock, 1);\n            }\n\n            (void)memset_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, 0, SHA256_BLOCK_SIZE - 8 - uiBlcLen);\n\n            pucBlock += SHA256_BLOCK_SIZE - 8;\n            PUT_UINT32_BE(pstCtx->N[1], pucBlock, 0);\n            pucBlock += sizeof(uint32_t);\n            PUT_UINT32_BE(pstCtx->N[0], pucBlock, 0);\n            pucBlock += sizeof(uint32_t);\n            pucBlock -= SHA256_BLOCK_SIZE;\n            vosSha256CompressMul(pstCtx, pucBlock, 1);\n            pstCtx->blocklen = 0;\n            (void)memset_s(pucBlock, SHA256_BLOCK_SIZE, 0, SHA256_BLOCK_SIZE);\n            pstCtx->computed = 1;\n        }\n\n        uiBlcLen = ((pstCtx->outlen <= uiOutSize) ? pstCtx->outlen : uiOutSize) / sizeof(uint32_t);\n        if (pucOut != NULL)\n        {\n            for (uiIndex = 0; uiIndex < uiBlcLen; uiIndex++)\n            {\n                PUT_UINT32_BE(pstCtx->h[uiIndex], pucOut, sizeof(uint32_t) * uiIndex);\n            }\n        }\n\n        return;\n    }",
                        "rust_code": "pub fn vosSha256End() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void vosSha256CompressBlock(uint32_t state[VOS_SHA256_CTX_HASH_LEN], const uint8_t block[SHA256_BLOCK_SIZE])\n    {\n        uint32_t W[64];\n        uint32_t i, j;\n        uint32_t a, b, c, d, e, f, g, h;\n\n        for (i = 0; i < 16; i++)\n        {\n            W[i] = GET_UINT32_BE(block, 4 * (i));\n        }\n\n        for (i = 16; i < 64; i++)\n        {\n            W[i] = W[i - 16] + W[i - 7] + (VOS_ROTR32(W[i - 15], 7) ^ VOS_ROTR32(W[i - 15], 18) ^ (W[i - 15] >> 3)) +\n                   (VOS_ROTR32(W[i - 2], 17) ^ VOS_ROTR32(W[i - 2], 19) ^ (W[i - 2] >> 10));\n        }\n\n        j = 0;\n        a = state[j++];\n        b = state[j++];\n        c = state[j++];\n        d = state[j++];\n        e = state[j++];\n        f = state[j++];\n        g = state[j++];\n        h = state[j];\n\n        for (i = 0; i < 64; i += 8)\n        {\n            j = 0;\n            VOS_ROUND(a, b, c, d, e, f, g, h, i + (j++), K256[i + 0], W);\n            VOS_ROUND(h, a, b, c, d, e, f, g, i + (j++), K256[i + 1], W);\n            VOS_ROUND(g, h, a, b, c, d, e, f, i + (j++), K256[i + 2], W);\n            VOS_ROUND(f, g, h, a, b, c, d, e, i + (j++), K256[i + 3], W);\n            VOS_ROUND(e, f, g, h, a, b, c, d, i + (j++), K256[i + 4], W);\n            VOS_ROUND(d, e, f, g, h, a, b, c, i + (j++), K256[i + 5], W);\n            VOS_ROUND(c, d, e, f, g, h, a, b, i + (j++), K256[i + 6], W);\n            VOS_ROUND(b, c, d, e, f, g, h, a, i + j, K256[i + 7], W);\n        }\n\n        j = 0;\n        state[j++] += a;\n        state[j++] += b;\n        state[j++] += c;\n        state[j++] += d;\n        state[j++] += e;\n        state[j++] += f;\n        state[j++] += g;\n        state[j] += h;\n    }",
                        "rust_code": "pub fn vosSha256CompressBlock() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void vosSha256CompressMul(VOS_SHA256_CTX *pstCtx, const uint8_t *pucInput, uint32_t uiNum)\n    {\n        uint32_t uiNumTmp = uiNum;\n        const uint8_t *pucBlock = pucInput;\n\n        while ((uiNumTmp--) != 0)\n        {\n            vosSha256CompressBlock(pstCtx->h, pucBlock);\n            pucBlock += SHA256_BLOCK_SIZE;\n        }\n    }",
                        "rust_code": "pub fn vosSha256CompressMul() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void VOS_Sha256Calc(const uint8_t *pucInput, uint32_t uiInputLen, uint8_t *pucOutput, uint32_t uiOutputLen)\n    {\n        VOS_SHA256_CTX stCtx;\n\n        vosSha256Begin(&stCtx);\n        vosSha256Hash(pucInput, uiInputLen, &stCtx);\n        vosSha256End(pucOutput, uiOutputLen, &stCtx);\n    }",
                        "rust_code": "pub fn VOS_Sha256Calc() { unimplemented!(); }"
                    }
                ]
            },
            "mod.rs": {
                "name": "mod.rs",
                "type": "file",
                "declarations": [
                    "pub mod sha256_c;"
                ],
                "definitions": [],
                "macros": [],
                "macro_functions": [],
                "functions": []
            }
        }
    },
    "lib.rs": {
        "name": "lib.rs",
        "type": "file",
        "declarations": [
            "pub(crate) mod translation_utils;",
            "pub(crate) mod include;",
            "pub(crate) mod src;"
        ],
        "definitions": [],
        "macros": [],
        "macro_functions": [],
        "functions": []
    }
}