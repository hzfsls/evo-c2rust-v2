{"void vosSha256Begin(VOS_SHA256_CTX *pstCtx)\n    {\n        if (pstCtx == NULL)\n        {\n            return;\n        }\n\n        (void)memset_s(pstCtx, sizeof(VOS_SHA256_CTX), 0, sizeof(VOS_SHA256_CTX));\n        pstCtx->h[0] = 0x6a09e667UL;\n        pstCtx->h[1] = 0xbb67ae85UL;\n        pstCtx->h[2] = 0x3c6ef372UL;\n        pstCtx->h[3] = 0xa54ff53aUL;\n        pstCtx->h[4] = 0x510e527fUL;\n        pstCtx->h[5] = 0x9b05688cUL;\n        pstCtx->h[6] = 0x1f83d9abUL;\n        pstCtx->h[7] = 0x5be0cd19UL;\n        pstCtx->outlen = SHA256_DIGEST_SIZE;\n    }": "0", "static uint32_t vosSha256CtxPrepare(VOS_SHA256_CTX *pstCtx, uint32_t uiLen)\n    {\n        uint32_t uiCntFirst;\n        uint32_t uiCntSec;\n\n        uiCntFirst = (pstCtx->N[0] + (uiLen << SHIFTS_PER_BYTE)) & 0xffffffffUL;\n        if (uiCntFirst < pstCtx->N[0])\n        {\n            ++pstCtx->N[1];\n            if (pstCtx->N[1] == 0)\n            {\n                pstCtx->corrupted = 1;\n                return SHA256_ERROR;\n            }\n        }\n\n        uiCntSec = pstCtx->N[1] + (uiLen >> (BITSIZE(uint32_t) - SHIFTS_PER_BYTE));\n        if (uiCntSec < pstCtx->N[1])\n        {\n            pstCtx->corrupted = 1;\n            return SHA256_ERROR;\n        }\n\n        pstCtx->N[1] = uiCntSec;\n        pstCtx->N[0] = uiCntFirst;\n        return SHA256_OK;\n    }": "1", "static uint32_t vosSha256LastPadding(const uint8_t *pucData, uint32_t uiLen, VOS_SHA256_CTX *pstCtx,\n                                         uint32_t *puiPaddingLen)\n    {\n        errno_t err;\n        uint32_t uiBlcLen = pstCtx->blocklen;\n        uint8_t *pucBlock = (uint8_t *)pstCtx->block;\n\n        if ((uiLen >= SHA256_BLOCK_SIZE) || (uiLen + uiBlcLen >= SHA256_BLOCK_SIZE))\n        {\n            err = memcpy_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, pucData, SHA256_BLOCK_SIZE - uiBlcLen);\n            if (err != EOK)\n            {\n                pstCtx->corrupted = 1;\n                return SHA256_ERROR;\n            }\n            vosSha256CompressMul(pstCtx, pucBlock, 1);\n            *puiPaddingLen = SHA256_BLOCK_SIZE - uiBlcLen;\n            pstCtx->blocklen = 0;\n            (void)memset_s(pucBlock, SHA256_BLOCK_SIZE, 0, SHA256_BLOCK_SIZE);\n        }\n        else\n        {\n            err = memcpy_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, pucData, uiLen);\n            if (err != EOK)\n            {\n                pstCtx->corrupted = 1;\n                return SHA256_ERROR;\n            }\n            pstCtx->blocklen += (uint32_t)uiLen;\n            return SHA256_ERROR;\n        }\n\n        return SHA256_OK;\n    }": "2", "static void vosSha256HashByBlcMulti(const uint8_t *pucData, uint32_t uiLen, VOS_SHA256_CTX *pstCtx)\n    {\n        errno_t err;\n        uint32_t uiBlcLen;\n        uint32_t uiLenTmp = uiLen;\n        const uint8_t *pucSrc = pucData;\n\n        uiBlcLen = (uint32_t)(uiLenTmp / SHA256_BLOCK_SIZE);\n        if (uiBlcLen > 0)\n        {\n            vosSha256CompressMul(pstCtx, pucSrc, uiBlcLen);\n            uiBlcLen *= SHA256_BLOCK_SIZE;\n            pucSrc += uiBlcLen;\n            uiLenTmp -= uiBlcLen;\n        }\n\n        if (uiLenTmp != 0)\n        {\n            pstCtx->blocklen = (uint32_t)uiLenTmp;\n            err = memcpy_s((uint8_t *)pstCtx->block, SHA256_BLOCK_SIZE, pucSrc, uiLenTmp);\n            if (err != EOK)\n            {\n                pstCtx->corrupted = 1;\n                return;\n            }\n        }\n        return;\n    }": "3", "void vosSha256Hash(const uint8_t *pucData, uint32_t uiLen, VOS_SHA256_CTX *pstCtx)\n    {\n        uint32_t uiBlcLen = 0;\n        uint32_t uiLenTmp = uiLen;\n        const uint8_t *pucSrc = pucData;\n\n        if ((pucSrc == NULL) || (uiLenTmp == 0) || (pstCtx == NULL) || (pstCtx->corrupted == 1) ||\n            (pstCtx->computed == 1) || (vosSha256CtxPrepare(pstCtx, uiLenTmp) != SHA256_OK))\n        {\n            return;\n        }\n\n        if (pstCtx->blocklen != 0)\n        {\n            if (vosSha256LastPadding(pucSrc, uiLenTmp, pstCtx, &uiBlcLen) == SHA256_OK)\n            {\n                pucSrc += uiBlcLen;\n                uiLenTmp -= uiBlcLen;\n            }\n            else\n            {\n                return;\n            }\n        }\n\n        vosSha256HashByBlcMulti(pucSrc, uiLenTmp, pstCtx);\n        return;\n    }": "4", "void vosSha256End(uint8_t *pucOut, uint32_t uiOutSize, VOS_SHA256_CTX *pstCtx)\n    {\n        uint32_t uiIndex;\n        uint8_t *pucBlock = NULL;\n        uint32_t uiBlcLen;\n\n        if (pstCtx == NULL)\n        {\n            return;\n        }\n\n        pucBlock = (uint8_t *)pstCtx->block;\n        uiBlcLen = pstCtx->blocklen;\n\n        if ((pstCtx->corrupted == 1) || (uiOutSize < pstCtx->outlen))\n        {\n            (void)memset_s(pstCtx, sizeof(VOS_SHA256_CTX), 0, sizeof(VOS_SHA256_CTX));\n            return;\n        }\n\n        if (pstCtx->computed == 0)\n        {\n            pucBlock[uiBlcLen++] = 0x80;\n            if (uiBlcLen > (SHA256_BLOCK_SIZE - 8))\n            {\n                (void)memset_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, 0, SHA256_BLOCK_SIZE - uiBlcLen);\n                uiBlcLen = 0;\n                vosSha256CompressMul(pstCtx, pucBlock, 1);\n            }\n\n            (void)memset_s(pucBlock + uiBlcLen, SHA256_BLOCK_SIZE - uiBlcLen, 0, SHA256_BLOCK_SIZE - 8 - uiBlcLen);\n\n            pucBlock += SHA256_BLOCK_SIZE - 8;\n            PUT_UINT32_BE(pstCtx->N[1], pucBlock, 0);\n            pucBlock += sizeof(uint32_t);\n            PUT_UINT32_BE(pstCtx->N[0], pucBlock, 0);\n            pucBlock += sizeof(uint32_t);\n            pucBlock -= SHA256_BLOCK_SIZE;\n            vosSha256CompressMul(pstCtx, pucBlock, 1);\n            pstCtx->blocklen = 0;\n            (void)memset_s(pucBlock, SHA256_BLOCK_SIZE, 0, SHA256_BLOCK_SIZE);\n            pstCtx->computed = 1;\n        }\n\n        uiBlcLen = ((pstCtx->outlen <= uiOutSize) ? pstCtx->outlen : uiOutSize) / sizeof(uint32_t);\n        if (pucOut != NULL)\n        {\n            for (uiIndex = 0; uiIndex < uiBlcLen; uiIndex++)\n            {\n                PUT_UINT32_BE(pstCtx->h[uiIndex], pucOut, sizeof(uint32_t) * uiIndex);\n            }\n        }\n\n        return;\n    }": "5", "static void vosSha256CompressBlock(uint32_t state[VOS_SHA256_CTX_HASH_LEN], const uint8_t block[SHA256_BLOCK_SIZE])\n    {\n        uint32_t W[64];\n        uint32_t i, j;\n        uint32_t a, b, c, d, e, f, g, h;\n\n        for (i = 0; i < 16; i++)\n        {\n            W[i] = GET_UINT32_BE(block, 4 * (i));\n        }\n\n        for (i = 16; i < 64; i++)\n        {\n            W[i] = W[i - 16] + W[i - 7] + (VOS_ROTR32(W[i - 15], 7) ^ VOS_ROTR32(W[i - 15], 18) ^ (W[i - 15] >> 3)) +\n                   (VOS_ROTR32(W[i - 2], 17) ^ VOS_ROTR32(W[i - 2], 19) ^ (W[i - 2] >> 10));\n        }\n\n        j = 0;\n        a = state[j++];\n        b = state[j++];\n        c = state[j++];\n        d = state[j++];\n        e = state[j++];\n        f = state[j++];\n        g = state[j++];\n        h = state[j];\n\n        for (i = 0; i < 64; i += 8)\n        {\n            j = 0;\n            VOS_ROUND(a, b, c, d, e, f, g, h, i + (j++), K256[i + 0], W);\n            VOS_ROUND(h, a, b, c, d, e, f, g, i + (j++), K256[i + 1], W);\n            VOS_ROUND(g, h, a, b, c, d, e, f, i + (j++), K256[i + 2], W);\n            VOS_ROUND(f, g, h, a, b, c, d, e, i + (j++), K256[i + 3], W);\n            VOS_ROUND(e, f, g, h, a, b, c, d, i + (j++), K256[i + 4], W);\n            VOS_ROUND(d, e, f, g, h, a, b, c, i + (j++), K256[i + 5], W);\n            VOS_ROUND(c, d, e, f, g, h, a, b, i + (j++), K256[i + 6], W);\n            VOS_ROUND(b, c, d, e, f, g, h, a, i + j, K256[i + 7], W);\n        }\n\n        j = 0;\n        state[j++] += a;\n        state[j++] += b;\n        state[j++] += c;\n        state[j++] += d;\n        state[j++] += e;\n        state[j++] += f;\n        state[j++] += g;\n        state[j] += h;\n    }": "6", "static void vosSha256CompressMul(VOS_SHA256_CTX *pstCtx, const uint8_t *pucInput, uint32_t uiNum)\n    {\n        uint32_t uiNumTmp = uiNum;\n        const uint8_t *pucBlock = pucInput;\n\n        while ((uiNumTmp--) != 0)\n        {\n            vosSha256CompressBlock(pstCtx->h, pucBlock);\n            pucBlock += SHA256_BLOCK_SIZE;\n        }\n    }": "7", "void VOS_Sha256Calc(const uint8_t *pucInput, uint32_t uiInputLen, uint8_t *pucOutput, uint32_t uiOutputLen)\n    {\n        VOS_SHA256_CTX stCtx;\n\n        vosSha256Begin(&stCtx);\n        vosSha256Hash(pucInput, uiInputLen, &stCtx);\n        vosSha256End(pucOutput, uiOutputLen, &stCtx);\n    }": "8"}