{
    "macro": {
        "all_cnt": 85,
        "passed_cnt": 85,
        "pass_rate": 1.0,
        "messages": []
    },
    "macro_function": {
        "all_cnt": 7,
        "passed_cnt": 7,
        "pass_rate": 1.0,
        "messages": []
    },
    "definition": {
        "all_cnt": 15,
        "passed_cnt": 7,
        "pass_rate": 0.4666666666666667,
        "messages": [
            {
                "c_code": "typedef struct\n    {\n        int32_t heap[BZP_MAX_ALPHA_SIZE + 1];\n        int32_t weight[BZP_MAX_ALPHA_SIZE * 2];\n        int32_t parent[BZP_MAX_ALPHA_SIZE * 2];\n        int32_t len[BZP_MAX_ALPHA_SIZE];\n        int32_t table[BZP_MAX_ALPHA_SIZE];\n        int32_t nHeap;\n        int32_t nWeight;\n        int32_t alphaSize;\n    } BzpHuffmanInfo;",
                "rust_code": "#[repr(C)]\n#[derive(Default, Clone, Copy)]\npub struct BzpHuffmanInfo {\n    pub heap: Array<i32, { BZP_MAX_ALPHA_SIZE!() + 1 }>,\n    pub weight: Array<i32, { BZP_MAX_ALPHA_SIZE!() * 2 }>,\n    pub parent: Array<i32, { BZP_MAX_ALPHA_SIZE!() * 2 }>,\n    pub len: Array<i32, { BZP_MAX_ALPHA_SIZE!() }>,\n    pub table: Array<i32, { BZP_MAX_ALPHA_SIZE!() }>,\n    pub nHeap: i32,\n    pub nWeight: i32,\n    pub alphaSize: i32,\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750006979077)\nerror[E0204]: the trait `std::marker::Copy` cannot be implemented for this type\n  --> src/src/compress/bzp_huffman_encode_h.rs:24:26\n   |\n24 | #[derive(Default, Clone, Copy)]\n   |                          ^^^^\n25 | pub struct BzpHuffmanInfo {\n26 |     pub heap: Array<i32, { BZP_MAX_ALPHA_SIZE!() + 1 }>,\n   |     --------------------------------------------------- this field does not implement `std::marker::Copy`\n27 |     pub weight: Array<i32, { BZP_MAX_ALPHA_SIZE!() * 2 }>,\n   |     ----------------------------------------------------- this field does not implement `std::marker::Copy`\n28 |     pub parent: Array<i32, { BZP_MAX_ALPHA_SIZE!() * 2 }>,\n29 |     pub len: Array<i32, { BZP_MAX_ALPHA_SIZE!() }>,\n   |     ---------------------------------------------- this field does not implement `std::marker::Copy`\n\nerror[E0277]: the trait bound `types::array::Array<i32, 259>: Clone` is not satisfied\n  --> src/src/compress/bzp_huffman_encode_h.rs:26:5\n   |\n24 | #[derive(Default, Clone, Copy)]\n   |                   ----- in this derive macro expansion\n25 | pub struct BzpHuffmanInfo {\n26 |     pub heap: Array<i32, { BZP_MAX_ALPHA_SIZE!() + 1 }>,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `types::array::Array<i32, 259>`\n   |\nnote: required by a bound in `AssertParamIsClone`\n  --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/clone.rs:251:1\nhelp: consider annotating `types::array::Array<i32, 259>` with `#[derive(Clone)]`\n  --> src/translation_utils/types/array.rs:5:1\n   |\n5  + #[derive(Clone)]\n6  | pub struct Array<T, const N: usize>(pub [T; N]);\n   |\n\nerror[E0277]: the trait bound `types::array::Array<i32, 516>: Clone` is not satisfied\n  --> src/src/compress/bzp_huffman_encode_h.rs:27:5\n   |\n24 | #[derive(Default, Clone, Copy)]\n   |                   ----- in this derive macro expansion\n...\n27 |     pub weight: Array<i32, { BZP_MAX_ALPHA_SIZE!() * 2 }>,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `types::array::Array<i32, 516>`\n   |\nnote: required by a bound in `AssertParamIsClone`\n  --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/clone.rs:251:1\nhelp: consider annotating `types::array::Array<i32, 516>` with `#[derive(Clone)]`\n  --> src/translation_utils/types/array.rs:5:1\n   |\n5  + #[derive(Clone)]\n6  | pub struct Array<T, const N: usize>(pub [T; N]);\n   |\n\nerror[E0277]: the trait bound `types::array::Array<i32, 258>: Clone` is not satisfied\n  --> src/src/compress/bzp_huffman_encode_h.rs:29:5\n   |\n24 | #[derive(Default, Clone, Copy)]\n   |                   ----- in this derive macro expansion\n...\n29 |     pub len: Array<i32, { BZP_MAX_ALPHA_SIZE!() }>,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `types::array::Array<i32, 258>`\n   |\nnote: required by a bound in `AssertParamIsClone`\n  --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/clone.rs:251:1\nhelp: consider annotating `types::array::Array<i32, 258>` with `#[derive(Clone)]`\n  --> src/translation_utils/types/array.rs:5:1\n   |\n5  + #[derive(Clone)]\n6  | pub struct Array<T, const N: usize>(pub [T; N]);\n   |\n\nSome errors have detailed explanations: E0204, E0277.\nFor more information about an error, try `rustc --explain E0204`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
            },
            {
                "c_code": "typedef struct\n    {\n        int32_t *block;\n        int32_t *mtfFreq;\n        int32_t *select;\n        int32_t *selectMTF;\n        BzpHuffmanInfo huffmanGroups[BZP_MAX_GROUPS_NUM];\n        int32_t cost[BZP_MAX_GROUPS_NUM];\n        int32_t nGroups;\n        int32_t nBlock;\n        int32_t nSelect;\n        int32_t alphaSize;\n    } BzpHuffmanGroups;",
                "rust_code": "#[repr(C)]\n#[derive(Default, Clone, Copy)]\npub struct BzpHuffmanGroups {\n    pub block: Ptr<i32>,\n    pub mtfFreq: Ptr<i32>,\n    pub select: Ptr<i32>,\n    pub selectMTF: Ptr<i32>,\n    pub huffmanGroups: Array<BzpHuffmanInfo, { BZP_MAX_GROUPS_NUM!() }>,\n    pub cost: Array<i32, { BZP_MAX_GROUPS_NUM!() }>,\n    pub nGroups: i32,\n    pub nBlock: i32,\n    pub nSelect: i32,\n    pub alphaSize: i32,\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750006979280)\nerror[E0204]: the trait `std::marker::Copy` cannot be implemented for this type\n  --> src/src/compress/bzp_huffman_encode_h.rs:26:26\n   |\n26 | #[derive(Default, Clone, Copy)]\n   |                          ^^^^\n...\n32 |     pub huffmanGroups: Array<BzpHuffmanInfo, { BZP_MAX_GROUPS_NUM!() }>,\n   |     ------------------------------------------------------------------- this field does not implement `std::marker::Copy`\n\nerror[E0277]: the trait bound `types::array::Array<i32, 6>: Clone` is not satisfied\n  --> src/src/compress/bzp_huffman_encode_h.rs:32:5\n   |\n26 | #[derive(Default, Clone, Copy)]\n   |                   ----- in this derive macro expansion\n...\n32 |     pub huffmanGroups: Array<BzpHuffmanInfo, { BZP_MAX_GROUPS_NUM!() }>,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `types::array::Array<i32, 6>`\n   |\nnote: required by a bound in `AssertParamIsClone`\n  --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/clone.rs:251:1\nhelp: consider annotating `types::array::Array<i32, 6>` with `#[derive(Clone)]`\n  --> src/translation_utils/types/array.rs:5:1\n   |\n5  + #[derive(Clone)]\n6  | pub struct Array<T, const N: usize>(pub [T; N]);\n   |\n\nSome errors have detailed explanations: E0204, E0277.\nFor more information about an error, try `rustc --explain E0204`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "typedef struct\n    {\n        uint8_t *block;\n        int32_t *map;\n        int32_t *mtfV;\n        bool *inUse;\n        int32_t mtfFreq[BZP_MAX_ALPHA_SIZE];\n        int32_t nBlock;\n        int32_t nMtf;\n        int32_t nUse;\n        int32_t pad;\n    } BzpMtfInfo;",
                "rust_code": "#[repr(C)]\n#[derive(Default, Clone, Copy)]\npub struct BzpMtfInfo {\n    pub block: Ptr<u8>,\n    pub map: Ptr<i32>,\n    pub mtfV: Ptr<i32>,\n    pub inUse: Ptr<bool>,\n    pub mtfFreq: Array<i32, { BZP_MAX_ALPHA_SIZE!() }>,\n    pub nBlock: i32,\n    pub nMtf: i32,\n    pub nUse: i32,\n    pub pad: i32,\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750006979481)\nerror[E0204]: the trait `std::marker::Copy` cannot be implemented for this type\n  --> src/src/compress/bzp_mtf_encode_h.rs:11:26\n   |\n11 | #[derive(Default, Clone, Copy)]\n   |                          ^^^^\n...\n17 |     pub mtfFreq: Array<i32, { BZP_MAX_ALPHA_SIZE!() }>,\n   |     -------------------------------------------------- this field does not implement `std::marker::Copy`\n\nerror[E0277]: the trait bound `types::array::Array<i32, 258>: Clone` is not satisfied\n  --> src/src/compress/bzp_mtf_encode_h.rs:17:5\n   |\n11 | #[derive(Default, Clone, Copy)]\n   |                   ----- in this derive macro expansion\n...\n17 |     pub mtfFreq: Array<i32, { BZP_MAX_ALPHA_SIZE!() }>,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `types::array::Array<i32, 258>`\n   |\nnote: required by a bound in `AssertParamIsClone`\n  --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/clone.rs:251:1\nhelp: consider annotating `types::array::Array<i32, 258>` with `#[derive(Clone)]`\n  --> src/translation_utils/types/array.rs:5:1\n   |\n5  + #[derive(Clone)]\n6  | pub struct Array<T, const N: usize>(pub [T; N]);\n   |\n\nSome errors have detailed explanations: E0204, E0277.\nFor more information about an error, try `rustc --explain E0204`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "typedef struct\n    {\n        int32_t *sortBlock;\n        int32_t *idx;\n        int32_t *isStartPos;\n        uint8_t *block;\n        uint32_t blockCRC;\n        uint32_t combinedCRC;\n        int32_t nBlockMax;\n        int32_t blockId;\n        int32_t nBlock;\n        int32_t oriPtr;\n        bool inUse[BZP_ASCII_SIZE];\n    } BzpBwtInfo;",
                "rust_code": "#[repr(C)]\n#[derive(Default, Clone, Copy)]\npub struct BzpBwtInfo {\n    pub sortBlock: Ptr<i32>,\n    pub idx: Ptr<i32>,\n    pub isStartPos: Ptr<i32>,\n    pub block: Ptr<u8>,\n    pub blockCRC: u32,\n    pub combinedCRC: u32,\n    pub nBlockMax: i32,\n    pub blockId: i32,\n    pub nBlock: i32,\n    pub oriPtr: i32,\n    pub inUse: Array<bool, { BZP_ASCII_SIZE!() }>,\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750006979677)\nerror[E0204]: the trait `std::marker::Copy` cannot be implemented for this type\n  --> src/src/compress/bzp_bwt_encode_h.rs:16:26\n   |\n16 | #[derive(Default, Clone, Copy)]\n   |                          ^^^^\n...\n28 |     pub inUse: Array<bool, { BZP_ASCII_SIZE!() }>,\n   |     --------------------------------------------- this field does not implement `std::marker::Copy`\n\nerror[E0277]: the trait bound `types::array::Array<bool, 256>: Clone` is not satisfied\n  --> src/src/compress/bzp_bwt_encode_h.rs:28:5\n   |\n16 | #[derive(Default, Clone, Copy)]\n   |                   ----- in this derive macro expansion\n...\n28 |     pub inUse: Array<bool, { BZP_ASCII_SIZE!() }>,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `types::array::Array<bool, 256>`\n   |\nnote: required by a bound in `AssertParamIsClone`\n  --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/clone.rs:251:1\nhelp: consider annotating `types::array::Array<bool, 256>` with `#[derive(Clone)]`\n  --> src/translation_utils/types/array.rs:5:1\n   |\n5  + #[derive(Clone)]\n6  | pub struct Array<T, const N: usize>(pub [T; N]);\n   |\n\nSome errors have detailed explanations: E0204, E0277.\nFor more information about an error, try `rustc --explain E0204`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "typedef struct\n    {\n        int32_t stackL[BZP_MAX_STACK_SIZE];\n        int32_t stackR[BZP_MAX_STACK_SIZE];\n        int32_t cnt;\n        int32_t tl, tr;\n    } BzpQSortInfo;",
                "rust_code": "#[repr(C)]\n#[derive(Default, Clone, Copy)]\npub struct BzpQSortInfo {\n    pub stackL: Array<i32, { BZP_MAX_STACK_SIZE!() }>,\n    pub stackR: Array<i32, { BZP_MAX_STACK_SIZE!() }>,\n    pub cnt: i32,\n    pub tl: i32,\n    pub tr: i32,\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750006979885)\nerror[E0204]: the trait `std::marker::Copy` cannot be implemented for this type\n  --> src/src/compress/bzp_bwt_encode_h.rs:18:26\n   |\n18 | #[derive(Default, Clone, Copy)]\n   |                          ^^^^\n19 | pub struct BzpQSortInfo {\n20 |     pub stackL: Array<i32, { BZP_MAX_STACK_SIZE!() }>,\n   |     ------------------------------------------------- this field does not implement `std::marker::Copy`\n\nerror[E0277]: the trait bound `types::array::Array<i32, 100>: Clone` is not satisfied\n  --> src/src/compress/bzp_bwt_encode_h.rs:20:5\n   |\n18 | #[derive(Default, Clone, Copy)]\n   |                   ----- in this derive macro expansion\n19 | pub struct BzpQSortInfo {\n20 |     pub stackL: Array<i32, { BZP_MAX_STACK_SIZE!() }>,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `types::array::Array<i32, 100>`\n   |\nnote: required by a bound in `AssertParamIsClone`\n  --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/clone.rs:251:1\nhelp: consider annotating `types::array::Array<i32, 100>` with `#[derive(Clone)]`\n  --> src/translation_utils/types/array.rs:5:1\n   |\n5  + #[derive(Clone)]\n6  | pub struct Array<T, const N: usize>(pub [T; N]);\n   |\n\nSome errors have detailed explanations: E0204, E0277.\nFor more information about an error, try `rustc --explain E0204`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "typedef struct\n    {\n        int32_t *select;\n        int32_t len[BZP_MAX_GROUPS_NUM][BZP_MAX_ALPHA_SIZE];\n        int32_t perm[BZP_MAX_GROUPS_NUM][BZP_MAX_ALPHA_SIZE];\n        int32_t limit[BZP_MAX_GROUPS_NUM][BZP_MAX_ALPHA_SIZE];\n        int32_t base[BZP_MAX_GROUPS_NUM][BZP_MAX_ALPHA_SIZE];\n        int32_t minLens[BZP_MAX_GROUPS_NUM];\n        int32_t nGroups;\n        int32_t nSelect;\n        int32_t alphaSize;\n        int32_t deCodeNum;\n        int32_t selectCnt;\n        int32_t nBlock;\n    } BzpHuffmanDecode;",
                "rust_code": "#[repr(C)]\n#[derive(Default, Clone, Copy)]\npub struct BzpHuffmanDecode {\n    pub select: Ptr<i32>,\n    pub len: Array<Array<i32, { BZP_MAX_ALPHA_SIZE!() }>, { BZP_MAX_GROUPS_NUM!() }>,\n    pub perm: Array<Array<i32, { BZP_MAX_ALPHA_SIZE!() }>, { BZP_MAX_GROUPS_NUM!() }>,\n    pub limit: Array<Array<i32, { BZP_MAX_ALPHA_SIZE!() }>, { BZP_MAX_GROUPS_NUM!() }>,\n    pub base: Array<Array<i32, { BZP_MAX_ALPHA_SIZE!() }>, { BZP_MAX_GROUPS_NUM!() }>,\n    pub minLens: Array<i32, { BZP_MAX_GROUPS_NUM!() }>,\n    pub nGroups: i32,\n    pub nSelect: i32,\n    pub alphaSize: i32,\n    pub deCodeNum: i32,\n    pub selectCnt: i32,\n    pub nBlock: i32,\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750006980286)\nerror[E0204]: the trait `std::marker::Copy` cannot be implemented for this type\n  --> src/src/decompress/bzp_huffman_decode_h.rs:10:26\n   |\n10 | #[derive(Default, Clone, Copy)]\n   |                          ^^^^\n...\n13 |     pub len: Array<Array<i32, { BZP_MAX_ALPHA_SIZE!() }>, { BZP_MAX_GROUPS_NUM!() }>,\n   |     -------------------------------------------------------------------------------- this field does not implement `std::marker::Copy`\n...\n17 |     pub minLens: Array<i32, { BZP_MAX_GROUPS_NUM!() }>,\n   |     -------------------------------------------------- this field does not implement `std::marker::Copy`\n\nerror[E0277]: the trait bound `types::array::Array<types::array::Array<i32, 258>, 6>: Clone` is not satisfied\n  --> src/src/decompress/bzp_huffman_decode_h.rs:13:5\n   |\n10 | #[derive(Default, Clone, Copy)]\n   |                   ----- in this derive macro expansion\n...\n13 |     pub len: Array<Array<i32, { BZP_MAX_ALPHA_SIZE!() }>, { BZP_MAX_GROUPS_NUM!() }>,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `types::array::Array<types::array::Array<i32, 258>, 6>`\n   |\nnote: required by a bound in `AssertParamIsClone`\n  --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/clone.rs:251:1\n\nerror[E0277]: the trait bound `types::array::Array<i32, 6>: Clone` is not satisfied\n  --> src/src/decompress/bzp_huffman_decode_h.rs:17:5\n   |\n10 | #[derive(Default, Clone, Copy)]\n   |                   ----- in this derive macro expansion\n...\n17 |     pub minLens: Array<i32, { BZP_MAX_GROUPS_NUM!() }>,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `types::array::Array<i32, 6>`\n   |\nnote: required by a bound in `AssertParamIsClone`\n  --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/clone.rs:251:1\nhelp: consider annotating `types::array::Array<i32, 6>` with `#[derive(Clone)]`\n  --> src/translation_utils/types/array.rs:5:1\n   |\n5  + #[derive(Clone)]\n6  | pub struct Array<T, const N: usize>(pub [T; N]);\n   |\n\nSome errors have detailed explanations: E0204, E0277.\nFor more information about an error, try `rustc --explain E0204`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "typedef struct\n    {\n        BzpStream *input;\n        BzpStream *output;\n        int32_t lasChar;\n        int32_t num;\n        uint32_t buf;\n        int32_t nBuf;\n        int32_t blockSize;\n        uint32_t blockCRC;\n        int32_t list[BZP_ASCII_SIZE];\n    } InDeComdata;",
                "rust_code": "#[repr(C)]\n#[derive(Default, Clone, Copy)]\npub struct InDeComdata {\n    pub input: Ptr<BzpStream>,\n    pub output: Ptr<BzpStream>,\n    pub lasChar: i32,\n    pub num: i32,\n    pub buf: u32,\n    pub nBuf: i32,\n    pub blockSize: i32,\n    pub blockCRC: u32,\n    pub list: Array<i32, { BZP_ASCII_SIZE!() }>,\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750006981288)\nerror[E0204]: the trait `std::marker::Copy` cannot be implemented for this type\n  --> src/src/public/bzp_decompress_stream_h.rs:26:26\n   |\n26 | #[derive(Default, Clone, Copy)]\n   |                          ^^^^\n...\n36 |     pub list: Array<i32, { BZP_ASCII_SIZE!() }>,\n   |     ------------------------------------------- this field does not implement `std::marker::Copy`\n\nerror[E0277]: the trait bound `types::array::Array<i32, 256>: Clone` is not satisfied\n  --> src/src/public/bzp_decompress_stream_h.rs:36:5\n   |\n26 | #[derive(Default, Clone, Copy)]\n   |                   ----- in this derive macro expansion\n...\n36 |     pub list: Array<i32, { BZP_ASCII_SIZE!() }>,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `types::array::Array<i32, 256>`\n   |\nnote: required by a bound in `AssertParamIsClone`\n  --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/clone.rs:251:1\nhelp: consider annotating `types::array::Array<i32, 256>` with `#[derive(Clone)]`\n  --> src/translation_utils/types/array.rs:5:1\n   |\n5  + #[derive(Clone)]\n6  | pub struct Array<T, const N: usize>(pub [T; N]);\n   |\n\nSome errors have detailed explanations: E0204, E0277.\nFor more information about an error, try `rustc --explain E0204`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "typedef struct\n    {\n        FILE *filePtr;\n        int32_t nBuf;\n        int32_t pos;\n        uint8_t buf[BZP_BUF_SIZE];\n    } BzpStream;",
                "rust_code": "#[repr(C)]\n#[derive(Default, Clone, Copy)]\npub struct BzpStream {\n    pub filePtr: FilePtr,\n    pub nBuf: i32,\n    pub pos: i32,\n    pub buf: Array<u8, { BZP_BUF_SIZE!() }>,\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750006981483)\nerror[E0204]: the trait `std::marker::Copy` cannot be implemented for this type\n  --> src/src/public/bzp_stream_utils_h.rs:7:26\n   |\n7  | #[derive(Default, Clone, Copy)]\n   |                          ^^^^\n...\n12 |     pub buf: Array<u8, { BZP_BUF_SIZE!() }>,\n   |     --------------------------------------- this field does not implement `std::marker::Copy`\n\nerror[E0277]: the trait bound `types::array::Array<u8, 5000>: Clone` is not satisfied\n  --> src/src/public/bzp_stream_utils_h.rs:12:5\n   |\n7  | #[derive(Default, Clone, Copy)]\n   |                   ----- in this derive macro expansion\n...\n12 |     pub buf: Array<u8, { BZP_BUF_SIZE!() }>,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `types::array::Array<u8, 5000>`\n   |\nnote: required by a bound in `AssertParamIsClone`\n  --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/clone.rs:251:1\nhelp: consider annotating `types::array::Array<u8, 5000>` with `#[derive(Clone)]`\n  --> src/translation_utils/types/array.rs:5:1\n   |\n5  + #[derive(Clone)]\n6  | pub struct Array<T, const N: usize>(pub [T; N]);\n   |\n\nSome errors have detailed explanations: E0204, E0277.\nFor more information about an error, try `rustc --explain E0204`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            }
        ]
    },
    "dummy_function": {
        "all_cnt": 92,
        "passed_cnt": 92,
        "pass_rate": 1.0,
        "messages": []
    },
    "function": {
        "all_cnt": 92,
        "passed_cnt": 26,
        "pass_rate": 0.2826086956521739,
        "messages": [
            {
                "c_code": "void BzpHuffmanInit(int32_t alphaSize, BzpHuffmanInfo *huffman)\n    {\n        (void)memset_s(huffman->len, sizeof(huffman->len), 0, sizeof(huffman->len));\n        huffman->nHeap = 0;\n        huffman->nWeight = 0;\n        huffman->alphaSize = alphaSize;\n    }",
                "rust_code": "pub fn BzpHuffmanInit(mut alphaSize: i32, mut huffman: Ptr<BzpHuffmanInfo>) {\n    c_memset_s!(huffman.len, c_sizeofval!(huffman.len), 0, c_sizeofval!(huffman.len)).cast::<Void>();\n    huffman.nHeap = 0;\n    huffman.nWeight = 0;\n    huffman.alphaSize = alphaSize;\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007000693)\nerror[E0609]: no field `len` on type `memory::ptr::Ptr<i32>`\n --> src/src/compress/bzp_huffman_encode_c.rs:5:25\n  |\n5 |     c_memset_s!(huffman.len, c_sizeofval!(huffman.len), 0, c_sizeofval!(huffman.len)).cast::<Void>();\n  |                         ^^^ unknown field\n  |\n  = note: available field is: `0`\n\nerror[E0609]: no field `len` on type `memory::ptr::Ptr<i32>`\n --> src/src/compress/bzp_huffman_encode_c.rs:5:51\n  |\n5 |     c_memset_s!(huffman.len, c_sizeofval!(huffman.len), 0, c_sizeofval!(huffman.len)).cast::<Void>();\n  |                                                   ^^^ unknown field\n  |\n  = note: available field is: `0`\n\nerror[E0609]: no field `len` on type `memory::ptr::Ptr<i32>`\n --> src/src/compress/bzp_huffman_encode_c.rs:5:81\n  |\n5 |     c_memset_s!(huffman.len, c_sizeofval!(huffman.len), 0, c_sizeofval!(huffman.len)).cast::<Void>();\n  |                                                                                 ^^^ unknown field\n  |\n  = note: available field is: `0`\n\nerror[E0609]: no field `nHeap` on type `memory::ptr::Ptr<i32>`\n --> src/src/compress/bzp_huffman_encode_c.rs:6:13\n  |\n6 |     huffman.nHeap = 0;\n  |             ^^^^^ unknown field\n  |\n  = note: available field is: `0`\n\nerror[E0609]: no field `nWeight` on type `memory::ptr::Ptr<i32>`\n --> src/src/compress/bzp_huffman_encode_c.rs:7:13\n  |\n7 |     huffman.nWeight = 0;\n  |             ^^^^^^^ unknown field\n  |\n  = note: available field is: `0`\n\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n --> src/src/compress/bzp_huffman_encode_c.rs:8:13\n  |\n8 |     huffman.alphaSize = alphaSize;\n  |             ^^^^^^^^^ unknown field\n  |\n  = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\n"
            },
            {
                "c_code": "void BzpHuffmanInitArray(BzpHuffmanInfo *huffman)\n    {\n        int32_t i;\n        huffman->nHeap = 0;\n        huffman->nWeight = huffman->alphaSize;\n\n        for (i = 0; i < huffman->alphaSize; i++)\n        {\n            huffman->parent[i] = -1;\n        }\n    }",
                "rust_code": "pub fn BzpHuffmanInitArray(mut huffman: Ptr<BzpHuffmanInfo>) {\n    let mut i: i32;\n    huffman.nHeap = 0;\n    huffman.nWeight = huffman.alphaSize.cast();\n    c_for!(i = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        huffman.parent[i] = -1;\n    });\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007000900)\nerror[E0609]: no field `nHeap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:11:13\n   |\n11 |     huffman.nHeap = 0;\n   |             ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nWeight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:12:13\n   |\n12 |     huffman.nWeight = huffman.alphaSize.cast();\n   |             ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:12:31\n   |\n12 |     huffman.nWeight = huffman.alphaSize.cast();\n   |                               ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:13:31\n   |\n13 |     c_for!(i = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n   |                               ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:14:17\n   |\n14 |         huffman.parent[i] = -1;\n   |                 ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
            },
            {
                "c_code": "void BzpHeapInit(BzpHuffmanInfo *huffman)\n    {\n        int32_t i = 0;\n        for (i = 0; i < huffman->alphaSize; i++)\n        {\n            huffman->nHeap++;\n            huffman->heap[huffman->nHeap] = i;\n            BzpHeapAdjustUp(huffman->heap, huffman->weight, huffman->nHeap);\n        }\n    }",
                "rust_code": "pub fn BzpHeapInit(mut huffman: Ptr<BzpHuffmanInfo>) {\n    let mut i: i32 = 0;\n    c_for!(i = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        huffman.nHeap += 1;\n        huffman.heap[huffman.nHeap] = i.cast();\n        BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n    });\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007001547)\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:51:31\n   |\n51 |     c_for!(i = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n   |                               ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nHeap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:52:17\n   |\n52 |         huffman.nHeap += 1;\n   |                 ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `heap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:53:17\n   |\n53 |         huffman.heap[huffman.nHeap] = i.cast();\n   |                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nHeap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:53:30\n   |\n53 |         huffman.heap[huffman.nHeap] = i.cast();\n   |                              ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `heap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:54:33\n   |\n54 |         BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n   |                                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `weight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:54:54\n   |\n54 |         BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n   |                                                      ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nHeap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:54:77\n   |\n54 |         BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n   |                                                                             ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 7 previous errors\n"
            },
            {
                "c_code": "void BzpBuildHuffmanTree(BzpHuffmanInfo *huffman)\n    {\n        BzpHuffmanInitArray(huffman);\n        BzpHeapInit(huffman);\n        int32_t idx1, idx2;\n        while (huffman->nHeap > 1)\n        {\n            idx1 = huffman->heap[1];\n            huffman->heap[1] = huffman->heap[huffman->nHeap--];\n            BzpHeapAdjustDown(huffman->heap, huffman->weight, huffman->nHeap);\n            idx2 = huffman->heap[1];\n            huffman->heap[1] = huffman->heap[huffman->nHeap--];\n            BzpHeapAdjustDown(huffman->heap, huffman->weight, huffman->nHeap);\n            huffman->weight[huffman->nWeight] = BzpHuffmanWeightAdd(huffman->weight[idx1], huffman->weight[idx2]);\n            huffman->parent[idx1] = huffman->nWeight;\n            huffman->parent[idx2] = huffman->nWeight;\n            huffman->parent[huffman->nWeight] = -1;\n            huffman->nHeap++;\n            huffman->heap[huffman->nHeap] = huffman->nWeight;\n            huffman->nWeight++;\n            BzpHeapAdjustUp(huffman->heap, huffman->weight, huffman->nHeap);\n        }\n    }",
                "rust_code": "pub fn BzpBuildHuffmanTree(mut huffman: Ptr<BzpHuffmanInfo>) {\n    BzpHuffmanInitArray(huffman.cast());\n    BzpHeapInit(huffman.cast());\n    let mut idx1: i32;\n    let mut idx2: i32;\n    while (huffman.nHeap > 1).as_bool() {\n        idx1 = huffman.heap[1].cast();\n        huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n        huffman.nHeap -= 1;\n        BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n        idx2 = huffman.heap[1].cast();\n        huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n        huffman.nHeap -= 1;\n        BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n        huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n        huffman.parent[idx1] = huffman.nWeight.cast();\n        huffman.parent[idx2] = huffman.nWeight.cast();\n        huffman.parent[huffman.nWeight] = -1;\n        huffman.nHeap += 1;\n        huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n        huffman.nWeight += 1;\n        BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007001962)\nerror[E0609]: no field `nHeap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:64:20\n   |\n64 |     while (huffman.nHeap > 1).as_bool() {\n   |                    ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `heap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:65:24\n   |\n65 |         idx1 = huffman.heap[1].cast();\n   |                        ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `heap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:66:17\n   |\n66 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `heap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:66:35\n   |\n66 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                                   ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nHeap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:66:48\n   |\n66 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                                                ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nHeap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:67:17\n   |\n67 |         huffman.nHeap -= 1;\n   |                 ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `heap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:68:35\n   |\n68 |         BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n   |                                   ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `weight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:68:56\n   |\n68 |         BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n   |                                                        ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nHeap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:68:79\n   |\n68 |         BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n   |                                                                               ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `heap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:69:24\n   |\n69 |         idx2 = huffman.heap[1].cast();\n   |                        ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `heap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:70:17\n   |\n70 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `heap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:70:35\n   |\n70 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                                   ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nHeap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:70:48\n   |\n70 |         huffman.heap[1] = huffman.heap[huffman.nHeap].cast();\n   |                                                ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nHeap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:71:17\n   |\n71 |         huffman.nHeap -= 1;\n   |                 ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `heap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:72:35\n   |\n72 |         BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n   |                                   ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `weight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:72:56\n   |\n72 |         BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n   |                                                        ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nHeap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:72:79\n   |\n72 |         BzpHeapAdjustDown(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n   |                                                                               ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `weight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:73:17\n   |\n73 |         huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n   |                 ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nWeight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:73:32\n   |\n73 |         huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n   |                                ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `weight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:73:71\n   |\n73 |         huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n   |                                                                       ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `weight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:73:100\n   |\n73 |         huffman.weight[huffman.nWeight] = BzpHuffmanWeightAdd(huffman.weight[idx1].cast(), huffman.weight[idx2].cast()).cast();\n   |                                                                                                    ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:74:17\n   |\n74 |         huffman.parent[idx1] = huffman.nWeight.cast();\n   |                 ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nWeight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:74:40\n   |\n74 |         huffman.parent[idx1] = huffman.nWeight.cast();\n   |                                        ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:75:17\n   |\n75 |         huffman.parent[idx2] = huffman.nWeight.cast();\n   |                 ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nWeight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:75:40\n   |\n75 |         huffman.parent[idx2] = huffman.nWeight.cast();\n   |                                        ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:76:17\n   |\n76 |         huffman.parent[huffman.nWeight] = -1;\n   |                 ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nWeight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:76:32\n   |\n76 |         huffman.parent[huffman.nWeight] = -1;\n   |                                ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nHeap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:77:17\n   |\n77 |         huffman.nHeap += 1;\n   |                 ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `heap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:78:17\n   |\n78 |         huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n   |                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nHeap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:78:30\n   |\n78 |         huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n   |                              ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nWeight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:78:47\n   |\n78 |         huffman.heap[huffman.nHeap] = huffman.nWeight.cast();\n   |                                               ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nWeight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:79:17\n   |\n79 |         huffman.nWeight += 1;\n   |                 ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `heap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:80:33\n   |\n80 |         BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n   |                                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `weight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:80:54\n   |\n80 |         BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n   |                                                      ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nHeap` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:80:77\n   |\n80 |         BzpHeapAdjustUp(huffman.heap.cast(), huffman.weight.cast(), huffman.nHeap.cast());\n   |                                                                             ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 35 previous errors\n"
            },
            {
                "c_code": "int32_t BzpGetCodeLen(BzpHuffmanInfo *huffman)\n    {\n        int32_t maxlen = 0;\n\n        BzpBuildHuffmanTree(huffman);\n        int32_t i;\n        maxlen = 0;\n        for (i = 0; i < huffman->alphaSize; i++)\n        {\n            int32_t x = i;\n            int32_t tlen = 0;\n            while (huffman->parent[x] >= 0)\n            {\n                x = huffman->parent[x];\n                tlen++;\n            }\n            huffman->len[i] = tlen;\n            maxlen = BZP_MAX_FUN(maxlen, tlen);\n        }\n\n        return maxlen;\n    }",
                "rust_code": "pub fn BzpGetCodeLen(mut huffman: Ptr<BzpHuffmanInfo>) -> i32 {\n    let mut maxlen: i32 = 0;\n    BzpBuildHuffmanTree(huffman.cast());\n    let mut i: i32;\n    maxlen = 0;\n    c_for!(i = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        let mut x: i32 = i.cast();\n        let mut tlen: i32 = 0;\n        while (huffman.parent[x] >= 0).as_bool() {\n            x = huffman.parent[x].cast();\n            tlen += 1;\n        }\n        huffman.len[i] = tlen.cast();\n        maxlen = BZP_MAX_FUN!(maxlen, tlen);\n    });\n    return maxlen.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007002156)\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:69:31\n   |\n69 |     c_for!(i = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n   |                               ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:72:24\n   |\n72 |         while (huffman.parent[x] >= 0).as_bool() {\n   |                        ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:73:25\n   |\n73 |             x = huffman.parent[x].cast();\n   |                         ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `len` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:76:17\n   |\n76 |         huffman.len[i] = tlen.cast();\n   |                 ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
            },
            {
                "c_code": "void BzpBuildTreeBalanceHeight(BzpHuffmanInfo *huffman)\n    {\n        int32_t maxlen = 0;\n        for (int32_t i = 0; i < huffman->alphaSize; i++)\n        {\n            if (huffman->weight[i] == 0)\n            {\n                huffman->weight[i] = 1 << BZP_HUFFMAN_HEIGHT_WEIGHT_BITS;\n            }\n            else\n            {\n                huffman->weight[i] <<= BZP_HUFFMAN_HEIGHT_WEIGHT_BITS;\n            }\n        }\n\n        do\n        {\n            maxlen = BzpGetCodeLen(huffman);\n\n            if (maxlen > BZP_MAX_TREE_HEIGHT_ENCODE)\n            {\n                for (int32_t i = 0; i < huffman->alphaSize; i++)\n                {\n                    int32_t w = (huffman->weight[i] >> BZP_HUFFMAN_HEIGHT_WEIGHT_BITS);\n                    w = ((w >> 1) + 1);\n                    huffman->weight[i] = w << BZP_HUFFMAN_HEIGHT_WEIGHT_BITS;\n                }\n            }\n        } while (maxlen > BZP_MAX_TREE_HEIGHT_ENCODE);\n    }",
                "rust_code": "pub fn BzpBuildTreeBalanceHeight(mut huffman: Ptr<BzpHuffmanInfo>) {\n    let mut maxlen: i32 = 0;\n    c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        if (huffman.weight[i] == 0).as_bool() {\n            huffman.weight[i] = 1 << BZP_HUFFMAN_HEIGHT_WEIGHT_BITS!();\n        } else {\n            huffman.weight[i] <<= BZP_HUFFMAN_HEIGHT_WEIGHT_BITS!();\n        }\n    });\n    c_do!({\n        maxlen = BzpGetCodeLen(huffman.cast()).cast();\n        if (maxlen > BZP_MAX_TREE_HEIGHT_ENCODE!()).as_bool() {\n            c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n                let mut w: i32 = (huffman.weight[i] >> BZP_HUFFMAN_HEIGHT_WEIGHT_BITS!()).cast();\n                w = ((w >> 1) + 1).cast();\n                huffman.weight[i] = (w << BZP_HUFFMAN_HEIGHT_WEIGHT_BITS!()).cast();\n            });\n        }\n    } while maxlen > BZP_MAX_TREE_HEIGHT_ENCODE!());\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007002361)\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:71:44\n   |\n71 |     c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n   |                                            ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `weight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:72:21\n   |\n72 |         if (huffman.weight[i] == 0).as_bool() {\n   |                     ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `weight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:73:21\n   |\n73 |             huffman.weight[i] = 1 << BZP_HUFFMAN_HEIGHT_WEIGHT_BITS!();\n   |                     ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `weight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:75:21\n   |\n75 |             huffman.weight[i] <<= BZP_HUFFMAN_HEIGHT_WEIGHT_BITS!();\n   |                     ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:81:52\n   |\n81 |             c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n   |                                                    ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `weight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:82:43\n   |\n82 |                 let mut w: i32 = (huffman.weight[i] >> BZP_HUFFMAN_HEIGHT_WEIGHT_BITS!()).cast();\n   |                                           ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `weight` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:84:25\n   |\n84 |                 huffman.weight[i] = (w << BZP_HUFFMAN_HEIGHT_WEIGHT_BITS!()).cast();\n   |                         ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 7 previous errors\n"
            },
            {
                "c_code": "void BzpGetHuffmanTable(BzpHuffmanInfo *huffman)\n    {\n        int32_t vec = 0;\n        int32_t mi = huffman->len[0], mx = huffman->len[0];\n        for (int32_t i = 0; i < huffman->alphaSize; i++)\n        {\n            mi = BZP_MIN_FUN(mi, huffman->len[i]);\n            mx = BZP_MAX_FUN(mx, huffman->len[i]);\n        }\n        for (int32_t i = mi; i <= mx; i++)\n        {\n            for (int32_t j = 0; j < huffman->alphaSize; j++)\n            {\n                if (huffman->len[j] == i)\n                {\n                    huffman->table[j] = vec;\n                    vec++;\n                }\n            }\n            vec <<= 1;\n        }\n    }",
                "rust_code": "pub fn BzpGetHuffmanTable(mut huffman: Ptr<BzpHuffmanInfo>) {\n    let mut vec: i32 = 0;\n    let mut mi: i32 = huffman.len[0].cast();\n    let mut mx: i32 = huffman.len[0].cast();\n    c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        mi = BZP_MIN_FUN!(mi, huffman.len[i]).cast();\n        mx = BZP_MAX_FUN!(mx, huffman.len[i]).cast();\n    });\n    c_for!(let mut i: i32 = mi; i <= mx; i.suffix_plus_plus(); {\n        c_for!(let mut j: i32 = 0; j < huffman.alphaSize; j.suffix_plus_plus(); {\n            if (huffman.len[j] == i).as_bool() {\n                huffman.table[j] = vec.cast();\n                vec += 1;\n            }\n        });\n        vec <<= 1;\n    });\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007002572)\nerror[E0609]: no field `len` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:76:31\n   |\n76 |     let mut mi: i32 = huffman.len[0].cast();\n   |                               ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `len` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:77:31\n   |\n77 |     let mut mx: i32 = huffman.len[0].cast();\n   |                               ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:78:44\n   |\n78 |     c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n   |                                            ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `len` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:79:39\n   |\n79 |         mi = BZP_MIN_FUN!(mi, huffman.len[i]).cast();\n   |                                       ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `len` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:80:39\n   |\n80 |         mx = BZP_MAX_FUN!(mx, huffman.len[i]).cast();\n   |                                       ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:83:48\n   |\n83 |         c_for!(let mut j: i32 = 0; j < huffman.alphaSize; j.suffix_plus_plus(); {\n   |                                                ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `len` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:84:25\n   |\n84 |             if (huffman.len[j] == i).as_bool() {\n   |                         ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `table` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:85:25\n   |\n85 |                 huffman.table[j] = vec.cast();\n   |                         ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"
            },
            {
                "c_code": "int32_t BzpHuffmanGroupsReset(BzpHuffmanGroups *huffman, int32_t alphaSize)\n    {\n        if (BZP_INVALID_ALPHA_SIZE(alphaSize))\n        {\n            return BZP_ERROR_PARAM;\n        }\n\n        huffman->alphaSize = alphaSize;\n        huffman->block = NULL;\n        huffman->mtfFreq = NULL;\n        huffman->nSelect = 0;\n        huffman->nGroups = 0;\n\n        for (int32_t i = 0; i < BZP_MAX_GROUPS_NUM; i++)\n        {\n            BzpHuffmanInit(alphaSize, &huffman->huffmanGroups[i]);\n        }\n        return BZP_OK;\n    }",
                "rust_code": "pub fn BzpHuffmanGroupsReset(mut huffman: Ptr<BzpHuffmanGroups>, mut alphaSize: i32) -> i32 {\n    if BZP_INVALID_ALPHA_SIZE!(alphaSize).as_bool() {\n        return BZP_ERROR_PARAM!();\n    }\n\n    huffman.alphaSize = alphaSize;\n    huffman.block = NULL!();\n    huffman.mtfFreq = NULL!();\n    huffman.nSelect = 0;\n    huffman.nGroups = 0;\n\n    c_for!(let mut i: i32 = 0; i < BZP_MAX_GROUPS_NUM!(); i.suffix_plus_plus(); {\n        BzpHuffmanInit(alphaSize.cast(), c_ref!(huffman.huffmanGroups[i]).cast());\n    });\n    return BZP_OK!();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007002786)\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:84:13\n   |\n84 |     huffman.alphaSize = alphaSize;\n   |             ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:85:13\n   |\n85 |     huffman.block = NULL!();\n   |             ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `mtfFreq` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:86:13\n   |\n86 |     huffman.mtfFreq = NULL!();\n   |             ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_huffman_encode_c.rs:85:21\n    |\n85  |     huffman.block = NULL!();\n    |                     ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `nSelect` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:87:13\n   |\n87 |     huffman.nSelect = 0;\n   |             ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_huffman_encode_c.rs:86:23\n    |\n86  |     huffman.mtfFreq = NULL!();\n    |                       ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `nGroups` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:88:13\n   |\n88 |     huffman.nGroups = 0;\n   |             ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `huffmanGroups` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:91:57\n   |\n91 |         BzpHuffmanInit(alphaSize.cast(), c_ref!(huffman.huffmanGroups[i]).cast());\n   |                                                         ^^^^^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"
            },
            {
                "c_code": "BzpHuffmanGroups *BzpHuffmanGroupsInit(int32_t blockSize)\n    {\n        if (BZP_INVALID_BLOCK_SIZE(blockSize))\n        {\n            return NULL;\n        }\n        BzpHuffmanGroups *huffmanGroups = (BzpHuffmanGroups *)malloc(sizeof(BzpHuffmanGroups));\n        if (huffmanGroups == NULL)\n        {\n            return NULL;\n        }\n        huffmanGroups->select = NULL;\n        huffmanGroups->selectMTF = NULL;\n        int32_t spaceSize = blockSize * BZP_BASE_BLOCK_SIZE / BZP_ELEMS_NUM_IN_ONE_GROUP;\n        huffmanGroups->select = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n        huffmanGroups->selectMTF = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n        if (huffmanGroups->select == NULL || huffmanGroups->selectMTF == NULL)\n        {\n            BzpBzpHuffmanGroupsFinish(huffmanGroups);\n            return NULL;\n        }\n        huffmanGroups->alphaSize = 0;\n        huffmanGroups->block = NULL;\n        huffmanGroups->mtfFreq = NULL;\n        huffmanGroups->nSelect = 0;\n        huffmanGroups->nGroups = 0;\n\n        for (int32_t i = 0; i < BZP_MAX_GROUPS_NUM; i++)\n        {\n            BzpHuffmanInit(0, &huffmanGroups->huffmanGroups[i]);\n        }\n\n        return huffmanGroups;\n    }",
                "rust_code": "pub fn BzpHuffmanGroupsInit(mut blockSize: i32) -> Ptr<BzpHuffmanGroups> {\n    if BZP_INVALID_BLOCK_SIZE!(blockSize).as_bool() {\n        return NULL!();\n    }\n    let mut huffmanGroups: Ptr<BzpHuffmanGroups> = c_malloc!(c_sizeof!(BzpHuffmanGroups));\n    if (huffmanGroups == NULL!()).as_bool() {\n        return NULL!();\n    }\n    huffmanGroups.select = NULL!();\n    huffmanGroups.selectMTF = NULL!();\n    let mut spaceSize: i32 = blockSize * BZP_BASE_BLOCK_SIZE!() / BZP_ELEMS_NUM_IN_ONE_GROUP!();\n    huffmanGroups.select = c_malloc!(spaceSize * c_sizeof!(i32));\n    huffmanGroups.selectMTF = c_malloc!(spaceSize * c_sizeof!(i32));\n    if (huffmanGroups.select == NULL!()).as_bool() || (huffmanGroups.selectMTF == NULL!()).as_bool() {\n        BzpBzpHuffmanGroupsFinish(huffmanGroups.cast());\n        return NULL!();\n    }\n    huffmanGroups.alphaSize = 0;\n    huffmanGroups.block = NULL!();\n    huffmanGroups.mtfFreq = NULL!();\n    huffmanGroups.nSelect = 0;\n    huffmanGroups.nGroups = 0;\n    c_for!(let mut i: i32 = 0; i < BZP_MAX_GROUPS_NUM!(); i.suffix_plus_plus(); {\n        BzpHuffmanInit(0, c_ref!(huffmanGroups.huffmanGroups[i]).cast());\n    });\n    return huffmanGroups.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007002990)\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:92:19\n   |\n92 |     huffmanGroups.select = NULL!();\n   |                   ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `selectMTF` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:93:19\n   |\n93 |     huffmanGroups.selectMTF = NULL!();\n   |                   ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_huffman_encode_c.rs:92:28\n    |\n92  |     huffmanGroups.select = NULL!();\n    |                            ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_huffman_encode_c.rs:93:31\n    |\n93  |     huffmanGroups.selectMTF = NULL!();\n    |                               ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:95:19\n   |\n95 |     huffmanGroups.select = c_malloc!(spaceSize * c_sizeof!(i32));\n   |                   ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `selectMTF` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:96:19\n   |\n96 |     huffmanGroups.selectMTF = c_malloc!(spaceSize * c_sizeof!(i32));\n   |                   ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:97:23\n   |\n97 |     if (huffmanGroups.select == NULL!()).as_bool() || (huffmanGroups.selectMTF == NULL!()).as_bool() {\n   |                       ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `selectMTF` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:97:70\n   |\n97 |     if (huffmanGroups.select == NULL!()).as_bool() || (huffmanGroups.selectMTF == NULL!()).as_bool() {\n   |                                                                      ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:101:19\n    |\n101 |     huffmanGroups.alphaSize = 0;\n    |                   ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:102:19\n    |\n102 |     huffmanGroups.block = NULL!();\n    |                   ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `mtfFreq` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:103:19\n    |\n103 |     huffmanGroups.mtfFreq = NULL!();\n    |                   ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_huffman_encode_c.rs:102:27\n    |\n102 |     huffmanGroups.block = NULL!();\n    |                           ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `nSelect` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:104:19\n    |\n104 |     huffmanGroups.nSelect = 0;\n    |                   ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_huffman_encode_c.rs:103:29\n    |\n103 |     huffmanGroups.mtfFreq = NULL!();\n    |                             ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `nGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:105:19\n    |\n105 |     huffmanGroups.nGroups = 0;\n    |                   ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `huffmanGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:107:48\n    |\n107 |         BzpHuffmanInit(0, c_ref!(huffmanGroups.huffmanGroups[i]).cast());\n    |                                                ^^^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_huffman_encode_c.rs:97:33\n    |\n97  |     if (huffmanGroups.select == NULL!()).as_bool() || (huffmanGroups.selectMTF == NULL!()).as_bool() {\n    |                                 ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 17 previous errors\n"
            },
            {
                "c_code": "void BzpBzpHuffmanGroupsFinish(BzpHuffmanGroups *huffman)\n    {\n        if (huffman != NULL)\n        {\n            if (huffman->select != NULL)\n            {\n                free(huffman->select);\n                huffman->select = NULL;\n            }\n            if (huffman->selectMTF != NULL)\n            {\n                free(huffman->selectMTF);\n                huffman->selectMTF = NULL;\n            }\n            free(huffman);\n            huffman = NULL;\n        }\n    }",
                "rust_code": "pub fn BzpBzpHuffmanGroupsFinish(mut huffman: Ptr<BzpHuffmanGroups>) {\n    if (huffman != NULL!()).as_bool() {\n        if (huffman.select != NULL!()).as_bool() {\n            c_free!(huffman.select);\n            huffman.select = NULL!();\n        }\n        if (huffman.selectMTF != NULL!()).as_bool() {\n            c_free!(huffman.selectMTF);\n            huffman.selectMTF = NULL!();\n        }\n        c_free!(huffman);\n        huffman = NULL!();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007003194)\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:91:21\n   |\n91 |         if (huffman.select != NULL!()).as_bool() {\n   |                     ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:92:29\n   |\n92 |             c_free!(huffman.select);\n   |                             ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:93:21\n   |\n93 |             huffman.select = NULL!();\n   |                     ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `selectMTF` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:95:21\n   |\n95 |         if (huffman.selectMTF != NULL!()).as_bool() {\n   |                     ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_huffman_encode_c.rs:93:30\n    |\n93  |             huffman.select = NULL!();\n    |                              ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `selectMTF` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:96:29\n   |\n96 |             c_free!(huffman.selectMTF);\n   |                             ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `selectMTF` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_huffman_encode_c.rs:97:21\n   |\n97 |             huffman.selectMTF = NULL!();\n   |                     ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_huffman_encode_c.rs:97:33\n    |\n97  |             huffman.selectMTF = NULL!();\n    |                                 ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_huffman_encode_c.rs:91:31\n    |\n91  |         if (huffman.select != NULL!()).as_bool() {\n    |                               ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 9 previous errors\n"
            },
            {
                "c_code": "void BzpGenerateSelectMTF(BzpHuffmanGroups *huffman)\n    {\n        int32_t nGroups = huffman->nGroups;\n        int32_t list[nGroups];\n        for (int32_t i = 0; i < nGroups; i++)\n        {\n            list[i] = i;\n        }\n        for (int32_t i = 0; i < huffman->nSelect; i++)\n        {\n            int32_t pos = 0;\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                if (huffman->select[i] == list[j])\n                {\n                    pos = j;\n                    break;\n                }\n            }\n            for (int32_t j = pos; j > 0; j--)\n            {\n                list[j] = list[j - 1];\n            }\n            list[0] = huffman->select[i];\n            huffman->selectMTF[i] = pos;\n        }\n    }",
                "rust_code": "pub fn BzpGenerateSelectMTF(mut huffman: Ptr<BzpHuffmanGroups>) {\n    let mut nGroups: i32 = huffman.nGroups.cast();\n    let mut list: Array<i32, { nGroups }> = arr![0; nGroups];\n    c_for!(let mut i: i32 = 0; i < nGroups; i.suffix_plus_plus(); {\n        list[i] = i.cast();\n    });\n    c_for!(let mut i: i32 = 0; i < huffman.nSelect; i.suffix_plus_plus(); {\n        let mut pos: i32 = 0;\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            if (huffman.select[i] == list[j]).as_bool() {\n                pos = j.cast();\n                break;\n            }\n        });\n        c_for!(let mut j: i32 = pos; j > 0; j.suffix_minus_minus(); {\n            list[j] = list[j - 1].cast();\n        });\n        list[0] = huffman.select[i].cast();\n        huffman.selectMTF[i] = pos.cast();\n    });\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007003609)\nerror[E0435]: attempt to use a non-constant value in a constant\n   --> src/src/compress/bzp_huffman_encode_c.rs:113:32\n    |\n113 |     let mut list: Array<i32, { nGroups }> = arr![0; nGroups];\n    |                                ^^^^^^^ non-constant value\n    |\nhelp: consider using `const` instead of `let`\n    |\n112 -     let mut nGroups: i32 = huffman.nGroups.cast();\n112 +     const nGroups: i32 = huffman.nGroups.cast();\n    |\n\nerror[E0435]: attempt to use a non-constant value in a constant\n   --> src/src/compress/bzp_huffman_encode_c.rs:113:53\n    |\n113 |     let mut list: Array<i32, { nGroups }> = arr![0; nGroups];\n    |                                                     ^^^^^^^ non-constant value\n    |\nhelp: consider using `const` instead of `let`\n    |\n112 -     let mut nGroups: i32 = huffman.nGroups.cast();\n112 +     const nGroups: i32 = huffman.nGroups.cast();\n    |\n\nerror[E0609]: no field `nGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:112:36\n    |\n112 |     let mut nGroups: i32 = huffman.nGroups.cast();\n    |                                    ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nSelect` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:117:44\n    |\n117 |     c_for!(let mut i: i32 = 0; i < huffman.nSelect; i.suffix_plus_plus(); {\n    |                                            ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:120:25\n    |\n120 |             if (huffman.select[i] == list[j]).as_bool() {\n    |                         ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:128:27\n    |\n128 |         list[0] = huffman.select[i].cast();\n    |                           ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `selectMTF` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:129:17\n    |\n129 |         huffman.selectMTF[i] = pos.cast();\n    |                 ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nSome errors have detailed explanations: E0435, E0609.\nFor more information about an error, try `rustc --explain E0435`.\nerror: could not compile `my_proj` (lib) due to 7 previous errors\n"
            },
            {
                "c_code": "void BzpInitLenArray(BzpHuffmanGroups *huffman)\n    {\n        int32_t nGroups = huffman->nGroups;\n        int32_t npart = nGroups;\n        int32_t AllFreqNum = huffman->nBlock;\n        int32_t st = 0, ed;\n\n        while (npart > 0)\n        {\n            int32_t NowFreqNum = 0;\n            int32_t FreqNumLimit = AllFreqNum / npart;\n\n            ed = st - 1;\n            while (ed < huffman->alphaSize - 1 && NowFreqNum < FreqNumLimit)\n            {\n                ed++;\n                NowFreqNum += huffman->mtfFreq[ed];\n            }\n\n            if (ed > st && npart != nGroups && npart != 1 && ((nGroups - npart) & 1))\n            {\n                NowFreqNum -= huffman->mtfFreq[ed];\n                ed--;\n            }\n\n            for (int32_t i = 0; i < huffman->alphaSize; i++)\n            {\n                if (i >= st && i <= ed)\n                {\n                    huffman->huffmanGroups[npart - 1].len[i] = 0;\n                }\n                else\n                {\n                    huffman->huffmanGroups[npart - 1].len[i] = BZP_HUFFMAN_LEN_MAX_COST;\n                }\n            }\n            npart--;\n            st = ed + 1;\n            AllFreqNum -= NowFreqNum;\n        }\n    }",
                "rust_code": "pub fn BzpInitLenArray(mut huffman: Ptr<BzpHuffmanGroups>) {\n    let mut nGroups: i32 = huffman.nGroups.cast();\n    let mut npart: i32 = nGroups.cast();\n    let mut AllFreqNum: i32 = huffman.nBlock.cast();\n    let mut st: i32 = 0;\n    let mut ed: i32 = Default::default();\n    while (npart > 0).as_bool() {\n        let mut NowFreqNum: i32 = 0;\n        let mut FreqNumLimit: i32 = AllFreqNum / npart;\n        ed = st - 1;\n        while (ed < huffman.alphaSize - 1).as_bool() && (NowFreqNum < FreqNumLimit).as_bool() {\n            ed += 1;\n            NowFreqNum += huffman.mtfFreq[ed].cast();\n        }\n        if (ed > st).as_bool() && (npart != nGroups).as_bool() && (npart != 1).as_bool() && ((nGroups - npart) & 1).as_bool() {\n            NowFreqNum -= huffman.mtfFreq[ed].cast();\n            ed -= 1;\n        }\n        c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n            if (i >= st).as_bool() && (i <= ed).as_bool() {\n                huffman.huffmanGroups[npart - 1].len[i] = 0;\n            } else {\n                huffman.huffmanGroups[npart - 1].len[i] = BZP_HUFFMAN_LEN_MAX_COST!();\n            }\n        });\n        npart -= 1;\n        st = ed + 1;\n        AllFreqNum -= NowFreqNum;\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007003814)\nerror[E0609]: no field `nGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:117:36\n    |\n117 |     let mut nGroups: i32 = huffman.nGroups.cast();\n    |                                    ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:119:39\n    |\n119 |     let mut AllFreqNum: i32 = huffman.nBlock.cast();\n    |                                       ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:126:29\n    |\n126 |         while (ed < huffman.alphaSize - 1).as_bool() && (NowFreqNum < FreqNumLimit).as_bool() {\n    |                             ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `mtfFreq` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:128:35\n    |\n128 |             NowFreqNum += huffman.mtfFreq[ed].cast();\n    |                                   ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `mtfFreq` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:131:35\n    |\n131 |             NowFreqNum -= huffman.mtfFreq[ed].cast();\n    |                                   ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:134:48\n    |\n134 |         c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n    |                                                ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `huffmanGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:136:25\n    |\n136 |                 huffman.huffmanGroups[npart - 1].len[i] = 0;\n    |                         ^^^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `huffmanGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:138:25\n    |\n138 |                 huffman.huffmanGroups[npart - 1].len[i] = BZP_HUFFMAN_LEN_MAX_COST!();\n    |                         ^^^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"
            },
            {
                "c_code": "void BzpCalculateCost(BzpHuffmanGroups *huffman, int32_t st, int32_t ed)\n    {\n        (void)memset_s(huffman->cost, sizeof(huffman->cost), 0, sizeof(huffman->cost));\n        int32_t nGroups = huffman->nGroups;\n        for (int32_t k = st; k <= ed; k++)\n        {\n            for (int32_t t = 0; t < nGroups; t++)\n            {\n                huffman->cost[t] += huffman->huffmanGroups[t].len[huffman->block[k]];\n            }\n        }\n    }",
                "rust_code": "pub fn BzpCalculateCost(mut huffman: Ptr<BzpHuffmanGroups>, mut st: i32, mut ed: i32) {\n    c_memset_s!(huffman.cost, c_sizeofval!(huffman.cost), 0, c_sizeofval!(huffman.cost)).cast::<Void>();\n    let mut nGroups: i32 = huffman.nGroups.cast();\n    c_for!(let mut k: i32 = st; k <= ed; k.suffix_plus_plus(); {\n        c_for!(let mut t: i32 = 0; t < nGroups; t.suffix_plus_plus(); {\n            huffman.cost[t] += huffman.huffmanGroups[t].len[huffman.block[k]].cast();\n        });\n    });\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007004012)\nerror[E0609]: no field `cost` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:122:25\n    |\n122 |     c_memset_s!(huffman.cost, c_sizeofval!(huffman.cost), 0, c_sizeofval!(huffman.cost)).cast::<Void>();\n    |                         ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cost` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:122:52\n    |\n122 |     c_memset_s!(huffman.cost, c_sizeofval!(huffman.cost), 0, c_sizeofval!(huffman.cost)).cast::<Void>();\n    |                                                    ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cost` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:122:83\n    |\n122 |     c_memset_s!(huffman.cost, c_sizeofval!(huffman.cost), 0, c_sizeofval!(huffman.cost)).cast::<Void>();\n    |                                                                                   ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:123:36\n    |\n123 |     let mut nGroups: i32 = huffman.nGroups.cast();\n    |                                    ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cost` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:126:21\n    |\n126 |             huffman.cost[t] += huffman.huffmanGroups[t].len[huffman.block[k]].cast();\n    |                     ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `huffmanGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:126:40\n    |\n126 |             huffman.cost[t] += huffman.huffmanGroups[t].len[huffman.block[k]].cast();\n    |                                        ^^^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:126:69\n    |\n126 |             huffman.cost[t] += huffman.huffmanGroups[t].len[huffman.block[k]].cast();\n    |                                                                     ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 7 previous errors\n"
            },
            {
                "c_code": "int32_t BzpSelectTree(BzpHuffmanGroups *huffman)\n    {\n        int32_t id = 0;\n        int32_t nGroups = huffman->nGroups;\n        for (int32_t k = 0; k < nGroups; k++)\n        {\n            if (huffman->cost[k] < huffman->cost[id])\n            {\n                id = k;\n            }\n        }\n        huffman->select[huffman->nSelect++] = id;\n        return id;\n    }",
                "rust_code": "pub fn BzpSelectTree(mut huffman: Ptr<BzpHuffmanGroups>) -> i32 {\n    let mut id: i32 = 0;\n    let mut nGroups: i32 = huffman.nGroups.cast();\n    c_for!(let mut k: i32 = 0; k < nGroups; k.suffix_plus_plus(); {\n        if (huffman.cost[k] < huffman.cost[id]).as_bool() {\n            id = k.cast();\n        }\n    });\n    huffman.select[huffman.nSelect] = id.cast();\n    huffman.nSelect += 1;\n    return id.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007004217)\nerror[E0609]: no field `nGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:128:36\n    |\n128 |     let mut nGroups: i32 = huffman.nGroups.cast();\n    |                                    ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cost` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:130:21\n    |\n130 |         if (huffman.cost[k] < huffman.cost[id]).as_bool() {\n    |                     ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cost` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:130:39\n    |\n130 |         if (huffman.cost[k] < huffman.cost[id]).as_bool() {\n    |                                       ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:134:13\n    |\n134 |     huffman.select[huffman.nSelect] = id.cast();\n    |             ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nSelect` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:134:28\n    |\n134 |     huffman.select[huffman.nSelect] = id.cast();\n    |                            ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nSelect` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:135:13\n    |\n135 |     huffman.nSelect += 1;\n    |             ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\n"
            },
            {
                "c_code": "void BzpHuffmanMain(BzpHuffmanGroups *huffman)\n    {\n        int32_t nGroups = BzpGetHuffmanGroups(huffman->nBlock);\n        huffman->nGroups = nGroups;\n\n        BzpInitLenArray(huffman);\n        int32_t st = 0, ed;\n\n        for (int32_t i = 0; i < BZP_MAX_ITER_NUM; i++)\n        {\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                (void)memset_s(huffman->huffmanGroups[j].weight, sizeof(huffman->huffmanGroups[j].weight), 0,\n                               sizeof(huffman->huffmanGroups[j].weight));\n            }\n\n            st = 0;\n            huffman->nSelect = 0;\n            while (st < huffman->nBlock)\n            {\n                ed = BZP_MIN_FUN(huffman->nBlock, st + (int32_t)BZP_ELEMS_NUM_IN_ONE_GROUP) - 1;\n\n                BzpCalculateCost(huffman, st, ed);\n\n                int32_t id = BzpSelectTree(huffman);\n\n                for (int32_t k = st; k <= ed; k++)\n                {\n                    huffman->huffmanGroups[id].weight[huffman->block[k]]++;\n                }\n                st = ed + 1;\n            }\n\n            for (int32_t j = 0; j < nGroups; j++)\n            {\n                BzpBuildTreeBalanceHeight(&huffman->huffmanGroups[j]);\n            }\n        }\n\n        BzpGenerateSelectMTF(huffman);\n\n        for (int32_t i = 0; i < nGroups; i++)\n        {\n            BzpGetHuffmanTable(&huffman->huffmanGroups[i]);\n        }\n    }",
                "rust_code": "pub fn BzpHuffmanMain(mut huffman: Ptr<BzpHuffmanGroups>) {\n    let mut nGroups: i32 = BzpGetHuffmanGroups(huffman.nBlock.cast()).cast();\n    huffman.nGroups = nGroups.cast();\n\n    BzpInitLenArray(huffman.cast());\n    let mut st: i32 = 0;\n    let mut ed: i32 = Default::default();\n\n    c_for!(let mut i: i32 = 0; i < BZP_MAX_ITER_NUM!().cast(); i.suffix_plus_plus(); {\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            c_memset_s!(huffman.huffmanGroups[j].weight, c_sizeofval!(huffman.huffmanGroups[j].weight), 0,\n                       c_sizeofval!(huffman.huffmanGroups[j].weight)).cast::<Void>();\n        });\n\n        st = 0;\n        huffman.nSelect = 0;\n        while (st < huffman.nBlock).as_bool() {\n            ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast()).cast::<i32>() - 1;\n\n            BzpCalculateCost(huffman.cast(), st.cast(), ed.cast());\n\n            let mut id: i32 = BzpSelectTree(huffman.cast()).cast();\n\n            c_for!(let mut k: i32 = st; k <= ed; k.suffix_plus_plus(); {\n                huffman.huffmanGroups[id].weight[huffman.block[k]] += 1;\n            });\n            st = ed + 1;\n        }\n\n        c_for!(let mut j: i32 = 0; j < nGroups; j.suffix_plus_plus(); {\n            BzpBuildTreeBalanceHeight(c_ref!(huffman.huffmanGroups[j]).cast());\n        });\n    });\n\n    BzpGenerateSelectMTF(huffman.cast());\n\n    c_for!(let mut i: i32 = 0; i < nGroups; i.suffix_plus_plus(); {\n        BzpGetHuffmanTable(c_ref!(huffman.huffmanGroups[i]).cast());\n    });\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007004422)\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:132:56\n    |\n132 |     let mut nGroups: i32 = BzpGetHuffmanGroups(huffman.nBlock.cast()).cast();\n    |                                                        ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:133:13\n    |\n133 |     huffman.nGroups = nGroups.cast();\n    |             ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `huffmanGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:141:33\n    |\n141 |             c_memset_s!(huffman.huffmanGroups[j].weight, c_sizeofval!(huffman.huffmanGroups[j].weight), 0,\n    |                                 ^^^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `huffmanGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:141:79\n    |\n141 |             c_memset_s!(huffman.huffmanGroups[j].weight, c_sizeofval!(huffman.huffmanGroups[j].weight), 0,\n    |                                                                               ^^^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `huffmanGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:142:45\n    |\n142 |                        c_sizeofval!(huffman.huffmanGroups[j].weight)).cast::<Void>();\n    |                                             ^^^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nSelect` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:146:17\n    |\n146 |         huffman.nSelect = 0;\n    |                 ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:147:29\n    |\n147 |         while (st < huffman.nBlock).as_bool() {\n    |                             ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:148:39\n    |\n148 |             ed = BZP_MIN_FUN!(huffman.nBlock, st + BZP_ELEMS_NUM_IN_ONE_GROUP!().cast()).cast::<i32>() - 1;\n    |                                       ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `huffmanGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:155:25\n    |\n155 |                 huffman.huffmanGroups[id].weight[huffman.block[k]] += 1;\n    |                         ^^^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:155:58\n    |\n155 |                 huffman.huffmanGroups[id].weight[huffman.block[k]] += 1;\n    |                                                          ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `huffmanGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:161:54\n    |\n161 |             BzpBuildTreeBalanceHeight(c_ref!(huffman.huffmanGroups[j]).cast());\n    |                                                      ^^^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `huffmanGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_huffman_encode_c.rs:168:43\n    |\n168 |         BzpGetHuffmanTable(c_ref!(huffman.huffmanGroups[i]).cast());\n    |                                           ^^^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 12 previous errors\n"
            },
            {
                "c_code": "BzpBwtInfo *BzpBlockSortInit(int32_t blockSize)\n    {\n        if (BZP_INVALID_BLOCK_SIZE(blockSize))\n        {\n            return NULL;\n        }\n        BzpBwtInfo *bwt = (BzpBwtInfo *)malloc(sizeof(BzpBwtInfo));\n        if (bwt == NULL)\n        {\n            return NULL;\n        }\n\n        (void)memset_s(bwt, sizeof(BzpBwtInfo), 0, sizeof(BzpBwtInfo));\n\n        int32_t spaceSize = blockSize * BZP_BASE_BLOCK_SIZE;\n        bwt->nBlockMax = spaceSize - BZP_BLOCK_RESERVED_SPACE_SIZE;\n        bwt->block = (uint8_t *)malloc(spaceSize * sizeof(uint8_t));\n        bwt->sortBlock = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n        bwt->idx = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n        bwt->isStartPos = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n        if (bwt->block == NULL || bwt->sortBlock == NULL || bwt->idx == NULL || bwt->isStartPos == NULL)\n        {\n            BzpBwtFinish(bwt);\n            return NULL;\n        }\n\n        (void)memset_s(bwt->isStartPos, spaceSize * sizeof(int32_t), 0, spaceSize * sizeof(int32_t));\n        bwt->blockCRC = BZP_INIT_BLOCK_CRC;\n        return bwt;\n    }",
                "rust_code": "pub fn BzpBlockSortInit(mut blockSize: i32) -> Ptr<BzpBwtInfo> {\n    if BZP_INVALID_BLOCK_SIZE!(blockSize).as_bool() {\n        return NULL!();\n    }\n    let mut bwt: Ptr<BzpBwtInfo> = c_malloc!(c_sizeof!(BzpBwtInfo));\n    if (bwt == NULL!()).as_bool() {\n        return NULL!();\n    }\n\n    c_memset_s!(bwt, c_sizeof!(BzpBwtInfo), 0, c_sizeof!(BzpBwtInfo)).cast::<Void>();\n\n    let mut spaceSize: i32 = blockSize * BZP_BASE_BLOCK_SIZE!();\n    bwt.nBlockMax = (spaceSize - BZP_BLOCK_RESERVED_SPACE_SIZE!()).cast();\n    bwt.block = c_malloc!(spaceSize * c_sizeof!(u8));\n    bwt.sortBlock = c_malloc!(spaceSize * c_sizeof!(i32));\n    bwt.idx = c_malloc!(spaceSize * c_sizeof!(i32));\n    bwt.isStartPos = c_malloc!(spaceSize * c_sizeof!(i32));\n    if (bwt.block == NULL!()).as_bool() || (bwt.sortBlock == NULL!()).as_bool() || (bwt.idx == NULL!()).as_bool() || (bwt.isStartPos == NULL!()).as_bool() {\n        BzpBwtFinish(bwt.cast());\n        return NULL!();\n    }\n\n    c_memset_s!(bwt.isStartPos, spaceSize * c_sizeof!(i32), 0, spaceSize * c_sizeof!(i32)).cast::<Void>();\n    bwt.blockCRC = BZP_INIT_BLOCK_CRC!();\n    return bwt.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007004626)\nerror[E0609]: no field `nBlockMax` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:16:9\n   |\n16 |     bwt.nBlockMax = (spaceSize - BZP_BLOCK_RESERVED_SPACE_SIZE!()).cast();\n   |         ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:17:9\n   |\n17 |     bwt.block = c_malloc!(spaceSize * c_sizeof!(u8));\n   |         ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `sortBlock` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:18:9\n   |\n18 |     bwt.sortBlock = c_malloc!(spaceSize * c_sizeof!(i32));\n   |         ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `idx` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:19:9\n   |\n19 |     bwt.idx = c_malloc!(spaceSize * c_sizeof!(i32));\n   |         ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `isStartPos` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:20:9\n   |\n20 |     bwt.isStartPos = c_malloc!(spaceSize * c_sizeof!(i32));\n   |         ^^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:21:13\n   |\n21 |     if (bwt.block == NULL!()).as_bool() || (bwt.sortBlock == NULL!()).as_bool() || (bwt.idx == NULL!()).as_bool() || (bwt.isStartPos == N...\n   |             ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `sortBlock` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:21:49\n   |\n21 |     if (bwt.block == NULL!()).as_bool() || (bwt.sortBlock == NULL!()).as_bool() || (bwt.idx == NULL!()).as_bool() || (bwt.isStartPos == N...\n   |                                                 ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `idx` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:21:89\n   |\n21 |     if (bwt.block == NULL!()).as_bool() || (bwt.sortBlock == NULL!()).as_bool() || (bwt.idx == NULL!()).as_bool() || (bwt.isStartPos == N...\n   |                                                                                         ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `isStartPos` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:21:123\n   |\n21 | ...)).as_bool() || (bwt.idx == NULL!()).as_bool() || (bwt.isStartPos == NULL!()).as_bool() {\n   |                                                           ^^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `isStartPos` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:26:21\n   |\n26 |     c_memset_s!(bwt.isStartPos, spaceSize * c_sizeof!(i32), 0, spaceSize * c_sizeof!(i32)).cast::<Void>();\n   |                     ^^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `blockCRC` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:27:9\n   |\n27 |     bwt.blockCRC = BZP_INIT_BLOCK_CRC!();\n   |         ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_bwt_encode_c.rs:21:22\n    |\n21  |     if (bwt.block == NULL!()).as_bool() || (bwt.sortBlock == NULL!()).as_bool() || (bwt.idx == NULL!()).as_bool() || (bwt.isStartPos == N...\n    |                      ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 12 previous errors\n"
            },
            {
                "c_code": "void BzpQSortSingle(int32_t *sortBlock, int32_t *idx, BzpQSortInfo *stack)\n    {\n        int32_t tl = stack->tl, tr = stack->tr;\n        int32_t value = BzpSelectMidVal(sortBlock, idx, tl, tr);\n        int32_t lPos = tl, rPos = tr, ePos = tl;\n\n        while (ePos <= rPos)\n        {\n            if (idx[sortBlock[ePos]] < value)\n            {\n                BzpSwap2Elem(sortBlock, ePos, lPos);\n                ePos++;\n                lPos++;\n            }\n            else if (idx[sortBlock[ePos]] == value)\n            {\n                ePos++;\n            }\n            else\n            {\n                while (rPos >= ePos && idx[sortBlock[rPos]] > value)\n                {\n                    rPos--;\n                }\n                if (rPos < ePos)\n                {\n                    break;\n                }\n                if (idx[sortBlock[rPos]] == value)\n                {\n                    BzpSwap2Elem(sortBlock, ePos, rPos);\n                }\n                else if (lPos == ePos)\n                {\n\n                    BzpSwap2Elem(sortBlock, ePos, rPos);\n                    lPos++;\n                }\n                else\n                {\n                    BzpSwap3Elem(sortBlock, lPos, ePos, rPos);\n                    lPos++;\n                }\n                ePos++;\n                rPos--;\n            }\n        }\n\n        if (lPos - tl > tr - rPos)\n        {\n            stack->stackL[stack->cnt] = tl;\n            stack->stackR[stack->cnt] = lPos - 1;\n            stack->cnt++;\n            stack->stackL[stack->cnt] = rPos + 1;\n            stack->stackR[stack->cnt] = tr;\n            stack->cnt++;\n        }\n        else\n        {\n            stack->stackL[stack->cnt] = rPos + 1;\n            stack->stackR[stack->cnt] = tr;\n            stack->cnt++;\n            stack->stackL[stack->cnt] = tl;\n            stack->stackR[stack->cnt] = lPos - 1;\n            stack->cnt++;\n        }\n    }",
                "rust_code": "pub fn BzpQSortSingle(mut sortBlock: Ptr<i32>, mut idx: Ptr<i32>, mut stack: Ptr<BzpQSortInfo>) {\n    let mut tl: i32 = stack.tl.cast();\n    let mut tr: i32 = stack.tr.cast();\n    let mut value: i32 = BzpSelectMidVal(sortBlock.cast(), idx.cast(), tl.cast(), tr.cast()).cast();\n    let mut lPos: i32 = tl.cast();\n    let mut rPos: i32 = tr.cast();\n    let mut ePos: i32 = tl.cast();\n\n    while (ePos <= rPos).as_bool() {\n        if (idx[sortBlock[ePos]] < value).as_bool() {\n            BzpSwap2Elem(sortBlock.cast(), ePos.cast(), lPos.cast());\n            ePos += 1;\n            lPos += 1;\n        } else if (idx[sortBlock[ePos]] == value).as_bool() {\n            ePos += 1;\n        } else {\n            while (rPos >= ePos).as_bool() && (idx[sortBlock[rPos]] > value).as_bool() {\n                rPos -= 1;\n            }\n            if (rPos < ePos).as_bool() {\n                break;\n            }\n            if (idx[sortBlock[rPos]] == value).as_bool() {\n                BzpSwap2Elem(sortBlock.cast(), ePos.cast(), rPos.cast());\n            } else if (lPos == ePos).as_bool() {\n                BzpSwap2Elem(sortBlock.cast(), ePos.cast(), rPos.cast());\n                lPos += 1;\n            } else {\n                BzpSwap3Elem(sortBlock.cast(), lPos.cast(), ePos.cast(), rPos.cast());\n                lPos += 1;\n            }\n            ePos += 1;\n            rPos -= 1;\n        }\n    }\n\n    if (lPos - tl > tr - rPos).as_bool() {\n        stack.stackL[stack.cnt] = tl.cast();\n        stack.stackR[stack.cnt] = (lPos - 1).cast();\n        stack.cnt += 1;\n        stack.stackL[stack.cnt] = (rPos + 1).cast();\n        stack.stackR[stack.cnt] = tr.cast();\n        stack.cnt += 1;\n    } else {\n        stack.stackL[stack.cnt] = (rPos + 1).cast();\n        stack.stackR[stack.cnt] = tr.cast();\n        stack.cnt += 1;\n        stack.stackL[stack.cnt] = tl.cast();\n        stack.stackR[stack.cnt] = (lPos - 1).cast();\n        stack.cnt += 1;\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007005676)\nerror[E0609]: no field `tl` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:71:29\n   |\n71 |     let mut tl: i32 = stack.tl.cast();\n   |                             ^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `tr` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:72:29\n   |\n72 |     let mut tr: i32 = stack.tr.cast();\n   |                             ^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `stackL` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:107:15\n    |\n107 |         stack.stackL[stack.cnt] = tl.cast();\n    |               ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cnt` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:107:28\n    |\n107 |         stack.stackL[stack.cnt] = tl.cast();\n    |                            ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `stackR` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:108:15\n    |\n108 |         stack.stackR[stack.cnt] = (lPos - 1).cast();\n    |               ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cnt` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:108:28\n    |\n108 |         stack.stackR[stack.cnt] = (lPos - 1).cast();\n    |                            ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cnt` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:109:15\n    |\n109 |         stack.cnt += 1;\n    |               ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `stackL` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:110:15\n    |\n110 |         stack.stackL[stack.cnt] = (rPos + 1).cast();\n    |               ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cnt` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:110:28\n    |\n110 |         stack.stackL[stack.cnt] = (rPos + 1).cast();\n    |                            ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `stackR` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:111:15\n    |\n111 |         stack.stackR[stack.cnt] = tr.cast();\n    |               ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cnt` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:111:28\n    |\n111 |         stack.stackR[stack.cnt] = tr.cast();\n    |                            ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cnt` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:112:15\n    |\n112 |         stack.cnt += 1;\n    |               ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `stackL` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:114:15\n    |\n114 |         stack.stackL[stack.cnt] = (rPos + 1).cast();\n    |               ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cnt` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:114:28\n    |\n114 |         stack.stackL[stack.cnt] = (rPos + 1).cast();\n    |                            ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `stackR` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:115:15\n    |\n115 |         stack.stackR[stack.cnt] = tr.cast();\n    |               ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cnt` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:115:28\n    |\n115 |         stack.stackR[stack.cnt] = tr.cast();\n    |                            ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cnt` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:116:15\n    |\n116 |         stack.cnt += 1;\n    |               ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `stackL` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:117:15\n    |\n117 |         stack.stackL[stack.cnt] = tl.cast();\n    |               ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cnt` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:117:28\n    |\n117 |         stack.stackL[stack.cnt] = tl.cast();\n    |                            ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `stackR` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:118:15\n    |\n118 |         stack.stackR[stack.cnt] = (lPos - 1).cast();\n    |               ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cnt` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:118:28\n    |\n118 |         stack.stackR[stack.cnt] = (lPos - 1).cast();\n    |                            ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `cnt` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:119:15\n    |\n119 |         stack.cnt += 1;\n    |               ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 22 previous errors\n"
            },
            {
                "c_code": "void BzpQuickSort(int32_t *sortBlock, int32_t *idx, int32_t l, int32_t r)\n    {\n        BzpQSortInfo stack;\n        stack.cnt = 0;\n        stack.stackL[stack.cnt] = l;\n        stack.stackR[stack.cnt] = r;\n        stack.cnt++;\n        while (stack.cnt > 0)\n        {\n            stack.cnt--;\n            int32_t tl = stack.stackL[stack.cnt];\n            int32_t tr = stack.stackR[stack.cnt];\n\n            if (tl >= tr)\n            {\n                continue;\n            }\n            if (tr - tl < BZP_THRESHOLD_SHELL_SORT)\n            {\n                BzpShellSort(sortBlock, idx, tl, tr);\n                continue;\n            }\n            stack.tl = tl;\n            stack.tr = tr;\n            BzpQSortSingle(sortBlock, idx, &stack);\n        }\n    }",
                "rust_code": "pub fn BzpQuickSort(mut sortBlock: Ptr<i32>, mut idx: Ptr<i32>, mut l: i32, mut r: i32) {\n    let mut stack: BzpQSortInfo = Default::default();\n    stack.cnt = 0;\n    stack.stackL[stack.cnt] = l.cast();\n    stack.stackR[stack.cnt] = r.cast();\n    stack.cnt += 1;\n    while (stack.cnt > 0).as_bool() {\n        stack.cnt -= 1;\n        let mut tl: i32 = stack.stackL[stack.cnt].cast();\n        let mut tr: i32 = stack.stackR[stack.cnt].cast();\n        if (tl >= tr).as_bool() {\n            continue;\n        }\n        if (tr - tl < BZP_THRESHOLD_SHELL_SORT!()).as_bool() {\n            BzpShellSort(sortBlock.cast(), idx.cast(), tl.cast(), tr.cast());\n            continue;\n        }\n        stack.tl = tl.cast();\n        stack.tr = tr.cast();\n        BzpQSortSingle(sortBlock.cast(), idx.cast(), c_ref!(stack).cast());\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007005874)\nerror[E0610]: `i32` is a primitive type and therefore doesn't have fields\n  --> src/src/compress/bzp_bwt_encode_c.rs:77:11\n   |\n77 |     stack.cnt = 0;\n   |           ^^^\n\nerror[E0610]: `i32` is a primitive type and therefore doesn't have fields\n  --> src/src/compress/bzp_bwt_encode_c.rs:78:11\n   |\n78 |     stack.stackL[stack.cnt] = l.cast();\n   |           ^^^^^^\n\nerror[E0610]: `i32` is a primitive type and therefore doesn't have fields\n  --> src/src/compress/bzp_bwt_encode_c.rs:78:24\n   |\n78 |     stack.stackL[stack.cnt] = l.cast();\n   |                        ^^^\n\nerror[E0610]: `i32` is a primitive type and therefore doesn't have fields\n  --> src/src/compress/bzp_bwt_encode_c.rs:79:11\n   |\n79 |     stack.stackR[stack.cnt] = r.cast();\n   |           ^^^^^^\n\nerror[E0610]: `i32` is a primitive type and therefore doesn't have fields\n  --> src/src/compress/bzp_bwt_encode_c.rs:79:24\n   |\n79 |     stack.stackR[stack.cnt] = r.cast();\n   |                        ^^^\n\nerror[E0610]: `i32` is a primitive type and therefore doesn't have fields\n  --> src/src/compress/bzp_bwt_encode_c.rs:80:11\n   |\n80 |     stack.cnt += 1;\n   |           ^^^\n\nerror[E0610]: `i32` is a primitive type and therefore doesn't have fields\n  --> src/src/compress/bzp_bwt_encode_c.rs:81:18\n   |\n81 |     while (stack.cnt > 0).as_bool() {\n   |                  ^^^\n\nerror[E0610]: `i32` is a primitive type and therefore doesn't have fields\n  --> src/src/compress/bzp_bwt_encode_c.rs:82:15\n   |\n82 |         stack.cnt -= 1;\n   |               ^^^\n\nerror[E0610]: `i32` is a primitive type and therefore doesn't have fields\n  --> src/src/compress/bzp_bwt_encode_c.rs:83:33\n   |\n83 |         let mut tl: i32 = stack.stackL[stack.cnt].cast();\n   |                                 ^^^^^^\n\nerror[E0610]: `i32` is a primitive type and therefore doesn't have fields\n  --> src/src/compress/bzp_bwt_encode_c.rs:83:46\n   |\n83 |         let mut tl: i32 = stack.stackL[stack.cnt].cast();\n   |                                              ^^^\n\nerror[E0610]: `i32` is a primitive type and therefore doesn't have fields\n  --> src/src/compress/bzp_bwt_encode_c.rs:84:33\n   |\n84 |         let mut tr: i32 = stack.stackR[stack.cnt].cast();\n   |                                 ^^^^^^\n\nerror[E0610]: `i32` is a primitive type and therefore doesn't have fields\n  --> src/src/compress/bzp_bwt_encode_c.rs:84:46\n   |\n84 |         let mut tr: i32 = stack.stackR[stack.cnt].cast();\n   |                                              ^^^\n\nerror[E0610]: `i32` is a primitive type and therefore doesn't have fields\n  --> src/src/compress/bzp_bwt_encode_c.rs:92:15\n   |\n92 |         stack.tl = tl.cast();\n   |               ^^\n\nerror[E0610]: `i32` is a primitive type and therefore doesn't have fields\n  --> src/src/compress/bzp_bwt_encode_c.rs:93:15\n   |\n93 |         stack.tr = tr.cast();\n   |               ^^\n\nFor more information about this error, try `rustc --explain E0610`.\nerror: could not compile `my_proj` (lib) due to 14 previous errors\n"
            },
            {
                "c_code": "void BzpUpdateflag(BzpBwtInfo *bwt, int32_t l, int32_t r)\n    {\n        int32_t tmpst = -1;\n        for (int32_t i = l; i <= r; i++)\n        {\n            int32_t tmpnow = bwt->idx[bwt->sortBlock[i]];\n            if (tmpst != tmpnow)\n            {\n                bwt->isStartPos[i] = 1;\n                tmpst = tmpnow;\n            }\n        }\n    }",
                "rust_code": "pub fn BzpUpdateflag(mut bwt: Ptr<BzpBwtInfo>, mut l: i32, mut r: i32) {\n    let mut tmpst: i32 = -1;\n    c_for!(let mut i: i32 = l; i <= r; i.suffix_plus_plus(); {\n        let mut tmpnow: i32 = bwt.idx[bwt.sortBlock[i]];\n        if (tmpst != tmpnow).as_bool() {\n            bwt.isStartPos[i] = 1;\n            tmpst = tmpnow;\n        }\n    });\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007006072)\nerror[E0609]: no field `idx` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:83:35\n   |\n83 |         let mut tmpnow: i32 = bwt.idx[bwt.sortBlock[i]];\n   |                                   ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `sortBlock` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:83:43\n   |\n83 |         let mut tmpnow: i32 = bwt.idx[bwt.sortBlock[i]];\n   |                                           ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `isStartPos` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:85:17\n   |\n85 |             bwt.isStartPos[i] = 1;\n   |                 ^^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "void BzpBinaryLiftingSort(BzpBwtInfo *bwt)\n    {\n        int32_t ftab[BZP_ASCII_SIZE];\n        (void)memset_s(ftab, sizeof(ftab), 0, sizeof(ftab));\n        for (int32_t i = 0; i < bwt->nBlock; i++)\n        {\n            ftab[bwt->block[i]]++;\n        }\n        for (int32_t i = 1; i < BZP_ASCII_SIZE; i++)\n        {\n            ftab[i] += ftab[i - 1];\n        }\n        for (int32_t i = 0; i < bwt->nBlock; i++)\n        {\n            int32_t ch = bwt->block[i];\n            ftab[ch]--;\n            bwt->sortBlock[ftab[ch]] = i;\n        }\n        for (int32_t i = 0; i < BZP_ASCII_SIZE; i++)\n        {\n            bwt->isStartPos[ftab[i]] = 1;\n        }\n        int32_t M = 1, sortflag = true;\n\n        while (M < bwt->nBlock && sortflag == true)\n        {\n            int32_t st = 0;\n            sortflag = false;\n\n            for (int32_t i = 0; i < bwt->nBlock; i++)\n            {\n                if (bwt->isStartPos[i])\n                {\n                    st = i;\n                }\n                int32_t pos = bwt->sortBlock[i] - M;\n                if (pos < 0)\n                {\n                    pos += bwt->nBlock;\n                }\n                bwt->idx[pos] = st;\n            }\n            int32_t l = 0, r = 1;\n            while (l < bwt->nBlock)\n            {\n                while (r < bwt->nBlock && bwt->isStartPos[r] != 1)\n                {\n                    r++;\n                }\n                r--;\n                if (l < r)\n                {\n                    sortflag = true;\n                    BzpQuickSort(bwt->sortBlock, bwt->idx, l, r);\n                    BzpUpdateflag(bwt, l, r);\n                }\n                l = r + 1;\n                r = l + 1;\n            }\n            M <<= 1;\n        }\n    }",
                "rust_code": "pub fn BzpBinaryLiftingSort(mut bwt: Ptr<BzpBwtInfo>) {\n    let mut ftab: Array<i32, { BZP_ASCII_SIZE!() }> = Default::default();\n    c_memset_s!(ftab, c_sizeofval!(ftab), 0, c_sizeofval!(ftab)).cast::<Void>();\n    c_for!(let mut i: i32 = 0; i < bwt.nBlock; i.suffix_plus_plus(); {\n        ftab[bwt.block[i]] += 1;\n    });\n    c_for!(let mut i: i32 = 1; i < BZP_ASCII_SIZE!(); i.suffix_plus_plus(); {\n        ftab[i] += ftab[i - 1];\n    });\n    c_for!(let mut i: i32 = 0; i < bwt.nBlock; i.suffix_plus_plus(); {\n        let mut ch: i32 = bwt.block[i].cast();\n        ftab[ch] -= 1;\n        bwt.sortBlock[ftab[ch]] = i.cast();\n    });\n    c_for!(let mut i: i32 = 0; i < BZP_ASCII_SIZE!(); i.suffix_plus_plus(); {\n        bwt.isStartPos[ftab[i]] = 1;\n    });\n    let mut M: i32 = 1;\n    let mut sortflag: bool = true;\n    while (M < bwt.nBlock).as_bool() && sortflag.as_bool() {\n        let mut st: i32 = 0;\n        sortflag = false;\n        c_for!(let mut i: i32 = 0; i < bwt.nBlock; i.suffix_plus_plus(); {\n            if bwt.isStartPos[i].as_bool() {\n                st = i.cast();\n            }\n            let mut pos: i32 = (bwt.sortBlock[i] - M).cast();\n            if (pos < 0).as_bool() {\n                pos += bwt.nBlock;\n            }\n            bwt.idx[pos] = st.cast();\n        });\n        let mut l: i32 = 0;\n        let mut r: i32 = 1;\n        while (l < bwt.nBlock).as_bool() {\n            while (r < bwt.nBlock).as_bool() && (!bwt.isStartPos[r].as_bool()) {\n                r += 1;\n            }\n            r -= 1;\n            if (l < r).as_bool() {\n                sortflag = true;\n                BzpQuickSort(bwt.sortBlock.cast(), bwt.idx.cast(), l.cast(), r.cast());\n                BzpUpdateflag(bwt.cast(), l.cast(), r.cast());\n            }\n            l = (r + 1).cast();\n            r = (l + 1).cast();\n        }\n        M <<= 1;\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007006274)\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:88:40\n   |\n88 |     c_for!(let mut i: i32 = 0; i < bwt.nBlock; i.suffix_plus_plus(); {\n   |                                        ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:89:18\n   |\n89 |         ftab[bwt.block[i]] += 1;\n   |                  ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:94:40\n   |\n94 |     c_for!(let mut i: i32 = 0; i < bwt.nBlock; i.suffix_plus_plus(); {\n   |                                        ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:95:31\n   |\n95 |         let mut ch: i32 = bwt.block[i].cast();\n   |                               ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `sortBlock` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:97:13\n   |\n97 |         bwt.sortBlock[ftab[ch]] = i.cast();\n   |             ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `isStartPos` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:100:13\n    |\n100 |         bwt.isStartPos[ftab[i]] = 1;\n    |             ^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:104:20\n    |\n104 |     while (M < bwt.nBlock).as_bool() && sortflag.as_bool() {\n    |                    ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:107:44\n    |\n107 |         c_for!(let mut i: i32 = 0; i < bwt.nBlock; i.suffix_plus_plus(); {\n    |                                            ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `isStartPos` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:108:20\n    |\n108 |             if bwt.isStartPos[i].as_bool() {\n    |                    ^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `sortBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:111:37\n    |\n111 |             let mut pos: i32 = (bwt.sortBlock[i] - M).cast();\n    |                                     ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:113:28\n    |\n113 |                 pos += bwt.nBlock;\n    |                            ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `idx` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:115:17\n    |\n115 |             bwt.idx[pos] = st.cast();\n    |                 ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:119:24\n    |\n119 |         while (l < bwt.nBlock).as_bool() {\n    |                        ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:120:28\n    |\n120 |             while (r < bwt.nBlock).as_bool() && (!bwt.isStartPos[r].as_bool()) {\n    |                            ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `isStartPos` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:120:55\n    |\n120 |             while (r < bwt.nBlock).as_bool() && (!bwt.isStartPos[r].as_bool()) {\n    |                                                       ^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `sortBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:126:34\n    |\n126 |                 BzpQuickSort(bwt.sortBlock.cast(), bwt.idx.cast(), l.cast(), r.cast());\n    |                                  ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `idx` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:126:56\n    |\n126 |                 BzpQuickSort(bwt.sortBlock.cast(), bwt.idx.cast(), l.cast(), r.cast());\n    |                                                        ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 17 previous errors\n"
            },
            {
                "c_code": "void BzpBlockSortMain(BzpBwtInfo *bwt)\n    {\n        BzpBinaryLiftingSort(bwt);\n\n        for (int32_t i = 0; i < bwt->nBlock; i++)\n        {\n            if (bwt->sortBlock[i] == 0)\n            {\n                bwt->oriPtr = i;\n                break;\n            }\n        }\n    }",
                "rust_code": "pub fn BzpBlockSortMain(mut bwt: Ptr<BzpBwtInfo>) {\n    BzpBinaryLiftingSort(bwt.cast());\n\n    c_for!(let mut i: i32 = 0; i < bwt.nBlock; i.suffix_plus_plus(); {\n        if (bwt.sortBlock[i] == 0).as_bool() {\n            bwt.oriPtr = i.cast();\n            break;\n        }\n    });\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007006487)\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:93:40\n   |\n93 |     c_for!(let mut i: i32 = 0; i < bwt.nBlock; i.suffix_plus_plus(); {\n   |                                        ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `sortBlock` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:94:17\n   |\n94 |         if (bwt.sortBlock[i] == 0).as_bool() {\n   |                 ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `oriPtr` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:95:17\n   |\n95 |             bwt.oriPtr = i.cast();\n   |                 ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "void BzpBwtFinish(BzpBwtInfo *bwt)\n    {\n        if (bwt != NULL)\n        {\n            if (bwt->block != NULL)\n            {\n                free(bwt->block);\n                bwt->block = NULL;\n            }\n            if (bwt->sortBlock != NULL)\n            {\n                free(bwt->sortBlock);\n                bwt->sortBlock = NULL;\n            }\n            if (bwt->idx != NULL)\n            {\n                free(bwt->idx);\n                bwt->idx = NULL;\n            }\n            if (bwt->isStartPos != NULL)\n            {\n                free(bwt->isStartPos);\n                bwt->isStartPos = NULL;\n            }\n\n            free(bwt);\n            bwt = NULL;\n        }\n    }",
                "rust_code": "pub fn BzpBwtFinish(mut bwt: Ptr<BzpBwtInfo>) {\n    if (bwt != NULL!()).as_bool() {\n        if (bwt.block != NULL!()).as_bool() {\n            c_free!(bwt.block);\n            bwt.block = NULL!();\n        }\n        if (bwt.sortBlock != NULL!()).as_bool() {\n            c_free!(bwt.sortBlock);\n            bwt.sortBlock = NULL!();\n        }\n        if (bwt.idx != NULL!()).as_bool() {\n            c_free!(bwt.idx);\n            bwt.idx = NULL!();\n        }\n        if (bwt.isStartPos != NULL!()).as_bool() {\n            c_free!(bwt.isStartPos);\n            bwt.isStartPos = NULL!();\n        }\n        c_free!(bwt);\n        bwt = NULL!();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007006691)\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:97:17\n   |\n97 |         if (bwt.block != NULL!()).as_bool() {\n   |                 ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:98:25\n   |\n98 |             c_free!(bwt.block);\n   |                         ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_bwt_encode_c.rs:99:17\n   |\n99 |             bwt.block = NULL!();\n   |                 ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `sortBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:101:17\n    |\n101 |         if (bwt.sortBlock != NULL!()).as_bool() {\n    |                 ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_bwt_encode_c.rs:99:25\n    |\n99  |             bwt.block = NULL!();\n    |                         ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `sortBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:102:25\n    |\n102 |             c_free!(bwt.sortBlock);\n    |                         ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `sortBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:103:17\n    |\n103 |             bwt.sortBlock = NULL!();\n    |                 ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `idx` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:105:17\n    |\n105 |         if (bwt.idx != NULL!()).as_bool() {\n    |                 ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_bwt_encode_c.rs:103:29\n    |\n103 |             bwt.sortBlock = NULL!();\n    |                             ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `idx` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:106:25\n    |\n106 |             c_free!(bwt.idx);\n    |                         ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `idx` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:107:17\n    |\n107 |             bwt.idx = NULL!();\n    |                 ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `isStartPos` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:109:17\n    |\n109 |         if (bwt.isStartPos != NULL!()).as_bool() {\n    |                 ^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_bwt_encode_c.rs:107:23\n    |\n107 |             bwt.idx = NULL!();\n    |                       ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `isStartPos` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:110:25\n    |\n110 |             c_free!(bwt.isStartPos);\n    |                         ^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `isStartPos` on type `memory::ptr::Ptr<i32>`\n   --> src/src/compress/bzp_bwt_encode_c.rs:111:17\n    |\n111 |             bwt.isStartPos = NULL!();\n    |                 ^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_bwt_encode_c.rs:111:30\n    |\n111 |             bwt.isStartPos = NULL!();\n    |                              ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_bwt_encode_c.rs:97:26\n    |\n97  |         if (bwt.block != NULL!()).as_bool() {\n    |                          ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 17 previous errors\n"
            },
            {
                "c_code": "BzpMtfInfo *BzpMtfInit(int32_t blockSize)\n    {\n        if (BZP_INVALID_BLOCK_SIZE(blockSize))\n        {\n            return NULL;\n        }\n        BzpMtfInfo *mtf = (BzpMtfInfo *)malloc(sizeof(BzpMtfInfo));\n        if (mtf == NULL)\n        {\n            return NULL;\n        }\n        mtf->mtfV = NULL;\n        mtf->mtfV = (int32_t *)malloc(blockSize * BZP_BASE_BLOCK_SIZE * sizeof(int32_t));\n        if (mtf->mtfV == NULL)\n        {\n            free(mtf);\n            mtf = NULL;\n            return NULL;\n        }\n\n        mtf->nUse = 0;\n        mtf->nMtf = 0;\n        mtf->block = NULL;\n        mtf->map = NULL;\n        mtf->inUse = NULL;\n        return mtf;\n    }",
                "rust_code": "pub fn BzpMtfInit(mut blockSize: i32) -> Ptr<BzpMtfInfo> {\n    if BZP_INVALID_BLOCK_SIZE!(blockSize).as_bool() {\n        return NULL!();\n    }\n    let mut mtf: Ptr<BzpMtfInfo> = c_malloc!(c_sizeof!(BzpMtfInfo));\n    if (mtf == NULL!()).as_bool() {\n        return NULL!();\n    }\n    mtf.mtfV = NULL!();\n    mtf.mtfV = c_malloc!(blockSize * BZP_BASE_BLOCK_SIZE!() * c_sizeof!(i32));\n    if (mtf.mtfV == NULL!()).as_bool() {\n        c_free!(mtf);\n        mtf = NULL!();\n        return NULL!();\n    }\n    mtf.nUse = 0;\n    mtf.nMtf = 0;\n    mtf.block = NULL!();\n    mtf.map = NULL!();\n    mtf.inUse = NULL!();\n    return mtf.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007006903)\nerror[E0609]: no field `mtfV` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:12:9\n   |\n12 |     mtf.mtfV = NULL!();\n   |         ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `mtfV` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:13:9\n   |\n13 |     mtf.mtfV = c_malloc!(blockSize * BZP_BASE_BLOCK_SIZE!() * c_sizeof!(i32));\n   |         ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_mtf_encode_c.rs:12:16\n    |\n12  |     mtf.mtfV = NULL!();\n    |                ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `mtfV` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:14:13\n   |\n14 |     if (mtf.mtfV == NULL!()).as_bool() {\n   |             ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nUse` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:19:9\n   |\n19 |     mtf.nUse = 0;\n   |         ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nMtf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:20:9\n   |\n20 |     mtf.nMtf = 0;\n   |         ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:21:9\n   |\n21 |     mtf.block = NULL!();\n   |         ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `map` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:22:9\n   |\n22 |     mtf.map = NULL!();\n   |         ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_mtf_encode_c.rs:21:17\n    |\n21  |     mtf.block = NULL!();\n    |                 ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `inUse` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:23:9\n   |\n23 |     mtf.inUse = NULL!();\n   |         ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_mtf_encode_c.rs:22:15\n    |\n22  |     mtf.map = NULL!();\n    |               ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_mtf_encode_c.rs:23:17\n    |\n23  |     mtf.inUse = NULL!();\n    |                 ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_mtf_encode_c.rs:14:21\n    |\n14  |     if (mtf.mtfV == NULL!()).as_bool() {\n    |                     ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 13 previous errors\n"
            },
            {
                "c_code": "void BzpMtfReSet(BzpMtfInfo *mtf)\n    {\n\n        mtf->nUse = 0;\n        mtf->nMtf = 0;\n        mtf->block = NULL;\n        mtf->map = NULL;\n        mtf->inUse = NULL;\n    }",
                "rust_code": "pub fn BzpMtfReSet(mut mtf: Ptr<BzpMtfInfo>) {\n    mtf.nUse = 0;\n    mtf.nMtf = 0;\n    mtf.block = NULL!();\n    mtf.map = NULL!();\n    mtf.inUse = NULL!();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007007111)\nerror[E0609]: no field `nUse` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:10:9\n   |\n10 |     mtf.nUse = 0;\n   |         ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nMtf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:11:9\n   |\n11 |     mtf.nMtf = 0;\n   |         ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:12:9\n   |\n12 |     mtf.block = NULL!();\n   |         ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `map` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:13:9\n   |\n13 |     mtf.map = NULL!();\n   |         ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_mtf_encode_c.rs:12:17\n    |\n12  |     mtf.block = NULL!();\n    |                 ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `inUse` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:14:9\n   |\n14 |     mtf.inUse = NULL!();\n   |         ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_mtf_encode_c.rs:13:15\n    |\n13  |     mtf.map = NULL!();\n    |               ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_mtf_encode_c.rs:14:17\n    |\n14  |     mtf.inUse = NULL!();\n    |                 ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"
            },
            {
                "c_code": "void BzpMapInputChar(BzpMtfInfo *mtf, uint8_t *list, int32_t lenList)\n    {\n        if (BZP_ASCII_SIZE > lenList)\n        {\n            return;\n        }\n        for (int32_t i = 0; i < BZP_ASCII_SIZE; i++)\n        {\n            if (mtf->inUse[i])\n            {\n                list[mtf->nUse] = (uint8_t)i;\n                mtf->nUse++;\n            }\n        }\n    }",
                "rust_code": "pub fn BzpMapInputChar(mut mtf: Ptr<BzpMtfInfo>, mut list: Ptr<u8>, mut lenList: i32) {\n    if (BZP_ASCII_SIZE!() > lenList).as_bool() {\n        return;\n    }\n    c_for!(let mut i: i32 = 0; i < BZP_ASCII_SIZE!().cast(); i.suffix_plus_plus(); {\n        if mtf.inUse[i].as_bool() {\n            list[mtf.nUse] = i.cast::<u8>();\n            mtf.nUse += 1;\n        }\n    });\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007007320)\nerror[E0609]: no field `inUse` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:19:16\n   |\n19 |         if mtf.inUse[i].as_bool() {\n   |                ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nUse` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:20:22\n   |\n20 |             list[mtf.nUse] = i.cast::<u8>();\n   |                      ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nUse` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:21:17\n   |\n21 |             mtf.nUse += 1;\n   |                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "void BzpNumEncode(BzpMtfInfo *mtf, int32_t num)\n    {\n        num <<= 1;\n\n        do\n        {\n            num >>= 1;\n            num--;\n            if (num & 1)\n            {\n                mtf->mtfV[mtf->nMtf++] = BZP_MTF_ENCODE1;\n                mtf->mtfFreq[BZP_MTF_ENCODE1]++;\n            }\n            else\n            {\n                mtf->mtfV[mtf->nMtf++] = BZP_MTF_ENCODE0;\n                mtf->mtfFreq[BZP_MTF_ENCODE0]++;\n            }\n        } while (num >= BZP_MTF_ENCODE_BASE);\n    }",
                "rust_code": "pub fn BzpNumEncode(mut mtf: Ptr<BzpMtfInfo>, mut num: i32) {\n    num <<= 1;\n    c_do!({\n        num >>= 1;\n        num -= 1;\n        if (num & 1).as_bool() {\n            mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE1!();\n            mtf.nMtf += 1;\n            mtf.mtfFreq[BZP_MTF_ENCODE1!()] += 1;\n        } else {\n            mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE0!();\n            mtf.nMtf += 1;\n            mtf.mtfFreq[BZP_MTF_ENCODE0!()] += 1;\n        }\n    } while num >= BZP_MTF_ENCODE_BASE!());\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007007520)\nerror[E0609]: no field `mtfV` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:25:17\n   |\n25 |             mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE1!();\n   |                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nMtf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:25:26\n   |\n25 |             mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE1!();\n   |                          ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nMtf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:26:17\n   |\n26 |             mtf.nMtf += 1;\n   |                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `mtfFreq` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:27:17\n   |\n27 |             mtf.mtfFreq[BZP_MTF_ENCODE1!()] += 1;\n   |                 ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `mtfV` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:29:17\n   |\n29 |             mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE0!();\n   |                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nMtf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:29:26\n   |\n29 |             mtf.mtfV[mtf.nMtf] = BZP_MTF_ENCODE0!();\n   |                          ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nMtf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:30:17\n   |\n30 |             mtf.nMtf += 1;\n   |                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `mtfFreq` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:31:17\n   |\n31 |             mtf.mtfFreq[BZP_MTF_ENCODE0!()] += 1;\n   |                 ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"
            },
            {
                "c_code": "void BzpMtfMain(BzpMtfInfo *mtf)\n    {\n        uint8_t list[BZP_MAX_ALPHA_SIZE];\n        int32_t EOB;\n        int32_t num = 0;\n        BzpMapInputChar(mtf, list, BZP_MAX_ALPHA_SIZE);\n        EOB = mtf->nUse + 1;\n        for (int32_t i = 0; i <= EOB; i++)\n        {\n            mtf->mtfFreq[i] = 0;\n        }\n        for (int32_t i = 0; i < mtf->nBlock; i++)\n        {\n            int32_t pos = mtf->map[i] - 1;\n            if (pos < 0)\n            {\n                pos += mtf->nBlock;\n            }\n            uint8_t ch = mtf->block[pos];\n            if (ch == list[0])\n            {\n                num++;\n            }\n            else\n            {\n                if (num > 0)\n                {\n                    BzpNumEncode(mtf, num);\n                    num = 0;\n                }\n                int32_t pos_ = 1;\n                while (ch != list[pos_] && pos_ < mtf->nUse)\n                {\n                    pos_++;\n                }\n\n                for (int32_t j = pos_; j > 0; j--)\n                {\n                    list[j] = list[j - 1];\n                }\n                list[0] = ch;\n\n                mtf->mtfV[mtf->nMtf] = pos_ + 1;\n                mtf->mtfFreq[pos_ + 1]++;\n                mtf->nMtf++;\n            }\n        }\n        if (num > 0)\n        {\n            BzpNumEncode(mtf, num);\n        }\n\n        mtf->mtfV[mtf->nMtf] = EOB;\n        mtf->mtfFreq[EOB]++;\n        mtf->nMtf++;\n    }",
                "rust_code": "pub fn BzpMtfMain(mut mtf: Ptr<BzpMtfInfo>) {\n    let mut list: Array<u8, { BZP_MAX_ALPHA_SIZE!() }> = Default::default();\n    let mut EOB: i32 = Default::default();\n    let mut num: i32 = 0;\n    BzpMapInputChar(mtf.cast(), list.cast(), BZP_MAX_ALPHA_SIZE!().cast());\n    EOB = (mtf.nUse + 1).cast();\n    c_for!(let mut i: i32 = 0; i <= EOB; i.suffix_plus_plus(); {\n        mtf.mtfFreq[i] = 0;\n    });\n    c_for!(let mut i: i32 = 0; i < mtf.nBlock; i.suffix_plus_plus(); {\n        let mut pos: i32 = (mtf.map[i] - 1).cast();\n        if (pos < 0).as_bool() {\n            pos += mtf.nBlock;\n        }\n        let mut ch: u8 = mtf.block[pos].cast();\n        if (ch == list[0]).as_bool() {\n            num += 1;\n        } else {\n            if (num > 0).as_bool() {\n                BzpNumEncode(mtf.cast(), num.cast());\n                num = 0;\n            }\n            let mut pos_: i32 = 1;\n            while (ch != list[pos_]).as_bool() && (pos_ < mtf.nUse).as_bool() {\n                pos_ += 1;\n            }\n            c_for!(let mut j: i32 = pos_; j > 0; j.suffix_minus_minus(); {\n                list[j] = list[j - 1].cast();\n            });\n            list[0] = ch.cast();\n            mtf.mtfV[mtf.nMtf] = (pos_ + 1).cast();\n            mtf.mtfFreq[pos_ + 1] += 1;\n            mtf.nMtf += 1;\n        }\n    });\n    if (num > 0).as_bool() {\n        BzpNumEncode(mtf.cast(), num.cast());\n    }\n    mtf.mtfV[mtf.nMtf] = EOB.cast();\n    mtf.mtfFreq[EOB] += 1;\n    mtf.nMtf += 1;\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007007725)\nerror[E0609]: no field `nUse` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:29:16\n   |\n29 |     EOB = (mtf.nUse + 1).cast();\n   |                ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `mtfFreq` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:31:13\n   |\n31 |         mtf.mtfFreq[i] = 0;\n   |             ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:33:40\n   |\n33 |     c_for!(let mut i: i32 = 0; i < mtf.nBlock; i.suffix_plus_plus(); {\n   |                                        ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `map` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:34:33\n   |\n34 |         let mut pos: i32 = (mtf.map[i] - 1).cast();\n   |                                 ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:36:24\n   |\n36 |             pos += mtf.nBlock;\n   |                        ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:38:30\n   |\n38 |         let mut ch: u8 = mtf.block[pos].cast();\n   |                              ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nUse` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:47:63\n   |\n47 |             while (ch != list[pos_]).as_bool() && (pos_ < mtf.nUse).as_bool() {\n   |                                                               ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `mtfV` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:54:17\n   |\n54 |             mtf.mtfV[mtf.nMtf] = (pos_ + 1).cast();\n   |                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nMtf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:54:26\n   |\n54 |             mtf.mtfV[mtf.nMtf] = (pos_ + 1).cast();\n   |                          ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `mtfFreq` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:55:17\n   |\n55 |             mtf.mtfFreq[pos_ + 1] += 1;\n   |                 ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nMtf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:56:17\n   |\n56 |             mtf.nMtf += 1;\n   |                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `mtfV` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:62:9\n   |\n62 |     mtf.mtfV[mtf.nMtf] = EOB.cast();\n   |         ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nMtf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:62:18\n   |\n62 |     mtf.mtfV[mtf.nMtf] = EOB.cast();\n   |                  ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `mtfFreq` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:63:9\n   |\n63 |     mtf.mtfFreq[EOB] += 1;\n   |         ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nMtf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:64:9\n   |\n64 |     mtf.nMtf += 1;\n   |         ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 15 previous errors\n"
            },
            {
                "c_code": "void BzpMtfFinish(BzpMtfInfo *mtf)\n    {\n        if (mtf != NULL)\n        {\n            if (mtf->mtfV != NULL)\n            {\n                free(mtf->mtfV);\n                mtf->mtfV = NULL;\n            }\n            free(mtf);\n            mtf = NULL;\n        }\n    }",
                "rust_code": "pub fn BzpMtfFinish(mut mtf: Ptr<BzpMtfInfo>) {\n    if (mtf != NULL!()).as_bool() {\n        if (mtf.mtfV != NULL!()).as_bool() {\n            c_free!(mtf.mtfV);\n            mtf.mtfV = NULL!();\n        }\n        c_free!(mtf);\n        mtf = NULL!();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007007932)\nerror[E0609]: no field `mtfV` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:31:17\n   |\n31 |         if (mtf.mtfV != NULL!()).as_bool() {\n   |                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `mtfV` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:32:25\n   |\n32 |             c_free!(mtf.mtfV);\n   |                         ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `mtfV` on type `memory::ptr::Ptr<i32>`\n  --> src/src/compress/bzp_mtf_encode_c.rs:33:17\n   |\n33 |             mtf.mtfV = NULL!();\n   |                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_mtf_encode_c.rs:33:24\n    |\n33  |             mtf.mtfV = NULL!();\n    |                        ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/compress/bzp_mtf_encode_c.rs:31:25\n    |\n31  |         if (mtf.mtfV != NULL!()).as_bool() {\n    |                         ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
            },
            {
                "c_code": "BzpHuffmanDecode *BzpHuffmanDecodeInit(int32_t blockSize)\n    {\n        if (BZP_INVALID_BLOCK_SIZE(blockSize))\n        {\n            return NULL;\n        }\n        BzpHuffmanDecode *huffman = (BzpHuffmanDecode *)malloc(sizeof(BzpHuffmanDecode));\n        if (huffman == NULL)\n        {\n            return NULL;\n        }\n        int32_t spaceSize = BZP_BASE_BLOCK_SIZE * blockSize / BZP_ELEMS_NUM_IN_ONE_GROUP;\n        huffman->select = (int32_t *)malloc(spaceSize * sizeof(int32_t));\n        if (huffman->select == NULL)\n        {\n            BzpHuffmanDecodeFinish(huffman);\n        }\n\n        (void)memset_s(huffman->base, sizeof(huffman->base), 0, sizeof(huffman->base));\n        (void)memset_s(huffman->perm, sizeof(huffman->perm), 0, sizeof(huffman->perm));\n        (void)memset_s(huffman->limit, sizeof(huffman->limit), 0, sizeof(huffman->limit));\n\n        huffman->selectCnt = 0;\n        huffman->deCodeNum = 0;\n        return huffman;\n    }",
                "rust_code": "pub fn BzpHuffmanDecodeInit(mut blockSize: i32) -> Ptr<BzpHuffmanDecode> {\n    if BZP_INVALID_BLOCK_SIZE!(blockSize).as_bool() {\n        return NULL!();\n    }\n    let mut huffman: Ptr<BzpHuffmanDecode> = c_malloc!(c_sizeof!(BzpHuffmanDecode));\n    if (huffman == NULL!()).as_bool() {\n        return NULL!();\n    }\n    let mut spaceSize: i32 = BZP_BASE_BLOCK_SIZE!() * blockSize / BZP_ELEMS_NUM_IN_ONE_GROUP!();\n    huffman.select = c_malloc!(spaceSize * c_sizeof!(i32));\n    if (huffman.select == NULL!()).as_bool() {\n        BzpHuffmanDecodeFinish(huffman.cast());\n    }\n    c_memset_s!(huffman.base, c_sizeofval!(huffman.base), 0, c_sizeofval!(huffman.base)).cast::<Void>();\n    c_memset_s!(huffman.perm, c_sizeofval!(huffman.perm), 0, c_sizeofval!(huffman.perm)).cast::<Void>();\n    c_memset_s!(huffman.limit, c_sizeofval!(huffman.limit), 0, c_sizeofval!(huffman.limit)).cast::<Void>();\n    huffman.selectCnt = 0;\n    huffman.deCodeNum = 0;\n    return huffman.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007008780)\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:13:13\n   |\n13 |     huffman.select = c_malloc!(spaceSize * c_sizeof!(i32));\n   |             ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:14:17\n   |\n14 |     if (huffman.select == NULL!()).as_bool() {\n   |                 ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `base` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:17:25\n   |\n17 |     c_memset_s!(huffman.base, c_sizeofval!(huffman.base), 0, c_sizeofval!(huffman.base)).cast::<Void>();\n   |                         ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `base` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:17:52\n   |\n17 |     c_memset_s!(huffman.base, c_sizeofval!(huffman.base), 0, c_sizeofval!(huffman.base)).cast::<Void>();\n   |                                                    ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `base` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:17:83\n   |\n17 |     c_memset_s!(huffman.base, c_sizeofval!(huffman.base), 0, c_sizeofval!(huffman.base)).cast::<Void>();\n   |                                                                                   ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `perm` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:18:25\n   |\n18 |     c_memset_s!(huffman.perm, c_sizeofval!(huffman.perm), 0, c_sizeofval!(huffman.perm)).cast::<Void>();\n   |                         ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `perm` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:18:52\n   |\n18 |     c_memset_s!(huffman.perm, c_sizeofval!(huffman.perm), 0, c_sizeofval!(huffman.perm)).cast::<Void>();\n   |                                                    ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `perm` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:18:83\n   |\n18 |     c_memset_s!(huffman.perm, c_sizeofval!(huffman.perm), 0, c_sizeofval!(huffman.perm)).cast::<Void>();\n   |                                                                                   ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `limit` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:19:25\n   |\n19 |     c_memset_s!(huffman.limit, c_sizeofval!(huffman.limit), 0, c_sizeofval!(huffman.limit)).cast::<Void>();\n   |                         ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `limit` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:19:53\n   |\n19 |     c_memset_s!(huffman.limit, c_sizeofval!(huffman.limit), 0, c_sizeofval!(huffman.limit)).cast::<Void>();\n   |                                                     ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `limit` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:19:85\n   |\n19 |     c_memset_s!(huffman.limit, c_sizeofval!(huffman.limit), 0, c_sizeofval!(huffman.limit)).cast::<Void>();\n   |                                                                                     ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `selectCnt` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:20:13\n   |\n20 |     huffman.selectCnt = 0;\n   |             ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `deCodeNum` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:21:13\n   |\n21 |     huffman.deCodeNum = 0;\n   |             ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/decompress/bzp_huffman_decode_c.rs:14:27\n    |\n14  |     if (huffman.select == NULL!()).as_bool() {\n    |                           ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 14 previous errors\n"
            },
            {
                "c_code": "void BzpHuffmanDecodeReset(BzpHuffmanDecode *huffman)\n    {\n        (void)memset_s(huffman->base, sizeof(huffman->base), 0, sizeof(huffman->base));\n        (void)memset_s(huffman->perm, sizeof(huffman->perm), 0, sizeof(huffman->perm));\n        (void)memset_s(huffman->limit, sizeof(huffman->limit), 0, sizeof(huffman->limit));\n\n        huffman->selectCnt = 0;\n        huffman->deCodeNum = 0;\n    }",
                "rust_code": "pub fn BzpHuffmanDecodeReset(mut huffman: Ptr<BzpHuffmanDecode>) {\n    c_memset_s!(huffman.base, c_sizeofval!(huffman.base), 0, c_sizeofval!(huffman.base)).cast::<Void>();\n    c_memset_s!(huffman.perm, c_sizeofval!(huffman.perm), 0, c_sizeofval!(huffman.perm)).cast::<Void>();\n    c_memset_s!(huffman.limit, c_sizeofval!(huffman.limit), 0, c_sizeofval!(huffman.limit)).cast::<Void>();\n    huffman.selectCnt = 0;\n    huffman.deCodeNum = 0;\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007008992)\nerror[E0609]: no field `base` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:10:25\n   |\n10 |     c_memset_s!(huffman.base, c_sizeofval!(huffman.base), 0, c_sizeofval!(huffman.base)).cast::<Void>();\n   |                         ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `base` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:10:52\n   |\n10 |     c_memset_s!(huffman.base, c_sizeofval!(huffman.base), 0, c_sizeofval!(huffman.base)).cast::<Void>();\n   |                                                    ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `base` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:10:83\n   |\n10 |     c_memset_s!(huffman.base, c_sizeofval!(huffman.base), 0, c_sizeofval!(huffman.base)).cast::<Void>();\n   |                                                                                   ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `perm` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:11:25\n   |\n11 |     c_memset_s!(huffman.perm, c_sizeofval!(huffman.perm), 0, c_sizeofval!(huffman.perm)).cast::<Void>();\n   |                         ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `perm` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:11:52\n   |\n11 |     c_memset_s!(huffman.perm, c_sizeofval!(huffman.perm), 0, c_sizeofval!(huffman.perm)).cast::<Void>();\n   |                                                    ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `perm` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:11:83\n   |\n11 |     c_memset_s!(huffman.perm, c_sizeofval!(huffman.perm), 0, c_sizeofval!(huffman.perm)).cast::<Void>();\n   |                                                                                   ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `limit` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:12:25\n   |\n12 |     c_memset_s!(huffman.limit, c_sizeofval!(huffman.limit), 0, c_sizeofval!(huffman.limit)).cast::<Void>();\n   |                         ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `limit` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:12:53\n   |\n12 |     c_memset_s!(huffman.limit, c_sizeofval!(huffman.limit), 0, c_sizeofval!(huffman.limit)).cast::<Void>();\n   |                                                     ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `limit` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:12:85\n   |\n12 |     c_memset_s!(huffman.limit, c_sizeofval!(huffman.limit), 0, c_sizeofval!(huffman.limit)).cast::<Void>();\n   |                                                                                     ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `selectCnt` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:13:13\n   |\n13 |     huffman.selectCnt = 0;\n   |             ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `deCodeNum` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:14:13\n   |\n14 |     huffman.deCodeNum = 0;\n   |             ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 11 previous errors\n"
            },
            {
                "c_code": "void BzpGetOneTable(BzpHuffmanDecode *huffman, int32_t t)\n    {\n        int32_t vec = 0, cnt = 0;\n        int32_t mi = huffman->len[t][0], mx = huffman->len[t][0];\n        for (int32_t i = 0; i < huffman->alphaSize; i++)\n        {\n            mi = BZP_MIN_FUN(mi, huffman->len[t][i]);\n            mx = BZP_MAX_FUN(mx, huffman->len[t][i]);\n        }\n        huffman->minLens[t] = mi;\n        for (int32_t i = mi; i <= mx; i++)\n        {\n            for (int32_t j = 0; j < huffman->alphaSize; j++)\n            {\n                if (huffman->len[t][j] == i)\n                {\n                    huffman->perm[t][cnt++] = j;\n                }\n            }\n        }\n        for (int32_t i = 0; i < huffman->alphaSize; i++)\n        {\n            huffman->base[t][huffman->len[t][i] + 1]++;\n        }\n\n        for (int32_t i = 1; i <= mx + 1; i++)\n        {\n            huffman->base[t][i] += huffman->base[t][i - 1];\n        }\n\n        for (int32_t i = mi; i <= mx; i++)\n        {\n\n            vec += (huffman->base[t][i + 1] - huffman->base[t][i]);\n\n            huffman->limit[t][i] = vec - 1;\n            vec <<= 1;\n        }\n        for (int32_t i = mi + 1; i <= mx; i++)\n        {\n            huffman->base[t][i] = ((huffman->limit[t][i - 1] + 1) << 1) - huffman->base[t][i];\n        }\n    }",
                "rust_code": "pub fn BzpGetOneTable(mut huffman: Ptr<BzpHuffmanDecode>, mut t: i32) {\n    let mut vec: i32 = 0;\n    let mut cnt: i32 = 0;\n    let mut mi: i32 = huffman.len[t][0];\n    let mut mx: i32 = huffman.len[t][0];\n    c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        mi = BZP_MIN_FUN!(mi, huffman.len[t][i]);\n        mx = BZP_MAX_FUN!(mx, huffman.len[t][i]);\n    });\n    huffman.minLens[t] = mi;\n    c_for!(let mut i: i32 = mi; i <= mx; i.suffix_plus_plus(); {\n        c_for!(let mut j: i32 = 0; j < huffman.alphaSize; j.suffix_plus_plus(); {\n            if (huffman.len[t][j] == i).as_bool() {\n                huffman.perm[t][cnt] = j;\n                cnt += 1;\n            }\n        });\n    });\n    c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n        huffman.base[t][huffman.len[t][i] + 1] += 1;\n    });\n    c_for!(let mut i: i32 = 1; i <= mx + 1; i.suffix_plus_plus(); {\n        huffman.base[t][i] += huffman.base[t][i - 1];\n    });\n    c_for!(let mut i: i32 = mi; i <= mx; i.suffix_plus_plus(); {\n        vec += (huffman.base[t][i + 1] - huffman.base[t][i]);\n        huffman.limit[t][i] = vec - 1;\n        vec <<= 1;\n    });\n    c_for!(let mut i: i32 = mi + 1; i <= mx; i.suffix_plus_plus(); {\n        huffman.base[t][i] = ((huffman.limit[t][i - 1] + 1) << 1) - huffman.base[t][i];\n    });\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007009196)\nerror[E0609]: no field `len` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:17:31\n   |\n17 |     let mut mi: i32 = huffman.len[t][0];\n   |                               ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `len` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:18:31\n   |\n18 |     let mut mx: i32 = huffman.len[t][0];\n   |                               ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:19:44\n   |\n19 |     c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n   |                                            ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `len` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:20:39\n   |\n20 |         mi = BZP_MIN_FUN!(mi, huffman.len[t][i]);\n   |                                       ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `len` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:21:39\n   |\n21 |         mx = BZP_MAX_FUN!(mx, huffman.len[t][i]);\n   |                                       ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `minLens` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:23:13\n   |\n23 |     huffman.minLens[t] = mi;\n   |             ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:25:48\n   |\n25 |         c_for!(let mut j: i32 = 0; j < huffman.alphaSize; j.suffix_plus_plus(); {\n   |                                                ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `len` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:26:25\n   |\n26 |             if (huffman.len[t][j] == i).as_bool() {\n   |                         ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `perm` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:27:25\n   |\n27 |                 huffman.perm[t][cnt] = j;\n   |                         ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:32:44\n   |\n32 |     c_for!(let mut i: i32 = 0; i < huffman.alphaSize; i.suffix_plus_plus(); {\n   |                                            ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `base` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:33:17\n   |\n33 |         huffman.base[t][huffman.len[t][i] + 1] += 1;\n   |                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `len` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:33:33\n   |\n33 |         huffman.base[t][huffman.len[t][i] + 1] += 1;\n   |                                 ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `base` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:36:17\n   |\n36 |         huffman.base[t][i] += huffman.base[t][i - 1];\n   |                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `base` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:36:39\n   |\n36 |         huffman.base[t][i] += huffman.base[t][i - 1];\n   |                                       ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `base` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:39:25\n   |\n39 |         vec += (huffman.base[t][i + 1] - huffman.base[t][i]);\n   |                         ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `base` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:39:50\n   |\n39 |         vec += (huffman.base[t][i + 1] - huffman.base[t][i]);\n   |                                                  ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `limit` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:40:17\n   |\n40 |         huffman.limit[t][i] = vec - 1;\n   |                 ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `base` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:44:17\n   |\n44 |         huffman.base[t][i] = ((huffman.limit[t][i - 1] + 1) << 1) - huffman.base[t][i];\n   |                 ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `limit` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:44:40\n   |\n44 |         huffman.base[t][i] = ((huffman.limit[t][i - 1] + 1) << 1) - huffman.base[t][i];\n   |                                        ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `base` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:44:77\n   |\n44 |         huffman.base[t][i] = ((huffman.limit[t][i - 1] + 1) << 1) - huffman.base[t][i];\n   |                                                                             ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 20 previous errors\n"
            },
            {
                "c_code": "void BzpGenerateDecodeTable(BzpHuffmanDecode *huffman)\n    {\n        for (int32_t t = 0; t < huffman->nGroups; t++)\n        {\n            BzpGetOneTable(huffman, t);\n        }\n    }",
                "rust_code": "pub fn BzpGenerateDecodeTable(mut huffman: Ptr<BzpHuffmanDecode>) {\n    c_for!(let mut t: i32 = 0; t < huffman.nGroups; t.suffix_plus_plus(); {\n        BzpGetOneTable(huffman.cast(), t.cast());\n    });\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007009402)\nerror[E0609]: no field `nGroups` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:20:44\n   |\n20 |     c_for!(let mut t: i32 = 0; t < huffman.nGroups; t.suffix_plus_plus(); {\n   |                                            ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void BzpHuffmanDecodeFinish(BzpHuffmanDecode *huffman)\n    {\n        if (huffman != NULL)\n        {\n            if (huffman->select != NULL)\n            {\n                free(huffman->select);\n                huffman->select = NULL;\n            }\n\n            free(huffman);\n            huffman = NULL;\n        }\n    }",
                "rust_code": "pub fn BzpHuffmanDecodeFinish(mut huffman: Ptr<BzpHuffmanDecode>) {\n    if (huffman != NULL!()).as_bool() {\n        if (huffman.select != NULL!()).as_bool() {\n            c_free!(huffman.select);\n            huffman.select = NULL!();\n        }\n        c_free!(huffman);\n        huffman = NULL!();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007009614)\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:26:21\n   |\n26 |         if (huffman.select != NULL!()).as_bool() {\n   |                     ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:27:29\n   |\n27 |             c_free!(huffman.select);\n   |                             ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n  --> src/src/decompress/bzp_huffman_decode_c.rs:28:21\n   |\n28 |             huffman.select = NULL!();\n   |                     ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/decompress/bzp_huffman_decode_c.rs:28:30\n    |\n28  |             huffman.select = NULL!();\n    |                              ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/decompress/bzp_huffman_decode_c.rs:26:31\n    |\n26  |         if (huffman.select != NULL!()).as_bool() {\n    |                               ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
            },
            {
                "c_code": "BzpStream *BzpStreamInit()\n{\n    BzpStream *stream = (BzpStream *)malloc(sizeof(BzpStream));\n    if (stream == NULL)\n    {\n        return NULL;\n    }\n    stream->filePtr = NULL;\n    stream->pos = 0;\n    stream->nBuf = 0;\n    return stream;\n}",
                "rust_code": "pub fn BzpStreamInit() -> Ptr<BzpStream> {\n    let mut stream: Ptr<BzpStream> = c_malloc!(c_sizeof!(BzpStream));\n    if (stream == NULL!()).as_bool() {\n        return NULL!();\n    }\n    stream.filePtr = NULL!();\n    stream.pos = 0;\n    stream.nBuf = 0;\n    return stream.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007009824)\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_stream_utils_c.rs:42:12\n   |\n42 |     stream.filePtr = NULL!();\n   |            ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `pos` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_stream_utils_c.rs:43:12\n   |\n43 |     stream.pos = 0;\n   |            ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/public/bzp_stream_utils_c.rs:42:22\n    |\n42  |     stream.filePtr = NULL!();\n    |                      ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_stream_utils_c.rs:44:12\n   |\n44 |     stream.nBuf = 0;\n   |            ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
            },
            {
                "c_code": "InDeComdata *BzpInDeComdataInit()\n    {\n        InDeComdata *inData = (InDeComdata *)malloc(sizeof(InDeComdata));\n        if (inData == NULL)\n        {\n            return NULL;\n        }\n        inData->input = NULL;\n        inData->output = NULL;\n        inData->num = 0;\n        inData->lasChar = BZP_ASCII_SIZE;\n        inData->nBuf = 0;\n        inData->buf = 0;\n        inData->num = 0;\n\n        inData->blockCRC = BZP_INIT_BLOCK_CRC;\n        return inData;\n    }",
                "rust_code": "pub fn BzpInDeComdataInit() -> Ptr<InDeComdata> {\n    let mut inData: Ptr<InDeComdata> = c_malloc!(c_sizeof!(InDeComdata));\n    if (inData == NULL!()).as_bool() {\n        return NULL!();\n    }\n    inData.input = NULL!();\n    inData.output = NULL!();\n    inData.num = 0;\n    inData.lasChar = BZP_ASCII_SIZE!();\n    inData.nBuf = 0;\n    inData.buf = 0;\n    inData.num = 0;\n    inData.blockCRC = BZP_INIT_BLOCK_CRC!();\n    return inData.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007010244)\nerror[E0609]: no field `input` on type `memory::ptr::Ptr<i32>`\n --> src/src/public/bzp_decompress_stream_c.rs:9:12\n  |\n9 |     inData.input = NULL!();\n  |            ^^^^^ unknown field\n  |\n  = note: available field is: `0`\n\nerror[E0609]: no field `output` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:10:12\n   |\n10 |     inData.output = NULL!();\n   |            ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:9:20\n    |\n9   |     inData.input = NULL!();\n    |                    ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `num` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:11:12\n   |\n11 |     inData.num = 0;\n   |            ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:10:21\n    |\n10  |     inData.output = NULL!();\n    |                     ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `lasChar` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:12:12\n   |\n12 |     inData.lasChar = BZP_ASCII_SIZE!();\n   |            ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:13:12\n   |\n13 |     inData.nBuf = 0;\n   |            ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `buf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:14:12\n   |\n14 |     inData.buf = 0;\n   |            ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `num` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:15:12\n   |\n15 |     inData.num = 0;\n   |            ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `blockCRC` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:16:12\n   |\n16 |     inData.blockCRC = BZP_INIT_BLOCK_CRC!();\n   |            ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 10 previous errors\n"
            },
            {
                "c_code": "uint32_t BzpReadBits(int32_t nBit, InDeComdata *inData)\n    {\n        uint32_t res = 0;\n\n        while (inData->nBuf < nBit)\n        {\n            if (inData->input->nBuf == inData->input->pos)\n            {\n                inData->input->nBuf =\n                    fread(inData->input->buf, sizeof(char), sizeof(inData->input->buf), inData->input->filePtr);\n                inData->input->pos = 0;\n            }\n            int32_t data = ((uint32_t)(inData->input->buf[inData->input->pos]));\n\n            inData->buf = (inData->buf << BZP_BITS8) | data;\n            inData->input->pos++;\n            inData->nBuf += BZP_BITS8;\n        }\n        res = inData->buf >> (inData->nBuf - nBit);\n        res = res & ((1 << nBit) - 1);\n        inData->nBuf -= nBit;\n        return res;\n    }",
                "rust_code": "pub fn BzpReadBits(mut nBit: i32, mut inData: Ptr<InDeComdata>) -> u32 {\n    let mut res: u32 = 0;\n    while (inData.nBuf < nBit).as_bool() {\n        if (inData.input.nBuf == inData.input.pos).as_bool() {\n            inData.input.nBuf = c_fread!(inData.input.buf, c_sizeof!(char), c_sizeofval!(inData.input.buf), inData.input.filePtr).cast();\n            inData.input.pos = 0;\n        }\n        let mut data: i32 = (inData.input.buf[inData.input.pos]).cast::<u32>();\n        inData.buf = (inData.buf << BZP_BITS8!()) | data.cast::<u32>();\n        inData.input.pos += 1;\n        inData.nBuf += BZP_BITS8!();\n    }\n    res = (inData.buf >> (inData.nBuf - nBit)).cast();\n    res = (res & ((1 << nBit) - 1)).cast();\n    inData.nBuf -= nBit;\n    return res.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007010666)\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:19:19\n   |\n19 |     while (inData.nBuf < nBit).as_bool() {\n   |                   ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `input` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:20:20\n   |\n20 |         if (inData.input.nBuf == inData.input.pos).as_bool() {\n   |                    ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `input` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:20:41\n   |\n20 |         if (inData.input.nBuf == inData.input.pos).as_bool() {\n   |                                         ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `input` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:21:20\n   |\n21 |             inData.input.nBuf = c_fread!(inData.input.buf, c_sizeof!(char), c_sizeofval!(inData.input.buf), inData.input.filePtr).cast();\n   |                    ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `input` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:21:49\n   |\n21 |             inData.input.nBuf = c_fread!(inData.input.buf, c_sizeof!(char), c_sizeofval!(inData.input.buf), inData.input.filePtr).cast();\n   |                                                 ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `input` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:21:97\n   |\n21 |             inData.input.nBuf = c_fread!(inData.input.buf, c_sizeof!(char), c_sizeofval!(inData.input.buf), inData.input.filePtr).cast();\n   |                                                                                                 ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `input` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:21:116\n   |\n21 |             inData.input.nBuf = c_fread!(inData.input.buf, c_sizeof!(char), c_sizeofval!(inData.input.buf), inData.input.filePtr).cast();\n   |                                                                                                                    ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `input` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:22:20\n   |\n22 |             inData.input.pos = 0;\n   |                    ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `input` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:24:37\n   |\n24 |         let mut data: i32 = (inData.input.buf[inData.input.pos]).cast::<u32>();\n   |                                     ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `input` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:24:54\n   |\n24 |         let mut data: i32 = (inData.input.buf[inData.input.pos]).cast::<u32>();\n   |                                                      ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `buf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:25:16\n   |\n25 |         inData.buf = (inData.buf << BZP_BITS8!()) | data.cast::<u32>();\n   |                ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `buf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:25:30\n   |\n25 |         inData.buf = (inData.buf << BZP_BITS8!()) | data.cast::<u32>();\n   |                              ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `input` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:26:16\n   |\n26 |         inData.input.pos += 1;\n   |                ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:27:16\n   |\n27 |         inData.nBuf += BZP_BITS8!();\n   |                ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `buf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:29:19\n   |\n29 |     res = (inData.buf >> (inData.nBuf - nBit)).cast();\n   |                   ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:29:34\n   |\n29 |     res = (inData.buf >> (inData.nBuf - nBit)).cast();\n   |                                  ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:31:12\n   |\n31 |     inData.nBuf -= nBit;\n   |            ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 17 previous errors\n"
            },
            {
                "c_code": "int32_t BzpWriteChar(uint8_t ch, InDeComdata *inData)\n    {\n        int32_t ret = BZP_OK;\n        if (inData->output->nBuf >= BZP_BUF_SIZE)\n        {\n            int32_t n2 =\n                fwrite((void *)(inData->output->buf), sizeof(uint8_t), inData->output->nBuf, inData->output->filePtr);\n            if (n2 != inData->output->nBuf)\n            {\n                ret = BZP_ERROR_IO;\n            }\n            inData->output->nBuf = 0;\n        }\n        inData->output->buf[inData->output->nBuf++] = ch;\n        return ret;\n    }",
                "rust_code": "pub fn BzpWriteChar(mut ch: u8, mut inData: Ptr<InDeComdata>) -> i32 {\n    let mut ret: i32 = BZP_OK!();\n    if (inData.output.nBuf >= BZP_BUF_SIZE!()).as_bool() {\n        let mut n2: i32 = c_fwrite!(inData.output.buf.cast::<Ptr<Void>>(), c_sizeof!(u8), inData.output.nBuf, inData.output.filePtr);\n        if (n2 != inData.output.nBuf).as_bool() {\n            ret = BZP_ERROR_IO!();\n        }\n        inData.output.nBuf = 0;\n    }\n    inData.output.buf[inData.output.nBuf.suffix_plus_plus()] = ch.cast();\n    return ret.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007010879)\nerror[E0609]: no field `output` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:24:16\n   |\n24 |     if (inData.output.nBuf >= BZP_BUF_SIZE!()).as_bool() {\n   |                ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `output` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:25:44\n   |\n25 |         let mut n2: i32 = c_fwrite!(inData.output.buf.cast::<Ptr<Void>>(), c_sizeof!(u8), inData.output.nBuf, inData.output.filePtr);\n   |                                            ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `output` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:25:98\n   |\n25 |         let mut n2: i32 = c_fwrite!(inData.output.buf.cast::<Ptr<Void>>(), c_sizeof!(u8), inData.output.nBuf, inData.output.filePtr);\n   |                                                                                                  ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `output` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:25:118\n   |\n25 |         let mut n2: i32 = c_fwrite!(inData.output.buf.cast::<Ptr<Void>>(), c_sizeof!(u8), inData.output.nBuf, inData.output.filePtr);\n   |                                                                                                                      ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `output` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:26:26\n   |\n26 |         if (n2 != inData.output.nBuf).as_bool() {\n   |                          ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `output` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:29:16\n   |\n29 |         inData.output.nBuf = 0;\n   |                ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `output` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:31:12\n   |\n31 |     inData.output.buf[inData.output.nBuf.suffix_plus_plus()] = ch.cast();\n   |            ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `output` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:31:30\n   |\n31 |     inData.output.buf[inData.output.nBuf.suffix_plus_plus()] = ch.cast();\n   |                              ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"
            },
            {
                "c_code": "int32_t BzpHuffmanDecodeStep(BzpHuffmanDecode *huffman, InDeComdata *inData)\n    {\n\n        if (huffman->deCodeNum == BZP_ELEMS_NUM_IN_ONE_GROUP)\n        {\n            huffman->deCodeNum = 0;\n            huffman->selectCnt++;\n        }\n        int32_t gid = huffman->select[huffman->selectCnt];\n\n        int32_t chlen = huffman->minLens[gid];\n        int32_t val = BzpReadBits(chlen, inData);\n\n        while (chlen < BZP_HUFFMAN_LEN_UPPER_LIMIT && val > huffman->limit[gid][chlen])\n        {\n            chlen++;\n            int32_t nxtbit = BzpReadBits(1, inData);\n            val = (val << 1) | nxtbit;\n        }\n        if (chlen > BZP_HUFFMAN_LEN_UPPER_LIMIT)\n        {\n            return -1;\n        }\n\n        val = val - huffman->base[gid][chlen];\n        val = huffman->perm[gid][val];\n        huffman->deCodeNum++;\n        return val;\n    }",
                "rust_code": "pub fn BzpHuffmanDecodeStep(mut huffman: Ptr<BzpHuffmanDecode>, mut inData: Ptr<InDeComdata>) -> i32 {\n    if (huffman.deCodeNum == BZP_ELEMS_NUM_IN_ONE_GROUP!()).as_bool() {\n        huffman.deCodeNum = 0;\n        huffman.selectCnt += 1;\n    }\n    let mut gid: i32 = huffman.select[huffman.selectCnt].cast();\n    let mut chlen: i32 = huffman.minLens[gid].cast();\n    let mut val: i32 = BzpReadBits(chlen.cast(), inData.cast()).cast();\n    while (chlen < BZP_HUFFMAN_LEN_UPPER_LIMIT!()).as_bool() && (val > huffman.limit[gid][chlen]).as_bool() {\n        chlen += 1;\n        let mut nxtbit: i32 = BzpReadBits(1, inData.cast()).cast();\n        val = (val << 1) | nxtbit;\n    }\n    if (chlen > BZP_HUFFMAN_LEN_UPPER_LIMIT!()).as_bool() {\n        return -1;\n    }\n    val = (val - huffman.base[gid][chlen]).cast();\n    val = huffman.perm[gid][val].cast();\n    huffman.deCodeNum += 1;\n    return val.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007011094)\nerror[E0609]: no field `deCodeNum` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:28:17\n   |\n28 |     if (huffman.deCodeNum == BZP_ELEMS_NUM_IN_ONE_GROUP!()).as_bool() {\n   |                 ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `deCodeNum` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:29:17\n   |\n29 |         huffman.deCodeNum = 0;\n   |                 ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `selectCnt` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:30:17\n   |\n30 |         huffman.selectCnt += 1;\n   |                 ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:32:32\n   |\n32 |     let mut gid: i32 = huffman.select[huffman.selectCnt].cast();\n   |                                ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `selectCnt` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:32:47\n   |\n32 |     let mut gid: i32 = huffman.select[huffman.selectCnt].cast();\n   |                                               ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `minLens` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:33:34\n   |\n33 |     let mut chlen: i32 = huffman.minLens[gid].cast();\n   |                                  ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `limit` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:35:80\n   |\n35 |     while (chlen < BZP_HUFFMAN_LEN_UPPER_LIMIT!()).as_bool() && (val > huffman.limit[gid][chlen]).as_bool() {\n   |                                                                                ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `base` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:43:26\n   |\n43 |     val = (val - huffman.base[gid][chlen]).cast();\n   |                          ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `perm` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:44:19\n   |\n44 |     val = huffman.perm[gid][val].cast();\n   |                   ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `deCodeNum` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:45:13\n   |\n45 |     huffman.deCodeNum += 1;\n   |             ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 10 previous errors\n"
            },
            {
                "c_code": "int32_t BzpDeHuffmanSelect(InDeComdata *inData, BzpHuffmanDecode *huffman)\n    {\n        uint8_t ch;\n\n        int32_t selectmtf[BZP_HUFFMAN_MAX_SIZE_SELECT];\n        for (int32_t i = 0; i < huffman->nSelect; i++)\n        {\n            int32_t j = -1;\n            do\n            {\n                ch = BzpReadBits(BZP_BIT, inData);\n                j++;\n            } while (ch != 0);\n            if (j >= huffman->nGroups)\n            {\n                return BZP_ERROR_DATA;\n            }\n            selectmtf[i] = j;\n        }\n\n        int32_t listSelect[BZP_MAX_GROUPS_NUM];\n        for (int32_t i = 0; i < BZP_MAX_GROUPS_NUM; i++)\n        {\n            listSelect[i] = i;\n        }\n\n        for (int32_t i = 0; i < huffman->nSelect; i++)\n        {\n            int32_t pos = selectmtf[i];\n            int32_t tmpv = listSelect[pos];\n            for (int32_t j = pos; j > 0; j--)\n            {\n                listSelect[j] = listSelect[j - 1];\n            }\n            listSelect[0] = tmpv;\n            huffman->select[i] = tmpv;\n        }\n        return BZP_OK;\n    }",
                "rust_code": "pub fn BzpDeHuffmanSelect(mut inData: Ptr<InDeComdata>, mut huffman: Ptr<BzpHuffmanDecode>) -> i32 {\n    let mut ch: u8 = Default::default();\n\n    let mut selectmtf: Array<i32, { BZP_HUFFMAN_MAX_SIZE_SELECT!() }> = Default::default();\n    c_for!(let mut i: i32 = 0; i < huffman.nSelect; i.suffix_plus_plus(); {\n        let mut j: i32 = -1;\n        c_do!({\n            ch = BzpReadBits(BZP_BIT!(), inData.cast()).cast();\n            j.suffix_plus_plus();\n        } while ch != 0);\n        if (j >= huffman.nGroups).as_bool() {\n            return BZP_ERROR_DATA!();\n        }\n        selectmtf[i] = j.cast();\n    });\n\n    let mut listSelect: Array<i32, { BZP_MAX_GROUPS_NUM!() }> = Default::default();\n    c_for!(let mut i: i32 = 0; i < BZP_MAX_GROUPS_NUM!(); i.suffix_plus_plus(); {\n        listSelect[i] = i.cast();\n    });\n\n    c_for!(let mut i: i32 = 0; i < huffman.nSelect; i.suffix_plus_plus(); {\n        let mut pos: i32 = selectmtf[i].cast();\n        let mut tmpv: i32 = listSelect[pos].cast();\n        c_for!(let mut j: i32 = pos; j > 0; j.suffix_minus_minus(); {\n            listSelect[j] = listSelect[j - 1].cast();\n        });\n        listSelect[0] = tmpv.cast();\n        huffman.select[i] = tmpv.cast();\n    });\n    return BZP_OK!();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007011938)\nerror[E0609]: no field `nSelect` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:90:44\n   |\n90 |     c_for!(let mut i: i32 = 0; i < huffman.nSelect; i.suffix_plus_plus(); {\n   |                                            ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nGroups` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:96:26\n   |\n96 |         if (j >= huffman.nGroups).as_bool() {\n   |                          ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `nSelect` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:107:44\n    |\n107 |     c_for!(let mut i: i32 = 0; i < huffman.nSelect; i.suffix_plus_plus(); {\n    |                                            ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:114:17\n    |\n114 |         huffman.select[i] = tmpv.cast();\n    |                 ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
            },
            {
                "c_code": "int32_t BzpDeHuffmanLen(InDeComdata *inData, BzpHuffmanDecode *huffman)\n    {\n        uint8_t ch;\n        for (int32_t i = 0; i < huffman->nGroups; i++)\n        {\n            int32_t val = BzpReadBits(BZP_BITS5, inData);\n            for (int32_t j = 0; j < huffman->alphaSize; j++)\n            {\n\n                ch = BzpReadBits(BZP_BIT, inData);\n                while (ch != 0)\n                {\n                    ch = BzpReadBits(BZP_BIT, inData);\n                    val += (ch == 0 ? 1 : -1);\n                    ch = BzpReadBits(BZP_BIT, inData);\n                }\n                if (val < 1 || val > BZP_HUFFMAN_LEN_UPPER_LIMIT)\n                {\n                    return BZP_ERROR_DATA;\n                }\n                huffman->len[i][j] = val;\n            }\n        }\n        return BZP_OK;\n    }",
                "rust_code": "pub fn BzpDeHuffmanLen(mut inData: Ptr<InDeComdata>, mut huffman: Ptr<BzpHuffmanDecode>) -> i32 {\n    let mut ch: u8 = Default::default();\n    c_for!(let mut i: i32 = 0; i < huffman.nGroups; i.suffix_plus_plus(); {\n        let mut val: i32 = BzpReadBits(BZP_BITS5!(), inData.cast()).cast();\n        c_for!(let mut j: i32 = 0; j < huffman.alphaSize; j.suffix_plus_plus(); {\n            ch = BzpReadBits(BZP_BIT!(), inData.cast()).cast();\n            while (ch != 0).as_bool() {\n                ch = BzpReadBits(BZP_BIT!(), inData.cast()).cast();\n                val += if ch == 0 { 1 } else { -1 };\n                ch = BzpReadBits(BZP_BIT!(), inData.cast()).cast();\n            }\n            if (val < 1 || val > BZP_HUFFMAN_LEN_UPPER_LIMIT!()).as_bool() {\n                return BZP_ERROR_DATA!();\n            }\n            huffman.len[i][j] = val.cast();\n        });\n    });\n    return BZP_OK!();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007012145)\nerror[E0609]: no field `nGroups` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:93:44\n   |\n93 |     c_for!(let mut i: i32 = 0; i < huffman.nGroups; i.suffix_plus_plus(); {\n   |                                            ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:95:48\n   |\n95 |         c_for!(let mut j: i32 = 0; j < huffman.alphaSize; j.suffix_plus_plus(); {\n   |                                                ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `len` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:105:21\n    |\n105 |             huffman.len[i][j] = val.cast();\n    |                     ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "int32_t BzpMTFDeCode(InDeComdata *inData, BzpHuffmanDecode *huffman, BzpBwtDecodeInfo *debwt)\n    {\n        debwt->nBlock = 0;\n        uint8_t ch;\n        int32_t ninUse = huffman->alphaSize - BZP_EXTRA_CHARS_NUM;\n        int32_t eob = ninUse + 1;\n        int32_t val = BzpHuffmanDecodeStep(huffman, inData);\n        while (val != eob && val != -1)\n        {\n            if (val == 0 || val == 1)\n            {\n                int32_t res = 0, basenum = 1;\n                while (val == 0 || val == 1)\n                {\n                    res = res + (val + 1) * basenum;\n                    basenum <<= 1;\n                    val = BzpHuffmanDecodeStep(huffman, inData);\n                }\n                for (int32_t j = 0; j < res; j++)\n                {\n                    debwt->block[debwt->nBlock++] = inData->list[0];\n                }\n            }\n            else\n            {\n                int32_t pos = val - 1;\n                ch = inData->list[pos];\n                debwt->block[debwt->nBlock++] = ch;\n\n                for (int32_t j = pos; j > 0; j--)\n                {\n                    inData->list[j] = inData->list[j - 1];\n                }\n                inData->list[0] = ch;\n                val = BzpHuffmanDecodeStep(huffman, inData);\n            }\n        }\n        if (val == -1)\n        {\n            return BZP_ERROR_DATA;\n        }\n        return BZP_OK;\n    }",
                "rust_code": "pub fn BzpMTFDeCode(mut inData: Ptr<InDeComdata>, mut huffman: Ptr<BzpHuffmanDecode>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    debwt.nBlock = 0;\n    let mut ch: u8 = Default::default();\n    let mut ninUse: i32 = huffman.alphaSize - BZP_EXTRA_CHARS_NUM!();\n    let mut eob: i32 = ninUse + 1;\n    let mut val: i32 = BzpHuffmanDecodeStep(huffman.cast(), inData.cast()).cast();\n    while (val != eob).as_bool() && (val != -1).as_bool() {\n        if (val == 0).as_bool() || (val == 1).as_bool() {\n            let mut res: i32 = 0;\n            let mut basenum: i32 = 1;\n            while (val == 0).as_bool() || (val == 1).as_bool() {\n                res = res + (val + 1) * basenum;\n                basenum <<= 1;\n                val = BzpHuffmanDecodeStep(huffman.cast(), inData.cast()).cast();\n            }\n            c_for!(let mut j: i32 = 0; j < res; j.suffix_plus_plus(); {\n                debwt.block[debwt.nBlock.suffix_plus_plus()] = inData.list[0].cast();\n            });\n        } else {\n            let mut pos: i32 = val - 1;\n            ch = inData.list[pos].cast();\n            debwt.block[debwt.nBlock.suffix_plus_plus()] = ch.cast();\n            c_for!(let mut j: i32 = pos; j > 0; j.suffix_minus_minus(); {\n                inData.list[j] = inData.list[j - 1].cast();\n            });\n            inData.list[0] = ch.cast();\n            val = BzpHuffmanDecodeStep(huffman.cast(), inData.cast()).cast();\n        }\n    }\n    if (val == -1).as_bool() {\n        return BZP_ERROR_DATA!();\n    }\n    return BZP_OK!();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007012355)\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_decompress_stream_c.rs:99:35\n   |\n99 |     let mut ninUse: i32 = huffman.alphaSize - BZP_EXTRA_CHARS_NUM!();\n   |                                   ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `list` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:112:71\n    |\n112 |                 debwt.block[debwt.nBlock.suffix_plus_plus()] = inData.list[0].cast();\n    |                                                                       ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `list` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:116:25\n    |\n116 |             ch = inData.list[pos].cast();\n    |                         ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `list` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:119:24\n    |\n119 |                 inData.list[j] = inData.list[j - 1].cast();\n    |                        ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `list` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:119:41\n    |\n119 |                 inData.list[j] = inData.list[j - 1].cast();\n    |                                         ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `list` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:121:20\n    |\n121 |             inData.list[0] = ch.cast();\n    |                    ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\n"
            },
            {
                "c_code": "int32_t BzpDeCodeToStream(InDeComdata *inData, BzpBwtDecodeInfo *debwt)\n    {\n        uint8_t ch;\n        int32_t ret = BZP_OK;\n        for (int32_t i = 0; i < debwt->nBlock; i++)\n        {\n            ch = debwt->deCode[i];\n            if (inData->num == BZP_RLC_NUM_4)\n            {\n                for (int32_t j = 0; j < ((int32_t)ch); j++)\n                {\n                    BZP_UPDATE_CRC(inData->blockCRC, (uint8_t)inData->lasChar);\n                    ret |= BzpWriteChar(inData->lasChar, inData);\n                }\n                inData->lasChar = BZP_ASCII_SIZE;\n                inData->num = 0;\n            }\n            else if (ch == inData->lasChar)\n            {\n                BZP_UPDATE_CRC(inData->blockCRC, ch);\n                ret = BzpWriteChar(ch, inData);\n                inData->num++;\n            }\n            else\n            {\n                BZP_UPDATE_CRC(inData->blockCRC, ch);\n                ret = BzpWriteChar(ch, inData);\n                inData->lasChar = ch;\n                inData->num = 1;\n            }\n            if (ret != BZP_OK)\n                break;\n        }\n        return ret;\n    }",
                "rust_code": "pub fn BzpDeCodeToStream(mut inData: Ptr<InDeComdata>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    let mut ch: u8 = Default::default();\n    let mut ret: i32 = BZP_OK!();\n    c_for!(let mut i: i32 = 0; i < debwt.nBlock; i.suffix_plus_plus(); {\n        ch = debwt.deCode[i].cast();\n        if (inData.num == BZP_RLC_NUM_4!()).as_bool() {\n            c_for!(let mut j: i32 = 0; j < ch.cast::<i32>(); j.suffix_plus_plus(); {\n                BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n                ret |= BzpWriteChar(inData.lasChar.cast(), inData.cast()).cast();\n            });\n            inData.lasChar = BZP_ASCII_SIZE!().cast();\n            inData.num = 0;\n        } else if (ch == inData.lasChar).as_bool() {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch);\n            ret = BzpWriteChar(ch.cast(), inData.cast()).cast();\n            inData.num += 1;\n        } else {\n            BZP_UPDATE_CRC!(inData.blockCRC, ch);\n            ret = BzpWriteChar(ch.cast(), inData.cast()).cast();\n            inData.lasChar = ch.cast();\n            inData.num = 1;\n        }\n        if (ret != BZP_OK!()).as_bool() {\n            break;\n        }\n    });\n    return ret.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007012564)\nerror[E0609]: no field `num` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:106:20\n    |\n106 |         if (inData.num == BZP_RLC_NUM_4!()).as_bool() {\n    |                    ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `blockCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:108:40\n    |\n108 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                                        ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `lasChar` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:108:57\n    |\n108 |                 BZP_UPDATE_CRC!(inData.blockCRC, inData.lasChar.cast::<u8>());\n    |                                                         ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `lasChar` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:109:44\n    |\n109 |                 ret |= BzpWriteChar(inData.lasChar.cast(), inData.cast()).cast();\n    |                                            ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `lasChar` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:111:20\n    |\n111 |             inData.lasChar = BZP_ASCII_SIZE!().cast();\n    |                    ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `num` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:112:20\n    |\n112 |             inData.num = 0;\n    |                    ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `lasChar` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:113:33\n    |\n113 |         } else if (ch == inData.lasChar).as_bool() {\n    |                                 ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `blockCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:114:36\n    |\n114 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |                                    ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `num` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:116:20\n    |\n116 |             inData.num += 1;\n    |                    ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `blockCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:118:36\n    |\n118 |             BZP_UPDATE_CRC!(inData.blockCRC, ch);\n    |                                    ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `lasChar` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:120:20\n    |\n120 |             inData.lasChar = ch.cast();\n    |                    ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `num` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:121:20\n    |\n121 |             inData.num = 1;\n    |                    ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 12 previous errors\n"
            },
            {
                "c_code": "int32_t BzpGetDictionaryList(InDeComdata *inData)\n    {\n        int32_t ninUse = 0;\n\n        bool use16[16] = {0};\n        bool inUse[BZP_ASCII_SIZE] = {0};\n        for (int32_t i = 0; i < BZP_GROUPS_ASCII; i++)\n        {\n            use16[i] = BzpReadBits(BZP_BIT, inData);\n        }\n        for (int32_t i = 0; i < BZP_GROUPS_ASCII; i++)\n        {\n            if (use16[i])\n            {\n                for (int32_t j = 0; j < BZP_CHARS_PER_GROUP_ASCII; j++)\n                {\n                    inUse[i * BZP_GROUPS_ASCII + j] = BzpReadBits(BZP_BIT, inData);\n                }\n            }\n        }\n\n        for (int32_t i = 0; i < BZP_ASCII_SIZE; i++)\n        {\n            if (inUse[i])\n            {\n                inData->list[ninUse++] = i;\n            }\n        }\n        return ninUse;\n    }",
                "rust_code": "pub fn BzpGetDictionaryList(mut inData: Ptr<InDeComdata>) -> i32 {\n    let mut ninUse: i32 = 0;\n    let mut use16: Array<bool, 16> = arr![false; 16];\n    let mut inUse: Array<bool, { BZP_ASCII_SIZE!() }> = arr![false; BZP_ASCII_SIZE!()];\n    c_for!(let mut i: i32 = 0; i < BZP_GROUPS_ASCII!().cast(); i.suffix_plus_plus(); {\n        use16[i] = BzpReadBits(BZP_BIT!(), inData.cast()).cast();\n    });\n    c_for!(let mut i: i32 = 0; i < BZP_GROUPS_ASCII!().cast(); i.suffix_plus_plus(); {\n        if use16[i].as_bool() {\n            c_for!(let mut j: i32 = 0; j < BZP_CHARS_PER_GROUP_ASCII!(); j.suffix_plus_plus(); {\n                inUse[i * BZP_GROUPS_ASCII!() + j] = BzpReadBits(BZP_BIT!(), inData.cast()).cast();\n            });\n        }\n    });\n    c_for!(let mut i: i32 = 0; i < BZP_ASCII_SIZE!().cast(); i.suffix_plus_plus(); {\n        if inUse[i].as_bool() {\n            inData.list[ninUse.suffix_plus_plus()] = i.cast();\n        }\n    });\n    return ninUse.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007012772)\nerror[E0609]: no field `list` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:122:20\n    |\n122 |             inData.list[ninUse.suffix_plus_plus()] = i.cast();\n    |                    ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int32_t BzpDeCompressOneBlock(InDeComdata *inData, BzpHuffmanDecode *huffman, BzpBwtDecodeInfo *debwt)\n    {\n\n        int32_t ret = BZP_OK;\n        BzpCheckFileHead(inData);\n        uint32_t blockCRC = BzpReadUInt32(inData);\n\n        (void)BzpReadBits(BZP_BIT, inData);\n\n        int32_t oriPtr = BzpReadUInt24(inData);\n        if (oriPtr < 0 || oriPtr > BZP_BASE_BLOCK_SIZE * inData->blockSize)\n        {\n            return BZP_ERROR_DATA;\n        }\n\n        int32_t ninUse = BzpGetDictionaryList(inData);\n        huffman->alphaSize = ninUse + BZP_EXTRA_CHARS_NUM;\n        huffman->nGroups = BzpReadBits(BZP_BITS3, inData);\n        if (huffman->nGroups < BZP_NGROUPS_NUM_0 || huffman->nGroups > BZP_NGROUPS_NUM_4)\n        {\n            return BZP_ERROR_DATA;\n        }\n        huffman->nSelect = BzpReadBits(BZP_BITS15, inData);\n\n        int32_t nSelectUpperLimit = (inData->blockSize * BZP_BASE_BLOCK_SIZE / BZP_ELEMS_NUM_IN_ONE_GROUP + 1);\n        if (huffman->nSelect < 1 || huffman->nSelect > nSelectUpperLimit)\n        {\n            return BZP_ERROR_DATA;\n        }\n\n        ret |= BzpDeHuffmanSelect(inData, huffman);\n\n        ret |= BzpDeHuffmanLen(inData, huffman);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n\n        BzpGenerateDecodeTable(huffman);\n\n        debwt->oriPtr = oriPtr;\n        ret = BzpMTFDeCode(inData, huffman, debwt);\n        if (ret != BZP_OK || debwt->nBlock >= BZP_BASE_BLOCK_SIZE * inData->blockSize)\n        {\n            return BZP_ERROR_DATA;\n        }\n\n        BzpBwtDecode(debwt);\n\n        ret = BzpDeCodeToStream(inData, debwt);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n        inData->blockCRC = ~(inData->blockCRC);\n\n        if (blockCRC != inData->blockCRC)\n        {\n            ret = BZP_ERROR_DATA;\n        }\n\n        return ret;\n    }",
                "rust_code": "pub fn BzpDeCompressOneBlock(mut inData: Ptr<InDeComdata>, mut huffman: Ptr<BzpHuffmanDecode>, mut debwt: Ptr<BzpBwtDecodeInfo>) -> i32 {\n    let mut ret: i32 = BZP_OK!();\n    BzpCheckFileHead(inData.cast());\n    let mut blockCRC: u32 = BzpReadUInt32(inData.cast()).cast();\n    BzpReadBits(BZP_BIT!(), inData.cast()).cast::<Void>();\n    let mut oriPtr: i32 = BzpReadUInt24(inData.cast()).cast();\n    if (oriPtr < 0 || oriPtr > BZP_BASE_BLOCK_SIZE!() * inData.blockSize).as_bool() {\n        return BZP_ERROR_DATA!();\n    }\n    let mut ninUse: i32 = BzpGetDictionaryList(inData.cast()).cast();\n    huffman.alphaSize = (ninUse + BZP_EXTRA_CHARS_NUM!()).cast();\n    huffman.nGroups = BzpReadBits(BZP_BITS3!(), inData.cast()).cast();\n    if (huffman.nGroups < BZP_NGROUPS_NUM_0!() || huffman.nGroups > BZP_NGROUPS_NUM_4!()).as_bool() {\n        return BZP_ERROR_DATA!();\n    }\n    huffman.nSelect = BzpReadBits(BZP_BITS15!(), inData.cast()).cast();\n    let mut nSelectUpperLimit: i32 = (inData.blockSize * BZP_BASE_BLOCK_SIZE!() / BZP_ELEMS_NUM_IN_ONE_GROUP!() + 1).cast();\n    if (huffman.nSelect < 1 || huffman.nSelect > nSelectUpperLimit).as_bool() {\n        return BZP_ERROR_DATA!();\n    }\n    ret |= BzpDeHuffmanSelect(inData.cast(), huffman.cast()).cast();\n    ret |= BzpDeHuffmanLen(inData.cast(), huffman.cast()).cast();\n    if (ret != BZP_OK!()).as_bool() {\n        return ret;\n    }\n    BzpGenerateDecodeTable(huffman.cast());\n    debwt.oriPtr = oriPtr.cast();\n    ret = BzpMTFDeCode(inData.cast(), huffman.cast(), debwt.cast()).cast();\n    if (ret != BZP_OK!() || debwt.nBlock >= BZP_BASE_BLOCK_SIZE!() * inData.blockSize).as_bool() {\n        return BZP_ERROR_DATA!();\n    }\n    BzpBwtDecode(debwt.cast());\n    ret = BzpDeCodeToStream(inData.cast(), debwt.cast()).cast();\n    if (ret != BZP_OK!()).as_bool() {\n        return ret;\n    }\n    inData.blockCRC = !(inData.blockCRC).cast();\n    if (blockCRC != inData.blockCRC).as_bool() {\n        ret = BZP_ERROR_DATA!();\n    }\n    return ret.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007012974)\nerror[E0609]: no field `blockSize` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:117:64\n    |\n117 |     if (oriPtr < 0 || oriPtr > BZP_BASE_BLOCK_SIZE!() * inData.blockSize).as_bool() {\n    |                                                                ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:121:13\n    |\n121 |     huffman.alphaSize = (ninUse + BZP_EXTRA_CHARS_NUM!()).cast();\n    |             ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:122:13\n    |\n122 |     huffman.nGroups = BzpReadBits(BZP_BITS3!(), inData.cast()).cast();\n    |             ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:123:17\n    |\n123 |     if (huffman.nGroups < BZP_NGROUPS_NUM_0!() || huffman.nGroups > BZP_NGROUPS_NUM_4!()).as_bool() {\n    |                 ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:123:59\n    |\n123 |     if (huffman.nGroups < BZP_NGROUPS_NUM_0!() || huffman.nGroups > BZP_NGROUPS_NUM_4!()).as_bool() {\n    |                                                           ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nSelect` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:126:13\n    |\n126 |     huffman.nSelect = BzpReadBits(BZP_BITS15!(), inData.cast()).cast();\n    |             ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `blockSize` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:127:46\n    |\n127 |     let mut nSelectUpperLimit: i32 = (inData.blockSize * BZP_BASE_BLOCK_SIZE!() / BZP_ELEMS_NUM_IN_ONE_GROUP!() + 1).cast();\n    |                                              ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nSelect` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:128:17\n    |\n128 |     if (huffman.nSelect < 1 || huffman.nSelect > nSelectUpperLimit).as_bool() {\n    |                 ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nSelect` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:128:40\n    |\n128 |     if (huffman.nSelect < 1 || huffman.nSelect > nSelectUpperLimit).as_bool() {\n    |                                        ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `blockSize` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:139:77\n    |\n139 |     if (ret != BZP_OK!() || debwt.nBlock >= BZP_BASE_BLOCK_SIZE!() * inData.blockSize).as_bool() {\n    |                                                                             ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `blockCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:147:12\n    |\n147 |     inData.blockCRC = !(inData.blockCRC).cast();\n    |            ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `blockCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:147:32\n    |\n147 |     inData.blockCRC = !(inData.blockCRC).cast();\n    |                                ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `blockCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:148:28\n    |\n148 |     if (blockCRC != inData.blockCRC).as_bool() {\n    |                            ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 13 previous errors\n"
            },
            {
                "c_code": "int32_t BzpReadFileHead(InDeComdata *inData)\n    {\n\n        uint8_t ch = BzpReadBits(BZP_BITS8, inData);\n        if (ch != BZP_HDR_B)\n        {\n            return BZP_ERROR_DATA_MAGIC;\n        }\n        ch = BzpReadBits(BZP_BITS8, inData);\n        if (ch != BZP_HDR_Z)\n        {\n            return BZP_ERROR_DATA_MAGIC;\n        }\n        ch = BzpReadBits(BZP_BITS8, inData);\n        if (ch != BZP_HDR_H)\n        {\n            return BZP_ERROR_DATA_MAGIC;\n        }\n        ch = BzpReadBits(BZP_BITS8, inData);\n        int32_t blockSize = ch - BZP_HDR_0;\n        if (BZP_INVALID_BLOCK_SIZE(blockSize))\n        {\n            return BZP_ERROR_DATA_MAGIC;\n        }\n\n        inData->blockSize = blockSize;\n        return BZP_OK;\n    }",
                "rust_code": "pub fn BzpReadFileHead(mut inData: Ptr<InDeComdata>) -> i32 {\n    let mut ch: u8 = BzpReadBits(BZP_BITS8!(), inData.cast()).cast();\n    if (ch != BZP_HDR_B!()).as_bool() {\n        return BZP_ERROR_DATA_MAGIC!();\n    }\n    ch = BzpReadBits(BZP_BITS8!(), inData.cast()).cast();\n    if (ch != BZP_HDR_Z!()).as_bool() {\n        return BZP_ERROR_DATA_MAGIC!();\n    }\n    ch = BzpReadBits(BZP_BITS8!(), inData.cast()).cast();\n    if (ch != BZP_HDR_H!()).as_bool() {\n        return BZP_ERROR_DATA_MAGIC!();\n    }\n    ch = BzpReadBits(BZP_BITS8!(), inData.cast()).cast();\n    let mut blockSize: i32 = (ch - BZP_HDR_0!()).cast();\n    if BZP_INVALID_BLOCK_SIZE!(blockSize).as_bool() {\n        return BZP_ERROR_DATA_MAGIC!();\n    }\n    inData.blockSize = blockSize.cast();\n    return BZP_OK!();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007013398)\nerror[E0609]: no field `blockSize` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:163:12\n    |\n163 |     inData.blockSize = blockSize.cast();\n    |            ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int32_t BZPDeCompressData(InDeComdata *inData)\n    {\n        int32_t ret = BZP_OK;\n        uint32_t caltotalCRC = 0;\n        uint8_t ch;\n        ret = BzpReadFileHead(inData);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n        BzpHuffmanDecode *huffman = BzpHuffmanDecodeInit(inData->blockSize);\n        BzpBwtDecodeInfo *debwt = BzpBwtDecodeInit(inData->blockSize);\n\n        while ((ch = BzpReadBits(BZP_BITS8, inData)) != BZP_FILE_END_0)\n        {\n            if (ch != BZP_BLOCK_HEAD_0)\n            {\n                ret = BZP_ERROR_DATA;\n                break;\n            }\n            BzpHuffmanDecodeReset(huffman);\n            inData->blockCRC = BZP_INIT_BLOCK_CRC;\n\n            ret = BzpDeCompressOneBlock(inData, huffman, debwt);\n            if (ret != BZP_OK)\n            {\n                break;\n            }\n\n            caltotalCRC = (caltotalCRC << 1) | (caltotalCRC >> BZP_CRC_MOVE_RIGHT_VAL);\n            caltotalCRC ^= inData->blockCRC;\n        }\n        if (ret == BZP_OK)\n        {\n            ret = BZPReadFileEnd(inData, caltotalCRC);\n        }\n        BzpHuffmanDecodeFinish(huffman);\n        BzpBwtDecodeFinish(debwt);\n        return ret;\n    }",
                "rust_code": "pub fn BZPDeCompressData(mut inData: Ptr<InDeComdata>) -> i32 {\n    let mut ret: i32 = BZP_OK!();\n    let mut caltotalCRC: u32 = 0;\n    let mut ch: u8;\n    ret = BzpReadFileHead(inData.cast()).cast();\n    if (ret != BZP_OK!()).as_bool() {\n        return ret;\n    }\n    let mut huffman: Ptr<BzpHuffmanDecode> = BzpHuffmanDecodeInit(inData.blockSize.cast());\n    let mut debwt: Ptr<BzpBwtDecodeInfo> = BzpBwtDecodeInit(inData.blockSize.cast());\n\n    while {\n        ch = BzpReadBits(BZP_BITS8!(), inData.cast()).cast();\n        ch != BZP_FILE_END_0!()\n    } {\n        if (ch != BZP_BLOCK_HEAD_0!()).as_bool() {\n            ret = BZP_ERROR_DATA!();\n            break;\n        }\n        BzpHuffmanDecodeReset(huffman.cast());\n        inData.blockCRC = BZP_INIT_BLOCK_CRC!();\n\n        ret = BzpDeCompressOneBlock(inData.cast(), huffman.cast(), debwt.cast()).cast();\n        if (ret != BZP_OK!()).as_bool() {\n            break;\n        }\n\n        caltotalCRC = (caltotalCRC << 1) | (caltotalCRC >> BZP_CRC_MOVE_RIGHT_VAL!());\n        caltotalCRC ^= inData.blockCRC.cast();\n    }\n    if (ret == BZP_OK!()).as_bool() {\n        ret = BZPReadFileEnd(inData.cast(), caltotalCRC.cast()).cast();\n    }\n    BzpHuffmanDecodeFinish(huffman.cast());\n    BzpBwtDecodeFinish(debwt.cast());\n    return ret.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007013600)\nerror[E0609]: no field `blockSize` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:158:74\n    |\n158 |     let mut huffman: Ptr<BzpHuffmanDecode> = BzpHuffmanDecodeInit(inData.blockSize.cast());\n    |                                                                          ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `blockSize` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:159:68\n    |\n159 |     let mut debwt: Ptr<BzpBwtDecodeInfo> = BzpBwtDecodeInit(inData.blockSize.cast());\n    |                                                                    ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `blockCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:170:16\n    |\n170 |         inData.blockCRC = BZP_INIT_BLOCK_CRC!();\n    |                ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `blockCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:178:31\n    |\n178 |         caltotalCRC ^= inData.blockCRC.cast();\n    |                               ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
            },
            {
                "c_code": "void BzpDeComStreamFinish(InDeComdata *inData, BzpStream *inStream, BzpStream *outStream)\n    {\n\n        if (inStream->filePtr != NULL)\n        {\n            fclose(inStream->filePtr);\n            inStream->filePtr = NULL;\n        }\n        if (outStream->filePtr != NULL)\n        {\n            fclose(outStream->filePtr);\n            outStream->filePtr = NULL;\n        }\n        BzpStreamFinish(inStream);\n        BzpStreamFinish(outStream);\n        BzpInDeComdataFinish(inData);\n    }",
                "rust_code": "pub fn BzpDeComStreamFinish(mut inData: Ptr<InDeComdata>, mut inStream: Ptr<BzpStream>, mut outStream: Ptr<BzpStream>) {\n    if (inStream.filePtr != NULL!()).as_bool() {\n        c_fclose!(inStream.filePtr);\n        inStream.filePtr = NULL!();\n    }\n    if (outStream.filePtr != NULL!()).as_bool() {\n        c_fclose!(outStream.filePtr);\n        outStream.filePtr = NULL!();\n    }\n    BzpStreamFinish(inStream.cast());\n    BzpStreamFinish(outStream.cast());\n    BzpInDeComdataFinish(inData.cast());\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007013808)\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:156:18\n    |\n156 |     if (inStream.filePtr != NULL!()).as_bool() {\n    |                  ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:157:28\n    |\n157 |         c_fclose!(inStream.filePtr);\n    |                            ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:158:18\n    |\n158 |         inStream.filePtr = NULL!();\n    |                  ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:160:19\n    |\n160 |     if (outStream.filePtr != NULL!()).as_bool() {\n    |                   ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:158:28\n    |\n158 |         inStream.filePtr = NULL!();\n    |                            ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:161:29\n    |\n161 |         c_fclose!(outStream.filePtr);\n    |                             ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:162:19\n    |\n162 |         outStream.filePtr = NULL!();\n    |                   ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:162:29\n    |\n162 |         outStream.filePtr = NULL!();\n    |                             ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:156:29\n    |\n156 |     if (inStream.filePtr != NULL!()).as_bool() {\n    |                             ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 9 previous errors\n"
            },
            {
                "c_code": "int32_t BzpDeCompressStream(char *inName, char *outName)\n    {\n        int32_t ret = BZP_OK;\n        if (inName == NULL || outName == NULL)\n        {\n            return BZP_ERROR_PARAM;\n        }\n\n        BzpStream *inStream = BzpStreamInit();\n        BzpStream *outStream = BzpStreamInit();\n        if (inStream == NULL || outStream == NULL)\n        {\n            BzpStreamFinish(inStream);\n            BzpStreamFinish(outStream);\n            return BZP_ERROR_MEMORY_OPER_FAILURE;\n        }\n        inStream->filePtr = fopen(inName, \"rb\");\n        outStream->filePtr = fopen(outName, \"wb\");\n        if ((inStream->filePtr == NULL || outStream->filePtr == NULL))\n        {\n            free(inStream);\n            inStream = NULL;\n            free(outStream);\n            outStream = NULL;\n            remove(outName);\n            return BZP_ERROR_IO;\n        }\n        InDeComdata *inData = BzpInDeComdataInit();\n        if (inData == NULL)\n        {\n            BzpDeComStreamFinish(inData, inStream, outStream);\n            remove(outName);\n            return BZP_ERROR_MEMORY_OPER_FAILURE;\n        }\n        inData->input = inStream;\n        inData->output = outStream;\n\n        ret = BZPDeCompressData(inData);\n\n        if (inData->output->nBuf > 0)\n        {\n            int32_t n2 =\n                fwrite((void *)(inData->output->buf), sizeof(uint8_t), inData->output->nBuf, inData->output->filePtr);\n            if (n2 != inData->output->nBuf)\n            {\n                ret = BZP_ERROR_IO;\n            }\n            inData->output->nBuf = 0;\n        }\n\n        BzpDeComStreamFinish(inData, inStream, outStream);\n        if (ret != BZP_OK)\n        {\n            remove(outName);\n        }\n        return ret;\n    }",
                "rust_code": "pub fn BzpDeCompressStream(mut inName: Ptr<u8>, mut outName: Ptr<u8>) -> i32 {\n    let mut ret: i32 = BZP_OK!();\n    if (inName == NULL!()).as_bool() || (outName == NULL!()).as_bool() {\n        return BZP_ERROR_PARAM!();\n    }\n\n    let mut inStream: Ptr<BzpStream> = BzpStreamInit();\n    let mut outStream: Ptr<BzpStream> = BzpStreamInit();\n    if (inStream == NULL!()).as_bool() || (outStream == NULL!()).as_bool() {\n        BzpStreamFinish(inStream.cast());\n        BzpStreamFinish(outStream.cast());\n        return BZP_ERROR_MEMORY_OPER_FAILURE!();\n    }\n    inStream.filePtr = c_fopen!(inName, cstr!(\"rb\"));\n    outStream.filePtr = c_fopen!(outName, cstr!(\"wb\"));\n    if (inStream.filePtr == NULL!()).as_bool() || (outStream.filePtr == NULL!()).as_bool() {\n        c_free!(inStream);\n        inStream = NULL!();\n        c_free!(outStream);\n        outStream = NULL!();\n        c_remove!(outName);\n        return BZP_ERROR_IO!();\n    }\n    let mut inData: Ptr<InDeComdata> = BzpInDeComdataInit();\n    if (inData == NULL!()).as_bool() {\n        BzpDeComStreamFinish(inData.cast(), inStream.cast(), outStream.cast());\n        c_remove!(outName);\n        return BZP_ERROR_MEMORY_OPER_FAILURE!();\n    }\n    inData.input = inStream.cast();\n    inData.output = outStream.cast();\n\n    ret = BZPDeCompressData(inData.cast()).cast();\n\n    if (inData.output.nBuf > 0).as_bool() {\n        let mut n2: i32 = c_fwrite!(inData.output.buf.cast::<Ptr<Void>>(), c_sizeof!(u8), inData.output.nBuf, inData.output.filePtr);\n        if (n2 != inData.output.nBuf).as_bool() {\n            ret = BZP_ERROR_IO!();\n        }\n        inData.output.nBuf = 0;\n    }\n\n    BzpDeComStreamFinish(inData.cast(), inStream.cast(), outStream.cast());\n    if (ret != BZP_OK!()).as_bool() {\n        c_remove!(outName);\n    }\n    return ret.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007014021)\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:173:14\n    |\n173 |     inStream.filePtr = c_fopen!(inName, cstr!(\"rb\"));\n    |              ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:174:15\n    |\n174 |     outStream.filePtr = c_fopen!(outName, cstr!(\"wb\"));\n    |               ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:175:18\n    |\n175 |     if (inStream.filePtr == NULL!()).as_bool() || (outStream.filePtr == NULL!()).as_bool() {\n    |                  ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:175:62\n    |\n175 |     if (inStream.filePtr == NULL!()).as_bool() || (outStream.filePtr == NULL!()).as_bool() {\n    |                                                              ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `input` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:189:12\n    |\n189 |     inData.input = inStream.cast();\n    |            ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `output` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:190:12\n    |\n190 |     inData.output = outStream.cast();\n    |            ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `output` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:194:16\n    |\n194 |     if (inData.output.nBuf > 0).as_bool() {\n    |                ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `output` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:195:44\n    |\n195 |         let mut n2: i32 = c_fwrite!(inData.output.buf.cast::<Ptr<Void>>(), c_sizeof!(u8), inData.output.nBuf, inData.output.filePtr);\n    |                                            ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `output` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:195:98\n    |\n195 |         let mut n2: i32 = c_fwrite!(inData.output.buf.cast::<Ptr<Void>>(), c_sizeof!(u8), inData.output.nBuf, inData.output.filePtr);\n    |                                                                                                  ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `output` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:195:118\n    |\n195 |         let mut n2: i32 = c_fwrite!(inData.output.buf.cast::<Ptr<Void>>(), c_sizeof!(u8), inData.output.nBuf, inData.output.filePtr);\n    |                                                                                                                      ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `output` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:196:26\n    |\n196 |         if (n2 != inData.output.nBuf).as_bool() {\n    |                          ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `output` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_decompress_stream_c.rs:199:16\n    |\n199 |         inData.output.nBuf = 0;\n    |                ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/public/bzp_decompress_stream_c.rs:175:29\n    |\n175 |     if (inStream.filePtr == NULL!()).as_bool() || (outStream.filePtr == NULL!()).as_bool() {\n    |                             ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 13 previous errors\n"
            },
            {
                "c_code": "int32_t BzpOpenFile(BzpAlgorithmInfo *bzpInfo, char *inName, char *outName)\n    {\n        if (bzpInfo == NULL)\n        {\n            return BZP_ERROR_PARAM;\n        }\n        bzpInfo->compressFile->input->filePtr = fopen(inName, \"rb\");\n        bzpInfo->compressFile->output->filePtr = fopen(outName, \"wb\");\n        if ((bzpInfo->compressFile->input->filePtr == NULL || bzpInfo->compressFile->output->filePtr == NULL))\n        {\n            BzpAlgorithmInfoFinish(bzpInfo);\n            remove(outName);\n            return BZP_ERROR_IO;\n        }\n        return BZP_OK;\n    }",
                "rust_code": "pub fn BzpOpenFile(mut bzpInfo: Ptr<BzpAlgorithmInfo>, mut inName: Ptr<u8>, mut outName: Ptr<u8>) -> i32 {\n    if (bzpInfo == NULL!()).as_bool() {\n        return BZP_ERROR_PARAM!();\n    }\n    bzpInfo.compressFile.input.filePtr = c_fopen!(inName, cstr!(\"rb\"));\n    bzpInfo.compressFile.output.filePtr = c_fopen!(outName, cstr!(\"wb\"));\n    if (bzpInfo.compressFile.input.filePtr == NULL!()).as_bool() || (bzpInfo.compressFile.output.filePtr == NULL!()).as_bool() {\n        BzpAlgorithmInfoFinish(bzpInfo.cast());\n        c_remove!(outName);\n        return BZP_ERROR_IO!();\n    }\n    return BZP_OK!();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007014446)\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_compress_stream_c.rs:26:32\n   |\n26 |     bzpInfo.compressFile.input.filePtr = c_fopen!(inName, cstr!(\"rb\"));\n   |                                ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_compress_stream_c.rs:27:33\n   |\n27 |     bzpInfo.compressFile.output.filePtr = c_fopen!(outName, cstr!(\"wb\"));\n   |                                 ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_compress_stream_c.rs:28:36\n   |\n28 |     if (bzpInfo.compressFile.input.filePtr == NULL!()).as_bool() || (bzpInfo.compressFile.output.filePtr == NULL!()).as_bool() {\n   |                                    ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_compress_stream_c.rs:28:98\n   |\n28 |     if (bzpInfo.compressFile.input.filePtr == NULL!()).as_bool() || (bzpInfo.compressFile.output.filePtr == NULL!()).as_bool() {\n   |                                                                                                  ^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:28:47\n    |\n28  |     if (bzpInfo.compressFile.input.filePtr == NULL!()).as_bool() || (bzpInfo.compressFile.output.filePtr == NULL!()).as_bool() {\n    |                                               ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
            },
            {
                "c_code": "BzpFile *BzpFileInit()\n    {\n        BzpFile *compressFile = (BzpFile *)malloc(sizeof(BzpFile));\n        BzpStream *inStream = BzpStreamInit();\n        BzpStream *outStream = BzpStreamInit();\n        if (compressFile == NULL || inStream == NULL || outStream == NULL)\n        {\n            BzpStreamFinish(inStream);\n            BzpStreamFinish(outStream);\n            BzpFileFinish(compressFile);\n            return NULL;\n        }\n        compressFile->input = inStream;\n        compressFile->output = outStream;\n        compressFile->input->pos = 0;\n        compressFile->output->pos = 0;\n        compressFile->num = 0;\n        compressFile->lasChar = BZP_ASCII_SIZE;\n        compressFile->state = BZP_INPUT_COMPRESS;\n        return compressFile;\n    }",
                "rust_code": "pub fn BzpFileInit() -> Ptr<BzpFile> {\n    let mut compressFile: Ptr<BzpFile> = c_malloc!(c_sizeof!(BzpFile));\n    let mut inStream: Ptr<BzpStream> = BzpStreamInit();\n    let mut outStream: Ptr<BzpStream> = BzpStreamInit();\n    if (compressFile == NULL!()).as_bool() || (inStream == NULL!()).as_bool() || (outStream == NULL!()).as_bool() {\n        BzpStreamFinish(inStream.cast());\n        BzpStreamFinish(outStream.cast());\n        BzpFileFinish(compressFile.cast());\n        return NULL!();\n    }\n    compressFile.input = inStream.cast();\n    compressFile.output = outStream.cast();\n    compressFile.input.pos = 0;\n    compressFile.output.pos = 0;\n    compressFile.num = 0;\n    compressFile.lasChar = BZP_ASCII_SIZE!();\n    compressFile.state = BZP_INPUT_COMPRESS!();\n    return compressFile.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007014880)\nerror[E0609]: no field `pos` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_compress_stream_c.rs:51:24\n   |\n51 |     compressFile.input.pos = 0;\n   |                        ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `pos` on type `memory::ptr::Ptr<i32>`\n  --> src/src/public/bzp_compress_stream_c.rs:52:25\n   |\n52 |     compressFile.output.pos = 0;\n   |                         ^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "void BzpWriteToArray(int32_t val, int32_t n, BzpOutComdata *data)\n    {\n\n        while (data->nBuf >= BZP_BITS8)\n        {\n            data->out[data->num++] = (uint8_t)(data->buf >> BZP_BITS24);\n            data->nBuf -= BZP_BITS8;\n            data->buf <<= BZP_BITS8;\n        }\n        data->buf |= (val << (BZP_BITS32 - n - data->nBuf));\n        data->nBuf += n;\n    }",
                "rust_code": "pub fn BzpWriteToArray(mut val: i32, mut n: i32, mut data: Ptr<BzpOutComdata>) {\n    while (data.nBuf >= BZP_BITS8!()).as_bool() {\n        data.out[data.num] = (data.buf >> BZP_BITS24!()).cast::<u8>();\n        data.num += 1;\n        data.nBuf -= BZP_BITS8!();\n        data.buf <<= BZP_BITS8!();\n    }\n    data.buf |= (val << (BZP_BITS32!() - n - data.nBuf)).cast::<u32>();\n    data.nBuf += n;\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007015760)\nerror[E0502]: cannot borrow `data` as immutable because it is also borrowed as mutable\n  --> src/src/public/bzp_compress_stream_c.rs:87:18\n   |\n87 |         data.out[data.num] = (data.buf >> BZP_BITS24!()).cast::<u8>();\n   |         ----    -^^^^-----\n   |         |       ||\n   |         |       |immutable borrow occurs here\n   |         |       mutable borrow later used here\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing this...\n  --> src/src/public/bzp_compress_stream_c.rs:87:18\n   |\n87 |         data.out[data.num] = (data.buf >> BZP_BITS24!()).cast::<u8>();\n   |                  ^^^^^^^^\nhelp: ...and then using that local here\n  --> src/src/public/bzp_compress_stream_c.rs:87:17\n   |\n87 |         data.out[data.num] = (data.buf >> BZP_BITS24!()).cast::<u8>();\n   |                 ^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void BzpCalculateCRC(BzpBwtInfo *bwt)\n    {\n        bwt->blockCRC = ~(bwt->blockCRC);\n        bwt->combinedCRC = (bwt->combinedCRC << 1) | (bwt->combinedCRC >> BZP_CRC_MOVE_RIGHT_VAL);\n        bwt->combinedCRC ^= bwt->blockCRC;\n    }",
                "rust_code": "pub fn BzpCalculateCRC(mut bwt: Ptr<BzpBwtInfo>) {\n    bwt.blockCRC = !(bwt.blockCRC);\n    bwt.combinedCRC = (bwt.combinedCRC << 1) | (bwt.combinedCRC >> BZP_CRC_MOVE_RIGHT_VAL!());\n    bwt.combinedCRC ^= bwt.blockCRC;\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007016617)\nerror[E0609]: no field `blockCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:119:9\n    |\n119 |     bwt.blockCRC = !(bwt.blockCRC);\n    |         ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `blockCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:119:26\n    |\n119 |     bwt.blockCRC = !(bwt.blockCRC);\n    |                          ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `combinedCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:120:9\n    |\n120 |     bwt.combinedCRC = (bwt.combinedCRC << 1) | (bwt.combinedCRC >> BZP_CRC_MOVE_RIGHT_VAL!());\n    |         ^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `combinedCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:120:28\n    |\n120 |     bwt.combinedCRC = (bwt.combinedCRC << 1) | (bwt.combinedCRC >> BZP_CRC_MOVE_RIGHT_VAL!());\n    |                            ^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `combinedCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:120:53\n    |\n120 |     bwt.combinedCRC = (bwt.combinedCRC << 1) | (bwt.combinedCRC >> BZP_CRC_MOVE_RIGHT_VAL!());\n    |                                                     ^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `combinedCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:121:9\n    |\n121 |     bwt.combinedCRC ^= bwt.blockCRC;\n    |         ^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `blockCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:121:28\n    |\n121 |     bwt.combinedCRC ^= bwt.blockCRC;\n    |                            ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 7 previous errors\n"
            },
            {
                "c_code": "void BzpWriteBlockHead(BzpOutComdata *outData, BzpBwtInfo *bwt)\n    {\n        BzpWriteToArray(BZP_BLOCK_HEAD_0, BZP_BITS8, outData);\n        BzpWriteToArray(BZP_BLOCK_HEAD_1, BZP_BITS8, outData);\n        BzpWriteToArray(BZP_BLOCK_HEAD_2, BZP_BITS8, outData);\n        BzpWriteToArray(BZP_BLOCK_HEAD_3, BZP_BITS8, outData);\n        BzpWriteToArray(BZP_BLOCK_HEAD_4, BZP_BITS8, outData);\n        BzpWriteToArray(BZP_BLOCK_HEAD_5, BZP_BITS8, outData);\n        BzpWriteInt32(bwt->blockCRC, outData);\n        BzpWriteToArray(0, BZP_BIT, outData);\n        BzpWriteToArray(bwt->oriPtr, BZP_BITS24, outData);\n    }",
                "rust_code": "pub fn BzpWriteBlockHead(mut outData: Ptr<BzpOutComdata>, mut bwt: Ptr<BzpBwtInfo>) {\n    BzpWriteToArray(BZP_BLOCK_HEAD_0!(), BZP_BITS8!(), outData.cast());\n    BzpWriteToArray(BZP_BLOCK_HEAD_1!(), BZP_BITS8!(), outData.cast());\n    BzpWriteToArray(BZP_BLOCK_HEAD_2!(), BZP_BITS8!(), outData.cast());\n    BzpWriteToArray(BZP_BLOCK_HEAD_3!(), BZP_BITS8!(), outData.cast());\n    BzpWriteToArray(BZP_BLOCK_HEAD_4!(), BZP_BITS8!(), outData.cast());\n    BzpWriteToArray(BZP_BLOCK_HEAD_5!(), BZP_BITS8!(), outData.cast());\n    BzpWriteInt32(bwt.blockCRC.cast(), outData.cast());\n    BzpWriteToArray(0, BZP_BIT!(), outData.cast());\n    BzpWriteToArray(bwt.oriPtr.cast(), BZP_BITS24!(), outData.cast());\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007016833)\nerror[E0609]: no field `blockCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:130:23\n    |\n130 |     BzpWriteInt32(bwt.blockCRC.cast(), outData.cast());\n    |                       ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `oriPtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:132:25\n    |\n132 |     BzpWriteToArray(bwt.oriPtr.cast(), BZP_BITS24!(), outData.cast());\n    |                         ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "void BzpWriteValidASCII(BzpOutComdata *outData, BzpBwtInfo *bwt)\n    {\n        int32_t validGid[BZP_ASCII_SIZE], cnt = 0;\n        bool use16[BZP_ASCII_SIZE];\n        (void)memset_s(use16, sizeof(use16), 0, sizeof(use16));\n\n        for (int32_t i = 0; i < BZP_ASCII_SIZE; i++)\n        {\n            int32_t gid = i / BZP_CHARS_PER_GROUP_ASCII;\n            use16[gid] |= bwt->inUse[i];\n        }\n        for (int32_t i = 0; i < BZP_GROUPS_ASCII; i++)\n        {\n            BzpWriteToArray((int32_t)(use16[i]), BZP_BIT, outData);\n            if (use16[i])\n            {\n                validGid[cnt++] = i;\n            }\n        }\n        for (int32_t i = 0; i < cnt; i++)\n        {\n            for (int32_t j = 0; j < BZP_CHARS_PER_GROUP_ASCII; j++)\n            {\n                int32_t valid = validGid[i] * BZP_CHARS_PER_GROUP_ASCII + j;\n                BzpWriteToArray((int32_t)(bwt->inUse[valid]), BZP_BIT, outData);\n            }\n        }\n    }",
                "rust_code": "pub fn BzpWriteValidASCII(mut outData: Ptr<BzpOutComdata>, mut bwt: Ptr<BzpBwtInfo>) {\n    let mut validGid: Array<i32, { BZP_ASCII_SIZE!() }> = Default::default();\n    let mut cnt: i32 = 0;\n    let mut use16: Array<bool, { BZP_ASCII_SIZE!() }> = Default::default();\n    c_memset_s!(use16, c_sizeofval!(use16), 0, c_sizeofval!(use16)).cast::<Void>();\n\n    c_for!(let mut i: i32 = 0; i < BZP_ASCII_SIZE!(); i.suffix_plus_plus(); {\n        let mut gid: i32 = i / BZP_CHARS_PER_GROUP_ASCII!();\n        use16[gid] |= bwt.inUse[i];\n    });\n    c_for!(let mut i: i32 = 0; i < BZP_GROUPS_ASCII!(); i.suffix_plus_plus(); {\n        BzpWriteToArray(use16[i].cast::<i32>(), BZP_BIT!(), outData.cast());\n        if use16[i].as_bool() {\n            validGid[cnt] = i.cast();\n            cnt += 1;\n        }\n    });\n    c_for!(let mut i: i32 = 0; i < cnt; i.suffix_plus_plus(); {\n        c_for!(let mut j: i32 = 0; j < BZP_CHARS_PER_GROUP_ASCII!(); j.suffix_plus_plus(); {\n            let mut valid: i32 = validGid[i] * BZP_CHARS_PER_GROUP_ASCII!() + j;\n            BzpWriteToArray(bwt.inUse[valid].cast::<i32>(), BZP_BIT!(), outData.cast());\n        });\n    });\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007017042)\nerror[E0609]: no field `inUse` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:136:27\n    |\n136 |         use16[gid] |= bwt.inUse[i];\n    |                           ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `inUse` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:148:33\n    |\n148 |             BzpWriteToArray(bwt.inUse[valid].cast::<i32>(), BZP_BIT!(), outData.cast());\n    |                                 ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "void BzpWriteSelect(BzpOutComdata *outData, BzpHuffmanGroups *huffman)\n    {\n\n        BzpWriteToArray(huffman->nSelect, BZP_BITS15, outData);\n\n        for (int32_t i = 0; i < huffman->nSelect; i++)\n        {\n            for (int32_t j = 0; j < huffman->selectMTF[i]; j++)\n            {\n                BzpWriteToArray(1, BZP_BIT, outData);\n            }\n            BzpWriteToArray(0, BZP_BIT, outData);\n        }\n    }",
                "rust_code": "pub fn BzpWriteSelect(mut outData: Ptr<BzpOutComdata>, mut huffman: Ptr<BzpHuffmanGroups>) {\n    BzpWriteToArray(huffman.nSelect.cast(), BZP_BITS15!(), outData.cast());\n    c_for!(let mut i: i32 = 0; i < huffman.nSelect; i.suffix_plus_plus(); {\n        c_for!(let mut j: i32 = 0; j < huffman.selectMTF[i]; j.suffix_plus_plus(); {\n            BzpWriteToArray(1, BZP_BIT!(), outData.cast());\n        });\n        BzpWriteToArray(0, BZP_BIT!(), outData.cast());\n    });\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007017257)\nerror[E0609]: no field `nSelect` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:134:29\n    |\n134 |     BzpWriteToArray(huffman.nSelect.cast(), BZP_BITS15!(), outData.cast());\n    |                             ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nSelect` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:135:44\n    |\n135 |     c_for!(let mut i: i32 = 0; i < huffman.nSelect; i.suffix_plus_plus(); {\n    |                                            ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `selectMTF` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:136:48\n    |\n136 |         c_for!(let mut j: i32 = 0; j < huffman.selectMTF[i]; j.suffix_plus_plus(); {\n    |                                                ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "void BzpWriteLen(BzpOutComdata *outData, BzpHuffmanGroups *huffman)\n    {\n        for (int32_t i = 0; i < huffman->nGroups; i++)\n        {\n            int32_t val = huffman->huffmanGroups[i].len[0];\n            BzpWriteToArray(val, BZP_BITS5, outData);\n\n            for (int32_t j = 0; j < huffman->alphaSize; j++)\n            {\n                int32_t tar = huffman->huffmanGroups[i].len[j];\n                int32_t deta = 0, saveVal = 0;\n                if (val < tar)\n                {\n                    saveVal = BZP_HUFFMAN_LEN_INCREASE;\n                    deta = 1;\n                }\n                else if (val > tar)\n                {\n                    saveVal = BZP_HUFFMAN_LEN_REDUCED;\n                    deta = -1;\n                }\n                while (val != tar)\n                {\n                    BzpWriteToArray(saveVal, BZP_BITS2, outData);\n                    val += deta;\n                }\n                BzpWriteToArray(0, BZP_BIT, outData);\n            }\n        }\n    }",
                "rust_code": "pub fn BzpWriteLen(mut outData: Ptr<BzpOutComdata>, mut huffman: Ptr<BzpHuffmanGroups>) {\n    c_for!(let mut i: i32 = 0; i < huffman.nGroups; i.suffix_plus_plus(); {\n        let mut val: i32 = huffman.huffmanGroups[i].len[0];\n        BzpWriteToArray(val.cast(), BZP_BITS5!(), outData.cast());\n\n        c_for!(let mut j: i32 = 0; j < huffman.alphaSize; j.suffix_plus_plus(); {\n            let mut tar: i32 = huffman.huffmanGroups[i].len[j];\n            let mut deta: i32 = 0;\n            let mut saveVal: i32 = 0;\n            if (val < tar).as_bool() {\n                saveVal = BZP_HUFFMAN_LEN_INCREASE!();\n                deta = 1;\n            } else if (val > tar).as_bool() {\n                saveVal = BZP_HUFFMAN_LEN_REDUCED!();\n                deta = -1;\n            }\n            while (val != tar).as_bool() {\n                BzpWriteToArray(saveVal.cast(), BZP_BITS2!(), outData.cast());\n                val += deta;\n            }\n            BzpWriteToArray(0, BZP_BIT!(), outData.cast());\n        });\n    });\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007017479)\nerror[E0609]: no field `nGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:139:44\n    |\n139 |     c_for!(let mut i: i32 = 0; i < huffman.nGroups; i.suffix_plus_plus(); {\n    |                                            ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `huffmanGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:140:36\n    |\n140 |         let mut val: i32 = huffman.huffmanGroups[i].len[0];\n    |                                    ^^^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `alphaSize` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:143:48\n    |\n143 |         c_for!(let mut j: i32 = 0; j < huffman.alphaSize; j.suffix_plus_plus(); {\n    |                                                ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `huffmanGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:144:40\n    |\n144 |             let mut tar: i32 = huffman.huffmanGroups[i].len[j];\n    |                                        ^^^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
            },
            {
                "c_code": "void BzpWriteInputEncode(BzpOutComdata *outData, BzpMtfInfo *mtf, BzpHuffmanGroups *huffman)\n    {\n        for (int32_t i = 0; i < mtf->nMtf; i++)\n        {\n            int32_t val = mtf->mtfV[i];\n            int32_t gid = huffman->select[i / BZP_ELEMS_NUM_IN_ONE_GROUP];\n            int32_t code = huffman->huffmanGroups[gid].table[val];\n            int32_t len = huffman->huffmanGroups[gid].len[val];\n            BzpWriteToArray(code, len, outData);\n        }\n    }",
                "rust_code": "pub fn BzpWriteInputEncode(mut outData: Ptr<BzpOutComdata>, mut mtf: Ptr<BzpMtfInfo>, mut huffman: Ptr<BzpHuffmanGroups>) {\n    c_for!(let mut i: i32 = 0; i < mtf.nMtf; i.suffix_plus_plus(); {\n        let mut val: i32 = mtf.mtfV[i].cast();\n        let mut gid: i32 = huffman.select[i / BZP_ELEMS_NUM_IN_ONE_GROUP!()].cast();\n        let mut code: i32 = huffman.huffmanGroups[gid].table[val].cast();\n        let mut len: i32 = huffman.huffmanGroups[gid].len[val].cast();\n        BzpWriteToArray(code.cast(), len.cast(), outData.cast());\n    });\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007017693)\nerror[E0609]: no field `nMtf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:144:40\n    |\n144 |     c_for!(let mut i: i32 = 0; i < mtf.nMtf; i.suffix_plus_plus(); {\n    |                                        ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `mtfV` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:145:32\n    |\n145 |         let mut val: i32 = mtf.mtfV[i].cast();\n    |                                ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `select` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:146:36\n    |\n146 |         let mut gid: i32 = huffman.select[i / BZP_ELEMS_NUM_IN_ONE_GROUP!()].cast();\n    |                                    ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `huffmanGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:147:37\n    |\n147 |         let mut code: i32 = huffman.huffmanGroups[gid].table[val].cast();\n    |                                     ^^^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `huffmanGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:148:36\n    |\n148 |         let mut len: i32 = huffman.huffmanGroups[gid].len[val].cast();\n    |                                    ^^^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
            },
            {
                "c_code": "void BzpFlushbuf(BzpOutComdata *outData)\n    {\n        while (outData->nBuf > 0)\n        {\n            outData->out[outData->num++] = (uint8_t)(outData->buf >> BZP_BITS24);\n            outData->nBuf -= BZP_BITS8;\n            outData->buf <<= BZP_BITS8;\n        }\n    }",
                "rust_code": "pub fn BzpFlushbuf(mut outData: Ptr<BzpOutComdata>) {\n    while (outData.nBuf > 0).as_bool() {\n        outData.out[outData.num] = (outData.buf >> BZP_BITS24!()).cast::<u8>();\n        outData.num += 1;\n        outData.nBuf -= BZP_BITS8!();\n        outData.buf <<= BZP_BITS8!();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007018121)\nerror[E0502]: cannot borrow `outData` as immutable because it is also borrowed as mutable\n   --> src/src/public/bzp_compress_stream_c.rs:161:21\n    |\n161 |         outData.out[outData.num] = (outData.buf >> BZP_BITS24!()).cast::<u8>();\n    |         -------    -^^^^^^^-----\n    |         |          ||\n    |         |          |immutable borrow occurs here\n    |         |          mutable borrow later used here\n    |         mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/public/bzp_compress_stream_c.rs:161:21\n    |\n161 |         outData.out[outData.num] = (outData.buf >> BZP_BITS24!()).cast::<u8>();\n    |                     ^^^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/public/bzp_compress_stream_c.rs:161:20\n    |\n161 |         outData.out[outData.num] = (outData.buf >> BZP_BITS24!()).cast::<u8>();\n    |                    ^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int32_t BzpCompressOneBlock(BzpAlgorithmInfo *bzpInfo, BzpOutComdata *outData)\n    {\n        BzpBwtInfo *bwt = bzpInfo->bwt;\n        BzpMtfInfo *mtf = bzpInfo->mtf;\n        BzpHuffmanGroups *huffman = bzpInfo->huffman;\n        int ret = BZP_OK;\n        if (bwt->nBlock == 0)\n        {\n            return BZP_OK;\n        }\n\n        BzpWriteFileHead(outData, bwt->blockId);\n        if (bwt->nBlock > 0)\n        {\n\n            BzpCalculateCRC(bwt);\n\n            BzpBlockSortMain(bwt);\n\n            BzpMtfReSet(mtf);\n\n            mtf->block = bwt->block;\n            mtf->map = bwt->sortBlock;\n            mtf->inUse = bwt->inUse;\n            mtf->nBlock = bwt->nBlock;\n\n            BzpMtfMain(mtf);\n\n            ret = BzpHuffmanGroupsReset(huffman, mtf->nUse + BZP_EXTRA_CHARS_NUM);\n            if (ret != BZP_OK)\n            {\n                return ret;\n            }\n\n            huffman->block = mtf->mtfV;\n            huffman->mtfFreq = mtf->mtfFreq;\n            huffman->nBlock = mtf->nMtf;\n\n            BzpHuffmanMain(huffman);\n\n            BzpWriteBlockHead(outData, bwt);\n\n            BzpWriteValidASCII(outData, bwt);\n\n            BzpWriteToArray(huffman->nGroups, BZP_BITS3, outData);\n\n            BzpWriteSelect(outData, huffman);\n\n            BzpWriteLen(outData, huffman);\n\n            BzpWriteInputEncode(outData, mtf, huffman);\n        }\n        return BZP_OK;\n    }",
                "rust_code": "pub fn BzpCompressOneBlock(mut bzpInfo: Ptr<BzpAlgorithmInfo>, mut outData: Ptr<BzpOutComdata>) -> i32 {\n    let mut bwt: Ptr<BzpBwtInfo> = bzpInfo.bwt.cast();\n    let mut mtf: Ptr<BzpMtfInfo> = bzpInfo.mtf.cast();\n    let mut huffman: Ptr<BzpHuffmanGroups> = bzpInfo.huffman.cast();\n    let mut ret: i32 = BZP_OK!();\n    if (bwt.nBlock == 0).as_bool() {\n        return BZP_OK!();\n    }\n\n    BzpWriteFileHead(outData.cast(), bwt.blockId.cast());\n    if (bwt.nBlock > 0).as_bool() {\n        BzpCalculateCRC(bwt.cast());\n\n        BzpBlockSortMain(bwt.cast());\n\n        BzpMtfReSet(mtf.cast());\n\n        mtf.block = bwt.block.cast();\n        mtf.map = bwt.sortBlock.cast();\n        mtf.inUse = bwt.inUse.cast();\n        mtf.nBlock = bwt.nBlock.cast();\n\n        BzpMtfMain(mtf.cast());\n\n        ret = BzpHuffmanGroupsReset(huffman.cast(), (mtf.nUse + BZP_EXTRA_CHARS_NUM!()).cast()).cast();\n        if (ret != BZP_OK!()).as_bool() {\n            return ret;\n        }\n\n        huffman.block = mtf.mtfV.cast();\n        huffman.mtfFreq = mtf.mtfFreq.cast();\n        huffman.nBlock = mtf.nMtf.cast();\n\n        BzpHuffmanMain(huffman.cast());\n\n        BzpWriteBlockHead(outData.cast(), bwt.cast());\n\n        BzpWriteValidASCII(outData.cast(), bwt.cast());\n\n        BzpWriteToArray(huffman.nGroups.cast(), BZP_BITS3!(), outData.cast());\n\n        BzpWriteSelect(outData.cast(), huffman.cast());\n\n        BzpWriteLen(outData.cast(), huffman.cast());\n\n        BzpWriteInputEncode(outData.cast(), mtf.cast(), huffman.cast());\n    }\n    return BZP_OK!();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007018325)\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:169:13\n    |\n169 |     if (bwt.nBlock == 0).as_bool() {\n    |             ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `blockId` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:173:42\n    |\n173 |     BzpWriteFileHead(outData.cast(), bwt.blockId.cast());\n    |                                          ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:174:13\n    |\n174 |     if (bwt.nBlock > 0).as_bool() {\n    |             ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:181:13\n    |\n181 |         mtf.block = bwt.block.cast();\n    |             ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:181:25\n    |\n181 |         mtf.block = bwt.block.cast();\n    |                         ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `map` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:182:13\n    |\n182 |         mtf.map = bwt.sortBlock.cast();\n    |             ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `sortBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:182:23\n    |\n182 |         mtf.map = bwt.sortBlock.cast();\n    |                       ^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `inUse` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:183:13\n    |\n183 |         mtf.inUse = bwt.inUse.cast();\n    |             ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `inUse` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:183:25\n    |\n183 |         mtf.inUse = bwt.inUse.cast();\n    |                         ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:184:13\n    |\n184 |         mtf.nBlock = bwt.nBlock.cast();\n    |             ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:184:26\n    |\n184 |         mtf.nBlock = bwt.nBlock.cast();\n    |                          ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nUse` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:188:58\n    |\n188 |         ret = BzpHuffmanGroupsReset(huffman.cast(), (mtf.nUse + BZP_EXTRA_CHARS_NUM!()).cast()).cast();\n    |                                                          ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:193:17\n    |\n193 |         huffman.block = mtf.mtfV.cast();\n    |                 ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `mtfV` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:193:29\n    |\n193 |         huffman.block = mtf.mtfV.cast();\n    |                             ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `mtfFreq` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:194:17\n    |\n194 |         huffman.mtfFreq = mtf.mtfFreq.cast();\n    |                 ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `mtfFreq` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:194:31\n    |\n194 |         huffman.mtfFreq = mtf.mtfFreq.cast();\n    |                               ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:195:17\n    |\n195 |         huffman.nBlock = mtf.nMtf.cast();\n    |                 ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nMtf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:195:30\n    |\n195 |         huffman.nBlock = mtf.nMtf.cast();\n    |                              ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nGroups` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:203:33\n    |\n203 |         BzpWriteToArray(huffman.nGroups.cast(), BZP_BITS3!(), outData.cast());\n    |                                 ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 19 previous errors\n"
            },
            {
                "c_code": "int32_t BzpBuffToStream(BzpFile *bzpf, BzpOutComdata *outData)\n    {\n        bzpf->output->pos = 0;\n\n        int32_t pos = 0;\n\n        while (pos < outData->num)\n        {\n            bzpf->output->nBuf = 0;\n\n            while (pos < outData->num && bzpf->output->nBuf < BZP_BUF_SIZE)\n            {\n                bzpf->output->buf[bzpf->output->nBuf++] = outData->out[pos];\n                pos++;\n            }\n            int32_t n2 =\n                fwrite((void *)(bzpf->output->buf), sizeof(uint8_t), bzpf->output->nBuf, bzpf->output->filePtr);\n            if (n2 != bzpf->output->nBuf)\n            {\n                return BZP_ERROR_IO;\n            }\n        }\n        return BZP_OK;\n    }",
                "rust_code": "pub fn BzpBuffToStream(mut bzpf: Ptr<BzpFile>, mut outData: Ptr<BzpOutComdata>) -> i32 {\n    bzpf.output.pos = 0;\n    let mut pos: i32 = 0;\n    while (pos < outData.num).as_bool() {\n        bzpf.output.nBuf = 0;\n        while (pos < outData.num).as_bool() && (bzpf.output.nBuf < BZP_BUF_SIZE!()).as_bool() {\n            bzpf.output.buf[bzpf.output.nBuf] = outData.out[pos].cast();\n            bzpf.output.nBuf += 1;\n            pos += 1;\n        }\n        let mut n2: i32 = c_fwrite!(bzpf.output.buf.cast::<Ptr<Void>>(), c_sizeof!(u8), bzpf.output.nBuf, bzpf.output.filePtr);\n        if (n2 != bzpf.output.nBuf).as_bool() {\n            return BZP_ERROR_IO!();\n        }\n    }\n    return BZP_OK!();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007018533)\nerror[E0609]: no field `pos` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:170:17\n    |\n170 |     bzpf.output.pos = 0;\n    |                 ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:173:21\n    |\n173 |         bzpf.output.nBuf = 0;\n    |                     ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:174:61\n    |\n174 |         while (pos < outData.num).as_bool() && (bzpf.output.nBuf < BZP_BUF_SIZE!()).as_bool() {\n    |                                                             ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `buf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:175:25\n    |\n175 |             bzpf.output.buf[bzpf.output.nBuf] = outData.out[pos].cast();\n    |                         ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:175:41\n    |\n175 |             bzpf.output.buf[bzpf.output.nBuf] = outData.out[pos].cast();\n    |                                         ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:176:25\n    |\n176 |             bzpf.output.nBuf += 1;\n    |                         ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `buf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:179:49\n    |\n179 |         let mut n2: i32 = c_fwrite!(bzpf.output.buf.cast::<Ptr<Void>>(), c_sizeof!(u8), bzpf.output.nBuf, bzpf.output.filePtr);\n    |                                                 ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:179:101\n    |\n179 |         let mut n2: i32 = c_fwrite!(bzpf.output.buf.cast::<Ptr<Void>>(), c_sizeof!(u8), bzpf.output.nBuf, bzpf.output.filePtr);\n    |                                                                                                     ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:179:119\n    |\n179 |         let mut n2: i32 = c_fwrite!(bzpf.output.buf.cast::<Ptr<Void>>(), c_sizeof!(u8), bzpf.output.nBuf, bzpf.output.filePtr);\n    |                                                                                                                       ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:180:31\n    |\n180 |         if (n2 != bzpf.output.nBuf).as_bool() {\n    |                               ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 10 previous errors\n"
            },
            {
                "c_code": "void BzpAddCharToBlock(uint8_t lasch, int32_t num, BzpBwtInfo *bwt)\n    {\n        if (num < BZP_RLC_NUM_LOWER_LIMIT || num > BZP_RLC_NUM_UPPER_LIMIT)\n        {\n            return;\n        }\n        for (int32_t i = 0; i < num; i++)\n        {\n            BZP_UPDATE_CRC(bwt->blockCRC, lasch);\n        }\n\n        int32_t val = BZP_MIN_FUN(num, (int32_t)BZP_RLC_NUM_4);\n        switch (val)\n        {\n        case BZP_RLC_NUM_4:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_3:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_2:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        case BZP_RLC_NUM_1:\n            bwt->block[bwt->nBlock++] = lasch;\n\n        default:\n            break;\n        }\n        if (num >= BZP_RLC_NUM_4)\n        {\n            bwt->block[bwt->nBlock++] = ((char)(num - BZP_RLC_NUM_4));\n            bwt->inUse[num - BZP_RLC_NUM_4] = true;\n        }\n\n        bwt->inUse[lasch] = true;\n    }",
                "rust_code": "pub fn BzpAddCharToBlock(mut lasch: u8, mut num: i32, mut bwt: Ptr<BzpBwtInfo>) {\n    if (num < BZP_RLC_NUM_LOWER_LIMIT!()).as_bool() || (num > BZP_RLC_NUM_UPPER_LIMIT!()).as_bool() {\n        return;\n    }\n    c_for!(let mut i: i32 = 0; i < num; i.suffix_plus_plus(); {\n        BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    });\n\n    let mut val: i32 = BZP_MIN_FUN!(num, BZP_RLC_NUM_4!().cast()).cast();\n    c_switch!(val, {\n        BZP_RLC_NUM_4!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch.cast();\n            break;\n        },\n        BZP_RLC_NUM_3!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch.cast();\n            break;\n        },\n        BZP_RLC_NUM_2!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch.cast();\n            break;\n        },\n        BZP_RLC_NUM_1!() => {\n            bwt.block[bwt.nBlock.suffix_plus_plus()] = lasch.cast();\n            break;\n        },\n        _ => {\n            break;\n        },\n    });\n    if (num >= BZP_RLC_NUM_4!()).as_bool() {\n        bwt.block[bwt.nBlock.suffix_plus_plus()] = (num - BZP_RLC_NUM_4!()).cast::<u8>();\n        bwt.inUse[num - BZP_RLC_NUM_4!()] = true;\n    }\n\n    bwt.inUse[lasch] = true;\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007018743)\nerror: no rules expected `,`\n   --> src/src/public/bzp_compress_stream_c.rs:183:18\n    |\n183 |     c_switch!(val, {\n    |                  ^ no rules expected this token in macro call\n    |\n   ::: src/translation_utils/c_alignment/c_switch.rs:3:1\n    |\n3   | macro_rules! c_switch {\n    | --------------------- when calling this macro\n    |\nnote: while trying to match `;`\n   --> src/translation_utils/c_alignment/c_switch.rs:5:17\n    |\n5   |     ($input:expr; $first:expr => $execute:expr$(,)?) => {\n    |                 ^\n\nerror[E0609]: no field `blockCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:179:29\n    |\n179 |         BZP_UPDATE_CRC!(bwt.blockCRC, lasch);\n    |                             ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `block` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:205:13\n    |\n205 |         bwt.block[bwt.nBlock.suffix_plus_plus()] = (num - BZP_RLC_NUM_4!()).cast::<u8>();\n    |             ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:205:23\n    |\n205 |         bwt.block[bwt.nBlock.suffix_plus_plus()] = (num - BZP_RLC_NUM_4!()).cast::<u8>();\n    |                       ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `inUse` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:206:13\n    |\n206 |         bwt.inUse[num - BZP_RLC_NUM_4!()] = true;\n    |             ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `inUse` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:209:9\n    |\n209 |     bwt.inUse[lasch] = true;\n    |         ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\n"
            },
            {
                "c_code": "void BzpBuffToBlockRLC(BzpFile *bzpf, BzpBwtInfo *bwt, bool IsLastdata)\n    {\n\n        while (!BZP_BLOCK_FULL(bwt) && !BZP_BUFF_READ_EMPTY(bzpf))\n        {\n            int32_t pos = bzpf->input->pos;\n            uint8_t ch = (uint8_t)bzpf->input->buf[pos];\n            uint8_t lasch = (uint8_t)bzpf->lasChar;\n            if (ch != lasch || bzpf->num == BZP_RLC_NUM_UPPER_LIMIT)\n            {\n                BzpAddCharToBlock(lasch, bzpf->num, bwt);\n                bzpf->lasChar = ch;\n                bzpf->num = 1;\n            }\n            else\n            {\n                bzpf->num++;\n            }\n\n            bzpf->input->pos++;\n        }\n\n        if (IsLastdata && BZP_BUFF_READ_EMPTY(bzpf))\n        {\n\n            BzpAddCharToBlock(bzpf->lasChar, bzpf->num, bwt);\n            bzpf->lasChar = BZP_ASCII_SIZE;\n            bzpf->num = 0;\n        }\n    }",
                "rust_code": "pub fn BzpBuffToBlockRLC(mut bzpf: Ptr<BzpFile>, mut bwt: Ptr<BzpBwtInfo>, mut IsLastdata: bool) {\n    while (!BZP_BLOCK_FULL!(bwt).as_bool() && !BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n        let mut pos: i32 = bzpf.input.pos.cast();\n        let mut ch: u8 = bzpf.input.buf[pos].cast::<u8>();\n        let mut lasch: u8 = bzpf.lasChar.cast::<u8>();\n        if (ch != lasch).as_bool() || (bzpf.num == BZP_RLC_NUM_UPPER_LIMIT!()).as_bool() {\n            BzpAddCharToBlock(lasch.cast(), bzpf.num.cast(), bwt.cast());\n            bzpf.lasChar = ch.cast();\n            bzpf.num = 1;\n        } else {\n            bzpf.num += 1;\n        }\n        bzpf.input.pos += 1;\n    }\n    if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n        BzpAddCharToBlock(bzpf.lasChar.cast(), bzpf.num.cast(), bwt.cast());\n        bzpf.lasChar = BZP_ASCII_SIZE!();\n        bzpf.num = 0;\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007018958)\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_stream_utils_h.rs:168:53\n    |\n168 | macro_rules! BZP_BLOCK_FULL { ($bwt:expr) => { $bwt.nBlock >= $bwt.nBlockMax } }\n    |                                                     ^^^^^^ unknown field\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:180:13\n    |\n180 |     while (!BZP_BLOCK_FULL!(bwt).as_bool() && !BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n    |             -------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BLOCK_FULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `nBlockMax` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_stream_utils_h.rs:168:68\n    |\n168 | macro_rules! BZP_BLOCK_FULL { ($bwt:expr) => { $bwt.nBlock >= $bwt.nBlockMax } }\n    |                                                                    ^^^^^^^^^ unknown field\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:180:13\n    |\n180 |     while (!BZP_BLOCK_FULL!(bwt).as_bool() && !BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n    |             -------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BLOCK_FULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `pos` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_stream_utils_h.rs:172:66\n    |\n172 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { $bzpf.input.pos >= $bzpf.input.nBuf } }\n    |                                                                  ^^^ unknown field\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:180:48\n    |\n180 |     while (!BZP_BLOCK_FULL!(bwt).as_bool() && !BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n    |                                                -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_stream_utils_h.rs:172:85\n    |\n172 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { $bzpf.input.pos >= $bzpf.input.nBuf } }\n    |                                                                                     ^^^^ unknown field\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:180:48\n    |\n180 |     while (!BZP_BLOCK_FULL!(bwt).as_bool() && !BZP_BUFF_READ_EMPTY!(bzpf).as_bool()) {\n    |                                                -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `pos` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:181:39\n    |\n181 |         let mut pos: i32 = bzpf.input.pos.cast();\n    |                                       ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `buf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:182:37\n    |\n182 |         let mut ch: u8 = bzpf.input.buf[pos].cast::<u8>();\n    |                                     ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `pos` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:191:20\n    |\n191 |         bzpf.input.pos += 1;\n    |                    ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `pos` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_stream_utils_h.rs:172:66\n    |\n172 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { $bzpf.input.pos >= $bzpf.input.nBuf } }\n    |                                                                  ^^^ unknown field\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:193:32\n    |\n193 |     if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n    |                                -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_stream_utils_h.rs:172:85\n    |\n172 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { $bzpf.input.pos >= $bzpf.input.nBuf } }\n    |                                                                                     ^^^^ unknown field\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:193:32\n    |\n193 |     if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n    |                                -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 9 previous errors\n"
            },
            {
                "c_code": "void BzpResetCompress(BzpBwtInfo *bwt, BzpOutComdata *outData)\n    {\n\n        outData->num = 0;\n\n        bwt->nBlock = 0;\n        bwt->blockCRC = BZP_INIT_BLOCK_CRC;\n        (void)memset_s(bwt->inUse, sizeof(bwt->inUse), 0, sizeof(bwt->inUse));\n        int32_t n = outData->blockSize * BZP_BASE_BLOCK_SIZE * sizeof(int32_t);\n        (void)memset_s(bwt->isStartPos, n, 0, n);\n        bwt->blockId++;\n    }",
                "rust_code": "pub fn BzpResetCompress(mut bwt: Ptr<BzpBwtInfo>, mut outData: Ptr<BzpOutComdata>) {\n    outData.num = 0;\n    bwt.nBlock = 0;\n    bwt.blockCRC = BZP_INIT_BLOCK_CRC!();\n    c_memset_s!(bwt.inUse, c_sizeofval!(bwt.inUse), 0, c_sizeofval!(bwt.inUse)).cast::<Void>();\n    let mut n: i32 = outData.blockSize * BZP_BASE_BLOCK_SIZE!() * c_sizeof!(i32);\n    c_memset_s!(bwt.isStartPos, n, 0, n).cast::<Void>();\n    bwt.blockId += 1;\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007019165)\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:186:9\n    |\n186 |     bwt.nBlock = 0;\n    |         ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `blockCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:187:9\n    |\n187 |     bwt.blockCRC = BZP_INIT_BLOCK_CRC!();\n    |         ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `inUse` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:188:21\n    |\n188 |     c_memset_s!(bwt.inUse, c_sizeofval!(bwt.inUse), 0, c_sizeofval!(bwt.inUse)).cast::<Void>();\n    |                     ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `inUse` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:188:45\n    |\n188 |     c_memset_s!(bwt.inUse, c_sizeofval!(bwt.inUse), 0, c_sizeofval!(bwt.inUse)).cast::<Void>();\n    |                                             ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `inUse` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:188:73\n    |\n188 |     c_memset_s!(bwt.inUse, c_sizeofval!(bwt.inUse), 0, c_sizeofval!(bwt.inUse)).cast::<Void>();\n    |                                                                         ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `isStartPos` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:190:21\n    |\n190 |     c_memset_s!(bwt.isStartPos, n, 0, n).cast::<Void>();\n    |                     ^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `blockId` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:191:9\n    |\n191 |     bwt.blockId += 1;\n    |         ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 7 previous errors\n"
            },
            {
                "c_code": "int32_t BzpProcessData(BzpAlgorithmInfo *bzpInfo, bool IsLastdata)\n    {\n        BzpFile *bzpf = bzpInfo->compressFile;\n        BzpOutComdata *outData = bzpInfo->outData;\n        BzpBwtInfo *bwt = bzpInfo->bwt;\n\n        bzpf->state = BZP_INPUT_COMPRESS;\n        int32_t ret = BZP_OK;\n        while (bzpf->state != BZP_RETUEN_COMPRESS)\n        {\n            if (bzpf->state == BZP_OUTPUT_COMPRESS)\n            {\n\n                ret = BzpBuffToStream(bzpf, outData);\n\n                BzpResetCompress(bwt, outData);\n                bzpf->state = BZP_INPUT_COMPRESS;\n                if (IsLastdata && BZP_BUFF_READ_EMPTY(bzpf))\n                {\n                    bzpf->state = BZP_RETUEN_COMPRESS;\n                }\n            }\n            if (bzpf->state == BZP_INPUT_COMPRESS)\n            {\n\n                BzpBuffToBlockRLC(bzpf, bwt, IsLastdata);\n\n                if (IsLastdata && BZP_BUFF_READ_EMPTY(bzpf))\n                {\n                    ret = BzpCompressOneBlock(bzpInfo, outData);\n\n                    BzpWriteFileEnd(outData, bwt->combinedCRC);\n                    BzpFlushbuf(outData);\n\n                    bzpf->state = BZP_OUTPUT_COMPRESS;\n                }\n                else if (BZP_BLOCK_FULL(bwt))\n                {\n                    ret = BzpCompressOneBlock(bzpInfo, outData);\n                    bzpf->state = BZP_OUTPUT_COMPRESS;\n                }\n                else\n                {\n                    bzpf->state = BZP_RETUEN_COMPRESS;\n                }\n            }\n            if (ret != BZP_OK)\n            {\n                return ret;\n            }\n        }\n        return ret;\n    }",
                "rust_code": "pub fn BzpProcessData(mut bzpInfo: Ptr<BzpAlgorithmInfo>, mut IsLastdata: bool) -> i32 {\n    let mut bzpf: Ptr<BzpFile> = bzpInfo.compressFile.cast();\n    let mut outData: Ptr<BzpOutComdata> = bzpInfo.outData.cast();\n    let mut bwt: Ptr<BzpBwtInfo> = bzpInfo.bwt.cast();\n\n    bzpf.state = BZP_INPUT_COMPRESS!();\n    let mut ret: i32 = BZP_OK!();\n    while (bzpf.state != BZP_RETUEN_COMPRESS!()).as_bool() {\n        if (bzpf.state == BZP_OUTPUT_COMPRESS!()).as_bool() {\n            ret = BzpBuffToStream(bzpf.cast(), outData.cast()).cast();\n\n            BzpResetCompress(bwt.cast(), outData.cast());\n            bzpf.state = BZP_INPUT_COMPRESS!();\n            if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n                bzpf.state = BZP_RETUEN_COMPRESS!();\n            }\n        }\n        if (bzpf.state == BZP_INPUT_COMPRESS!()).as_bool() {\n            BzpBuffToBlockRLC(bzpf.cast(), bwt.cast(), IsLastdata.cast());\n\n            if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n                ret = BzpCompressOneBlock(bzpInfo.cast(), outData.cast()).cast();\n\n                BzpWriteFileEnd(outData.cast(), bwt.combinedCRC.cast());\n                BzpFlushbuf(outData.cast());\n\n                bzpf.state = BZP_OUTPUT_COMPRESS!();\n            } else if BZP_BLOCK_FULL!(bwt).as_bool() {\n                ret = BzpCompressOneBlock(bzpInfo.cast(), outData.cast()).cast();\n                bzpf.state = BZP_OUTPUT_COMPRESS!();\n            } else {\n                bzpf.state = BZP_RETUEN_COMPRESS!();\n            }\n        }\n        if (ret != BZP_OK!()).as_bool() {\n            return ret;\n        }\n    }\n    return ret.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007019379)\nerror[E0609]: no field `pos` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_stream_utils_h.rs:172:66\n    |\n172 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { $bzpf.input.pos >= $bzpf.input.nBuf } }\n    |                                                                  ^^^ unknown field\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:202:40\n    |\n202 |             if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n    |                                        -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_stream_utils_h.rs:172:85\n    |\n172 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { $bzpf.input.pos >= $bzpf.input.nBuf } }\n    |                                                                                     ^^^^ unknown field\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:202:40\n    |\n202 |             if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n    |                                        -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `pos` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_stream_utils_h.rs:172:66\n    |\n172 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { $bzpf.input.pos >= $bzpf.input.nBuf } }\n    |                                                                  ^^^ unknown field\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:209:40\n    |\n209 |             if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n    |                                        -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_stream_utils_h.rs:172:85\n    |\n172 | macro_rules! BZP_BUFF_READ_EMPTY { ($bzpf:expr) => { $bzpf.input.pos >= $bzpf.input.nBuf } }\n    |                                                                                     ^^^^ unknown field\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:209:40\n    |\n209 |             if IsLastdata.as_bool() && BZP_BUFF_READ_EMPTY!(bzpf).as_bool() {\n    |                                        -------------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BUFF_READ_EMPTY` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `combinedCRC` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:212:53\n    |\n212 |                 BzpWriteFileEnd(outData.cast(), bwt.combinedCRC.cast());\n    |                                                     ^^^^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `nBlock` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_stream_utils_h.rs:168:53\n    |\n168 | macro_rules! BZP_BLOCK_FULL { ($bwt:expr) => { $bwt.nBlock >= $bwt.nBlockMax } }\n    |                                                     ^^^^^^ unknown field\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:216:23\n    |\n216 |             } else if BZP_BLOCK_FULL!(bwt).as_bool() {\n    |                       -------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BLOCK_FULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `nBlockMax` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_stream_utils_h.rs:168:68\n    |\n168 | macro_rules! BZP_BLOCK_FULL { ($bwt:expr) => { $bwt.nBlock >= $bwt.nBlockMax } }\n    |                                                                    ^^^^^^^^^ unknown field\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:216:23\n    |\n216 |             } else if BZP_BLOCK_FULL!(bwt).as_bool() {\n    |                       -------------------- in this macro invocation\n    |\n    = note: this error originates in the macro `BZP_BLOCK_FULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 7 previous errors\n"
            },
            {
                "c_code": "void BzpCompressEnd(BzpAlgorithmInfo *bzpInfo)\n    {\n\n        if (bzpInfo->compressFile->input->filePtr != NULL)\n        {\n            fclose(bzpInfo->compressFile->input->filePtr);\n        }\n        if (bzpInfo->compressFile->output->filePtr != NULL)\n        {\n            fclose(bzpInfo->compressFile->output->filePtr);\n        }\n        BzpAlgorithmInfoFinish(bzpInfo);\n    }",
                "rust_code": "pub fn BzpCompressEnd(mut bzpInfo: Ptr<BzpAlgorithmInfo>) {\n    if (bzpInfo.compressFile.input.filePtr != NULL!()).as_bool() {\n        c_fclose!(bzpInfo.compressFile.input.filePtr);\n    }\n    if (bzpInfo.compressFile.output.filePtr != NULL!()).as_bool() {\n        c_fclose!(bzpInfo.compressFile.output.filePtr);\n    }\n    BzpAlgorithmInfoFinish(bzpInfo.cast());\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007019603)\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:195:36\n    |\n195 |     if (bzpInfo.compressFile.input.filePtr != NULL!()).as_bool() {\n    |                                    ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:196:46\n    |\n196 |         c_fclose!(bzpInfo.compressFile.input.filePtr);\n    |                                              ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:198:37\n    |\n198 |     if (bzpInfo.compressFile.output.filePtr != NULL!()).as_bool() {\n    |                                     ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:199:47\n    |\n199 |         c_fclose!(bzpInfo.compressFile.output.filePtr);\n    |                                               ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/public/bzp_compress_stream_c.rs:195:47\n    |\n195 |     if (bzpInfo.compressFile.input.filePtr != NULL!()).as_bool() {\n    |                                               ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
            },
            {
                "c_code": "int32_t BzpCompressStream(char *inName, char *outName, int32_t blockSize)\n    {\n\n        int32_t ret = BZP_OK;\n        bool IsLastdata = false;\n\n        if (inName == NULL || outName == NULL || BZP_INVALID_BLOCK_SIZE(blockSize))\n        {\n            return BZP_ERROR_PARAM;\n        }\n\n        BzpAlgorithmInfo *bzpInfo = BzpAlgorithmInfoInit(blockSize);\n        if (bzpInfo == NULL)\n        {\n            return BZP_ERROR_MEMORY_OPER_FAILURE;\n        }\n        ret = BzpOpenFile(bzpInfo, inName, outName);\n        if (ret != BZP_OK)\n        {\n            return ret;\n        }\n        BzpStream *inStream = bzpInfo->compressFile->input;\n\n        while (!IsLastdata)\n        {\n            inStream->nBuf = fread(inStream->buf, sizeof(char), sizeof(inStream->buf), inStream->filePtr);\n            inStream->pos = 0;\n            IsLastdata = BzpFileEOF(inStream->filePtr);\n            ret = BzpProcessData(bzpInfo, IsLastdata);\n            if (ret != BZP_OK)\n            {\n                break;\n            }\n        }\n        BzpCompressEnd(bzpInfo);\n        if (ret != BZP_OK)\n        {\n            remove(outName);\n        }\n        return ret;\n    }",
                "rust_code": "pub fn BzpCompressStream(mut inName: Ptr<u8>, mut outName: Ptr<u8>, mut blockSize: i32) -> i32 {\n    let mut ret: i32 = BZP_OK!();\n    let mut IsLastdata: bool = false;\n    if (inName == NULL!()).as_bool() || (outName == NULL!()).as_bool() || BZP_INVALID_BLOCK_SIZE!(blockSize).as_bool() {\n        return BZP_ERROR_PARAM!();\n    }\n    let mut bzpInfo: Ptr<BzpAlgorithmInfo> = BzpAlgorithmInfoInit(blockSize.cast());\n    if (bzpInfo == NULL!()).as_bool() {\n        return BZP_ERROR_MEMORY_OPER_FAILURE!();\n    }\n    ret = BzpOpenFile(bzpInfo.cast(), inName.cast(), outName.cast()).cast();\n    if (ret != BZP_OK!()).as_bool() {\n        return ret;\n    }\n    let mut inStream: Ptr<BzpStream> = bzpInfo.compressFile.input.cast();\n    while !IsLastdata.as_bool() {\n        inStream.nBuf = c_fread!(inStream.buf, c_sizeof!(char), c_sizeofval!(inStream.buf), inStream.filePtr).cast();\n        inStream.pos = 0;\n        IsLastdata = BzpFileEOF(inStream.filePtr.cast()).cast();\n        ret = BzpProcessData(bzpInfo.cast(), IsLastdata.cast()).cast();\n        if (ret != BZP_OK!()).as_bool() {\n            break;\n        }\n    }\n    BzpCompressEnd(bzpInfo.cast());\n    if (ret != BZP_OK!()).as_bool() {\n        c_remove!(outName);\n    }\n    return ret.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/bzp_1750007019815)\nerror[E0609]: no field `nBuf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:215:18\n    |\n215 |         inStream.nBuf = c_fread!(inStream.buf, c_sizeof!(char), c_sizeofval!(inStream.buf), inStream.filePtr).cast();\n    |                  ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `buf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:215:43\n    |\n215 |         inStream.nBuf = c_fread!(inStream.buf, c_sizeof!(char), c_sizeofval!(inStream.buf), inStream.filePtr).cast();\n    |                                           ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `buf` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:215:87\n    |\n215 |         inStream.nBuf = c_fread!(inStream.buf, c_sizeof!(char), c_sizeofval!(inStream.buf), inStream.filePtr).cast();\n    |                                                                                       ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:215:102\n    |\n215 |         inStream.nBuf = c_fread!(inStream.buf, c_sizeof!(char), c_sizeofval!(inStream.buf), inStream.filePtr).cast();\n    |                                                                                                      ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `pos` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:216:18\n    |\n216 |         inStream.pos = 0;\n    |                  ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `filePtr` on type `memory::ptr::Ptr<i32>`\n   --> src/src/public/bzp_compress_stream_c.rs:217:42\n    |\n217 |         IsLastdata = BzpFileEOF(inStream.filePtr.cast()).cast();\n    |                                          ^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\n"
            }
        ]
    }
}