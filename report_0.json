{
    "macro": {
        "all_cnt": 29,
        "passed_cnt": 29,
        "pass_rate": 1.0,
        "messages": []
    },
    "macro_function": {
        "all_cnt": 0,
        "passed_cnt": 0,
        "pass_rate": 100.0,
        "messages": []
    },
    "definition": {
        "all_cnt": 95,
        "passed_cnt": 92,
        "pass_rate": 0.968421052631579,
        "messages": [
            {
                "c_code": "struct _AVLTreeNode\n{\n    AVLTreeNode *children[2];\n    AVLTreeNode *parent;\n    AVLTreeKey key;\n    AVLTreeValue value;\n    int height;\n};",
                "rust_code": "#[repr(C)]\n#[derive(Default, Clone, Copy)]\npub struct _AVLTreeNode {\n    pub children: Array<Ptr<AVLTreeNode>, 2>,\n    pub parent: Ptr<AVLTreeNode>,\n    pub key: AVLTreeKey,\n    pub value: AVLTreeValue,\n    pub height: i32,\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003293709)\nerror[E0204]: the trait `std::marker::Copy` cannot be implemented for this type\n --> src/src/avl_tree_c.rs:5:26\n  |\n5 | #[derive(Default, Clone, Copy)]\n  |                          ^^^^\n6 | pub struct _AVLTreeNode {\n7 |     pub children: Array<Ptr<AVLTreeNode>, 2>,\n  |     ---------------------------------------- this field does not implement `std::marker::Copy`\n\nerror[E0277]: the trait bound `types::array::Array<memory::ptr::Ptr<i32>, 2>: Clone` is not satisfied\n --> src/src/avl_tree_c.rs:7:5\n  |\n5 | #[derive(Default, Clone, Copy)]\n  |                   ----- in this derive macro expansion\n6 | pub struct _AVLTreeNode {\n7 |     pub children: Array<Ptr<AVLTreeNode>, 2>,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `types::array::Array<memory::ptr::Ptr<i32>, 2>`\n  |\nnote: required by a bound in `AssertParamIsClone`\n --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/clone.rs:251:1\nhelp: consider annotating `types::array::Array<memory::ptr::Ptr<i32>, 2>` with `#[derive(Clone)]`\n --> src/translation_utils/types/array.rs:5:1\n  |\n5 + #[derive(Clone)]\n6 | pub struct Array<T, const N: usize>(pub [T; N]);\n  |\n\nSome errors have detailed explanations: E0204, E0277.\nFor more information about an error, try `rustc --explain E0204`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "struct _TrieNode\n{\n    TrieValue data;\n    unsigned int use_count;\n    TrieNode *next[256];\n};",
                "rust_code": "#[repr(C)]\n#[derive(Default, Clone, Copy)]\npub struct _TrieNode {\n    pub data: TrieValue,\n    pub use_count: u32,\n    pub next: Array<Ptr<TrieNode>, 256>,\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003310839)\nerror[E0204]: the trait `std::marker::Copy` cannot be implemented for this type\n  --> src/src/trie_c.rs:8:26\n   |\n8  | #[derive(Default, Clone, Copy)]\n   |                          ^^^^\n...\n12 |     pub next: Array<Ptr<TrieNode>, 256>,\n   |     ----------------------------------- this field does not implement `std::marker::Copy`\n\nerror[E0277]: the trait bound `types::array::Array<memory::ptr::Ptr<_TrieNode>, 256>: Clone` is not satisfied\n  --> src/src/trie_c.rs:12:5\n   |\n8  | #[derive(Default, Clone, Copy)]\n   |                   ----- in this derive macro expansion\n...\n12 |     pub next: Array<Ptr<TrieNode>, 256>,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `types::array::Array<memory::ptr::Ptr<_TrieNode>, 256>`\n   |\nnote: required by a bound in `AssertParamIsClone`\n  --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/clone.rs:251:1\nhelp: consider annotating `types::array::Array<memory::ptr::Ptr<_TrieNode>, 256>` with `#[derive(Clone)]`\n  --> src/translation_utils/types/array.rs:5:1\n   |\n5  + #[derive(Clone)]\n6  | pub struct Array<T, const N: usize>(pub [T; N]);\n   |\n\nSome errors have detailed explanations: E0204, E0277.\nFor more information about an error, try `rustc --explain E0204`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "struct _RBTreeNode\n{\n    RBTreeNodeColor color;\n    RBTreeKey key;\n    RBTreeValue value;\n    RBTreeNode *parent;\n    RBTreeNode *children[2];\n};",
                "rust_code": "#[repr(C)]\n#[derive(Default, Clone, Copy)]\npub struct _RBTreeNode {\n    pub color: RBTreeNodeColor,\n    pub key: RBTreeKey,\n    pub value: RBTreeValue,\n    pub parent: Ptr<RBTreeNode>,\n    pub children: Array<Ptr<RBTreeNode>, 2>,\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003313950)\nerror[E0204]: the trait `std::marker::Copy` cannot be implemented for this type\n  --> src/src/rb_tree_c.rs:5:26\n   |\n5  | #[derive(Default, Clone, Copy)]\n   |                          ^^^^\n...\n11 |     pub children: Array<Ptr<RBTreeNode>, 2>,\n   |     --------------------------------------- this field does not implement `std::marker::Copy`\n\nerror[E0277]: the trait bound `types::array::Array<memory::ptr::Ptr<_RBTreeNode>, 2>: Clone` is not satisfied\n  --> src/src/rb_tree_c.rs:11:5\n   |\n5  | #[derive(Default, Clone, Copy)]\n   |                   ----- in this derive macro expansion\n...\n11 |     pub children: Array<Ptr<RBTreeNode>, 2>,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `types::array::Array<memory::ptr::Ptr<_RBTreeNode>, 2>`\n   |\nnote: required by a bound in `AssertParamIsClone`\n  --> /rustc/17067e9ac6d7ecb70e50f92c1944e545188d2359/library/core/src/clone.rs:251:1\nhelp: consider annotating `types::array::Array<memory::ptr::Ptr<_RBTreeNode>, 2>` with `#[derive(Clone)]`\n  --> src/translation_utils/types/array.rs:5:1\n   |\n5  + #[derive(Clone)]\n6  | pub struct Array<T, const N: usize>(pub [T; N]);\n   |\n\nSome errors have detailed explanations: E0204, E0277.\nFor more information about an error, try `rustc --explain E0204`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            }
        ]
    },
    "dummy_function": {
        "all_cnt": 200,
        "passed_cnt": 200,
        "pass_rate": 1.0,
        "messages": []
    },
    "function": {
        "all_cnt": 200,
        "passed_cnt": 136,
        "pass_rate": 0.68,
        "messages": [
            {
                "c_code": "ListEntry *list_prepend(ListEntry **list, ListValue data)\n{\n    ListEntry *newentry;\n\n    if (list == NULL)\n    {\n\n        return NULL;\n    }\n\n    newentry = malloc(sizeof(ListEntry));\n\n    if (newentry == NULL)\n    {\n        return NULL;\n    }\n\n    newentry->data = data;\n\n    if (*list != NULL)\n    {\n        (*list)->prev = newentry;\n    }\n    newentry->prev = NULL;\n    newentry->next = *list;\n    *list = newentry;\n\n    return newentry;\n}",
                "rust_code": "pub fn list_prepend(mut list: Ptr<Ptr<ListEntry>>, mut data: ListValue) -> Ptr<ListEntry> {\n    let mut newentry: Ptr<ListEntry>;\n\n    if (list == NULL!()).as_bool() {\n        return NULL!();\n    }\n\n    newentry = c_malloc!(c_sizeof!(ListEntry));\n\n    if (newentry == NULL!()).as_bool() {\n        return NULL!();\n    }\n\n    newentry.data = data.cast();\n\n    if (*list != NULL!()).as_bool() {\n        (*list).prev = newentry.cast();\n    }\n    newentry.prev = NULL!();\n    newentry.next = *list.cast();\n    *list = newentry.cast();\n\n    return newentry.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003359358)\nerror[E0282]: type annotations needed\n  --> src/src/list_c.rs:46:27\n   |\n46 |     newentry.next = *list.cast();\n   |                           ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n46 |     newentry.next = *list.cast::<T>();\n   |                               +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "ListEntry *list_append(ListEntry **list, ListValue data)\n{\n    ListEntry *rover;\n    ListEntry *newentry;\n\n    if (list == NULL)\n    {\n        return NULL;\n    }\n\n    newentry = malloc(sizeof(ListEntry));\n\n    if (newentry == NULL)\n    {\n        return NULL;\n    }\n\n    newentry->data = data;\n    newentry->next = NULL;\n\n    if (*list == NULL)\n    {\n\n        *list = newentry;\n        newentry->prev = NULL;\n    }\n    else\n    {\n\n        for (rover = *list; rover->next != NULL; rover = rover->next)\n            ;\n\n        newentry->prev = rover;\n        rover->next = newentry;\n    }\n\n    return newentry;\n}",
                "rust_code": "pub fn list_append(mut list: Ptr<Ptr<ListEntry>>, mut data: ListValue) -> Ptr<ListEntry> {\n    let mut rover: Ptr<ListEntry> = Default::default();\n    let mut newentry: Ptr<ListEntry> = Default::default();\n\n    if (list == NULL!()).as_bool() {\n        return NULL!();\n    }\n\n    newentry = c_malloc!(c_sizeof!(ListEntry));\n\n    if (newentry == NULL!()).as_bool() {\n        return NULL!();\n    }\n\n    newentry.data = data.cast();\n    newentry.next = NULL!();\n\n    if (*list == NULL!()).as_bool() {\n        *list = newentry.cast();\n        newentry.prev = NULL!();\n    } else {\n        rover = *list.cast();\n        while (rover.next != NULL!()).as_bool() {\n            rover = rover.next.cast();\n        }\n\n        newentry.prev = rover.cast();\n        rover.next = newentry.cast();\n    }\n\n    return newentry.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003359587)\nerror[E0282]: type annotations needed\n  --> src/src/list_c.rs:53:23\n   |\n53 |         rover = *list.cast();\n   |                       ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n53 |         rover = *list.cast::<T>();\n   |                           +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void sortedarray_remove_range(SortedArray *sortedarray, unsigned int index, unsigned int length)\n{\n\n    if (index > sortedarray->length || index + length > sortedarray->length)\n    {\n        return;\n    }\n\n    memmove(&sortedarray->data[index], &sortedarray->data[index + length],\n            (sortedarray->length - (index + length)) * sizeof(SortedArrayValue));\n\n    sortedarray->length -= length;\n}",
                "rust_code": "pub fn sortedarray_remove_range(mut sortedarray: Ptr<SortedArray>, mut index: u32, mut length: u32) {\n    if (index > sortedarray.length).as_bool() || (index + length > sortedarray.length).as_bool() {\n        return;\n    }\n    c_memmove_s!(\n        c_ref!(sortedarray.data[index]).cast(),\n        c_ref!(sortedarray.data[index + length]).cast(),\n        (sortedarray.length - (index + length)) * c_sizeof!(SortedArrayValue)\n    );\n    sortedarray.length -= length;\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003365314)\nerror: unexpected end of macro invocation\n   --> src/src/sortedarray_c.rs:109:78\n    |\n109 |         (sortedarray.length - (index + length)) * c_sizeof!(SortedArrayValue)\n    |                                                - help: missing comma here    ^ missing tokens in macro arguments\n    |\n   ::: src/translation_utils/c_alignment/libraries/safelib/c_memmove_s.rs:45:1\n    |\n45  | macro_rules! c_memmove_s {\n    | ------------------------ when calling this macro\n    |\nnote: while trying to match `,`\n   --> src/translation_utils/c_alignment/libraries/safelib/c_memmove_s.rs:46:42\n    |\n46  |     ($dst:expr, $dst_size:expr, $src:expr, $count:expr) => {\n    |                                          ^\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int sortedarray_insert(SortedArray *sortedarray, SortedArrayValue data)\n{\n\n    unsigned int left = 0;\n    unsigned int right = sortedarray->length;\n    unsigned int index = 0;\n\n    right = (right > 1) ? right : 0;\n\n    while (left != right)\n    {\n        index = (left + right) / 2;\n\n        int order = sortedarray->cmp_func(data, sortedarray->data[index]);\n        if (order < 0)\n        {\n\n            right = index;\n        }\n        else if (order > 0)\n        {\n\n            left = index + 1;\n        }\n        else\n        {\n\n            break;\n        }\n    }\n\n    if (sortedarray->length > 0 && sortedarray->cmp_func(data, sortedarray->data[index]) > 0)\n    {\n        index++;\n    }\n\n    if (sortedarray->length + 1 > sortedarray->_alloced)\n    {\n\n        unsigned int newsize;\n        SortedArrayValue *data;\n\n        newsize = sortedarray->_alloced * 2;\n        data = realloc(sortedarray->data, sizeof(SortedArrayValue) * newsize);\n\n        if (data == NULL)\n        {\n            return 0;\n        }\n        else\n        {\n            sortedarray->data = data;\n            sortedarray->_alloced = newsize;\n        }\n    }\n\n    memmove(&sortedarray->data[index + 1], &sortedarray->data[index],\n            (sortedarray->length - index) * sizeof(SortedArrayValue));\n\n    sortedarray->data[index] = data;\n    ++(sortedarray->length);\n\n    return 1;\n}",
                "rust_code": "pub fn sortedarray_insert(mut sortedarray: Ptr<SortedArray>, mut data: SortedArrayValue) -> i32 {\n    let mut left: u32 = 0;\n    let mut right: u32 = sortedarray.length.cast();\n    let mut index: u32 = 0;\n    right = if right > 1 { right } else { 0 };\n    while (left != right).as_bool() {\n        index = (left + right) / 2;\n        let mut order: i32 = (sortedarray.cmp_func)(data.cast(), sortedarray.data[index].cast()).cast();\n        if order < 0 {\n            right = index.cast();\n        } else if order > 0 {\n            left = (index + 1).cast();\n        } else {\n            break;\n        }\n    }\n    if (sortedarray.length > 0).as_bool() && ((sortedarray.cmp_func)(data.cast(), sortedarray.data[index].cast()) > 0).as_bool() {\n        index += 1;\n    }\n    if (sortedarray.length + 1 > sortedarray._alloced).as_bool() {\n        let mut newsize: u32;\n        let mut data: Ptr<SortedArrayValue>;\n        newsize = sortedarray._alloced * 2;\n        data = c_realloc!(sortedarray.data, c_sizeof!(SortedArrayValue) * newsize);\n        if (data == NULL!()).as_bool() {\n            return 0;\n        } else {\n            sortedarray.data = data.cast();\n            sortedarray._alloced = newsize.cast();\n        }\n    }\n    c_memmove!(c_ref!(sortedarray.data[index + 1]).cast(), c_ref!(sortedarray.data[index]).cast(), (sortedarray.length - index) * c_sizeof!(SortedArrayValue));\n    sortedarray.data[index] = data.cast();\n    sortedarray.length += 1;\n    return 1;\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003365533)\nerror[E0282]: type annotations needed\n   --> src/src/sortedarray_c.rs:138:52\n    |\n138 |     c_memmove!(c_ref!(sortedarray.data[index + 1]).cast(), c_ref!(sortedarray.data[index]).cast(), (sortedarray.length - index) * c_sizeo...\n    |                                                    ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n    |\nhelp: consider specifying the generic argument\n    |\n138 |     c_memmove!(c_ref!(sortedarray.data[index + 1]).cast::<T>(), c_ref!(sortedarray.data[index]).cast(), (sortedarray.length - index) * c_sizeof!(SortedArrayValue));\n    |                                                        +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static void avl_tree_free_subtree(AVLTree *tree, AVLTreeNode *node)\n{\n    if (node == NULL)\n    {\n        return;\n    }\n\n    avl_tree_free_subtree(tree, node->children[AVL_TREE_NODE_LEFT]);\n    avl_tree_free_subtree(tree, node->children[AVL_TREE_NODE_RIGHT]);\n\n    free(node);\n}",
                "rust_code": "pub fn avl_tree_free_subtree(mut tree: Ptr<AVLTree>, mut node: Ptr<AVLTreeNode>) {\n    if (node == NULL!()).as_bool() {\n        return;\n    }\n    avl_tree_free_subtree(tree.cast(), node.children[AVL_TREE_NODE_LEFT!()].cast());\n    avl_tree_free_subtree(tree.cast(), node.children[AVL_TREE_NODE_RIGHT!()].cast());\n    c_free!(node);\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003366474)\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:36:45\n   |\n36 |     avl_tree_free_subtree(tree.cast(), node.children[AVL_TREE_NODE_LEFT!()].cast());\n   |                                             ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:37:45\n   |\n37 |     avl_tree_free_subtree(tree.cast(), node.children[AVL_TREE_NODE_RIGHT!()].cast());\n   |                                             ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "int avl_tree_subtree_height(AVLTreeNode *node)\n{\n    if (node == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        return node->height;\n    }\n}",
                "rust_code": "pub fn avl_tree_subtree_height(mut node: Ptr<AVLTreeNode>) -> i32 {\n    if (node == NULL!()).as_bool() {\n        return 0;\n    } else {\n        return node.height.cast();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003366944)\nerror[E0609]: no field `height` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:47:21\n   |\n47 |         return node.height.cast();\n   |                     ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static void avl_tree_update_height(AVLTreeNode *node)\n{\n    AVLTreeNode *left_subtree;\n    AVLTreeNode *right_subtree;\n    int left_height, right_height;\n\n    left_subtree = node->children[AVL_TREE_NODE_LEFT];\n    right_subtree = node->children[AVL_TREE_NODE_RIGHT];\n    left_height = avl_tree_subtree_height(left_subtree);\n    right_height = avl_tree_subtree_height(right_subtree);\n\n    if (left_height > right_height)\n    {\n        node->height = left_height + 1;\n    }\n    else\n    {\n        node->height = right_height + 1;\n    }\n}",
                "rust_code": "pub fn avl_tree_update_height(mut node: Ptr<AVLTreeNode>) {\n    let mut left_subtree: Ptr<AVLTreeNode> = Default::default();\n    let mut right_subtree: Ptr<AVLTreeNode> = Default::default();\n    let mut left_height: i32 = Default::default();\n    let mut right_height: i32 = Default::default();\n\n    left_subtree = node.children[AVL_TREE_NODE_LEFT!()].cast();\n    right_subtree = node.children[AVL_TREE_NODE_RIGHT!()].cast();\n    left_height = avl_tree_subtree_height(left_subtree.cast()).cast();\n    right_height = avl_tree_subtree_height(right_subtree.cast()).cast();\n\n    if (left_height > right_height).as_bool() {\n        node.height = (left_height + 1).cast();\n    } else {\n        node.height = (right_height + 1).cast();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003367173)\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:54:25\n   |\n54 |     left_subtree = node.children[AVL_TREE_NODE_LEFT!()].cast();\n   |                         ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:55:26\n   |\n55 |     right_subtree = node.children[AVL_TREE_NODE_RIGHT!()].cast();\n   |                          ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `height` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:60:14\n   |\n60 |         node.height = (left_height + 1).cast();\n   |              ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `height` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:62:14\n   |\n62 |         node.height = (right_height + 1).cast();\n   |              ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
            },
            {
                "c_code": "static AVLTreeNodeSide avl_tree_node_parent_side(AVLTreeNode *node)\n{\n    if (node->parent->children[AVL_TREE_NODE_LEFT] == node)\n    {\n        return AVL_TREE_NODE_LEFT;\n    }\n    else\n    {\n        return AVL_TREE_NODE_RIGHT;\n    }\n}",
                "rust_code": "pub fn avl_tree_node_parent_side(mut node: Ptr<AVLTreeNode>) -> AVLTreeNodeSide {\n    if (node.parent.children[AVL_TREE_NODE_LEFT!()] == node).as_bool() {\n        return AVL_TREE_NODE_LEFT!();\n    } else {\n        return AVL_TREE_NODE_RIGHT!();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003367402)\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:54:14\n   |\n54 |     if (node.parent.children[AVL_TREE_NODE_LEFT!()] == node).as_bool() {\n   |              ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static void avl_tree_node_replace(AVLTree *tree, AVLTreeNode *node1, AVLTreeNode *node2)\n{\n    int side;\n\n    if (node2 != NULL)\n    {\n        node2->parent = node1->parent;\n    }\n\n    if (node1->parent == NULL)\n    {\n        tree->root_node = node2;\n    }\n    else\n    {\n        side = avl_tree_node_parent_side(node1);\n        node1->parent->children[side] = node2;\n\n        avl_tree_update_height(node1->parent);\n    }\n}",
                "rust_code": "pub fn avl_tree_node_replace(mut tree: Ptr<AVLTree>, mut node1: Ptr<AVLTreeNode>, mut node2: Ptr<AVLTreeNode>) {\n    let mut side: i32 = Default::default();\n    if (node2 != NULL!()).as_bool() {\n        node2.parent = node1.parent.cast();\n    }\n    if (node1.parent == NULL!()).as_bool() {\n        tree.root_node = node2.cast();\n    } else {\n        side = avl_tree_node_parent_side(node1.cast()).cast();\n        node1.parent.children[side] = node2.cast();\n        avl_tree_update_height(node1.parent.cast());\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003367629)\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:61:15\n   |\n61 |         node2.parent = node1.parent.cast();\n   |               ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:61:30\n   |\n61 |         node2.parent = node1.parent.cast();\n   |                              ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:63:15\n   |\n63 |     if (node1.parent == NULL!()).as_bool() {\n   |               ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:67:15\n   |\n67 |         node1.parent.children[side] = node2.cast();\n   |               ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:68:38\n   |\n68 |         avl_tree_update_height(node1.parent.cast());\n   |                                      ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/avl_tree_c.rs:63:25\n    |\n63  |     if (node1.parent == NULL!()).as_bool() {\n    |                         ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 6 previous errors\n"
            },
            {
                "c_code": "static AVLTreeNode *avl_tree_rotate(AVLTree *tree, AVLTreeNode *node, AVLTreeNodeSide direction)\n{\n    AVLTreeNode *new_root;\n\n    new_root = node->children[1 - direction];\n\n    avl_tree_node_replace(tree, node, new_root);\n\n    node->children[1 - direction] = new_root->children[direction];\n    new_root->children[direction] = node;\n\n    node->parent = new_root;\n\n    if (node->children[1 - direction] != NULL)\n    {\n        node->children[1 - direction]->parent = node;\n    }\n\n    avl_tree_update_height(new_root);\n    avl_tree_update_height(node);\n\n    return new_root;\n}",
                "rust_code": "pub fn avl_tree_rotate(mut tree: Ptr<AVLTree>, mut node: Ptr<AVLTreeNode>, mut direction: AVLTreeNodeSide) -> Ptr<AVLTreeNode> {\n    let mut new_root: Ptr<AVLTreeNode>;\n    new_root = node.children[1 - direction].cast();\n    avl_tree_node_replace(tree.cast(), node.cast(), new_root.cast());\n    node.children[1 - direction] = new_root.children[direction].cast();\n    new_root.children[direction] = node.cast();\n    node.parent = new_root.cast();\n    if (node.children[1 - direction] != NULL!()).as_bool() {\n        node.children[1 - direction].parent = node.cast();\n    }\n    avl_tree_update_height(new_root.cast());\n    avl_tree_update_height(node.cast());\n    return new_root.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003367859)\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:65:21\n   |\n65 |     new_root = node.children[1 - direction].cast();\n   |                     ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:67:10\n   |\n67 |     node.children[1 - direction] = new_root.children[direction].cast();\n   |          ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:67:45\n   |\n67 |     node.children[1 - direction] = new_root.children[direction].cast();\n   |                                             ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:68:14\n   |\n68 |     new_root.children[direction] = node.cast();\n   |              ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:69:10\n   |\n69 |     node.parent = new_root.cast();\n   |          ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:70:14\n   |\n70 |     if (node.children[1 - direction] != NULL!()).as_bool() {\n   |              ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:71:14\n   |\n71 |         node.children[1 - direction].parent = node.cast();\n   |              ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/avl_tree_c.rs:70:41\n    |\n70  |     if (node.children[1 - direction] != NULL!()).as_bool() {\n    |                                         ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"
            },
            {
                "c_code": "static AVLTreeNode *avl_tree_node_balance(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *left_subtree;\n    AVLTreeNode *right_subtree;\n    AVLTreeNode *child;\n    int diff;\n\n    left_subtree = node->children[AVL_TREE_NODE_LEFT];\n    right_subtree = node->children[AVL_TREE_NODE_RIGHT];\n\n    diff = avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if (diff >= 2)\n    {\n\n        child = right_subtree;\n\n        if (avl_tree_subtree_height(child->children[AVL_TREE_NODE_RIGHT]) <\n            avl_tree_subtree_height(child->children[AVL_TREE_NODE_LEFT]))\n        {\n\n            avl_tree_rotate(tree, right_subtree, AVL_TREE_NODE_RIGHT);\n        }\n\n        node = avl_tree_rotate(tree, node, AVL_TREE_NODE_LEFT);\n    }\n    else if (diff <= -2)\n    {\n\n        child = node->children[AVL_TREE_NODE_LEFT];\n\n        if (avl_tree_subtree_height(child->children[AVL_TREE_NODE_LEFT]) <\n            avl_tree_subtree_height(child->children[AVL_TREE_NODE_RIGHT]))\n        {\n\n            avl_tree_rotate(tree, left_subtree, AVL_TREE_NODE_LEFT);\n        }\n\n        node = avl_tree_rotate(tree, node, AVL_TREE_NODE_RIGHT);\n    }\n\n    avl_tree_update_height(node);\n\n    return node;\n}",
                "rust_code": "pub fn avl_tree_node_balance(mut tree: Ptr<AVLTree>, mut node: Ptr<AVLTreeNode>) -> Ptr<AVLTreeNode> {\n    let mut left_subtree: Ptr<AVLTreeNode>;\n    let mut right_subtree: Ptr<AVLTreeNode>;\n    let mut child: Ptr<AVLTreeNode>;\n    let mut diff: i32;\n\n    left_subtree = node.children[AVL_TREE_NODE_LEFT!()].cast();\n    right_subtree = node.children[AVL_TREE_NODE_RIGHT!()].cast();\n\n    diff = (avl_tree_subtree_height(right_subtree.cast()) - avl_tree_subtree_height(left_subtree.cast())).cast();\n\n    if (diff >= 2).as_bool() {\n        child = right_subtree.cast();\n\n        if (avl_tree_subtree_height(child.children[AVL_TREE_NODE_RIGHT!()].cast()) <\n            avl_tree_subtree_height(child.children[AVL_TREE_NODE_LEFT!()].cast())).as_bool() {\n            avl_tree_rotate(tree.cast(), right_subtree.cast(), AVL_TREE_NODE_RIGHT!().cast());\n        }\n\n        node = avl_tree_rotate(tree.cast(), node.cast(), AVL_TREE_NODE_LEFT!().cast());\n    } else if (diff <= -2).as_bool() {\n        child = node.children[AVL_TREE_NODE_LEFT!()].cast();\n\n        if (avl_tree_subtree_height(child.children[AVL_TREE_NODE_LEFT!()].cast()) <\n            avl_tree_subtree_height(child.children[AVL_TREE_NODE_RIGHT!()].cast())).as_bool() {\n            avl_tree_rotate(tree.cast(), left_subtree.cast(), AVL_TREE_NODE_LEFT!().cast());\n        }\n\n        node = avl_tree_rotate(tree.cast(), node.cast(), AVL_TREE_NODE_RIGHT!().cast());\n    }\n\n    avl_tree_update_height(node.cast());\n\n    return node.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003368091)\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:74:25\n   |\n74 |     left_subtree = node.children[AVL_TREE_NODE_LEFT!()].cast();\n   |                         ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:75:26\n   |\n75 |     right_subtree = node.children[AVL_TREE_NODE_RIGHT!()].cast();\n   |                          ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:82:43\n   |\n82 |         if (avl_tree_subtree_height(child.children[AVL_TREE_NODE_RIGHT!()].cast()) <\n   |                                           ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:83:43\n   |\n83 |             avl_tree_subtree_height(child.children[AVL_TREE_NODE_LEFT!()].cast())).as_bool() {\n   |                                           ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:89:22\n   |\n89 |         child = node.children[AVL_TREE_NODE_LEFT!()].cast();\n   |                      ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:91:43\n   |\n91 |         if (avl_tree_subtree_height(child.children[AVL_TREE_NODE_LEFT!()].cast()) <\n   |                                           ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:92:43\n   |\n92 |             avl_tree_subtree_height(child.children[AVL_TREE_NODE_RIGHT!()].cast())).as_bool() {\n   |                                           ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 7 previous errors\n"
            },
            {
                "c_code": "static void avl_tree_balance_to_root(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *rover;\n\n    rover = node;\n\n    while (rover != NULL)\n    {\n\n        rover = avl_tree_node_balance(tree, rover);\n\n        rover = rover->parent;\n    }\n}",
                "rust_code": "pub fn avl_tree_balance_to_root(mut tree: Ptr<AVLTree>, mut node: Ptr<AVLTreeNode>) {\n    let mut rover: Ptr<AVLTreeNode> = node.cast();\n    while (rover != NULL!()).as_bool() {\n        rover = avl_tree_node_balance(tree.cast(), rover.cast()).cast();\n        rover = rover.parent.cast();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003368329)\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:77:23\n   |\n77 |         rover = rover.parent.cast();\n   |                       ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "AVLTreeNode *avl_tree_insert(AVLTree *tree, AVLTreeKey key, AVLTreeValue value)\n{\n    AVLTreeNode **rover;\n    AVLTreeNode *new_node;\n    AVLTreeNode *previous_node;\n\n    rover = &tree->root_node;\n    previous_node = NULL;\n\n    while (*rover != NULL)\n    {\n        previous_node = *rover;\n        if (tree->compare_func(key, (*rover)->key) < 0)\n        {\n            rover = &((*rover)->children[AVL_TREE_NODE_LEFT]);\n        }\n        else\n        {\n            rover = &((*rover)->children[AVL_TREE_NODE_RIGHT]);\n        }\n    }\n\n    new_node = (AVLTreeNode *)malloc(sizeof(AVLTreeNode));\n\n    if (new_node == NULL)\n    {\n        return NULL;\n    }\n\n    new_node->children[AVL_TREE_NODE_LEFT] = NULL;\n    new_node->children[AVL_TREE_NODE_RIGHT] = NULL;\n    new_node->parent = previous_node;\n    new_node->key = key;\n    new_node->value = value;\n    new_node->height = 1;\n\n    *rover = new_node;\n\n    avl_tree_balance_to_root(tree, previous_node);\n\n    ++tree->num_nodes;\n\n    return new_node;\n}",
                "rust_code": "pub fn avl_tree_insert(mut tree: Ptr<AVLTree>, mut key: AVLTreeKey, mut value: AVLTreeValue) -> Ptr<AVLTreeNode> {\n    let mut rover: Ptr<Ptr<AVLTreeNode>> = Default::default();\n    let mut new_node: Ptr<AVLTreeNode> = Default::default();\n    let mut previous_node: Ptr<AVLTreeNode> = Default::default();\n\n    rover = c_ref!(tree.root_node).cast();\n    previous_node = NULL!();\n\n    while (*rover != NULL!()).as_bool() {\n        previous_node = *rover.cast();\n        if (tree.compare_func(key.cast(), (*rover).key.cast()) < 0 {\n            rover = c_ref!((*rover).children[AVL_TREE_NODE_LEFT!()]).cast();\n        } else {\n            rover = c_ref!((*rover).children[AVL_TREE_NODE_RIGHT!()]).cast();\n        }\n    }\n\n    new_node = c_malloc!(c_sizeof!(AVLTreeNode));\n\n    if (new_node == NULL!()).as_bool() {\n        return NULL!();\n    }\n\n    new_node.children[AVL_TREE_NODE_LEFT!()] = NULL!();\n    new_node.children[AVL_TREE_NODE_RIGHT!()] = NULL!();\n    new_node.parent = previous_node.cast();\n    new_node.key = key.cast();\n    new_node.value = value.cast();\n    new_node.height = 1;\n\n    *rover = new_node.cast();\n\n    avl_tree_balance_to_root(tree.cast(), previous_node.cast());\n\n    tree.num_nodes.prefix_plus_plus();\n\n    return new_node.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003368564)\nerror: mismatched closing delimiter: `}`\n  --> src/src/avl_tree_c.rs:88:12\n   |\n86 |     while (*rover != NULL!()).as_bool() {\n   |                                         - closing delimiter possibly meant for this\n87 |         previous_node = *rover.cast();\n88 |         if (tree.compare_func(key.cast(), (*rover).key.cast()) < 0 {\n   |            ^ unclosed delimiter\n...\n93 |     }\n   |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static AVLTreeNode *avl_tree_node_get_replacement(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *left_subtree;\n    AVLTreeNode *right_subtree;\n    AVLTreeNode *result;\n    AVLTreeNode *child;\n    int left_height, right_height;\n    int side;\n\n    left_subtree = node->children[AVL_TREE_NODE_LEFT];\n    right_subtree = node->children[AVL_TREE_NODE_RIGHT];\n\n    if (left_subtree == NULL && right_subtree == NULL)\n    {\n        return NULL;\n    }\n\n    left_height = avl_tree_subtree_height(left_subtree);\n    right_height = avl_tree_subtree_height(right_subtree);\n\n    if (left_height < right_height)\n    {\n        side = AVL_TREE_NODE_RIGHT;\n    }\n    else\n    {\n        side = AVL_TREE_NODE_LEFT;\n    }\n\n    result = node->children[side];\n\n    while (result->children[1 - side] != NULL)\n    {\n        result = result->children[1 - side];\n    }\n\n    child = result->children[side];\n    avl_tree_node_replace(tree, result, child);\n\n    avl_tree_update_height(result->parent);\n\n    return result;\n}",
                "rust_code": "pub fn avl_tree_node_get_replacement(mut tree: Ptr<AVLTree>, mut node: Ptr<AVLTreeNode>) -> Ptr<AVLTreeNode> {\n    let mut left_subtree: Ptr<AVLTreeNode> = Default::default();\n    let mut right_subtree: Ptr<AVLTreeNode> = Default::default();\n    let mut result: Ptr<AVLTreeNode> = Default::default();\n    let mut child: Ptr<AVLTreeNode> = Default::default();\n    let mut left_height: i32 = Default::default();\n    let mut right_height: i32 = Default::default();\n    let mut side: i32 = Default::default();\n\n    left_subtree = node.children[AVL_TREE_NODE_LEFT!()].cast();\n    right_subtree = node.children[AVL_TREE_NODE_RIGHT!()].cast();\n\n    if (left_subtree == NULL!()).as_bool() && (right_subtree == NULL!()).as_bool() {\n        return NULL!();\n    }\n\n    left_height = avl_tree_subtree_height(left_subtree.cast()).cast();\n    right_height = avl_tree_subtree_height(right_subtree.cast()).cast();\n\n    if (left_height < right_height).as_bool() {\n        side = AVL_TREE_NODE_RIGHT!();\n    } else {\n        side = AVL_TREE_NODE_LEFT!();\n    }\n\n    result = node.children[side].cast();\n\n    while (result.children[1 - side] != NULL!()).as_bool() {\n        result = result.children[1 - side].cast();\n    }\n\n    child = result.children[side].cast();\n    avl_tree_node_replace(tree.cast(), result.cast(), child.cast());\n\n    avl_tree_update_height(result.parent.cast());\n\n    return result.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003368660)\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:92:25\n   |\n92 |     left_subtree = node.children[AVL_TREE_NODE_LEFT!()].cast();\n   |                         ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:93:26\n   |\n93 |     right_subtree = node.children[AVL_TREE_NODE_RIGHT!()].cast();\n   |                          ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:108:19\n    |\n108 |     result = node.children[side].cast();\n    |                   ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:110:19\n    |\n110 |     while (result.children[1 - side] != NULL!()).as_bool() {\n    |                   ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:111:25\n    |\n111 |         result = result.children[1 - side].cast();\n    |                         ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:114:20\n    |\n114 |     child = result.children[side].cast();\n    |                    ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:117:35\n    |\n117 |     avl_tree_update_height(result.parent.cast());\n    |                                   ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/avl_tree_c.rs:110:41\n    |\n110 |     while (result.children[1 - side] != NULL!()).as_bool() {\n    |                                         ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"
            },
            {
                "c_code": "void avl_tree_remove_node(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *swap_node;\n    AVLTreeNode *balance_startpoint;\n    int i;\n\n    swap_node = avl_tree_node_get_replacement(tree, node);\n\n    if (swap_node == NULL)\n    {\n\n        avl_tree_node_replace(tree, node, NULL);\n\n        balance_startpoint = node->parent;\n    }\n    else\n    {\n\n        if (swap_node->parent == node)\n        {\n            balance_startpoint = swap_node;\n        }\n        else\n        {\n            balance_startpoint = swap_node->parent;\n        }\n\n        for (i = 0; i < 2; ++i)\n        {\n            swap_node->children[i] = node->children[i];\n\n            if (swap_node->children[i] != NULL)\n            {\n                swap_node->children[i]->parent = swap_node;\n            }\n        }\n\n        swap_node->height = node->height;\n\n        avl_tree_node_replace(tree, node, swap_node);\n    }\n\n    free(node);\n\n    --tree->num_nodes;\n\n    avl_tree_balance_to_root(tree, balance_startpoint);\n}",
                "rust_code": "pub fn avl_tree_remove_node(mut tree: Ptr<AVLTree>, mut node: Ptr<AVLTreeNode>) {\n    let mut swap_node: Ptr<AVLTreeNode> = Default::default();\n    let mut balance_startpoint: Ptr<AVLTreeNode> = Default::default();\n    let mut i: i32 = Default::default();\n\n    swap_node = avl_tree_node_get_replacement(tree.cast(), node.cast()).cast();\n\n    if (swap_node == NULL!()).as_bool() {\n        avl_tree_node_replace(tree.cast(), node.cast(), NULL!().cast());\n\n        balance_startpoint = node.parent.cast();\n    } else {\n        if (swap_node.parent == node).as_bool() {\n            balance_startpoint = swap_node.cast();\n        } else {\n            balance_startpoint = swap_node.parent.cast();\n        }\n\n        c_for!(i = 0; i < 2; i.prefix_plus_plus(); {\n            swap_node.children[i] = node.children[i].cast();\n\n            if (swap_node.children[i] != NULL!()).as_bool() {\n                swap_node.children[i].parent = swap_node.cast();\n            }\n        });\n\n        swap_node.height = node.height.cast();\n\n        avl_tree_node_replace(tree.cast(), node.cast(), swap_node.cast());\n    }\n\n    c_free!(node);\n\n    tree.num_nodes -= 1;\n\n    avl_tree_balance_to_root(tree.cast(), balance_startpoint.cast());\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003368902)\nerror[E0282]: type annotations needed\n  --> src/translation_utils/types/null.rs:15:9\n   |\n15 |         Null().cast()\n   |         ^^^^^^^^^^^^^ cannot infer type\n   |\n  ::: src/src/avl_tree_c.rs:96:57\n   |\n96 |         avl_tree_node_replace(tree.cast(), node.cast(), NULL!().cast());\n   |                                                         ------- in this macro invocation\n   |\n   = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/avl_tree_c.rs:96:57\n    |\n96  |         avl_tree_node_replace(tree.cast(), node.cast(), NULL!().cast());\n    |                                                         ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/avl_tree_c.rs:98:35\n   |\n98 |         balance_startpoint = node.parent.cast();\n   |                                   ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:100:23\n    |\n100 |         if (swap_node.parent == node).as_bool() {\n    |                       ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:103:44\n    |\n103 |             balance_startpoint = swap_node.parent.cast();\n    |                                            ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:107:23\n    |\n107 |             swap_node.children[i] = node.children[i].cast();\n    |                       ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:107:42\n    |\n107 |             swap_node.children[i] = node.children[i].cast();\n    |                                          ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:109:27\n    |\n109 |             if (swap_node.children[i] != NULL!()).as_bool() {\n    |                           ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:110:27\n    |\n110 |                 swap_node.children[i].parent = swap_node.cast();\n    |                           ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `height` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:114:19\n    |\n114 |         swap_node.height = node.height.cast();\n    |                   ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `height` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:114:33\n    |\n114 |         swap_node.height = node.height.cast();\n    |                                 ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/avl_tree_c.rs:109:42\n    |\n109 |             if (swap_node.children[i] != NULL!()).as_bool() {\n    |                                          ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0282, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 12 previous errors\n"
            },
            {
                "c_code": "AVLTreeNode *avl_tree_lookup_node(AVLTree *tree, AVLTreeKey key)\n{\n    AVLTreeNode *node;\n    int diff;\n\n    node = tree->root_node;\n\n    while (node != NULL)\n    {\n\n        diff = tree->compare_func(key, node->key);\n\n        if (diff == 0)\n        {\n\n            return node;\n        }\n        else if (diff < 0)\n        {\n            node = node->children[AVL_TREE_NODE_LEFT];\n        }\n        else\n        {\n            node = node->children[AVL_TREE_NODE_RIGHT];\n        }\n    }\n\n    return NULL;\n}",
                "rust_code": "pub fn avl_tree_lookup_node(mut tree: Ptr<AVLTree>, mut key: AVLTreeKey) -> Ptr<AVLTreeNode> {\n    let mut node: Ptr<AVLTreeNode> = Default::default();\n    let mut diff: i32 = Default::default();\n\n    node = tree.root_node.cast();\n\n    while (node != NULL!()).as_bool() {\n\n        diff = (tree.compare_func)(key.cast(), node.key.cast()).cast();\n\n        if (diff == 0).as_bool() {\n\n            return node.cast();\n        } else if (diff < 0).as_bool() {\n            node = node.children[AVL_TREE_NODE_LEFT!()].cast();\n        } else {\n            node = node.children[AVL_TREE_NODE_RIGHT!()].cast();\n        }\n    }\n\n    return NULL!();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003369388)\nerror[E0609]: no field `key` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:116:53\n    |\n116 |         diff = (tree.compare_func)(key.cast(), node.key.cast()).cast();\n    |                                                     ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:122:25\n    |\n122 |             node = node.children[AVL_TREE_NODE_LEFT!()].cast();\n    |                         ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:124:25\n    |\n124 |             node = node.children[AVL_TREE_NODE_RIGHT!()].cast();\n    |                         ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "AVLTreeValue avl_tree_lookup(AVLTree *tree, AVLTreeKey key)\n{\n    AVLTreeNode *node;\n\n    node = avl_tree_lookup_node(tree, key);\n\n    if (node == NULL)\n    {\n        return AVL_TREE_NULL;\n    }\n    else\n    {\n        return node->value;\n    }\n}",
                "rust_code": "pub fn avl_tree_lookup(mut tree: Ptr<AVLTree>, mut key: AVLTreeKey) -> AVLTreeValue {\n    let mut node: Ptr<AVLTreeNode> = Default::default();\n\n    node = avl_tree_lookup_node(tree.cast(), key.cast()).cast();\n\n    if (node == NULL!()).as_bool() {\n        return AVL_TREE_NULL!();\n    } else {\n        return node.value.cast();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003369644)\nerror[E0609]: no field `value` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:121:21\n    |\n121 |         return node.value.cast();\n    |                     ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "AVLTreeKey avl_tree_node_key(AVLTreeNode *node)\n{\n    return node->key;\n}",
                "rust_code": "pub fn avl_tree_node_key(mut node: Ptr<AVLTreeNode>) -> AVLTreeKey {\n    return node.key.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003370124)\nerror[E0609]: no field `key` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:124:17\n    |\n124 |     return node.key.cast();\n    |                 ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "AVLTreeValue avl_tree_node_value(AVLTreeNode *node)\n{\n    return node->value;\n}",
                "rust_code": "pub fn avl_tree_node_value(mut node: Ptr<AVLTreeNode>) -> AVLTreeValue {\n    return node.value.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003370354)\nerror[E0609]: no field `value` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:129:17\n    |\n129 |     return node.value.cast();\n    |                 ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "AVLTreeNode *avl_tree_node_child(AVLTreeNode *node, AVLTreeNodeSide side)\n{\n    if (side == AVL_TREE_NODE_LEFT || side == AVL_TREE_NODE_RIGHT)\n    {\n        return node->children[side];\n    }\n    else\n    {\n        return NULL;\n    }\n}",
                "rust_code": "pub fn avl_tree_node_child(mut node: Ptr<AVLTreeNode>, mut side: AVLTreeNodeSide) -> Ptr<AVLTreeNode> {\n    if (side == AVL_TREE_NODE_LEFT!()).as_bool() || (side == AVL_TREE_NODE_RIGHT!()).as_bool() {\n        return node.children[side].cast();\n    } else {\n        return NULL!();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003370589)\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:135:21\n    |\n135 |         return node.children[side].cast();\n    |                     ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/avl_tree_c.rs:137:16\n    |\n137 |         return NULL!();\n    |                ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "AVLTreeNode *avl_tree_node_parent(AVLTreeNode *node)\n{\n    return node->parent;\n}",
                "rust_code": "pub fn avl_tree_node_parent(mut node: Ptr<AVLTreeNode>) -> Ptr<AVLTreeNode> {\n    return node.parent.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003370827)\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:139:17\n    |\n139 |     return node.parent.cast();\n    |                 ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static void avl_tree_to_array_add_subtree(AVLTreeNode *subtree, AVLTreeValue *array, int *index)\n{\n    if (subtree == NULL)\n    {\n        return;\n    }\n\n    avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_LEFT], array, index);\n\n    array[*index] = subtree->key;\n    ++*index;\n\n    avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_RIGHT], array, index);\n}",
                "rust_code": "pub fn avl_tree_to_array_add_subtree(mut subtree: Ptr<AVLTreeNode>, mut array: Ptr<AVLTreeValue>, mut index: Ptr<i32>) {\n    if (subtree == NULL!()).as_bool() {\n        return;\n    }\n    avl_tree_to_array_add_subtree(subtree.children[AVL_TREE_NODE_LEFT!()].cast(), array.cast(), index.cast());\n    array[*index] = subtree.key.cast();\n    (*index).prefix_plus_plus();\n    avl_tree_to_array_add_subtree(subtree.children[AVL_TREE_NODE_RIGHT!()].cast(), array.cast(), index.cast());\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003371298)\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:152:43\n    |\n152 |     avl_tree_to_array_add_subtree(subtree.children[AVL_TREE_NODE_LEFT!()].cast(), array.cast(), index.cast());\n    |                                           ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `key` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:153:29\n    |\n153 |     array[*index] = subtree.key.cast();\n    |                             ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n   --> src/src/avl_tree_c.rs:155:43\n    |\n155 |     avl_tree_to_array_add_subtree(subtree.children[AVL_TREE_NODE_RIGHT!()].cast(), array.cast(), index.cast());\n    |                                           ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "BloomFilter *bloom_filter_new(unsigned int table_size, BloomFilterHashFunc hash_func, unsigned int num_functions)\n{\n    BloomFilter *filter;\n\n    if (num_functions > sizeof(salts) / sizeof(*salts))\n    {\n        return NULL;\n    }\n\n    filter = malloc(sizeof(BloomFilter));\n\n    if (filter == NULL)\n    {\n        return NULL;\n    }\n\n    filter->table = calloc((table_size + 7) / 8, 1);\n\n    if (filter->table == NULL)\n    {\n        free(filter);\n        return NULL;\n    }\n\n    filter->hash_func = hash_func;\n    filter->num_functions = num_functions;\n    filter->table_size = table_size;\n\n    return filter;\n}",
                "rust_code": "pub fn bloom_filter_new(mut table_size: u32, mut hash_func: BloomFilterHashFunc, mut num_functions: u32) -> Ptr<BloomFilter> {\n    let mut filter: Ptr<BloomFilter>;\n\n    if (num_functions > (c_sizeofval!(salts) / c_sizeofval!(*salts))).as_bool() {\n        return NULL!();\n    }\n\n    filter = c_malloc!(c_sizeof!(BloomFilter));\n\n    if (filter == NULL!()).as_bool() {\n        return NULL!();\n    }\n\n    filter.table = c_calloc!((table_size + 7) / 8, 1);\n\n    if (filter.table == NULL!()).as_bool() {\n        c_free!(filter);\n        return NULL!();\n    }\n\n    filter.hash_func = hash_func.cast();\n    filter.num_functions = num_functions.cast();\n    filter.table_size = table_size.cast();\n\n    return filter.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003371777)\nerror[E0614]: type `types::array::Array<u32, 64>` cannot be dereferenced\n  --> src/src/bloom_filter_c.rs:29:61\n   |\n29 |     if (num_functions > (c_sizeofval!(salts) / c_sizeofval!(*salts))).as_bool() {\n   |                                                             ^^^^^^ can't be dereferenced\n\nerror[E0308]: mismatched types\n  --> src/src/bloom_filter_c.rs:29:25\n   |\n29 |     if (num_functions > (c_sizeofval!(salts) / c_sizeofval!(*salts))).as_bool() {\n   |         -------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found `Num`\n   |         |\n   |         expected because this is `u32`\n\nSome errors have detailed explanations: E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "void bloom_filter_insert(BloomFilter *bloomfilter, BloomFilterValue value)\n{\n    unsigned int hash;\n    unsigned int subhash;\n    unsigned int index;\n    unsigned int i;\n    unsigned char b;\n\n    hash = bloomfilter->hash_func(value);\n\n    for (i = 0; i < bloomfilter->num_functions; ++i)\n    {\n\n        subhash = hash ^ salts[i];\n\n        index = subhash % bloomfilter->table_size;\n\n        b = (unsigned char)(1 << (index % 8));\n        bloomfilter->table[index / 8] |= b;\n    }\n}",
                "rust_code": "pub fn bloom_filter_insert(mut bloomfilter: Ptr<BloomFilter>, mut value: BloomFilterValue) {\n    let mut hash: u32;\n    let mut subhash: u32;\n    let mut index: u32;\n    let mut i: u32;\n    let mut b: u8;\n\n    hash = bloomfilter.hash_func(value.cast());\n\n    c_for!(i = 0; i < bloomfilter.num_functions; i.prefix_plus_plus(); {\n        subhash = hash ^ salts[i];\n        index = subhash % bloomfilter.table_size;\n        b = (1 << (index % 8)).cast::<u8>();\n        bloomfilter.table[index / 8] |= b;\n    });\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003372309)\nerror[E0599]: no method named `hash_func` found for struct `memory::ptr::Ptr<_BloomFilter>` in the current scope\n  --> src/src/bloom_filter_c.rs:44:24\n   |\n44 |     hash = bloomfilter.hash_func(value.cast());\n   |                        ^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `hash_func` not found for this struct\n   |\nhelp: to call the function pointer stored in `hash_func`, surround the field access with parentheses\n   |\n44 |     hash = (bloomfilter.hash_func)(value.cast());\n   |            +                     +\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int bloom_filter_query(BloomFilter *bloomfilter, BloomFilterValue value)\n{\n    unsigned int hash;\n    unsigned int subhash;\n    unsigned int index;\n    unsigned int i;\n    unsigned char b;\n    int bit;\n\n    hash = bloomfilter->hash_func(value);\n\n    for (i = 0; i < bloomfilter->num_functions; ++i)\n    {\n\n        subhash = hash ^ salts[i];\n\n        index = subhash % bloomfilter->table_size;\n\n        b = bloomfilter->table[index / 8];\n        bit = 1 << (index % 8);\n\n        if ((b & bit) == 0)\n        {\n            return 0;\n        }\n    }\n\n    return 1;\n}",
                "rust_code": "pub fn bloom_filter_query(mut bloomfilter: Ptr<BloomFilter>, mut value: BloomFilterValue) -> i32 {\n    let mut hash: u32;\n    let mut subhash: u32;\n    let mut index: u32;\n    let mut i: u32;\n    let mut b: u8;\n    let mut bit: i32;\n\n    hash = bloomfilter.hash_func(value).cast();\n\n    c_for!(i = 0; i < bloomfilter.num_functions; i.prefix_plus_plus(); {\n        subhash = (hash ^ salts[i]).cast();\n\n        index = (subhash % bloomfilter.table_size).cast();\n\n        b = bloomfilter.table[index / 8].cast();\n        bit = (1 << (index % 8)).cast();\n\n        if ((b & bit) == 0).as_bool() {\n            return 0;\n        }\n    });\n\n    return 1;\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003372562)\nerror[E0599]: no method named `hash_func` found for struct `memory::ptr::Ptr<_BloomFilter>` in the current scope\n  --> src/src/bloom_filter_c.rs:50:24\n   |\n50 |     hash = bloomfilter.hash_func(value).cast();\n   |                        ^^^^^^^^^ field, not a method\n   |\n  ::: src/translation_utils/memory/ptr.rs:8:1\n   |\n8  | pub struct Ptr<T>(pub Option<NonNull<T>>);\n   | ----------------- method `hash_func` not found for this struct\n   |\nhelp: to call the function pointer stored in `hash_func`, surround the field access with parentheses\n   |\n50 |     hash = (bloomfilter.hash_func)(value).cast();\n   |            +                     +\n\nerror[E0308]: mismatched types\n  --> src/src/bloom_filter_c.rs:60:18\n   |\n60 |         if ((b & bit) == 0).as_bool() {\n   |                  ^^^ expected `u8`, found `i32`\n\nerror[E0277]: no implementation for `u8 & i32`\n  --> src/src/bloom_filter_c.rs:60:16\n   |\n60 |         if ((b & bit) == 0).as_bool() {\n   |                ^ no implementation for `u8 & i32`\n   |\n   = help: the trait `BitAnd<i32>` is not implemented for `u8`\n   = help: the following other types implement trait `BitAnd<Rhs>`:\n             `&u8` implements `BitAnd<u8>`\n             `&u8` implements `BitAnd`\n             `u8` implements `BitAnd<&u8>`\n             `u8` implements `BitAnd`\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "static int hash_table_allocate_table(HashTable *hash_table)\n{\n    unsigned int new_table_size;\n\n    if (hash_table->prime_index < hash_table_num_primes)\n    {\n        new_table_size = hash_table_primes[hash_table->prime_index];\n    }\n    else\n    {\n        new_table_size = hash_table->entries * 10;\n    }\n\n    hash_table->table_size = new_table_size;\n\n    hash_table->table = calloc(hash_table->table_size, sizeof(HashTableEntry *));\n\n    return hash_table->table != NULL;\n}",
                "rust_code": "pub fn hash_table_allocate_table(mut hash_table: Ptr<HashTable>) -> i32 {\n    let mut new_table_size: u32 = Default::default();\n\n    if (hash_table.prime_index < hash_table_num_primes!()).as_bool() {\n        new_table_size = hash_table_primes[hash_table.prime_index].cast();\n    } else {\n        new_table_size = (hash_table.entries * 10).cast();\n    }\n\n    hash_table.table_size = new_table_size.cast();\n\n    hash_table.table = c_calloc!(hash_table.table_size, c_sizeof!(Ptr<HashTableEntry>));\n\n    return (hash_table.table != NULL!()).cast::<i32>();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003375284)\nerror: cannot find macro `hash_table_num_primes` in this scope\n  --> src/src/hash_table_c.rs:39:34\n   |\n39 |     if (hash_table.prime_index < hash_table_num_primes!()).as_bool() {\n   |                                  ^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `hash_table_num_primes` is in scope, but it is a constant, not a macro\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static int set_allocate_table(Set *set)\n{\n\n    if (set->prime_index < set_num_primes)\n    {\n        set->table_size = set_primes[set->prime_index];\n    }\n    else\n    {\n        set->table_size = set->entries * 10;\n    }\n\n    set->table = calloc(set->table_size, sizeof(SetEntry *));\n\n    return set->table != NULL;\n}",
                "rust_code": "pub fn set_allocate_table(mut set: Ptr<Set>) -> i32 {\n    if (set.prime_index < set_num_primes!()).as_bool() {\n        set.table_size = set_primes[set.prime_index].cast();\n    } else {\n        set.table_size = (set.entries * 10).cast();\n    }\n    set.table = c_calloc!(set.table_size, c_sizeof!(Ptr<SetEntry>));\n    return (set.table != NULL!()).cast::<i32>();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003378562)\nerror: cannot find macro `set_num_primes` in this scope\n  --> src/src/set_c.rs:36:27\n   |\n36 |     if (set.prime_index < set_num_primes!()).as_bool() {\n   |                           ^^^^^^^^^^^^^^\n   |\n   = note: `set_num_primes` is in scope, but it is a constant, not a macro\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "BinaryHeapValue binary_heap_pop(BinaryHeap *heap)\n{\n    BinaryHeapValue result;\n    BinaryHeapValue new_value;\n    unsigned int index;\n    unsigned int next_index;\n    unsigned int child1, child2;\n\n    if (heap->num_values == 0)\n    {\n        return BINARY_HEAP_NULL;\n    }\n\n    result = heap->values[0];\n\n    new_value = heap->values[heap->num_values - 1];\n    --heap->num_values;\n\n    index = 0;\n\n    for (;;)\n    {\n\n        child1 = index * 2 + 1;\n        child2 = index * 2 + 2;\n\n        if (child1 < heap->num_values && binary_heap_cmp(heap, new_value, heap->values[child1]) > 0)\n        {\n\n            if (child2 < heap->num_values && binary_heap_cmp(heap, heap->values[child1], heap->values[child2]) > 0)\n            {\n                next_index = child2;\n            }\n            else\n            {\n                next_index = child1;\n            }\n        }\n        else if (child2 < heap->num_values && binary_heap_cmp(heap, new_value, heap->values[child2]) > 0)\n        {\n\n            next_index = child2;\n        }\n        else\n        {\n\n            heap->values[index] = new_value;\n            break;\n        }\n\n        heap->values[index] = heap->values[next_index];\n\n        index = next_index;\n    }\n\n    return result;\n}",
                "rust_code": "pub fn binary_heap_pop(mut heap: Ptr<BinaryHeap>) -> BinaryHeapValue {\n    let mut result: BinaryHeapValue = Default::default();\n    let mut new_value: BinaryHeapValue = Default::default();\n    let mut index: u32 = Default::default();\n    let mut next_index: u32 = Default::default();\n    let mut child1: u32 = Default::default();\n    let mut child2: u32 = Default::default();\n\n    if (heap.num_values == 0).as_bool() {\n        return BINARY_HEAP_NULL!();\n    }\n\n    result = heap.values[0].cast();\n\n    new_value = heap.values[heap.num_values - 1].cast();\n    heap.num_values -= 1;\n\n    index = 0;\n\n    loop {\n        child1 = index * 2 + 1;\n        child2 = index * 2 + 2;\n\n        if (child1 < heap.num_values).as_bool() && (binary_heap_cmp(heap.cast(), new_value.cast(), heap.values[child1].cast()) > 0).as_bool() {\n            if (child2 < heap.num_values).as_bool() && (binary_heap_cmp(heap.cast(), heap.values[child1].cast(), heap.values[child2].cast()) > 0).as_bool() {\n                next_index = child2;\n            } else {\n                next_index = child1;\n            }\n        } else if (child2 < heap.num_values).as_bool() && (binary_heap_cmp(heap.cast(), new_value.cast(), heap.values[child2].cast()) > 0).as_bool() {\n            next_index = child2;\n        } else {\n            heap.values[index] = new_value.cast();\n            break;\n        }\n\n        heap.values[index] = heap.values[next_index].cast();\n\n        index = next_index;\n    }\n\n    return result.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003387223)\nerror[E0502]: cannot borrow `heap` as immutable because it is also borrowed as mutable\n   --> src/src/binary_heap_c.rs:104:29\n    |\n104 |     new_value = heap.values[heap.num_values - 1].cast();\n    |                 ----       -^^^^----------------\n    |                 |          ||\n    |                 |          |immutable borrow occurs here\n    |                 |          mutable borrow later used here\n    |                 mutable borrow occurs here\n    |\nhelp: try adding a local storing this...\n   --> src/src/binary_heap_c.rs:104:29\n    |\n104 |     new_value = heap.values[heap.num_values - 1].cast();\n    |                             ^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n   --> src/src/binary_heap_c.rs:104:28\n    |\n104 |     new_value = heap.values[heap.num_values - 1].cast();\n    |                            ^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static void trie_free_list_push(TrieNode **list, TrieNode *node)\n{\n    node->data = *list;\n    *list = node;\n}",
                "rust_code": "pub fn trie_free_list_push(mut list: Ptr<Ptr<TrieNode>>, mut node: Ptr<TrieNode>) {\n    node.data = (*list).cast();\n    *list = node.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003388290)\nerror[E0609]: no field `data` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:27:10\n   |\n27 |     node.data = (*list).cast();\n   |          ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static TrieNode *trie_free_list_pop(TrieNode **list)\n{\n    TrieNode *result;\n\n    result = *list;\n    *list = result->data;\n\n    return result;\n}",
                "rust_code": "pub fn trie_free_list_pop(mut list: Ptr<Ptr<TrieNode>>) -> Ptr<TrieNode> {\n    let mut result: Ptr<TrieNode>;\n    result = *list;\n    *list = result.data.cast();\n    return result.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003388542)\nerror[E0609]: no field `data` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:34:20\n   |\n34 |     *list = result.data.cast();\n   |                    ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void trie_free(Trie *trie)\n{\n    TrieNode *free_list;\n    TrieNode *node;\n    int i;\n\n    free_list = NULL;\n\n    if (trie->root_node != NULL)\n    {\n        trie_free_list_push(&free_list, trie->root_node);\n    }\n\n    while (free_list != NULL)\n    {\n        node = trie_free_list_pop(&free_list);\n\n        for (i = 0; i < 256; ++i)\n        {\n            if (node->next[i] != NULL)\n            {\n                trie_free_list_push(&free_list, node->next[i]);\n            }\n        }\n\n        free(node);\n    }\n\n    free(trie);\n}",
                "rust_code": "pub fn trie_free(mut trie: Ptr<Trie>) {\n    let mut free_list: Ptr<TrieNode> = NULL!();\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut i: i32 = Default::default();\n\n    if (trie.root_node != NULL!()).as_bool() {\n        trie_free_list_push(c_ref!(free_list).cast(), trie.root_node.cast());\n    }\n\n    while (free_list != NULL!()).as_bool() {\n        node = trie_free_list_pop(c_ref!(free_list).cast());\n\n        c_for!(i = 0; i < 256; i.prefix_plus_plus(); {\n            if (node.next[i] != NULL!()).as_bool() {\n                trie_free_list_push(c_ref!(free_list).cast(), node.next[i].cast());\n            }\n        });\n\n        c_free!(node);\n    }\n\n    c_free!(trie);\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003388797)\nerror[E0609]: no field `next` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:49:22\n   |\n49 |             if (node.next[i] != NULL!()).as_bool() {\n   |                      ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `next` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:50:68\n   |\n50 |                 trie_free_list_push(c_ref!(free_list).cast(), node.next[i].cast());\n   |                                                                    ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/trie_c.rs:49:33\n    |\n49  |             if (node.next[i] != NULL!()).as_bool() {\n    |                                 ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "static TrieNode *trie_find_end(Trie *trie, char *key)\n{\n    TrieNode *node;\n    char *p;\n\n    node = trie->root_node;\n\n    for (p = key; *p != '\\0'; ++p)\n    {\n\n        if (node == NULL)\n        {\n\n            return NULL;\n        }\n\n        node = node->next[(unsigned char)*p];\n    }\n\n    return node;\n}",
                "rust_code": "pub fn trie_find_end(mut trie: Ptr<Trie>, mut key: Ptr<u8>) -> Ptr<TrieNode> {\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut p: Ptr<u8> = Default::default();\n\n    node = trie.root_node.cast();\n\n    c_for!(p = key; *p != 0; p.suffix_plus_plus(); {\n        if (node == NULL!()).as_bool() {\n            return NULL!();\n        }\n\n        node = node.next[*p].cast();\n    });\n\n    return node.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003389061)\nerror[E0609]: no field `next` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:52:21\n   |\n52 |         node = node.next[*p].cast();\n   |                     ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static TrieNode *trie_find_end_binary(Trie *trie, unsigned char *key, int key_length)\n{\n    TrieNode *node;\n    int j;\n    int c;\n\n    node = trie->root_node;\n\n    for (j = 0; j < key_length; j++)\n    {\n\n        if (node == NULL)\n        {\n\n            return NULL;\n        }\n\n        c = (unsigned char)key[j];\n\n        node = node->next[c];\n    }\n\n    return node;\n}",
                "rust_code": "pub fn trie_find_end_binary(mut trie: Ptr<Trie>, mut key: Ptr<u8>, mut key_length: i32) -> Ptr<TrieNode> {\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut j: i32 = Default::default();\n    let mut c: i32 = Default::default();\n\n    node = trie.root_node.cast();\n\n    c_for!(j = 0; j < key_length; j.suffix_plus_plus(); {\n        if (node == NULL!()).as_bool() {\n            return NULL!();\n        }\n\n        c = key[j].cast::<u8>().cast::<i32>();\n\n        node = node.next[c].cast();\n    });\n\n    return node.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003389325)\nerror[E0609]: no field `next` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:60:21\n   |\n60 |         node = node.next[c].cast();\n   |                     ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static void trie_insert_rollback(Trie *trie, unsigned char *key)\n{\n    TrieNode *node;\n    TrieNode **prev_ptr;\n    TrieNode *next_node;\n    TrieNode **next_prev_ptr;\n    unsigned char *p;\n\n    node = trie->root_node;\n    prev_ptr = &trie->root_node;\n    p = key;\n\n    while (node != NULL)\n    {\n\n        next_prev_ptr = &node->next[(unsigned char)*p];\n        next_node = *next_prev_ptr;\n        ++p;\n\n        --node->use_count;\n\n        if (node->use_count == 0)\n        {\n            free(node);\n\n            if (prev_ptr != NULL)\n            {\n                *prev_ptr = NULL;\n            }\n\n            next_prev_ptr = NULL;\n        }\n\n        node = next_node;\n        prev_ptr = next_prev_ptr;\n    }\n}",
                "rust_code": "pub fn trie_insert_rollback(mut trie: Ptr<Trie>, mut key: Ptr<u8>) {\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut prev_ptr: Ptr<Ptr<TrieNode>> = Default::default();\n    let mut next_node: Ptr<TrieNode> = Default::default();\n    let mut next_prev_ptr: Ptr<Ptr<TrieNode>> = Default::default();\n    let mut p: Ptr<u8> = Default::default();\n\n    node = trie.root_node.cast();\n    prev_ptr = c_ref!(trie.root_node).cast();\n    p = key.cast();\n\n    while (node != NULL!()).as_bool() {\n        next_prev_ptr = c_ref!(node.next[*p]).cast();\n        next_node = *next_prev_ptr;\n        p += 1;\n\n        node.use_count -= 1;\n\n        if (node.use_count == 0).as_bool() {\n            c_free!(node);\n\n            if (prev_ptr != NULL!()).as_bool() {\n                *prev_ptr = NULL!();\n            }\n\n            next_prev_ptr = NULL!();\n        }\n\n        node = next_node.cast();\n        prev_ptr = next_prev_ptr.cast();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003389588)\nerror[E0609]: no field `next` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:63:37\n   |\n63 |         next_prev_ptr = c_ref!(node.next[*p]).cast();\n   |                                     ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `use_count` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:67:14\n   |\n67 |         node.use_count -= 1;\n   |              ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `use_count` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:69:18\n   |\n69 |         if (node.use_count == 0).as_bool() {\n   |                  ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "int trie_insert(Trie *trie, char *key, TrieValue value)\n{\n    TrieNode **rover;\n    TrieNode *node;\n    char *p;\n    int c;\n\n    if (value == TRIE_NULL)\n    {\n        return 0;\n    }\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = value;\n        return 1;\n    }\n\n    rover = &trie->root_node;\n    p = key;\n\n    for (;;)\n    {\n\n        node = *rover;\n\n        if (node == NULL)\n        {\n\n            node = (TrieNode *)calloc(1, sizeof(TrieNode));\n\n            if (node == NULL)\n            {\n\n                trie_insert_rollback(trie, (unsigned char *)key);\n\n                return 0;\n            }\n\n            node->data = TRIE_NULL;\n\n            *rover = node;\n        }\n\n        ++node->use_count;\n\n        c = (unsigned char)*p;\n\n        if (c == '\\0')\n        {\n\n            node->data = value;\n\n            break;\n        }\n\n        rover = &node->next[c];\n        ++p;\n    }\n\n    return 1;\n}",
                "rust_code": "pub fn trie_insert(mut trie: Ptr<Trie>, mut key: Ptr<u8>, mut value: TrieValue) -> i32 {\n    let mut rover: Ptr<Ptr<TrieNode>> = Default::default();\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut p: Ptr<u8> = Default::default();\n    let mut c: i32 = Default::default();\n\n    if (value == TRIE_NULL!()).as_bool() {\n        return 0;\n    }\n\n    node = trie_find_end(trie.cast(), key.cast()).cast();\n\n    if (node != NULL!()).as_bool() && (node.data != TRIE_NULL!()).as_bool() {\n        node.data = value.cast();\n        return 1;\n    }\n\n    rover = c_ref!(trie.root_node).cast();\n    p = key.cast();\n\n    loop {\n        node = *rover;\n\n        if (node == NULL!()).as_bool() {\n            node = c_calloc!(1, c_sizeof!(TrieNode));\n\n            if (node == NULL!()).as_bool() {\n                trie_insert_rollback(trie.cast(), key.cast::<Ptr<u8>>());\n\n                return 0;\n            }\n\n            node.data = TRIE_NULL!();\n\n            *rover = node.cast();\n        }\n\n        node.use_count.prefix_plus_plus();\n\n        c = (*p).cast::<u8>().cast::<i32>();\n\n        if (c == '\\0').as_bool() {\n            node.data = value.cast();\n\n            break;\n        }\n\n        rover = c_ref!(node.next[c]).cast();\n        p.prefix_plus_plus();\n    }\n\n    return 1;\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003389859)\nerror[E0609]: no field `data` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:68:45\n   |\n68 |     if (node != NULL!()).as_bool() && (node.data != TRIE_NULL!()).as_bool() {\n   |                                             ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `data` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:69:14\n   |\n69 |         node.data = value.cast();\n   |              ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `data` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:88:18\n   |\n88 |             node.data = TRIE_NULL!();\n   |                  ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/trie_c.rs:88:25\n    |\n88  |             node.data = TRIE_NULL!();\n    |                         ------------ in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` which comes from the expansion of the macro `TRIE_NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `use_count` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:93:14\n   |\n93 |         node.use_count.prefix_plus_plus();\n   |              ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0308]: mismatched types\n  --> src/src/trie_c.rs:97:18\n   |\n97 |         if (c == '\\0').as_bool() {\n   |             -    ^^^^ expected `i32`, found `char`\n   |             |\n   |             expected because this is `i32`\n   |\nhelp: you can cast a `char` to an `i32`, since a `char` always occupies 4 bytes\n   |\n97 |         if (c == '\\0' as i32).as_bool() {\n   |                       ++++++\n\nerror[E0609]: no field `data` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:98:18\n   |\n98 |             node.data = value.cast();\n   |                  ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `next` on type `memory::ptr::Ptr<i32>`\n   --> src/src/trie_c.rs:103:29\n    |\n103 |         rover = c_ref!(node.next[c]).cast();\n    |                             ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/trie_c.rs:68:53\n    |\n68  |     if (node != NULL!()).as_bool() && (node.data != TRIE_NULL!()).as_bool() {\n    |                                                     ------------ in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` which comes from the expansion of the macro `TRIE_NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 9 previous errors\n"
            },
            {
                "c_code": "int trie_insert_binary(Trie *trie, unsigned char *key, int key_length, TrieValue value)\n{\n    TrieNode **rover;\n    TrieNode *node;\n    int p, c;\n\n    if (value == TRIE_NULL)\n    {\n        return 0;\n    }\n\n    node = trie_find_end_binary(trie, key, key_length);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = value;\n        return 1;\n    }\n\n    rover = &trie->root_node;\n    p = 0;\n\n    for (;;)\n    {\n\n        node = *rover;\n\n        if (node == NULL)\n        {\n\n            node = (TrieNode *)calloc(1, sizeof(TrieNode));\n\n            if (node == NULL)\n            {\n\n                trie_insert_rollback(trie, key);\n\n                return 0;\n            }\n\n            node->data = TRIE_NULL;\n\n            *rover = node;\n        }\n\n        ++node->use_count;\n\n        c = (unsigned char)key[p];\n\n        if (p == key_length)\n        {\n\n            node->data = value;\n\n            break;\n        }\n\n        rover = &node->next[c];\n        ++p;\n    }\n\n    return 1;\n}",
                "rust_code": "pub fn trie_insert_binary(mut trie: Ptr<Trie>, mut key: Ptr<u8>, mut key_length: i32, mut value: TrieValue) -> i32 {\n    let mut rover: Ptr<Ptr<TrieNode>> = Default::default();\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut p: i32 = Default::default();\n    let mut c: i32 = Default::default();\n\n    if (value == TRIE_NULL!()).as_bool() {\n        return 0;\n    }\n\n    node = trie_find_end_binary(trie.cast(), key.cast(), key_length.cast()).cast();\n\n    if (node != NULL!()).as_bool() && (node.data != TRIE_NULL!()).as_bool() {\n        node.data = value.cast();\n        return 1;\n    }\n\n    rover = c_ref!(trie.root_node).cast();\n    p = 0;\n\n    loop {\n        node = *rover;\n\n        if (node == NULL!()).as_bool() {\n            node = c_calloc!(1, c_sizeof!(TrieNode));\n\n            if (node == NULL!()).as_bool() {\n                trie_insert_rollback(trie.cast(), key.cast()).cast();\n\n                return 0;\n            }\n\n            node.data = TRIE_NULL!();\n\n            *rover = node.cast();\n        }\n\n        node.use_count.prefix_plus_plus();\n\n        c = key[p].cast::<u8>();\n\n        if (p == key_length).as_bool() {\n            node.data = value.cast();\n\n            break;\n        }\n\n        rover = c_ref!(node.next[c]).cast();\n        p.prefix_plus_plus();\n    }\n\n    return 1;\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003390133)\nerror[E0609]: no field `data` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:73:45\n   |\n73 |     if (node != NULL!()).as_bool() && (node.data != TRIE_NULL!()).as_bool() {\n   |                                             ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `data` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:74:14\n   |\n74 |         node.data = value.cast();\n   |              ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `data` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:93:18\n   |\n93 |             node.data = TRIE_NULL!();\n   |                  ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/trie_c.rs:93:25\n    |\n93  |             node.data = TRIE_NULL!();\n    |                         ------------ in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` which comes from the expansion of the macro `TRIE_NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `use_count` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:98:14\n   |\n98 |         node.use_count.prefix_plus_plus();\n   |              ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0308]: mismatched types\n   --> src/src/trie_c.rs:100:13\n    |\n65  |     let mut c: i32 = Default::default();\n    |                --- expected due to this type\n...\n100 |         c = key[p].cast::<u8>();\n    |             ^^^^^^^^^^^^^^^^^^^ expected `i32`, found `u8`\n\nerror[E0609]: no field `data` on type `memory::ptr::Ptr<i32>`\n   --> src/src/trie_c.rs:103:18\n    |\n103 |             node.data = value.cast();\n    |                  ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `next` on type `memory::ptr::Ptr<i32>`\n   --> src/src/trie_c.rs:108:29\n    |\n108 |         rover = c_ref!(node.next[c]).cast();\n    |                             ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `(): cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/src/trie_c.rs:88:63\n    |\n88  |                 trie_insert_rollback(trie.cast(), key.cast()).cast();\n    |                                                               ^^^^ the trait `integer::Integer` is not implemented for `()`\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<()>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `()` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/trie_c.rs:73:53\n    |\n73  |     if (node != NULL!()).as_bool() && (node.data != TRIE_NULL!()).as_bool() {\n    |                                                     ------------ in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` which comes from the expansion of the macro `TRIE_NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 10 previous errors\n"
            },
            {
                "c_code": "int trie_remove_binary(Trie *trie, unsigned char *key, int key_length)\n{\n    TrieNode *node;\n    TrieNode *next;\n    TrieNode **last_next_ptr;\n    int p, c;\n\n    node = trie_find_end_binary(trie, key, key_length);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = TRIE_NULL;\n    }\n    else\n    {\n        return 0;\n    }\n\n    node = trie->root_node;\n    last_next_ptr = &trie->root_node;\n    p = 0;\n\n    for (;;)\n    {\n\n        c = (unsigned char)key[p];\n        next = node->next[c];\n\n        --node->use_count;\n\n        if (node->use_count <= 0)\n        {\n            free(node);\n\n            if (last_next_ptr != NULL)\n            {\n                *last_next_ptr = NULL;\n                last_next_ptr = NULL;\n            }\n        }\n\n        if (p == key_length)\n        {\n            break;\n        }\n        else\n        {\n            ++p;\n        }\n\n        if (last_next_ptr != NULL)\n        {\n            last_next_ptr = &node->next[c];\n        }\n\n        node = next;\n    }\n\n    return 1;\n}",
                "rust_code": "pub fn trie_remove_binary(mut trie: Ptr<Trie>, mut key: Ptr<u8>, mut key_length: i32) -> i32 {\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut next: Ptr<TrieNode> = Default::default();\n    let mut last_next_ptr: Ptr<Ptr<TrieNode>> = Default::default();\n    let mut p: i32 = Default::default();\n    let mut c: i32 = Default::default();\n\n    node = trie_find_end_binary(trie.cast(), key.cast(), key_length.cast()).cast();\n\n    if (node != NULL!()).as_bool() && (node.data != TRIE_NULL!()).as_bool() {\n        node.data = TRIE_NULL!();\n    } else {\n        return 0;\n    }\n\n    node = trie.root_node.cast();\n    last_next_ptr = c_ref!(trie.root_node).cast();\n    p = 0;\n\n    loop {\n        c = key[p].cast::<u8>().cast::<i32>();\n        next = node.next[c].cast();\n\n        node.use_count -= 1;\n\n        if (node.use_count <= 0).as_bool() {\n            c_free!(node);\n\n            if (last_next_ptr != NULL!()).as_bool() {\n                *last_next_ptr = NULL!();\n                last_next_ptr = NULL!();\n            }\n        }\n\n        if (p == key_length).as_bool() {\n            break;\n        } else {\n            p += 1;\n        }\n\n        if (last_next_ptr != NULL!()).as_bool() {\n            last_next_ptr = c_ref!(node.next[c]).cast();\n        }\n\n        node = next.cast();\n    }\n\n    return 1;\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003390405)\nerror[E0609]: no field `data` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:75:45\n   |\n75 |     if (node != NULL!()).as_bool() && (node.data != TRIE_NULL!()).as_bool() {\n   |                                             ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `data` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:76:14\n   |\n76 |         node.data = TRIE_NULL!();\n   |              ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/trie_c.rs:76:21\n    |\n76  |         node.data = TRIE_NULL!();\n    |                     ------------ in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` which comes from the expansion of the macro `TRIE_NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `next` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:87:21\n   |\n87 |         next = node.next[c].cast();\n   |                     ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `use_count` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:89:14\n   |\n89 |         node.use_count -= 1;\n   |              ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `use_count` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:91:18\n   |\n91 |         if (node.use_count <= 0).as_bool() {\n   |                  ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `next` on type `memory::ptr::Ptr<i32>`\n   --> src/src/trie_c.rs:107:41\n    |\n107 |             last_next_ptr = c_ref!(node.next[c]).cast();\n    |                                         ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/trie_c.rs:75:53\n    |\n75  |     if (node != NULL!()).as_bool() && (node.data != TRIE_NULL!()).as_bool() {\n    |                                                     ------------ in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` which comes from the expansion of the macro `TRIE_NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"
            },
            {
                "c_code": "int trie_remove(Trie *trie, char *key)\n{\n    TrieNode *node;\n    TrieNode *next;\n    TrieNode **last_next_ptr;\n    char *p;\n    int c;\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = TRIE_NULL;\n    }\n    else\n    {\n        return 0;\n    }\n\n    node = trie->root_node;\n    last_next_ptr = &trie->root_node;\n    p = key;\n\n    for (;;)\n    {\n\n        c = (unsigned char)*p;\n        next = node->next[c];\n\n        --node->use_count;\n\n        if (node->use_count <= 0)\n        {\n            free(node);\n\n            if (last_next_ptr != NULL)\n            {\n                *last_next_ptr = NULL;\n                last_next_ptr = NULL;\n            }\n        }\n\n        if (c == '\\0')\n        {\n            break;\n        }\n        else\n        {\n            ++p;\n        }\n\n        if (last_next_ptr != NULL)\n        {\n            last_next_ptr = &node->next[c];\n        }\n\n        node = next;\n    }\n\n    return 1;\n}",
                "rust_code": "pub fn trie_remove(mut trie: Ptr<Trie>, mut key: Ptr<u8>) -> i32 {\n    let mut node: Ptr<TrieNode> = Default::default();\n    let mut next: Ptr<TrieNode> = Default::default();\n    let mut last_next_ptr: Ptr<Ptr<TrieNode>> = Default::default();\n    let mut p: Ptr<u8> = Default::default();\n    let mut c: i32 = Default::default();\n\n    node = trie_find_end(trie.cast(), key.cast()).cast();\n\n    if (node != NULL!()).as_bool() && (node.data != TRIE_NULL!()).as_bool() {\n        node.data = TRIE_NULL!();\n    } else {\n        return 0;\n    }\n\n    node = trie.root_node.cast();\n    last_next_ptr = c_ref!(trie.root_node).cast();\n    p = key.cast();\n\n    loop {\n        c = (*p).cast::<u8>().cast::<i32>();\n        next = node.next[c].cast();\n\n        node.use_count -= 1;\n\n        if (node.use_count <= 0).as_bool() {\n            c_free!(node);\n\n            if (last_next_ptr != NULL!()).as_bool() {\n                *last_next_ptr = NULL!();\n                last_next_ptr = NULL!();\n            }\n        }\n\n        if (c == '\\0' as i32).as_bool() {\n            break;\n        } else {\n            p += 1;\n        }\n\n        if (last_next_ptr != NULL!()).as_bool() {\n            last_next_ptr = c_ref!(node.next[c]).cast();\n        }\n\n        node = next.cast();\n    }\n\n    return 1;\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003390669)\nerror[E0609]: no field `data` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:80:45\n   |\n80 |     if (node != NULL!()).as_bool() && (node.data != TRIE_NULL!()).as_bool() {\n   |                                             ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `data` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:81:14\n   |\n81 |         node.data = TRIE_NULL!();\n   |              ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/trie_c.rs:81:21\n    |\n81  |         node.data = TRIE_NULL!();\n    |                     ------------ in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` which comes from the expansion of the macro `TRIE_NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0609]: no field `next` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:92:21\n   |\n92 |         next = node.next[c].cast();\n   |                     ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `use_count` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:94:14\n   |\n94 |         node.use_count -= 1;\n   |              ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `use_count` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:96:18\n   |\n96 |         if (node.use_count <= 0).as_bool() {\n   |                  ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `next` on type `memory::ptr::Ptr<i32>`\n   --> src/src/trie_c.rs:112:41\n    |\n112 |             last_next_ptr = c_ref!(node.next[c]).cast();\n    |                                         ^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/trie_c.rs:80:53\n    |\n80  |     if (node != NULL!()).as_bool() && (node.data != TRIE_NULL!()).as_bool() {\n    |                                                     ------------ in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` which comes from the expansion of the macro `TRIE_NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"
            },
            {
                "c_code": "TrieValue trie_lookup(Trie *trie, char *key)\n{\n    TrieNode *node;\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL)\n    {\n        return node->data;\n    }\n    else\n    {\n        return TRIE_NULL;\n    }\n}",
                "rust_code": "pub fn trie_lookup(mut trie: Ptr<Trie>, mut key: Ptr<u8>) -> TrieValue {\n    let mut node: Ptr<TrieNode> = Default::default();\n\n    node = trie_find_end(trie.cast(), key.cast()).cast();\n\n    if (node != NULL!()).as_bool() {\n        return node.data.cast();\n    } else {\n        return TRIE_NULL!();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003390942)\nerror[E0609]: no field `data` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:82:21\n   |\n82 |         return node.data.cast();\n   |                     ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/trie_c.rs:84:16\n    |\n84  |         return TRIE_NULL!();\n    |                ------------ in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` which comes from the expansion of the macro `TRIE_NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "TrieValue trie_lookup_binary(Trie *trie, unsigned char *key, int key_length)\n{\n    TrieNode *node;\n\n    node = trie_find_end_binary(trie, key, key_length);\n\n    if (node != NULL)\n    {\n        return node->data;\n    }\n    else\n    {\n        return TRIE_NULL;\n    }\n}",
                "rust_code": "pub fn trie_lookup_binary(mut trie: Ptr<Trie>, mut key: Ptr<u8>, mut key_length: i32) -> TrieValue {\n    let mut node: Ptr<TrieNode> = Default::default();\n\n    node = trie_find_end_binary(trie.cast(), key.cast(), key_length.cast()).cast();\n\n    if (node != NULL!()).as_bool() {\n        return node.data.cast();\n    } else {\n        return TRIE_NULL!();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003391212)\nerror[E0609]: no field `data` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:87:21\n   |\n87 |         return node.data.cast();\n   |                     ^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/trie_c.rs:89:16\n    |\n89  |         return TRIE_NULL!();\n    |                ------------ in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` which comes from the expansion of the macro `TRIE_NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "unsigned int trie_num_entries(Trie *trie)\n{\n\n    if (trie->root_node == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        return trie->root_node->use_count;\n    }\n}",
                "rust_code": "pub fn trie_num_entries(mut trie: Ptr<Trie>) -> u32 {\n    if (trie.root_node == NULL!()).as_bool() {\n        return 0;\n    } else {\n        return trie.root_node.use_count.cast();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003391474)\nerror[E0609]: no field `use_count` on type `memory::ptr::Ptr<i32>`\n  --> src/src/trie_c.rs:90:31\n   |\n90 |         return trie.root_node.use_count.cast();\n   |                               ^^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "int arraylist_insert(ArrayList *arraylist, unsigned int index, ArrayListValue data)\n{\n\n    if (index > arraylist->length)\n    {\n        return 0;\n    }\n\n    if (arraylist->length + 1 > arraylist->_alloced)\n    {\n        if (!arraylist_enlarge(arraylist))\n        {\n            return 0;\n        }\n    }\n\n    memmove(&arraylist->data[index + 1], &arraylist->data[index], (arraylist->length - index) * sizeof(ArrayListValue));\n\n    arraylist->data[index] = data;\n    ++arraylist->length;\n\n    return 1;\n}",
                "rust_code": "pub fn arraylist_insert(mut arraylist: Ptr<ArrayList>, mut index: u32, mut data: ArrayListValue) -> i32 {\n    if (index > arraylist.length).as_bool() {\n        return 0;\n    }\n    if (arraylist.length + 1 > arraylist._alloced).as_bool() {\n        if !arraylist_enlarge(arraylist.cast()).as_bool() {\n            return 0;\n        }\n    }\n    c_memmove!(\n        c_ref!(arraylist.data[index + 1]).cast(),\n        c_ref!(arraylist.data[index]).cast(),\n        (arraylist.length - index) * c_sizeof!(ArrayListValue)\n    );\n    arraylist.data[index] = data.cast();\n    arraylist.length += 1;\n    return 1;\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003392546)\nerror[E0282]: type annotations needed\n  --> src/src/arraylist_c.rs:68:43\n   |\n68 |         c_ref!(arraylist.data[index + 1]).cast(),\n   |                                           ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n68 |         c_ref!(arraylist.data[index + 1]).cast::<T>(),\n   |                                               +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "void arraylist_remove_range(ArrayList *arraylist, unsigned int index, unsigned int length)\n{\n\n    if (index > arraylist->length || index + length > arraylist->length)\n    {\n        return;\n    }\n\n    memmove(&arraylist->data[index], &arraylist->data[index + length],\n            (arraylist->length - (index + length)) * sizeof(ArrayListValue));\n\n    arraylist->length -= length;\n}",
                "rust_code": "pub fn arraylist_remove_range(mut arraylist: Ptr<ArrayList>, mut index: u32, mut length: u32) {\n    if (index > arraylist.length).as_bool() || (index + length > arraylist.length).as_bool() {\n        return;\n    }\n    c_memmove!(\n        c_ref!(arraylist.data[index]).cast(),\n        c_ref!(arraylist.data[index + length]).cast(),\n        (arraylist.length - (index + length)) * c_sizeof!(ArrayListValue)\n    );\n    arraylist.length -= length;\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003393347)\nerror[E0282]: type annotations needed\n  --> src/src/arraylist_c.rs:78:39\n   |\n78 |         c_ref!(arraylist.data[index]).cast(),\n   |                                       ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n78 |         c_ref!(arraylist.data[index]).cast::<T>(),\n   |                                           +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static void binomial_tree_unref(BinomialTree *tree)\n{\n    int i;\n\n    if (tree == NULL)\n    {\n        return;\n    }\n\n    --tree->refcount;\n\n    if (tree->refcount == 0)\n    {\n\n        for (i = 0; i < tree->order; ++i)\n        {\n            binomial_tree_unref(tree->subtrees[i]);\n        }\n\n        free(tree->subtrees);\n        free(tree);\n    }\n}",
                "rust_code": "pub fn binomial_tree_unref(mut tree: Ptr<BinomialTree>) {\n    let mut i: i32 = Default::default();\n    if (tree == NULL!()).as_bool() {\n        return;\n    }\n    tree.refcount.suffix_minus_minus();\n    if (tree.refcount == 0).as_bool() {\n        c_for!(i = 0; i < tree.order; i.suffix_plus_plus(); {\n            binomial_tree_unref(tree.subtrees[i].cast());\n        });\n        c_free!(tree.subtrees);\n        c_free!(tree);\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003395519)\nerror[E0308]: mismatched types\n  --> src/src/binomial_heap_c.rs:51:27\n   |\n51 |         c_for!(i = 0; i < tree.order; i.suffix_plus_plus(); {\n   |                       -   ^^^^^^^^^^ expected `i32`, found `u16`\n   |                       |\n   |                       expected because this is `i32`\n   |\nhelp: you can convert a `u16` to an `i32`\n   |\n51 |         c_for!(i = 0; i < tree.order.into(); i.suffix_plus_plus(); {\n   |                                     +++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static BinomialTree *binomial_tree_merge(BinomialHeap *heap, BinomialTree *tree1, BinomialTree *tree2)\n{\n    BinomialTree *new_tree;\n    BinomialTree *tmp;\n    int i;\n\n    if (binomial_heap_cmp(heap, tree1->value, tree2->value) > 0)\n    {\n\n        tmp = tree1;\n        tree1 = tree2;\n        tree2 = tmp;\n    }\n\n    new_tree = malloc(sizeof(BinomialTree));\n\n    if (new_tree == NULL)\n    {\n        return NULL;\n    }\n\n    new_tree->refcount = 0;\n    new_tree->order = (unsigned short)(tree1->order + 1);\n\n    new_tree->value = tree1->value;\n\n    new_tree->subtrees = malloc(sizeof(BinomialTree *) * new_tree->order);\n\n    if (new_tree->subtrees == NULL)\n    {\n        free(new_tree);\n        return NULL;\n    }\n\n    memcpy(new_tree->subtrees, tree1->subtrees, sizeof(BinomialTree *) * tree1->order);\n    new_tree->subtrees[new_tree->order - 1] = tree2;\n\n    for (i = 0; i < new_tree->order; ++i)\n    {\n        binomial_tree_ref(new_tree->subtrees[i]);\n    }\n\n    return new_tree;\n}",
                "rust_code": "pub fn binomial_tree_merge(mut heap: Ptr<BinomialHeap>, mut tree1: Ptr<BinomialTree>, mut tree2: Ptr<BinomialTree>) -> Ptr<BinomialTree> {\n    let mut new_tree: Ptr<BinomialTree>;\n    let mut tmp: Ptr<BinomialTree>;\n    let mut i: i32;\n\n    if (binomial_heap_cmp(heap.cast(), tree1.value.cast(), tree2.value.cast()) > 0).as_bool() {\n        tmp = tree1.cast();\n        tree1 = tree2.cast();\n        tree2 = tmp.cast();\n    }\n\n    new_tree = c_malloc!(c_sizeof!(BinomialTree));\n\n    if (new_tree == NULL!()).as_bool() {\n        return NULL!();\n    }\n\n    new_tree.refcount = 0;\n    new_tree.order = (tree1.order + 1).cast();\n\n    new_tree.value = tree1.value.cast();\n\n    new_tree.subtrees = c_malloc!(c_sizeof!(Ptr<BinomialTree>) * new_tree.order);\n\n    if (new_tree.subtrees == NULL!()).as_bool() {\n        c_free!(new_tree);\n        return NULL!();\n    }\n\n    c_memcpy!(new_tree.subtrees, tree1.subtrees, c_sizeof!(Ptr<BinomialTree>) * tree1.order);\n    new_tree.subtrees[new_tree.order - 1] = tree2.cast();\n\n    c_for!(i = 0; i < new_tree.order; i.prefix_plus_plus(); {\n        binomial_tree_ref(new_tree.subtrees[i].cast());\n    });\n\n    return new_tree.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003395784)\nerror[E0308]: mismatched types\n  --> src/src/binomial_heap_c.rs:81:23\n   |\n81 |     c_for!(i = 0; i < new_tree.order; i.prefix_plus_plus(); {\n   |                   -   ^^^^^^^^^^^^^^ expected `i32`, found `u16`\n   |                   |\n   |                   expected because this is `i32`\n   |\nhelp: you can convert a `u16` to an `i32`\n   |\n81 |     c_for!(i = 0; i < new_tree.order.into(); i.prefix_plus_plus(); {\n   |                                     +++++++\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "SListEntry *slist_append(SListEntry **list, SListValue data)\n{\n    SListEntry *rover;\n    SListEntry *newentry;\n\n    newentry = malloc(sizeof(SListEntry));\n\n    if (newentry == NULL)\n    {\n        return NULL;\n    }\n\n    newentry->data = data;\n    newentry->next = NULL;\n\n    if (*list == NULL)\n    {\n\n        *list = newentry;\n    }\n    else\n    {\n\n        for (rover = *list; rover->next != NULL; rover = rover->next)\n            ;\n\n        rover->next = newentry;\n    }\n\n    return newentry;\n}",
                "rust_code": "pub fn slist_append(mut list: Ptr<Ptr<SListEntry>>, mut data: SListValue) -> Ptr<SListEntry> {\n    let mut rover: Ptr<SListEntry> = Default::default();\n    let mut newentry: Ptr<SListEntry> = Default::default();\n\n    newentry = c_malloc!(c_sizeof!(SListEntry));\n\n    if (newentry == NULL!()).as_bool() {\n        return NULL!();\n    }\n\n    newentry.data = data.cast();\n    newentry.next = NULL!();\n\n    if (*list == NULL!()).as_bool() {\n        *list = newentry.cast();\n    } else {\n        rover = *list.cast();\n        while (rover.next != NULL!()).as_bool() {\n            rover = rover.next.cast();\n        }\n        rover.next = newentry.cast();\n    }\n\n    return newentry.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003398608)\nerror[E0282]: type annotations needed\n  --> src/src/slist_c.rs:56:23\n   |\n56 |         rover = *list.cast();\n   |                       ^^^^ cannot infer type of the type parameter `T` declared on the method `cast`\n   |\nhelp: consider specifying the generic argument\n   |\n56 |         rover = *list.cast::<T>();\n   |                           +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static RBTreeNodeSide rb_tree_node_side(RBTreeNode *node)\n{\n    if (node->parent->children[RB_TREE_NODE_LEFT] == node)\n    {\n        return RB_TREE_NODE_LEFT;\n    }\n    else\n    {\n        return RB_TREE_NODE_RIGHT;\n    }\n}",
                "rust_code": "pub fn rb_tree_node_side(mut node: Ptr<RBTreeNode>) -> RBTreeNodeSide {\n    if (node.parent.children[RB_TREE_NODE_LEFT!()] == node).as_bool() {\n        return RB_TREE_NODE_LEFT!();\n    } else {\n        return RB_TREE_NODE_RIGHT!();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003404236)\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:16:14\n   |\n16 |     if (node.parent.children[RB_TREE_NODE_LEFT!()] == node).as_bool() {\n   |              ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static RBTreeNode *rb_tree_node_sibling(RBTreeNode *node)\n{\n    RBTreeNodeSide side;\n\n    side = rb_tree_node_side(node);\n\n    return node->parent->children[1 - side];\n}",
                "rust_code": "pub fn rb_tree_node_sibling(mut node: Ptr<RBTreeNode>) -> Ptr<RBTreeNode> {\n    let mut side: RBTreeNodeSide;\n    side = rb_tree_node_side(node.cast()).cast();\n    return node.parent.children[1 - side].cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003404523)\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:23:17\n   |\n23 |     return node.parent.children[1 - side].cast();\n   |                 ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "RBTreeNode *rb_tree_node_uncle(RBTreeNode *node)\n{\n    return rb_tree_node_sibling(node->parent);\n}",
                "rust_code": "pub fn rb_tree_node_uncle(mut node: Ptr<RBTreeNode>) -> Ptr<RBTreeNode> {\n    return rb_tree_node_sibling(node.parent.cast()).cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003404809)\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:26:38\n   |\n26 |     return rb_tree_node_sibling(node.parent.cast()).cast();\n   |                                      ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static void rb_tree_node_replace(RBTree *tree, RBTreeNode *node1, RBTreeNode *node2)\n{\n    int side;\n\n    if (node2 != NULL)\n    {\n        node2->parent = node1->parent;\n    }\n\n    if (node1->parent == NULL)\n    {\n        tree->root_node = node2;\n    }\n    else\n    {\n        side = rb_tree_node_side(node1);\n        node1->parent->children[side] = node2;\n    }\n}",
                "rust_code": "pub fn rb_tree_node_replace(mut tree: Ptr<RBTree>, mut node1: Ptr<RBTreeNode>, mut node2: Ptr<RBTreeNode>) {\n    let mut side: i32;\n    if (node2 != NULL!()).as_bool() {\n        node2.parent = node1.parent.cast();\n    }\n    if (node1.parent == NULL!()).as_bool() {\n        tree.root_node = node2.cast();\n    } else {\n        side = rb_tree_node_side(node1.cast()).cast();\n        node1.parent.children[side] = node2.cast();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003405088)\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:33:15\n   |\n33 |         node2.parent = node1.parent.cast();\n   |               ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:33:30\n   |\n33 |         node2.parent = node1.parent.cast();\n   |                              ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:35:15\n   |\n35 |     if (node1.parent == NULL!()).as_bool() {\n   |               ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:39:15\n   |\n39 |         node1.parent.children[side] = node2.cast();\n   |               ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/rb_tree_c.rs:35:25\n    |\n35  |     if (node1.parent == NULL!()).as_bool() {\n    |                         ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
            },
            {
                "c_code": "static RBTreeNode *rb_tree_rotate(RBTree *tree, RBTreeNode *node, RBTreeNodeSide direction)\n{\n    RBTreeNode *new_root;\n\n    new_root = node->children[1 - direction];\n\n    rb_tree_node_replace(tree, node, new_root);\n\n    node->children[1 - direction] = new_root->children[direction];\n    new_root->children[direction] = node;\n\n    node->parent = new_root;\n\n    if (node->children[1 - direction] != NULL)\n    {\n        node->children[1 - direction]->parent = node;\n    }\n\n    return new_root;\n}",
                "rust_code": "pub fn rb_tree_rotate(mut tree: Ptr<RBTree>, mut node: Ptr<RBTreeNode>, mut direction: RBTreeNodeSide) -> Ptr<RBTreeNode> {\n    let mut new_root: Ptr<RBTreeNode>;\n    new_root = node.children[1 - direction].cast();\n    rb_tree_node_replace(tree.cast(), node.cast(), new_root.cast());\n    node.children[1 - direction] = new_root.children[direction].cast();\n    new_root.children[direction] = node.cast();\n    node.parent = new_root.cast();\n    if (node.children[1 - direction] != NULL!()).as_bool() {\n        node.children[1 - direction].parent = node.cast();\n    }\n    return new_root.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003405370)\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:37:21\n   |\n37 |     new_root = node.children[1 - direction].cast();\n   |                     ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:39:10\n   |\n39 |     node.children[1 - direction] = new_root.children[direction].cast();\n   |          ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:39:45\n   |\n39 |     node.children[1 - direction] = new_root.children[direction].cast();\n   |                                             ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:40:14\n   |\n40 |     new_root.children[direction] = node.cast();\n   |              ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:41:10\n   |\n41 |     node.parent = new_root.cast();\n   |          ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:42:14\n   |\n42 |     if (node.children[1 - direction] != NULL!()).as_bool() {\n   |              ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:43:14\n   |\n43 |         node.children[1 - direction].parent = node.cast();\n   |              ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/rb_tree_c.rs:42:41\n    |\n42  |     if (node.children[1 - direction] != NULL!()).as_bool() {\n    |                                         ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 8 previous errors\n"
            },
            {
                "c_code": "static void rb_tree_free_subtree(RBTreeNode *node)\n{\n    if (node != NULL)\n    {\n\n        rb_tree_free_subtree(node->children[RB_TREE_NODE_LEFT]);\n        rb_tree_free_subtree(node->children[RB_TREE_NODE_RIGHT]);\n\n        free(node);\n    }\n}",
                "rust_code": "pub fn rb_tree_free_subtree(mut node: Ptr<RBTreeNode>) {\n    if (node != NULL!()).as_bool() {\n        rb_tree_free_subtree(node.children[RB_TREE_NODE_LEFT!()].cast());\n        rb_tree_free_subtree(node.children[RB_TREE_NODE_RIGHT!()].cast());\n        c_free!(node);\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003405966)\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:57:35\n   |\n57 |         rb_tree_free_subtree(node.children[RB_TREE_NODE_LEFT!()].cast());\n   |                                   ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:58:35\n   |\n58 |         rb_tree_free_subtree(node.children[RB_TREE_NODE_RIGHT!()].cast());\n   |                                   ^^^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "static void rb_tree_insert_case1(RBTree *tree, RBTreeNode *node)\n{\n    if (node->parent == NULL)\n    {\n\n        node->color = RB_TREE_NODE_BLACK;\n    }\n    else\n    {\n\n        rb_tree_insert_case2(tree, node);\n    }\n}",
                "rust_code": "pub fn rb_tree_insert_case1(mut tree: Ptr<RBTree>, mut node: Ptr<RBTreeNode>) {\n    if (node.parent == NULL!()).as_bool() {\n        node.color = RB_TREE_NODE_BLACK!();\n    } else {\n        rb_tree_insert_case2(tree.cast(), node.cast());\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003406544)\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:67:14\n   |\n67 |     if (node.parent == NULL!()).as_bool() {\n   |              ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `color` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:68:14\n   |\n68 |         node.color = RB_TREE_NODE_BLACK!();\n   |              ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/rb_tree_c.rs:67:24\n    |\n67  |     if (node.parent == NULL!()).as_bool() {\n    |                        ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "static void rb_tree_insert_case2(RBTree *tree, RBTreeNode *node)\n{\n\n    if (node->parent->color != RB_TREE_NODE_BLACK)\n    {\n        rb_tree_insert_case3(tree, node);\n    }\n}",
                "rust_code": "pub fn rb_tree_insert_case2(mut tree: Ptr<RBTree>, mut node: Ptr<RBTreeNode>) {\n    if (node.parent.color != RB_TREE_NODE_BLACK!()).as_bool() {\n        rb_tree_insert_case3(tree.cast(), node.cast());\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003406826)\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:72:14\n   |\n72 |     if (node.parent.color != RB_TREE_NODE_BLACK!()).as_bool() {\n   |              ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "static void rb_tree_insert_case3(RBTree *tree, RBTreeNode *node)\n{\n    RBTreeNode *grandparent;\n    RBTreeNode *uncle;\n\n    grandparent = node->parent->parent;\n    uncle = rb_tree_node_uncle(node);\n\n    if (uncle != NULL && uncle->color == RB_TREE_NODE_RED)\n    {\n\n        node->parent->color = RB_TREE_NODE_BLACK;\n        uncle->color = RB_TREE_NODE_BLACK;\n        grandparent->color = RB_TREE_NODE_RED;\n\n        rb_tree_insert_case1(tree, grandparent);\n    }\n    else\n    {\n        rb_tree_insert_case4(tree, node);\n    }\n}",
                "rust_code": "pub fn rb_tree_insert_case3(mut tree: Ptr<RBTree>, mut node: Ptr<RBTreeNode>) {\n    let mut grandparent: Ptr<RBTreeNode>;\n    let mut uncle: Ptr<RBTreeNode>;\n\n    grandparent = node.parent.parent.cast();\n    uncle = rb_tree_node_uncle(node.cast()).cast();\n\n    if (uncle != NULL!()).as_bool() && (uncle.color == RB_TREE_NODE_RED!()).as_bool() {\n        node.parent.color = RB_TREE_NODE_BLACK!();\n        uncle.color = RB_TREE_NODE_BLACK!();\n        grandparent.color = RB_TREE_NODE_RED!();\n\n        rb_tree_insert_case1(tree.cast(), grandparent.cast());\n    } else {\n        rb_tree_insert_case4(tree.cast(), node.cast());\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003407112)\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:80:24\n   |\n80 |     grandparent = node.parent.parent.cast();\n   |                        ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `color` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:83:47\n   |\n83 |     if (uncle != NULL!()).as_bool() && (uncle.color == RB_TREE_NODE_RED!()).as_bool() {\n   |                                               ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:84:14\n   |\n84 |         node.parent.color = RB_TREE_NODE_BLACK!();\n   |              ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `color` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:85:15\n   |\n85 |         uncle.color = RB_TREE_NODE_BLACK!();\n   |               ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `color` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:86:21\n   |\n86 |         grandparent.color = RB_TREE_NODE_RED!();\n   |                     ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 5 previous errors\n"
            },
            {
                "c_code": "void rb_tree_insert_case4(RBTree *tree, RBTreeNode *node)\n{\n    RBTreeNode *next_node;\n    RBTreeNodeSide side;\n\n    side = rb_tree_node_side(node);\n\n    if (side != rb_tree_node_side(node->parent))\n    {\n\n        next_node = node->parent;\n\n        rb_tree_rotate(tree, node->parent, 1 - side);\n    }\n    else\n    {\n        next_node = node;\n    }\n\n    rb_tree_insert_case5(tree, next_node);\n}",
                "rust_code": "pub fn rb_tree_insert_case4(mut tree: Ptr<RBTree>, mut node: Ptr<RBTreeNode>) {\n    let mut next_node: Ptr<RBTreeNode> = Default::default();\n    let mut side: RBTreeNodeSide = Default::default();\n\n    side = rb_tree_node_side(node.cast()).cast();\n\n    if (side != rb_tree_node_side(node.parent).cast()).as_bool() {\n        next_node = node.parent.cast();\n\n        rb_tree_rotate(tree.cast(), node.parent.cast(), (1 - side).cast());\n    } else {\n        next_node = node.cast();\n    }\n\n    rb_tree_insert_case5(tree.cast(), next_node.cast());\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003407397)\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:87:40\n   |\n87 |     if (side != rb_tree_node_side(node.parent).cast()).as_bool() {\n   |                                        ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:88:26\n   |\n88 |         next_node = node.parent.cast();\n   |                          ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:90:42\n   |\n90 |         rb_tree_rotate(tree.cast(), node.parent.cast(), (1 - side).cast());\n   |                                          ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 3 previous errors\n"
            },
            {
                "c_code": "void rb_tree_insert_case5(RBTree *tree, RBTreeNode *node)\n{\n    RBTreeNode *parent;\n    RBTreeNode *grandparent;\n    RBTreeNodeSide side;\n\n    parent = node->parent;\n    grandparent = parent->parent;\n\n    side = rb_tree_node_side(node);\n\n    rb_tree_rotate(tree, grandparent, 1 - side);\n\n    parent->color = RB_TREE_NODE_BLACK;\n    grandparent->color = RB_TREE_NODE_RED;\n}",
                "rust_code": "pub fn rb_tree_insert_case5(mut tree: Ptr<RBTree>, mut node: Ptr<RBTreeNode>) {\n    let mut parent: Ptr<RBTreeNode>;\n    let mut grandparent: Ptr<RBTreeNode>;\n    let mut side: RBTreeNodeSide;\n\n    parent = node.parent.cast();\n    grandparent = parent.parent.cast();\n\n    side = rb_tree_node_side(node.cast()).cast();\n\n    rb_tree_rotate(tree.cast(), grandparent.cast(), (1 - side).cast());\n\n    parent.color = RB_TREE_NODE_BLACK!();\n    grandparent.color = RB_TREE_NODE_RED!();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003407682)\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:91:19\n   |\n91 |     parent = node.parent.cast();\n   |                   ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:92:26\n   |\n92 |     grandparent = parent.parent.cast();\n   |                          ^^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `color` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:98:12\n   |\n98 |     parent.color = RB_TREE_NODE_BLACK!();\n   |            ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nerror[E0609]: no field `color` on type `memory::ptr::Ptr<i32>`\n  --> src/src/rb_tree_c.rs:99:17\n   |\n99 |     grandparent.color = RB_TREE_NODE_RED!();\n   |                 ^^^^^ unknown field\n   |\n   = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 4 previous errors\n"
            },
            {
                "c_code": "RBTreeNode *rb_tree_insert(RBTree *tree, RBTreeKey key, RBTreeValue value)\n{\n    RBTreeNode *node;\n    RBTreeNode **rover;\n    RBTreeNode *parent;\n    RBTreeNodeSide side;\n\n    node = malloc(sizeof(RBTreeNode));\n\n    if (node == NULL)\n    {\n        return NULL;\n    }\n\n    node->key = key;\n    node->value = value;\n    node->color = RB_TREE_NODE_RED;\n    node->children[RB_TREE_NODE_LEFT] = NULL;\n    node->children[RB_TREE_NODE_RIGHT] = NULL;\n\n    parent = NULL;\n    rover = &tree->root_node;\n\n    while (*rover != NULL)\n    {\n\n        parent = *rover;\n\n        if (tree->compare_func(value, (*rover)->value) < 0)\n        {\n            side = RB_TREE_NODE_LEFT;\n        }\n        else\n        {\n            side = RB_TREE_NODE_RIGHT;\n        }\n\n        rover = &(*rover)->children[side];\n    }\n\n    *rover = node;\n    node->parent = parent;\n\n    rb_tree_insert_case1(tree, node);\n\n    ++tree->num_nodes;\n\n    return node;\n}",
                "rust_code": "pub fn rb_tree_insert(mut tree: Ptr<RBTree>, mut key: RBTreeKey, mut value: RBTreeValue) -> Ptr<RBTreeNode> {\n    let mut node: Ptr<RBTreeNode>;\n    let mut rover: Ptr<Ptr<RBTreeNode>>;\n    let mut parent: Ptr<RBTreeNode>;\n    let mut side: RBTreeNodeSide;\n\n    node = c_malloc!(c_sizeof!(RBTreeNode));\n\n    if (node == NULL!()).as_bool() {\n        return NULL!();\n    }\n\n    node.key = key.cast();\n    node.value = value.cast();\n    node.color = RB_TREE_NODE_RED!();\n    node.children[RB_TREE_NODE_LEFT!()] = NULL!();\n    node.children[RB_TREE_NODE_RIGHT!()] = NULL!();\n\n    parent = NULL!();\n    rover = c_ref!(tree.root_node).cast();\n\n    while (*rover != NULL!()).as_bool() {\n        parent = *rover.cast();\n\n        if (tree.compare_func(value.cast(), (*rover).value.cast()) < 0 {\n            side = RB_TREE_NODE_LEFT!();\n        } else {\n            side = RB_TREE_NODE_RIGHT!();\n        }\n\n        rover = c_ref!((*rover).children[side]).cast();\n    }\n\n    *rover = node.cast();\n    node.parent = parent.cast();\n\n    rb_tree_insert_case1(tree.cast(), node.cast());\n\n    tree.num_nodes.prefix_plus_plus();\n\n    return node.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003407983)\nerror: mismatched closing delimiter: `}`\n   --> src/src/rb_tree_c.rs:115:12\n    |\n112 |     while (*rover != NULL!()).as_bool() {\n    |                                         - closing delimiter possibly meant for this\n...\n115 |         if (tree.compare_func(value.cast(), (*rover).value.cast()) < 0 {\n    |            ^ unclosed delimiter\n...\n122 |     }\n    |     ^ mismatched closing delimiter\n\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "RBTreeNode *rb_tree_lookup_node(RBTree *tree, RBTreeKey key)\n{\n    RBTreeNode *node;\n    RBTreeNodeSide side;\n    int diff;\n\n    node = tree->root_node;\n\n    while (node != NULL)\n    {\n        diff = tree->compare_func(key, node->key);\n\n        if (diff == 0)\n        {\n            return node;\n        }\n        else if (diff < 0)\n        {\n            side = RB_TREE_NODE_LEFT;\n        }\n        else\n        {\n            side = RB_TREE_NODE_RIGHT;\n        }\n\n        node = node->children[side];\n    }\n\n    return NULL;\n}",
                "rust_code": "pub fn rb_tree_lookup_node(mut tree: Ptr<RBTree>, mut key: RBTreeKey) -> Ptr<RBTreeNode> {\n    let mut node: Ptr<RBTreeNode> = Default::default();\n    let mut side: RBTreeNodeSide = Default::default();\n    let mut diff: i32 = Default::default();\n\n    node = tree.root_node.cast();\n\n    while (node != NULL!()).as_bool() {\n        diff = (tree.compare_func)(key.cast(), node.key.cast()).cast();\n\n        if diff == 0 {\n            return node.cast();\n        } else if diff < 0 {\n            side = RB_TREE_NODE_LEFT!();\n        } else {\n            side = RB_TREE_NODE_RIGHT!();\n        }\n\n        node = node.children[side].cast();\n    }\n\n    return NULL!();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003408071)\nerror[E0609]: no field `key` on type `memory::ptr::Ptr<i32>`\n   --> src/src/rb_tree_c.rs:104:53\n    |\n104 |         diff = (tree.compare_func)(key.cast(), node.key.cast()).cast();\n    |                                                     ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n   --> src/src/rb_tree_c.rs:114:21\n    |\n114 |         node = node.children[side].cast();\n    |                     ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "RBTreeValue rb_tree_lookup(RBTree *tree, RBTreeKey key)\n{\n    RBTreeNode *node;\n\n    node = rb_tree_lookup_node(tree, key);\n\n    if (node == NULL)\n    {\n        return RB_TREE_NULL;\n    }\n    else\n    {\n        return node->value;\n    }\n}",
                "rust_code": "pub fn rb_tree_lookup(mut tree: Ptr<RBTree>, mut key: RBTreeKey) -> RBTreeValue {\n    let mut node: Ptr<RBTreeNode> = Default::default();\n\n    node = rb_tree_lookup_node(tree.cast(), key.cast()).cast();\n\n    if (node == NULL!()).as_bool() {\n        return RB_TREE_NULL!();\n    } else {\n        return node.value.cast();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003408350)\nerror[E0609]: no field `value` on type `memory::ptr::Ptr<i32>`\n   --> src/src/rb_tree_c.rs:109:21\n    |\n109 |         return node.value.cast();\n    |                     ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "RBTreeKey rb_tree_node_key(RBTreeNode *node)\n{\n    return node->key;\n}",
                "rust_code": "pub fn rb_tree_node_key(mut node: Ptr<RBTreeNode>) -> RBTreeKey {\n    return node.key.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003409531)\nerror[E0609]: no field `key` on type `memory::ptr::Ptr<i32>`\n   --> src/src/rb_tree_c.rs:131:17\n    |\n131 |     return node.key.cast();\n    |                 ^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "RBTreeValue rb_tree_node_value(RBTreeNode *node)\n{\n    return node->value;\n}",
                "rust_code": "pub fn rb_tree_node_value(mut node: Ptr<RBTreeNode>) -> RBTreeValue {\n    return node.value.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003409815)\nerror[E0609]: no field `value` on type `memory::ptr::Ptr<i32>`\n   --> src/src/rb_tree_c.rs:136:17\n    |\n136 |     return node.value.cast();\n    |                 ^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            },
            {
                "c_code": "RBTreeNode *rb_tree_node_child(RBTreeNode *node, RBTreeNodeSide side)\n{\n    if (side == RB_TREE_NODE_LEFT || side == RB_TREE_NODE_RIGHT)\n    {\n        return node->children[side];\n    }\n    else\n    {\n        return NULL;\n    }\n}",
                "rust_code": "pub fn rb_tree_node_child(mut node: Ptr<RBTreeNode>, mut side: RBTreeNodeSide) -> Ptr<RBTreeNode> {\n    if (side == RB_TREE_NODE_LEFT!()).as_bool() || (side == RB_TREE_NODE_RIGHT!()).as_bool() {\n        return node.children[side].cast();\n    } else {\n        return NULL!();\n    }\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003410138)\nerror[E0609]: no field `children` on type `memory::ptr::Ptr<i32>`\n   --> src/src/rb_tree_c.rs:142:21\n    |\n142 |         return node.children[side].cast();\n    |                     ^^^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nerror[E0277]: the trait bound `types::null::Null: cast_trait::CastInto<{type error}>` is not satisfied\n   --> src/translation_utils/types/null.rs:15:16\n    |\n15  |         Null().cast()\n    |                ^^^^ the trait `integer::Integer` is not implemented for `types::null::Null`\n    |\n   ::: src/src/rb_tree_c.rs:144:16\n    |\n144 |         return NULL!();\n    |                ------- in this macro invocation\n    |\n    = help: the following other types implement trait `integer::Integer`:\n              bool\n              i128\n              i16\n              i32\n              i64\n              i8\n              isize\n              types::num::Num\n            and 6 others\nnote: required for `{type error}` to implement `cast_trait::CastFrom<types::null::Null>`\n   --> src/translation_utils/types/integer.rs:195:32\n    |\n195 | impl<I1: Integer, I2: Integer> CastFrom<I1> for I2 {\n    |          -------               ^^^^^^^^^^^^     ^^\n    |          |\n    |          unsatisfied trait bound introduced here\nnote: required for `types::null::Null` to implement `cast_trait::CastInto<{type error}>`\n   --> src/translation_utils/types/cast_trait.rs:11:14\n    |\n11  | impl<T1, T2> CastInto<T2> for T1\n    |              ^^^^^^^^^^^^     ^^\n12  | where\n13  |     T2: CastFrom<T1>,\n    |         ------------ unsatisfied trait bound introduced here\nnote: required by a bound in `cast_trait::CastIntoTyped::cast`\n   --> src/translation_utils/types/cast_trait.rs:23:15\n    |\n21  |     fn cast<T>(&mut self) -> T\n    |        ---- required by a bound in this associated function\n22  |     where\n23  |         Self: CastInto<T>,\n    |               ^^^^^^^^^^^ required by this bound in `CastIntoTyped::cast`\n    = note: this error originates in the macro `NULL` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `my_proj` (lib) due to 2 previous errors\n"
            },
            {
                "c_code": "RBTreeNode *rb_tree_node_parent(RBTreeNode *node)\n{\n    return node->parent;\n}",
                "rust_code": "pub fn rb_tree_node_parent(mut node: Ptr<RBTreeNode>) -> Ptr<RBTreeNode> {\n    return node.parent.cast();\n}\n",
                "error_msg": "    Checking my_proj v0.1.0 (/home/ytr/evo-c2rust-v2/.tmp/created_project/c-algorithms_1750003410421)\nerror[E0609]: no field `parent` on type `memory::ptr::Ptr<i32>`\n   --> src/src/rb_tree_c.rs:146:17\n    |\n146 |     return node.parent.cast();\n    |                 ^^^^^^ unknown field\n    |\n    = note: available field is: `0`\n\nFor more information about this error, try `rustc --explain E0609`.\nerror: could not compile `my_proj` (lib) due to 1 previous error\n"
            }
        ]
    }
}