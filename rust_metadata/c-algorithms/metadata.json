{
    "src": {
        "name": "src",
        "type": "folder",
        "children": {
            "list_c.rs": {
                "name": "list_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::list_h::*;"
                ],
                "definitions": [
                    {
                        "c_code": "struct _ListEntry\n{\n    ListValue data;\n    ListEntry *prev;\n    ListEntry *next;\n};",
                        "rust_code": "pub type _ListEntry = i32;"
                    }
                ],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "void list_free(ListEntry *list)\n{\n    ListEntry *entry;\n\n    entry = list;\n\n    while (entry != NULL)\n    {\n        ListEntry *next;\n\n        next = entry->next;\n\n        free(entry);\n\n        entry = next;\n    }\n}",
                        "rust_code": "pub fn list_free() { unimplemented!(); }"
                    },
                    {
                        "c_code": "ListEntry *list_prepend(ListEntry **list, ListValue data)\n{\n    ListEntry *newentry;\n\n    if (list == NULL)\n    {\n\n        return NULL;\n    }\n\n    newentry = malloc(sizeof(ListEntry));\n\n    if (newentry == NULL)\n    {\n        return NULL;\n    }\n\n    newentry->data = data;\n\n    if (*list != NULL)\n    {\n        (*list)->prev = newentry;\n    }\n    newentry->prev = NULL;\n    newentry->next = *list;\n    *list = newentry;\n\n    return newentry;\n}",
                        "rust_code": "pub fn list_prepend() { unimplemented!(); }"
                    },
                    {
                        "c_code": "ListEntry *list_append(ListEntry **list, ListValue data)\n{\n    ListEntry *rover;\n    ListEntry *newentry;\n\n    if (list == NULL)\n    {\n        return NULL;\n    }\n\n    newentry = malloc(sizeof(ListEntry));\n\n    if (newentry == NULL)\n    {\n        return NULL;\n    }\n\n    newentry->data = data;\n    newentry->next = NULL;\n\n    if (*list == NULL)\n    {\n\n        *list = newentry;\n        newentry->prev = NULL;\n    }\n    else\n    {\n\n        for (rover = *list; rover->next != NULL; rover = rover->next)\n            ;\n\n        newentry->prev = rover;\n        rover->next = newentry;\n    }\n\n    return newentry;\n}",
                        "rust_code": "pub fn list_append() { unimplemented!(); }"
                    },
                    {
                        "c_code": "ListValue list_data(ListEntry *listentry)\n{\n    if (listentry == NULL)\n    {\n        return LIST_NULL;\n    }\n\n    return listentry->data;\n}",
                        "rust_code": "pub fn list_data() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void list_set_data(ListEntry *listentry, ListValue value)\n{\n    if (listentry != NULL)\n    {\n        listentry->data = value;\n    }\n}",
                        "rust_code": "pub fn list_set_data() { unimplemented!(); }"
                    },
                    {
                        "c_code": "ListEntry *list_prev(ListEntry *listentry)\n{\n    if (listentry == NULL)\n    {\n        return NULL;\n    }\n\n    return listentry->prev;\n}",
                        "rust_code": "pub fn list_prev() { unimplemented!(); }"
                    },
                    {
                        "c_code": "ListEntry *list_next(ListEntry *listentry)\n{\n    if (listentry == NULL)\n    {\n        return NULL;\n    }\n\n    return listentry->next;\n}",
                        "rust_code": "pub fn list_next() { unimplemented!(); }"
                    },
                    {
                        "c_code": "ListEntry *list_nth_entry(ListEntry *list, unsigned int n)\n{\n    ListEntry *entry;\n    unsigned int i;\n\n    entry = list;\n\n    for (i = 0; i < n; ++i)\n    {\n\n        if (entry == NULL)\n        {\n            return NULL;\n        }\n        entry = entry->next;\n    }\n\n    return entry;\n}",
                        "rust_code": "pub fn list_nth_entry() { unimplemented!(); }"
                    },
                    {
                        "c_code": "ListValue list_nth_data(ListEntry *list, unsigned int n)\n{\n    ListEntry *entry;\n\n    entry = list_nth_entry(list, n);\n\n    if (entry == NULL)\n    {\n        return LIST_NULL;\n    }\n    else\n    {\n        return entry->data;\n    }\n}",
                        "rust_code": "pub fn list_nth_data() { unimplemented!(); }"
                    },
                    {
                        "c_code": "unsigned int list_length(ListEntry *list)\n{\n    ListEntry *entry;\n    unsigned int length;\n\n    length = 0;\n    entry = list;\n\n    while (entry != NULL)\n    {\n\n        ++length;\n\n        entry = entry->next;\n    }\n\n    return length;\n}",
                        "rust_code": "pub fn list_length() { unimplemented!(); }"
                    },
                    {
                        "c_code": "ListValue *list_to_array(ListEntry *list)\n{\n    ListEntry *rover;\n    ListValue *array;\n    unsigned int length;\n    unsigned int i;\n\n    length = list_length(list);\n\n    array = malloc(sizeof(ListValue) * length);\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    rover = list;\n\n    for (i = 0; i < length; ++i)\n    {\n\n        array[i] = rover->data;\n\n        rover = rover->next;\n    }\n\n    return array;\n}",
                        "rust_code": "pub fn list_to_array() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int list_remove_entry(ListEntry **list, ListEntry *entry)\n{\n\n    if (list == NULL || *list == NULL || entry == NULL)\n    {\n        return 0;\n    }\n\n    if (entry->prev == NULL)\n    {\n\n        *list = entry->next;\n\n        if (entry->next != NULL)\n        {\n            entry->next->prev = NULL;\n        }\n    }\n    else\n    {\n\n        entry->prev->next = entry->next;\n\n        if (entry->next != NULL)\n        {\n            entry->next->prev = entry->prev;\n        }\n    }\n\n    free(entry);\n\n    return 1;\n}",
                        "rust_code": "pub fn list_remove_entry() { unimplemented!(); }"
                    },
                    {
                        "c_code": "unsigned int list_remove_data(ListEntry **list, ListEqualFunc callback, ListValue data)\n{\n    unsigned int entries_removed;\n    ListEntry *rover;\n    ListEntry *next;\n\n    if (list == NULL || callback == NULL)\n    {\n        return 0;\n    }\n\n    entries_removed = 0;\n\n    rover = *list;\n\n    while (rover != NULL)\n    {\n\n        next = rover->next;\n\n        if (callback(rover->data, data))\n        {\n\n            if (rover->prev == NULL)\n            {\n\n                *list = rover->next;\n            }\n            else\n            {\n\n                rover->prev->next = rover->next;\n            }\n\n            if (rover->next != NULL)\n            {\n                rover->next->prev = rover->prev;\n            }\n\n            free(rover);\n\n            ++entries_removed;\n        }\n\n        rover = next;\n    }\n\n    return entries_removed;\n}",
                        "rust_code": "pub fn list_remove_data() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static ListEntry *list_sort_internal(ListEntry **list, ListCompareFunc compare_func)\n{\n    ListEntry *pivot;\n    ListEntry *rover;\n    ListEntry *less_list, *more_list;\n    ListEntry *less_list_end, *more_list_end;\n\n    if (list == NULL || compare_func == NULL)\n    {\n        return NULL;\n    }\n\n    if (*list == NULL || (*list)->next == NULL)\n    {\n        return *list;\n    }\n\n    pivot = *list;\n\n    less_list = NULL;\n    more_list = NULL;\n    rover = (*list)->next;\n\n    while (rover != NULL)\n    {\n        ListEntry *next = rover->next;\n\n        if (compare_func(rover->data, pivot->data) < 0)\n        {\n\n            rover->prev = NULL;\n            rover->next = less_list;\n            if (less_list != NULL)\n            {\n                less_list->prev = rover;\n            }\n            less_list = rover;\n        }\n        else\n        {\n\n            rover->prev = NULL;\n            rover->next = more_list;\n            if (more_list != NULL)\n            {\n                more_list->prev = rover;\n            }\n            more_list = rover;\n        }\n\n        rover = next;\n    }\n\n    less_list_end = list_sort_internal(&less_list, compare_func);\n    more_list_end = list_sort_internal(&more_list, compare_func);\n\n    *list = less_list;\n\n    if (less_list == NULL)\n    {\n        pivot->prev = NULL;\n        *list = pivot;\n    }\n    else\n    {\n        pivot->prev = less_list_end;\n        less_list_end->next = pivot;\n    }\n\n    pivot->next = more_list;\n    if (more_list != NULL)\n    {\n        more_list->prev = pivot;\n    }\n\n    if (more_list == NULL)\n    {\n        return pivot;\n    }\n    else\n    {\n        return more_list_end;\n    }\n}",
                        "rust_code": "pub fn list_sort_internal() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void list_sort(ListEntry **list, ListCompareFunc compare_func)\n{\n    list_sort_internal(list, compare_func);\n}",
                        "rust_code": "pub fn list_sort() { unimplemented!(); }"
                    },
                    {
                        "c_code": "ListEntry *list_find_data(ListEntry *list, ListEqualFunc callback, ListValue data)\n{\n    ListEntry *rover;\n\n    for (rover = list; rover != NULL; rover = rover->next)\n    {\n        if (callback(rover->data, data) != 0)\n        {\n            return rover;\n        }\n    }\n\n    return NULL;\n}",
                        "rust_code": "pub fn list_find_data() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void list_iterate(ListEntry **list, ListIterator *iter)\n{\n\n    iter->prev_next = list;\n\n    iter->current = NULL;\n}",
                        "rust_code": "pub fn list_iterate() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int list_iter_has_more(ListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n\n        return *iter->prev_next != NULL;\n    }\n    else\n    {\n\n        return iter->current->next != NULL;\n    }\n}",
                        "rust_code": "pub fn list_iter_has_more() { unimplemented!(); }"
                    },
                    {
                        "c_code": "ListValue list_iter_next(ListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n\n        iter->current = *iter->prev_next;\n    }\n    else\n    {\n\n        iter->prev_next = &iter->current->next;\n        iter->current = iter->current->next;\n    }\n\n    if (iter->current == NULL)\n    {\n        return LIST_NULL;\n    }\n    else\n    {\n        return iter->current->data;\n    }\n}",
                        "rust_code": "pub fn list_iter_next() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void list_iter_remove(ListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n    }\n    else\n    {\n\n        *iter->prev_next = iter->current->next;\n\n        if (iter->current->next != NULL)\n        {\n            iter->current->next->prev = iter->current->prev;\n        }\n\n        free(iter->current);\n        iter->current = NULL;\n    }\n}",
                        "rust_code": "pub fn list_iter_remove() { unimplemented!(); }"
                    }
                ]
            },
            "sortedarray_c.rs": {
                "name": "sortedarray_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::sortedarray_h::*;"
                ],
                "definitions": [
                    {
                        "c_code": "struct _SortedArray\n{\n\n    SortedArrayValue *data;\n\n    unsigned int length;\n\n    unsigned int _alloced;\n\n    SortedArrayEqualFunc equ_func;\n\n    SortedArrayCompareFunc cmp_func;\n};",
                        "rust_code": "pub type _SortedArray = i32;"
                    }
                ],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "static unsigned int sortedarray_first_index(SortedArray *sortedarray, SortedArrayValue data, unsigned int left,\n                                            unsigned int right)\n{\n    unsigned int index = left;\n\n    while (left < right)\n    {\n        index = (left + right) / 2;\n\n        int order = sortedarray->cmp_func(data, sortedarray->data[index]);\n        if (order > 0)\n        {\n            left = index + 1;\n        }\n        else\n        {\n            right = index;\n        }\n    }\n\n    return index;\n}",
                        "rust_code": "pub fn sortedarray_first_index() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static unsigned int sortedarray_last_index(SortedArray *sortedarray, SortedArrayValue data, unsigned int left,\n                                           unsigned int right)\n{\n    unsigned int index = right;\n\n    while (left < right)\n    {\n        index = (left + right) / 2;\n\n        int order = sortedarray->cmp_func(data, sortedarray->data[index]);\n        if (order <= 0)\n        {\n            left = index + 1;\n        }\n        else\n        {\n            right = index;\n        }\n    }\n\n    return index;\n}",
                        "rust_code": "pub fn sortedarray_last_index() { unimplemented!(); }"
                    },
                    {
                        "c_code": "SortedArrayValue *sortedarray_get(SortedArray *array, unsigned int i)\n{\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    return array->data[i];\n}",
                        "rust_code": "pub fn sortedarray_get() { unimplemented!(); }"
                    },
                    {
                        "c_code": "unsigned int sortedarray_length(SortedArray *array)\n{\n    return array->length;\n}",
                        "rust_code": "pub fn sortedarray_length() { unimplemented!(); }"
                    },
                    {
                        "c_code": "SortedArray *sortedarray_new(unsigned int length, SortedArrayEqualFunc equ_func, SortedArrayCompareFunc cmp_func)\n{\n\n    if (equ_func == NULL || cmp_func == NULL)\n    {\n        return NULL;\n    }\n\n    if (length == 0)\n    {\n        length = 16;\n    }\n\n    SortedArrayValue *array = malloc(sizeof(SortedArrayValue) * length);\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    SortedArray *sortedarray = malloc(sizeof(SortedArray));\n\n    if (sortedarray == NULL)\n    {\n        free(array);\n        return NULL;\n    }\n\n    sortedarray->data = array;\n    sortedarray->length = 0;\n    sortedarray->_alloced = length;\n    sortedarray->equ_func = equ_func;\n    sortedarray->cmp_func = cmp_func;\n    return sortedarray;\n}",
                        "rust_code": "pub fn sortedarray_new() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void sortedarray_free(SortedArray *sortedarray)\n{\n    if (sortedarray != NULL)\n    {\n        free(sortedarray->data);\n        free(sortedarray);\n    }\n}",
                        "rust_code": "pub fn sortedarray_free() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void sortedarray_remove(SortedArray *sortedarray, unsigned int index)\n{\n\n    sortedarray_remove_range(sortedarray, index, 1);\n}",
                        "rust_code": "pub fn sortedarray_remove() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void sortedarray_remove_range(SortedArray *sortedarray, unsigned int index, unsigned int length)\n{\n\n    if (index > sortedarray->length || index + length > sortedarray->length)\n    {\n        return;\n    }\n\n    memmove(&sortedarray->data[index], &sortedarray->data[index + length],\n            (sortedarray->length - (index + length)) * sizeof(SortedArrayValue));\n\n    sortedarray->length -= length;\n}",
                        "rust_code": "pub fn sortedarray_remove_range() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int sortedarray_insert(SortedArray *sortedarray, SortedArrayValue data)\n{\n\n    unsigned int left = 0;\n    unsigned int right = sortedarray->length;\n    unsigned int index = 0;\n\n    right = (right > 1) ? right : 0;\n\n    while (left != right)\n    {\n        index = (left + right) / 2;\n\n        int order = sortedarray->cmp_func(data, sortedarray->data[index]);\n        if (order < 0)\n        {\n\n            right = index;\n        }\n        else if (order > 0)\n        {\n\n            left = index + 1;\n        }\n        else\n        {\n\n            break;\n        }\n    }\n\n    if (sortedarray->length > 0 && sortedarray->cmp_func(data, sortedarray->data[index]) > 0)\n    {\n        index++;\n    }\n\n    if (sortedarray->length + 1 > sortedarray->_alloced)\n    {\n\n        unsigned int newsize;\n        SortedArrayValue *data;\n\n        newsize = sortedarray->_alloced * 2;\n        data = realloc(sortedarray->data, sizeof(SortedArrayValue) * newsize);\n\n        if (data == NULL)\n        {\n            return 0;\n        }\n        else\n        {\n            sortedarray->data = data;\n            sortedarray->_alloced = newsize;\n        }\n    }\n\n    memmove(&sortedarray->data[index + 1], &sortedarray->data[index],\n            (sortedarray->length - index) * sizeof(SortedArrayValue));\n\n    sortedarray->data[index] = data;\n    ++(sortedarray->length);\n\n    return 1;\n}",
                        "rust_code": "pub fn sortedarray_insert() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int sortedarray_index_of(SortedArray *sortedarray, SortedArrayValue data)\n{\n    if (sortedarray == NULL)\n    {\n        return -1;\n    }\n\n    unsigned int left = 0;\n    unsigned int right = sortedarray->length;\n    unsigned int index = 0;\n\n    right = (right > 1) ? right : 0;\n\n    while (left != right)\n    {\n        index = (left + right) / 2;\n\n        int order = sortedarray->cmp_func(data, sortedarray->data[index]);\n        if (order < 0)\n        {\n\n            right = index;\n        }\n        else if (order > 0)\n        {\n\n            left = index + 1;\n        }\n        else\n        {\n\n            left = sortedarray_first_index(sortedarray, data, left, index);\n            right = sortedarray_last_index(sortedarray, data, index, right);\n\n            for (index = left; index <= right; index++)\n            {\n                if (sortedarray->equ_func(data, sortedarray->data[index]))\n                {\n                    return (int)index;\n                }\n            }\n\n            return -1;\n        }\n    }\n\n    return -1;\n}",
                        "rust_code": "pub fn sortedarray_index_of() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void sortedarray_clear(SortedArray *sortedarray)\n{\n\n    sortedarray->length = 0;\n}",
                        "rust_code": "pub fn sortedarray_clear() { unimplemented!(); }"
                    }
                ]
            },
            "avl_tree_c.rs": {
                "name": "avl_tree_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::avl_tree_h::*;"
                ],
                "definitions": [
                    {
                        "c_code": "struct _AVLTreeNode\n{\n    AVLTreeNode *children[2];\n    AVLTreeNode *parent;\n    AVLTreeKey key;\n    AVLTreeValue value;\n    int height;\n};",
                        "rust_code": "pub type _AVLTreeNode = i32;"
                    },
                    {
                        "c_code": "struct _AVLTree\n{\n    AVLTreeNode *root_node;\n    AVLTreeCompareFunc compare_func;\n    unsigned int num_nodes;\n};",
                        "rust_code": "pub type _AVLTree = i32;"
                    }
                ],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "AVLTree *avl_tree_new(AVLTreeCompareFunc compare_func)\n{\n    AVLTree *new_tree;\n\n    new_tree = (AVLTree *)malloc(sizeof(AVLTree));\n\n    if (new_tree == NULL)\n    {\n        return NULL;\n    }\n\n    new_tree->root_node = NULL;\n    new_tree->compare_func = compare_func;\n    new_tree->num_nodes = 0;\n\n    return new_tree;\n}",
                        "rust_code": "pub fn avl_tree_new() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void avl_tree_free_subtree(AVLTree *tree, AVLTreeNode *node)\n{\n    if (node == NULL)\n    {\n        return;\n    }\n\n    avl_tree_free_subtree(tree, node->children[AVL_TREE_NODE_LEFT]);\n    avl_tree_free_subtree(tree, node->children[AVL_TREE_NODE_RIGHT]);\n\n    free(node);\n}",
                        "rust_code": "pub fn avl_tree_free_subtree() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void avl_tree_free(AVLTree *tree)\n{\n\n    avl_tree_free_subtree(tree, tree->root_node);\n\n    free(tree);\n}",
                        "rust_code": "pub fn avl_tree_free() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int avl_tree_subtree_height(AVLTreeNode *node)\n{\n    if (node == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        return node->height;\n    }\n}",
                        "rust_code": "pub fn avl_tree_subtree_height() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void avl_tree_update_height(AVLTreeNode *node)\n{\n    AVLTreeNode *left_subtree;\n    AVLTreeNode *right_subtree;\n    int left_height, right_height;\n\n    left_subtree = node->children[AVL_TREE_NODE_LEFT];\n    right_subtree = node->children[AVL_TREE_NODE_RIGHT];\n    left_height = avl_tree_subtree_height(left_subtree);\n    right_height = avl_tree_subtree_height(right_subtree);\n\n    if (left_height > right_height)\n    {\n        node->height = left_height + 1;\n    }\n    else\n    {\n        node->height = right_height + 1;\n    }\n}",
                        "rust_code": "pub fn avl_tree_update_height() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static AVLTreeNodeSide avl_tree_node_parent_side(AVLTreeNode *node)\n{\n    if (node->parent->children[AVL_TREE_NODE_LEFT] == node)\n    {\n        return AVL_TREE_NODE_LEFT;\n    }\n    else\n    {\n        return AVL_TREE_NODE_RIGHT;\n    }\n}",
                        "rust_code": "pub fn avl_tree_node_parent_side() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void avl_tree_node_replace(AVLTree *tree, AVLTreeNode *node1, AVLTreeNode *node2)\n{\n    int side;\n\n    if (node2 != NULL)\n    {\n        node2->parent = node1->parent;\n    }\n\n    if (node1->parent == NULL)\n    {\n        tree->root_node = node2;\n    }\n    else\n    {\n        side = avl_tree_node_parent_side(node1);\n        node1->parent->children[side] = node2;\n\n        avl_tree_update_height(node1->parent);\n    }\n}",
                        "rust_code": "pub fn avl_tree_node_replace() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static AVLTreeNode *avl_tree_rotate(AVLTree *tree, AVLTreeNode *node, AVLTreeNodeSide direction)\n{\n    AVLTreeNode *new_root;\n\n    new_root = node->children[1 - direction];\n\n    avl_tree_node_replace(tree, node, new_root);\n\n    node->children[1 - direction] = new_root->children[direction];\n    new_root->children[direction] = node;\n\n    node->parent = new_root;\n\n    if (node->children[1 - direction] != NULL)\n    {\n        node->children[1 - direction]->parent = node;\n    }\n\n    avl_tree_update_height(new_root);\n    avl_tree_update_height(node);\n\n    return new_root;\n}",
                        "rust_code": "pub fn avl_tree_rotate() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static AVLTreeNode *avl_tree_node_balance(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *left_subtree;\n    AVLTreeNode *right_subtree;\n    AVLTreeNode *child;\n    int diff;\n\n    left_subtree = node->children[AVL_TREE_NODE_LEFT];\n    right_subtree = node->children[AVL_TREE_NODE_RIGHT];\n\n    diff = avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if (diff >= 2)\n    {\n\n        child = right_subtree;\n\n        if (avl_tree_subtree_height(child->children[AVL_TREE_NODE_RIGHT]) <\n            avl_tree_subtree_height(child->children[AVL_TREE_NODE_LEFT]))\n        {\n\n            avl_tree_rotate(tree, right_subtree, AVL_TREE_NODE_RIGHT);\n        }\n\n        node = avl_tree_rotate(tree, node, AVL_TREE_NODE_LEFT);\n    }\n    else if (diff <= -2)\n    {\n\n        child = node->children[AVL_TREE_NODE_LEFT];\n\n        if (avl_tree_subtree_height(child->children[AVL_TREE_NODE_LEFT]) <\n            avl_tree_subtree_height(child->children[AVL_TREE_NODE_RIGHT]))\n        {\n\n            avl_tree_rotate(tree, left_subtree, AVL_TREE_NODE_LEFT);\n        }\n\n        node = avl_tree_rotate(tree, node, AVL_TREE_NODE_RIGHT);\n    }\n\n    avl_tree_update_height(node);\n\n    return node;\n}",
                        "rust_code": "pub fn avl_tree_node_balance() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void avl_tree_balance_to_root(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *rover;\n\n    rover = node;\n\n    while (rover != NULL)\n    {\n\n        rover = avl_tree_node_balance(tree, rover);\n\n        rover = rover->parent;\n    }\n}",
                        "rust_code": "pub fn avl_tree_balance_to_root() { unimplemented!(); }"
                    },
                    {
                        "c_code": "AVLTreeNode *avl_tree_insert(AVLTree *tree, AVLTreeKey key, AVLTreeValue value)\n{\n    AVLTreeNode **rover;\n    AVLTreeNode *new_node;\n    AVLTreeNode *previous_node;\n\n    rover = &tree->root_node;\n    previous_node = NULL;\n\n    while (*rover != NULL)\n    {\n        previous_node = *rover;\n        if (tree->compare_func(key, (*rover)->key) < 0)\n        {\n            rover = &((*rover)->children[AVL_TREE_NODE_LEFT]);\n        }\n        else\n        {\n            rover = &((*rover)->children[AVL_TREE_NODE_RIGHT]);\n        }\n    }\n\n    new_node = (AVLTreeNode *)malloc(sizeof(AVLTreeNode));\n\n    if (new_node == NULL)\n    {\n        return NULL;\n    }\n\n    new_node->children[AVL_TREE_NODE_LEFT] = NULL;\n    new_node->children[AVL_TREE_NODE_RIGHT] = NULL;\n    new_node->parent = previous_node;\n    new_node->key = key;\n    new_node->value = value;\n    new_node->height = 1;\n\n    *rover = new_node;\n\n    avl_tree_balance_to_root(tree, previous_node);\n\n    ++tree->num_nodes;\n\n    return new_node;\n}",
                        "rust_code": "pub fn avl_tree_insert() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static AVLTreeNode *avl_tree_node_get_replacement(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *left_subtree;\n    AVLTreeNode *right_subtree;\n    AVLTreeNode *result;\n    AVLTreeNode *child;\n    int left_height, right_height;\n    int side;\n\n    left_subtree = node->children[AVL_TREE_NODE_LEFT];\n    right_subtree = node->children[AVL_TREE_NODE_RIGHT];\n\n    if (left_subtree == NULL && right_subtree == NULL)\n    {\n        return NULL;\n    }\n\n    left_height = avl_tree_subtree_height(left_subtree);\n    right_height = avl_tree_subtree_height(right_subtree);\n\n    if (left_height < right_height)\n    {\n        side = AVL_TREE_NODE_RIGHT;\n    }\n    else\n    {\n        side = AVL_TREE_NODE_LEFT;\n    }\n\n    result = node->children[side];\n\n    while (result->children[1 - side] != NULL)\n    {\n        result = result->children[1 - side];\n    }\n\n    child = result->children[side];\n    avl_tree_node_replace(tree, result, child);\n\n    avl_tree_update_height(result->parent);\n\n    return result;\n}",
                        "rust_code": "pub fn avl_tree_node_get_replacement() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void avl_tree_remove_node(AVLTree *tree, AVLTreeNode *node)\n{\n    AVLTreeNode *swap_node;\n    AVLTreeNode *balance_startpoint;\n    int i;\n\n    swap_node = avl_tree_node_get_replacement(tree, node);\n\n    if (swap_node == NULL)\n    {\n\n        avl_tree_node_replace(tree, node, NULL);\n\n        balance_startpoint = node->parent;\n    }\n    else\n    {\n\n        if (swap_node->parent == node)\n        {\n            balance_startpoint = swap_node;\n        }\n        else\n        {\n            balance_startpoint = swap_node->parent;\n        }\n\n        for (i = 0; i < 2; ++i)\n        {\n            swap_node->children[i] = node->children[i];\n\n            if (swap_node->children[i] != NULL)\n            {\n                swap_node->children[i]->parent = swap_node;\n            }\n        }\n\n        swap_node->height = node->height;\n\n        avl_tree_node_replace(tree, node, swap_node);\n    }\n\n    free(node);\n\n    --tree->num_nodes;\n\n    avl_tree_balance_to_root(tree, balance_startpoint);\n}",
                        "rust_code": "pub fn avl_tree_remove_node() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int avl_tree_remove(AVLTree *tree, AVLTreeKey key)\n{\n    AVLTreeNode *node;\n\n    node = avl_tree_lookup_node(tree, key);\n\n    if (node == NULL)\n    {\n\n        return 0;\n    }\n\n    avl_tree_remove_node(tree, node);\n\n    return 1;\n}",
                        "rust_code": "pub fn avl_tree_remove() { unimplemented!(); }"
                    },
                    {
                        "c_code": "AVLTreeNode *avl_tree_lookup_node(AVLTree *tree, AVLTreeKey key)\n{\n    AVLTreeNode *node;\n    int diff;\n\n    node = tree->root_node;\n\n    while (node != NULL)\n    {\n\n        diff = tree->compare_func(key, node->key);\n\n        if (diff == 0)\n        {\n\n            return node;\n        }\n        else if (diff < 0)\n        {\n            node = node->children[AVL_TREE_NODE_LEFT];\n        }\n        else\n        {\n            node = node->children[AVL_TREE_NODE_RIGHT];\n        }\n    }\n\n    return NULL;\n}",
                        "rust_code": "pub fn avl_tree_lookup_node() { unimplemented!(); }"
                    },
                    {
                        "c_code": "AVLTreeValue avl_tree_lookup(AVLTree *tree, AVLTreeKey key)\n{\n    AVLTreeNode *node;\n\n    node = avl_tree_lookup_node(tree, key);\n\n    if (node == NULL)\n    {\n        return AVL_TREE_NULL;\n    }\n    else\n    {\n        return node->value;\n    }\n}",
                        "rust_code": "pub fn avl_tree_lookup() { unimplemented!(); }"
                    },
                    {
                        "c_code": "AVLTreeNode *avl_tree_root_node(AVLTree *tree)\n{\n    return tree->root_node;\n}",
                        "rust_code": "pub fn avl_tree_root_node() { unimplemented!(); }"
                    },
                    {
                        "c_code": "AVLTreeKey avl_tree_node_key(AVLTreeNode *node)\n{\n    return node->key;\n}",
                        "rust_code": "pub fn avl_tree_node_key() { unimplemented!(); }"
                    },
                    {
                        "c_code": "AVLTreeValue avl_tree_node_value(AVLTreeNode *node)\n{\n    return node->value;\n}",
                        "rust_code": "pub fn avl_tree_node_value() { unimplemented!(); }"
                    },
                    {
                        "c_code": "AVLTreeNode *avl_tree_node_child(AVLTreeNode *node, AVLTreeNodeSide side)\n{\n    if (side == AVL_TREE_NODE_LEFT || side == AVL_TREE_NODE_RIGHT)\n    {\n        return node->children[side];\n    }\n    else\n    {\n        return NULL;\n    }\n}",
                        "rust_code": "pub fn avl_tree_node_child() { unimplemented!(); }"
                    },
                    {
                        "c_code": "AVLTreeNode *avl_tree_node_parent(AVLTreeNode *node)\n{\n    return node->parent;\n}",
                        "rust_code": "pub fn avl_tree_node_parent() { unimplemented!(); }"
                    },
                    {
                        "c_code": "unsigned int avl_tree_num_entries(AVLTree *tree)\n{\n    return tree->num_nodes;\n}",
                        "rust_code": "pub fn avl_tree_num_entries() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void avl_tree_to_array_add_subtree(AVLTreeNode *subtree, AVLTreeValue *array, int *index)\n{\n    if (subtree == NULL)\n    {\n        return;\n    }\n\n    avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_LEFT], array, index);\n\n    array[*index] = subtree->key;\n    ++*index;\n\n    avl_tree_to_array_add_subtree(subtree->children[AVL_TREE_NODE_RIGHT], array, index);\n}",
                        "rust_code": "pub fn avl_tree_to_array_add_subtree() { unimplemented!(); }"
                    },
                    {
                        "c_code": "AVLTreeValue *avl_tree_to_array(AVLTree *tree)\n{\n    AVLTreeValue *array;\n    int index;\n\n    array = malloc(sizeof(AVLTreeValue) * tree->num_nodes);\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    index = 0;\n\n    avl_tree_to_array_add_subtree(tree->root_node, array, &index);\n\n    return array;\n}",
                        "rust_code": "pub fn avl_tree_to_array() { unimplemented!(); }"
                    }
                ]
            },
            "bloom_filter_c.rs": {
                "name": "bloom_filter_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::bloom_filter_h::*;"
                ],
                "definitions": [
                    {
                        "c_code": "struct _BloomFilter\n{\n    BloomFilterHashFunc hash_func;\n    unsigned char *table;\n    unsigned int table_size;\n    unsigned int num_functions;\n};",
                        "rust_code": "pub type _BloomFilter = i32;"
                    },
                    {
                        "c_code": "static const unsigned int salts[] = {\n    0x1953c322, 0x588ccf17, 0x64bf600c, 0xa6be3f3d, 0x341a02ea, 0x15b03217, 0x3b062858, 0x5956fd06,\n    0x18b5624f, 0xe3be0b46, 0x20ffcd5c, 0xa35dfd2b, 0x1fc4a9bf, 0x57c45d5c, 0xa8661c4a, 0x4f1b74d2,\n    0x5a6dde13, 0x3b18dac6, 0x05a8afbf, 0xbbda2fe2, 0xa2520d78, 0xe7934849, 0xd541bc75, 0x09a55b57,\n    0x9b345ae2, 0xfc2d26af, 0x38679cef, 0x81bd1e0d, 0x654681ae, 0x4b3d87ad, 0xd5ff10fb, 0x23b32f67,\n    0xafc7e366, 0xdd955ead, 0xe7c34b1c, 0xfeace0a6, 0xeb16f09d, 0x3c57a72d, 0x2c8294c5, 0xba92662a,\n    0xcd5b2d14, 0x743936c8, 0x2489beff, 0xc6c56e00, 0x74a4f606, 0xb244a94a, 0x5edfc423, 0xf1901934,\n    0x24af7691, 0xf6c98b25, 0xea25af46, 0x76d5f2e6, 0x5e33cdf2, 0x445eb357, 0x88556bd2, 0x70d1da7a,\n    0x54449368, 0x381020bc, 0x1c0520bf, 0xf7e44942, 0xa27e2a58, 0x66866fc5, 0x12519ce7, 0x437a8456,\n};",
                        "rust_code": "pub static salts: i32 = 0;"
                    }
                ],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "BloomFilter *bloom_filter_new(unsigned int table_size, BloomFilterHashFunc hash_func, unsigned int num_functions)\n{\n    BloomFilter *filter;\n\n    if (num_functions > sizeof(salts) / sizeof(*salts))\n    {\n        return NULL;\n    }\n\n    filter = malloc(sizeof(BloomFilter));\n\n    if (filter == NULL)\n    {\n        return NULL;\n    }\n\n    filter->table = calloc((table_size + 7) / 8, 1);\n\n    if (filter->table == NULL)\n    {\n        free(filter);\n        return NULL;\n    }\n\n    filter->hash_func = hash_func;\n    filter->num_functions = num_functions;\n    filter->table_size = table_size;\n\n    return filter;\n}",
                        "rust_code": "pub fn bloom_filter_new() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void bloom_filter_free(BloomFilter *bloomfilter)\n{\n    free(bloomfilter->table);\n    free(bloomfilter);\n}",
                        "rust_code": "pub fn bloom_filter_free() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void bloom_filter_insert(BloomFilter *bloomfilter, BloomFilterValue value)\n{\n    unsigned int hash;\n    unsigned int subhash;\n    unsigned int index;\n    unsigned int i;\n    unsigned char b;\n\n    hash = bloomfilter->hash_func(value);\n\n    for (i = 0; i < bloomfilter->num_functions; ++i)\n    {\n\n        subhash = hash ^ salts[i];\n\n        index = subhash % bloomfilter->table_size;\n\n        b = (unsigned char)(1 << (index % 8));\n        bloomfilter->table[index / 8] |= b;\n    }\n}",
                        "rust_code": "pub fn bloom_filter_insert() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int bloom_filter_query(BloomFilter *bloomfilter, BloomFilterValue value)\n{\n    unsigned int hash;\n    unsigned int subhash;\n    unsigned int index;\n    unsigned int i;\n    unsigned char b;\n    int bit;\n\n    hash = bloomfilter->hash_func(value);\n\n    for (i = 0; i < bloomfilter->num_functions; ++i)\n    {\n\n        subhash = hash ^ salts[i];\n\n        index = subhash % bloomfilter->table_size;\n\n        b = bloomfilter->table[index / 8];\n        bit = 1 << (index % 8);\n\n        if ((b & bit) == 0)\n        {\n            return 0;\n        }\n    }\n\n    return 1;\n}",
                        "rust_code": "pub fn bloom_filter_query() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void bloom_filter_read(BloomFilter *bloomfilter, unsigned char *array)\n{\n    unsigned int array_size;\n\n    array_size = (bloomfilter->table_size + 7) / 8;\n\n    memcpy(array, bloomfilter->table, array_size);\n}",
                        "rust_code": "pub fn bloom_filter_read() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void bloom_filter_load(BloomFilter *bloomfilter, unsigned char *array)\n{\n    unsigned int array_size;\n\n    array_size = (bloomfilter->table_size + 7) / 8;\n\n    memcpy(bloomfilter->table, array, array_size);\n}",
                        "rust_code": "pub fn bloom_filter_load() { unimplemented!(); }"
                    },
                    {
                        "c_code": "BloomFilter *bloom_filter_union(BloomFilter *filter1, BloomFilter *filter2)\n{\n    BloomFilter *result;\n    unsigned int i;\n    unsigned int array_size;\n\n    if (filter1->table_size != filter2->table_size || filter1->num_functions != filter2->num_functions ||\n        filter1->hash_func != filter2->hash_func)\n    {\n        return NULL;\n    }\n\n    result = bloom_filter_new(filter1->table_size, filter1->hash_func, filter1->num_functions);\n\n    if (result == NULL)\n    {\n        return NULL;\n    }\n\n    array_size = (filter1->table_size + 7) / 8;\n\n    for (i = 0; i < array_size; ++i)\n    {\n        result->table[i] = filter1->table[i] | filter2->table[i];\n    }\n\n    return result;\n}",
                        "rust_code": "pub fn bloom_filter_union() { unimplemented!(); }"
                    },
                    {
                        "c_code": "BloomFilter *bloom_filter_intersection(BloomFilter *filter1, BloomFilter *filter2)\n{\n    BloomFilter *result;\n    unsigned int i;\n    unsigned int array_size;\n\n    if (filter1->table_size != filter2->table_size || filter1->num_functions != filter2->num_functions ||\n        filter1->hash_func != filter2->hash_func)\n    {\n        return NULL;\n    }\n\n    result = bloom_filter_new(filter1->table_size, filter1->hash_func, filter1->num_functions);\n\n    if (result == NULL)\n    {\n        return NULL;\n    }\n\n    array_size = (filter1->table_size + 7) / 8;\n\n    for (i = 0; i < array_size; ++i)\n    {\n        result->table[i] = filter1->table[i] & filter2->table[i];\n    }\n\n    return result;\n}",
                        "rust_code": "pub fn bloom_filter_intersection() { unimplemented!(); }"
                    }
                ]
            },
            "compare_string_c.rs": {
                "name": "compare_string_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::compare_string_h::*;"
                ],
                "definitions": [],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "int string_equal(void *string1, void *string2)\n{\n    return strcmp((char *)string1, (char *)string2) == 0;\n}",
                        "rust_code": "pub fn string_equal() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int string_compare(void *string1, void *string2)\n{\n    int result;\n\n    result = strcmp((char *)string1, (char *)string2);\n\n    if (result < 0)\n    {\n        return -1;\n    }\n    else if (result > 0)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}",
                        "rust_code": "pub fn string_compare() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int string_nocase_equal(void *string1, void *string2)\n{\n    return string_nocase_compare((char *)string1, (char *)string2) == 0;\n}",
                        "rust_code": "pub fn string_nocase_equal() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int string_nocase_compare(void *string1, void *string2)\n{\n    char *p1;\n    char *p2;\n    int c1, c2;\n\n    p1 = (char *)string1;\n    p2 = (char *)string2;\n\n    for (;;)\n    {\n\n        c1 = tolower(*p1);\n        c2 = tolower(*p2);\n\n        if (c1 != c2)\n        {\n\n            if (c1 < c2)\n            {\n                return -1;\n            }\n            else\n            {\n                return 1;\n            }\n        }\n\n        if (c1 == '\\0')\n            break;\n\n        ++p1;\n        ++p2;\n    }\n\n    return 0;\n}",
                        "rust_code": "pub fn string_nocase_compare() { unimplemented!(); }"
                    }
                ]
            },
            "hash_pointer_h.rs": {
                "name": "hash_pointer_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::hash_pointer_c::pointer_hash;"
                ],
                "definitions": [],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_HASH_POINTER_H",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "compare_pointer_c.rs": {
                "name": "compare_pointer_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::compare_pointer_h::*;"
                ],
                "definitions": [],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "int pointer_equal(void *location1, void *location2)\n{\n    return location1 == location2;\n}",
                        "rust_code": "pub fn pointer_equal() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int pointer_compare(void *location1, void *location2)\n{\n    if (location1 < location2)\n    {\n        return -1;\n    }\n    else if (location1 > location2)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}",
                        "rust_code": "pub fn pointer_compare() { unimplemented!(); }"
                    }
                ]
            },
            "hash_table_c.rs": {
                "name": "hash_table_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::hash_table_h::*;"
                ],
                "definitions": [
                    {
                        "c_code": "struct _HashTableEntry\n{\n    HashTablePair pair;\n    HashTableEntry *next;\n};",
                        "rust_code": "pub type _HashTableEntry = i32;"
                    },
                    {
                        "c_code": "struct _HashTable\n{\n    HashTableEntry **table;\n    unsigned int table_size;\n    HashTableHashFunc hash_func;\n    HashTableEqualFunc equal_func;\n    HashTableKeyFreeFunc key_free_func;\n    HashTableValueFreeFunc value_free_func;\n    unsigned int entries;\n    unsigned int prime_index;\n};",
                        "rust_code": "pub type _HashTable = i32;"
                    },
                    {
                        "c_code": "static const unsigned int hash_table_primes[] = {\n    193,      389,      769,      1543,      3079,      6151,      12289,     24593,\n    49157,    98317,    196613,   393241,    786433,    1572869,   3145739,   6291469,\n    12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457, 1610612741,\n};",
                        "rust_code": "pub static hash_table_primes: i32 = 0;"
                    },
                    {
                        "c_code": "static const unsigned int hash_table_num_primes = sizeof(hash_table_primes) / sizeof(int);",
                        "rust_code": "pub static hash_table_num_primes: i32 = 0;"
                    }
                ],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "static int hash_table_allocate_table(HashTable *hash_table)\n{\n    unsigned int new_table_size;\n\n    if (hash_table->prime_index < hash_table_num_primes)\n    {\n        new_table_size = hash_table_primes[hash_table->prime_index];\n    }\n    else\n    {\n        new_table_size = hash_table->entries * 10;\n    }\n\n    hash_table->table_size = new_table_size;\n\n    hash_table->table = calloc(hash_table->table_size, sizeof(HashTableEntry *));\n\n    return hash_table->table != NULL;\n}",
                        "rust_code": "pub fn hash_table_allocate_table() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void hash_table_free_entry(HashTable *hash_table, HashTableEntry *entry)\n{\n    HashTablePair *pair;\n\n    pair = &(entry->pair);\n\n    if (hash_table->key_free_func != NULL)\n    {\n        hash_table->key_free_func(pair->key);\n    }\n\n    if (hash_table->value_free_func != NULL)\n    {\n        hash_table->value_free_func(pair->value);\n    }\n\n    free(entry);\n}",
                        "rust_code": "pub fn hash_table_free_entry() { unimplemented!(); }"
                    },
                    {
                        "c_code": "HashTable *hash_table_new(HashTableHashFunc hash_func, HashTableEqualFunc equal_func)\n{\n    HashTable *hash_table;\n\n    hash_table = (HashTable *)malloc(sizeof(HashTable));\n\n    if (hash_table == NULL)\n    {\n        return NULL;\n    }\n\n    hash_table->hash_func = hash_func;\n    hash_table->equal_func = equal_func;\n    hash_table->key_free_func = NULL;\n    hash_table->value_free_func = NULL;\n    hash_table->entries = 0;\n    hash_table->prime_index = 0;\n\n    if (!hash_table_allocate_table(hash_table))\n    {\n        free(hash_table);\n\n        return NULL;\n    }\n\n    return hash_table;\n}",
                        "rust_code": "pub fn hash_table_new() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void hash_table_free(HashTable *hash_table)\n{\n    HashTableEntry *rover;\n    HashTableEntry *next;\n    unsigned int i;\n\n    for (i = 0; i < hash_table->table_size; ++i)\n    {\n        rover = hash_table->table[i];\n        while (rover != NULL)\n        {\n            next = rover->next;\n            hash_table_free_entry(hash_table, rover);\n            rover = next;\n        }\n    }\n\n    free(hash_table->table);\n\n    free(hash_table);\n}",
                        "rust_code": "pub fn hash_table_free() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void hash_table_register_free_functions(HashTable *hash_table, HashTableKeyFreeFunc key_free_func,\n                                        HashTableValueFreeFunc value_free_func)\n{\n    hash_table->key_free_func = key_free_func;\n    hash_table->value_free_func = value_free_func;\n}",
                        "rust_code": "pub fn hash_table_register_free_functions() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static int hash_table_enlarge(HashTable *hash_table)\n{\n    HashTableEntry **old_table;\n    unsigned int old_table_size;\n    unsigned int old_prime_index;\n    HashTableEntry *rover;\n    HashTablePair *pair;\n    HashTableEntry *next;\n    unsigned int index;\n    unsigned int i;\n\n    old_table = hash_table->table;\n    old_table_size = hash_table->table_size;\n    old_prime_index = hash_table->prime_index;\n\n    ++hash_table->prime_index;\n\n    if (!hash_table_allocate_table(hash_table))\n    {\n\n        hash_table->table = old_table;\n        hash_table->table_size = old_table_size;\n        hash_table->prime_index = old_prime_index;\n\n        return 0;\n    }\n\n    for (i = 0; i < old_table_size; ++i)\n    {\n        rover = old_table[i];\n\n        while (rover != NULL)\n        {\n            next = rover->next;\n\n            pair = &(rover->pair);\n\n            index = hash_table->hash_func(pair->key) % hash_table->table_size;\n\n            rover->next = hash_table->table[index];\n            hash_table->table[index] = rover;\n\n            rover = next;\n        }\n    }\n\n    free(old_table);\n\n    return 1;\n}",
                        "rust_code": "pub fn hash_table_enlarge() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int hash_table_insert(HashTable *hash_table, HashTableKey key, HashTableValue value)\n{\n    HashTableEntry *rover;\n    HashTablePair *pair;\n    HashTableEntry *newentry;\n    unsigned int index;\n\n    if ((hash_table->entries * 3) / hash_table->table_size > 0)\n    {\n\n        if (!hash_table_enlarge(hash_table))\n        {\n\n            return 0;\n        }\n    }\n\n    index = hash_table->hash_func(key) % hash_table->table_size;\n\n    rover = hash_table->table[index];\n\n    while (rover != NULL)\n    {\n\n        pair = &(rover->pair);\n\n        if (hash_table->equal_func(pair->key, key) != 0)\n        {\n\n            if (hash_table->value_free_func != NULL)\n            {\n                hash_table->value_free_func(pair->value);\n            }\n\n            if (hash_table->key_free_func != NULL)\n            {\n                hash_table->key_free_func(pair->key);\n            }\n\n            pair->key = key;\n            pair->value = value;\n\n            return 1;\n        }\n\n        rover = rover->next;\n    }\n\n    newentry = (HashTableEntry *)malloc(sizeof(HashTableEntry));\n\n    if (newentry == NULL)\n    {\n        return 0;\n    }\n\n    newentry->pair.key = key;\n    newentry->pair.value = value;\n\n    newentry->next = hash_table->table[index];\n    hash_table->table[index] = newentry;\n\n    ++hash_table->entries;\n\n    return 1;\n}",
                        "rust_code": "pub fn hash_table_insert() { unimplemented!(); }"
                    },
                    {
                        "c_code": "HashTableValue hash_table_lookup(HashTable *hash_table, HashTableKey key)\n{\n    HashTableEntry *rover;\n    HashTablePair *pair;\n    unsigned int index;\n\n    index = hash_table->hash_func(key) % hash_table->table_size;\n\n    rover = hash_table->table[index];\n\n    while (rover != NULL)\n    {\n        pair = &(rover->pair);\n\n        if (hash_table->equal_func(key, pair->key) != 0)\n        {\n\n            return pair->value;\n        }\n\n        rover = rover->next;\n    }\n\n    return HASH_TABLE_NULL;\n}",
                        "rust_code": "pub fn hash_table_lookup() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int hash_table_remove(HashTable *hash_table, HashTableKey key)\n{\n    HashTableEntry **rover;\n    HashTableEntry *entry;\n    HashTablePair *pair;\n    unsigned int index;\n    int result;\n\n    index = hash_table->hash_func(key) % hash_table->table_size;\n\n    result = 0;\n    rover = &hash_table->table[index];\n\n    while (*rover != NULL)\n    {\n\n        pair = &((*rover)->pair);\n\n        if (hash_table->equal_func(key, pair->key) != 0)\n        {\n\n            entry = *rover;\n\n            *rover = entry->next;\n\n            hash_table_free_entry(hash_table, entry);\n\n            --hash_table->entries;\n\n            result = 1;\n\n            break;\n        }\n\n        rover = &((*rover)->next);\n    }\n\n    return result;\n}",
                        "rust_code": "pub fn hash_table_remove() { unimplemented!(); }"
                    },
                    {
                        "c_code": "unsigned int hash_table_num_entries(HashTable *hash_table)\n{\n    return hash_table->entries;\n}",
                        "rust_code": "pub fn hash_table_num_entries() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void hash_table_iterate(HashTable *hash_table, HashTableIterator *iterator)\n{\n    unsigned int chain;\n\n    iterator->hash_table = hash_table;\n\n    iterator->next_entry = NULL;\n\n    for (chain = 0; chain < hash_table->table_size; ++chain)\n    {\n\n        if (hash_table->table[chain] != NULL)\n        {\n            iterator->next_entry = hash_table->table[chain];\n            iterator->next_chain = chain;\n            break;\n        }\n    }\n}",
                        "rust_code": "pub fn hash_table_iterate() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int hash_table_iter_has_more(HashTableIterator *iterator)\n{\n    return iterator->next_entry != NULL;\n}",
                        "rust_code": "pub fn hash_table_iter_has_more() { unimplemented!(); }"
                    },
                    {
                        "c_code": "HashTablePair hash_table_iter_next(HashTableIterator *iterator)\n{\n    HashTableEntry *current_entry;\n    HashTable *hash_table;\n    HashTablePair pair = {NULL, NULL};\n    unsigned int chain;\n\n    hash_table = iterator->hash_table;\n\n    if (iterator->next_entry == NULL)\n    {\n        return pair;\n    }\n\n    current_entry = iterator->next_entry;\n    pair = current_entry->pair;\n\n    if (current_entry->next != NULL)\n    {\n\n        iterator->next_entry = current_entry->next;\n    }\n    else\n    {\n\n        chain = iterator->next_chain + 1;\n\n        iterator->next_entry = NULL;\n\n        while (chain < hash_table->table_size)\n        {\n\n            if (hash_table->table[chain] != NULL)\n            {\n                iterator->next_entry = hash_table->table[chain];\n                break;\n            }\n\n            ++chain;\n        }\n\n        iterator->next_chain = chain;\n    }\n\n    return pair;\n}",
                        "rust_code": "pub fn hash_table_iter_next() { unimplemented!(); }"
                    }
                ]
            },
            "compare_pointer_h.rs": {
                "name": "compare_pointer_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::compare_pointer_c::pointer_equal;",
                    "pub use crate::src::compare_pointer_c::pointer_compare;"
                ],
                "definitions": [],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_COMPARE_POINTER_H",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "set_c.rs": {
                "name": "set_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::set_h::*;"
                ],
                "definitions": [
                    {
                        "c_code": "struct _SetEntry\n{\n    SetValue data;\n    SetEntry *next;\n};",
                        "rust_code": "pub type _SetEntry = i32;"
                    },
                    {
                        "c_code": "struct _Set\n{\n    SetEntry **table;\n    unsigned int entries;\n    unsigned int table_size;\n    unsigned int prime_index;\n    SetHashFunc hash_func;\n    SetEqualFunc equal_func;\n    SetFreeFunc free_func;\n};",
                        "rust_code": "pub type _Set = i32;"
                    },
                    {
                        "c_code": "static const unsigned int set_primes[] = {\n    193,      389,      769,      1543,      3079,      6151,      12289,     24593,\n    49157,    98317,    196613,   393241,    786433,    1572869,   3145739,   6291469,\n    12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457, 1610612741,\n};",
                        "rust_code": "pub static set_primes: i32 = 0;"
                    },
                    {
                        "c_code": "static const unsigned int set_num_primes = sizeof(set_primes) / sizeof(int);",
                        "rust_code": "pub static set_num_primes: i32 = 0;"
                    }
                ],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "static int set_allocate_table(Set *set)\n{\n\n    if (set->prime_index < set_num_primes)\n    {\n        set->table_size = set_primes[set->prime_index];\n    }\n    else\n    {\n        set->table_size = set->entries * 10;\n    }\n\n    set->table = calloc(set->table_size, sizeof(SetEntry *));\n\n    return set->table != NULL;\n}",
                        "rust_code": "pub fn set_allocate_table() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void set_free_entry(Set *set, SetEntry *entry)\n{\n\n    if (set->free_func != NULL)\n    {\n        set->free_func(entry->data);\n    }\n\n    free(entry);\n}",
                        "rust_code": "pub fn set_free_entry() { unimplemented!(); }"
                    },
                    {
                        "c_code": "Set *set_new(SetHashFunc hash_func, SetEqualFunc equal_func)\n{\n    Set *new_set;\n\n    new_set = (Set *)malloc(sizeof(Set));\n\n    if (new_set == NULL)\n    {\n        return NULL;\n    }\n\n    new_set->hash_func = hash_func;\n    new_set->equal_func = equal_func;\n    new_set->entries = 0;\n    new_set->prime_index = 0;\n    new_set->free_func = NULL;\n\n    if (!set_allocate_table(new_set))\n    {\n        free(new_set);\n        return NULL;\n    }\n\n    return new_set;\n}",
                        "rust_code": "pub fn set_new() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void set_free(Set *set)\n{\n    SetEntry *rover;\n    SetEntry *next;\n    unsigned int i;\n\n    for (i = 0; i < set->table_size; ++i)\n    {\n        rover = set->table[i];\n\n        while (rover != NULL)\n        {\n            next = rover->next;\n\n            set_free_entry(set, rover);\n\n            rover = next;\n        }\n    }\n\n    free(set->table);\n\n    free(set);\n}",
                        "rust_code": "pub fn set_free() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void set_register_free_function(Set *set, SetFreeFunc free_func)\n{\n    set->free_func = free_func;\n}",
                        "rust_code": "pub fn set_register_free_function() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static int set_enlarge(Set *set)\n{\n    SetEntry *rover;\n    SetEntry *next;\n    SetEntry **old_table;\n    unsigned int old_table_size;\n    unsigned int old_prime_index;\n    unsigned int index;\n    unsigned int i;\n\n    old_table = set->table;\n    old_table_size = set->table_size;\n    old_prime_index = set->prime_index;\n\n    ++set->prime_index;\n\n    if (!set_allocate_table(set))\n    {\n        set->table = old_table;\n        set->table_size = old_table_size;\n        set->prime_index = old_prime_index;\n\n        return 0;\n    }\n\n    for (i = 0; i < old_table_size; ++i)\n    {\n\n        rover = old_table[i];\n\n        while (rover != NULL)\n        {\n\n            next = rover->next;\n\n            index = set->hash_func(rover->data) % set->table_size;\n            rover->next = set->table[index];\n            set->table[index] = rover;\n\n            rover = next;\n        }\n    }\n\n    free(old_table);\n\n    return 1;\n}",
                        "rust_code": "pub fn set_enlarge() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int set_insert(Set *set, SetValue data)\n{\n    SetEntry *newentry;\n    SetEntry *rover;\n    unsigned int index;\n\n    if ((set->entries * 3) / set->table_size > 0)\n    {\n\n        if (!set_enlarge(set))\n        {\n            return 0;\n        }\n    }\n\n    index = set->hash_func(data) % set->table_size;\n\n    rover = set->table[index];\n\n    while (rover != NULL)\n    {\n\n        if (set->equal_func(data, rover->data) != 0)\n        {\n\n            return 0;\n        }\n\n        rover = rover->next;\n    }\n\n    newentry = (SetEntry *)malloc(sizeof(SetEntry));\n\n    if (newentry == NULL)\n    {\n        return 0;\n    }\n\n    newentry->data = data;\n\n    newentry->next = set->table[index];\n    set->table[index] = newentry;\n\n    ++set->entries;\n\n    return 1;\n}",
                        "rust_code": "pub fn set_insert() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int set_remove(Set *set, SetValue data)\n{\n    SetEntry **rover;\n    SetEntry *entry;\n    unsigned int index;\n\n    index = set->hash_func(data) % set->table_size;\n\n    rover = &set->table[index];\n\n    while (*rover != NULL)\n    {\n        if (set->equal_func(data, (*rover)->data) != 0)\n        {\n\n            entry = *rover;\n\n            *rover = entry->next;\n\n            --set->entries;\n\n            set_free_entry(set, entry);\n\n            return 1;\n        }\n\n        rover = &((*rover)->next);\n    }\n\n    return 0;\n}",
                        "rust_code": "pub fn set_remove() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int set_query(Set *set, SetValue data)\n{\n    SetEntry *rover;\n    unsigned int index;\n\n    index = set->hash_func(data) % set->table_size;\n\n    rover = set->table[index];\n\n    while (rover != NULL)\n    {\n        if (set->equal_func(data, rover->data) != 0)\n        {\n\n            return 1;\n        }\n\n        rover = rover->next;\n    }\n\n    return 0;\n}",
                        "rust_code": "pub fn set_query() { unimplemented!(); }"
                    },
                    {
                        "c_code": "unsigned int set_num_entries(Set *set)\n{\n    return set->entries;\n}",
                        "rust_code": "pub fn set_num_entries() { unimplemented!(); }"
                    },
                    {
                        "c_code": "SetValue *set_to_array(Set *set)\n{\n    SetValue *array;\n    int array_counter;\n    unsigned int i;\n    SetEntry *rover;\n\n    array = malloc(sizeof(SetValue) * set->entries);\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    array_counter = 0;\n\n    for (i = 0; i < set->table_size; ++i)\n    {\n\n        rover = set->table[i];\n\n        while (rover != NULL)\n        {\n\n            array[array_counter] = rover->data;\n            ++array_counter;\n\n            rover = rover->next;\n        }\n    }\n\n    return array;\n}",
                        "rust_code": "pub fn set_to_array() { unimplemented!(); }"
                    },
                    {
                        "c_code": "Set *set_union(Set *set1, Set *set2)\n{\n    SetIterator iterator;\n    Set *new_set;\n    SetValue value;\n\n    new_set = set_new(set1->hash_func, set1->equal_func);\n\n    if (new_set == NULL)\n    {\n        return NULL;\n    }\n\n    set_iterate(set1, &iterator);\n\n    while (set_iter_has_more(&iterator))\n    {\n\n        value = set_iter_next(&iterator);\n\n        if (!set_insert(new_set, value))\n        {\n\n            set_free(new_set);\n            return NULL;\n        }\n    }\n\n    set_iterate(set2, &iterator);\n\n    while (set_iter_has_more(&iterator))\n    {\n\n        value = set_iter_next(&iterator);\n\n        if (set_query(new_set, value) == 0)\n        {\n            if (!set_insert(new_set, value))\n            {\n\n                set_free(new_set);\n                return NULL;\n            }\n        }\n    }\n\n    return new_set;\n}",
                        "rust_code": "pub fn set_union() { unimplemented!(); }"
                    },
                    {
                        "c_code": "Set *set_intersection(Set *set1, Set *set2)\n{\n    Set *new_set;\n    SetIterator iterator;\n    SetValue value;\n\n    new_set = set_new(set1->hash_func, set2->equal_func);\n\n    if (new_set == NULL)\n    {\n        return NULL;\n    }\n\n    set_iterate(set1, &iterator);\n\n    while (set_iter_has_more(&iterator))\n    {\n\n        value = set_iter_next(&iterator);\n\n        if (set_query(set2, value) != 0)\n        {\n\n            if (!set_insert(new_set, value))\n            {\n                set_free(new_set);\n\n                return NULL;\n            }\n        }\n    }\n\n    return new_set;\n}",
                        "rust_code": "pub fn set_intersection() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void set_iterate(Set *set, SetIterator *iter)\n{\n    unsigned int chain;\n\n    iter->set = set;\n    iter->next_entry = NULL;\n\n    for (chain = 0; chain < set->table_size; ++chain)\n    {\n\n        if (set->table[chain] != NULL)\n        {\n            iter->next_entry = set->table[chain];\n            break;\n        }\n    }\n\n    iter->next_chain = chain;\n}",
                        "rust_code": "pub fn set_iterate() { unimplemented!(); }"
                    },
                    {
                        "c_code": "SetValue set_iter_next(SetIterator *iterator)\n{\n    Set *set;\n    SetValue result;\n    SetEntry *current_entry;\n    unsigned int chain;\n\n    set = iterator->set;\n\n    if (iterator->next_entry == NULL)\n    {\n        return SET_NULL;\n    }\n\n    current_entry = iterator->next_entry;\n    result = current_entry->data;\n\n    if (current_entry->next != NULL)\n    {\n\n        iterator->next_entry = current_entry->next;\n    }\n    else\n    {\n\n        iterator->next_entry = NULL;\n\n        chain = iterator->next_chain + 1;\n\n        while (chain < set->table_size)\n        {\n\n            if (set->table[chain] != NULL)\n            {\n\n                iterator->next_entry = set->table[chain];\n\n                break;\n            }\n\n            ++chain;\n        }\n\n        iterator->next_chain = chain;\n    }\n\n    return result;\n}",
                        "rust_code": "pub fn set_iter_next() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int set_iter_has_more(SetIterator *iterator)\n{\n    return iterator->next_entry != NULL;\n}",
                        "rust_code": "pub fn set_iter_has_more() { unimplemented!(); }"
                    }
                ]
            },
            "hash_int_h.rs": {
                "name": "hash_int_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::hash_int_c::int_hash;"
                ],
                "definitions": [],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_HASH_INT_H",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "hash_string_h.rs": {
                "name": "hash_string_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::hash_string_c::string_hash;",
                    "pub use crate::src::hash_string_c::string_nocase_hash;"
                ],
                "definitions": [],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_HASH_STRING_H",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "hash_int_c.rs": {
                "name": "hash_int_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::hash_int_h::*;"
                ],
                "definitions": [],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "unsigned int int_hash(void *vlocation)\n{\n    int *location;\n\n    location = (int *)vlocation;\n\n    return (unsigned int)*location;\n}",
                        "rust_code": "pub fn int_hash() { unimplemented!(); }"
                    }
                ]
            },
            "bloom_filter_h.rs": {
                "name": "bloom_filter_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::bloom_filter_c::_BloomFilter;",
                    "pub use crate::src::bloom_filter_c::bloom_filter_insert;",
                    "pub use crate::src::bloom_filter_c::bloom_filter_intersection;",
                    "pub use crate::src::bloom_filter_c::bloom_filter_new;",
                    "pub use crate::src::bloom_filter_c::bloom_filter_read;",
                    "pub use crate::src::bloom_filter_c::bloom_filter_load;",
                    "pub use crate::src::bloom_filter_c::bloom_filter_free;",
                    "pub use crate::src::bloom_filter_c::bloom_filter_union;",
                    "pub use crate::src::bloom_filter_c::bloom_filter_query;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef struct _BloomFilter BloomFilter;",
                        "rust_code": "pub type BloomFilter = i32;"
                    },
                    {
                        "c_code": "typedef void *BloomFilterValue;",
                        "rust_code": "pub type BloomFilterValue = i32;"
                    },
                    {
                        "c_code": "typedef unsigned int (*BloomFilterHashFunc)(BloomFilterValue data);",
                        "rust_code": "pub type BloomFilterHashFunc = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_BLOOM_FILTER_H",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "binary_heap_h.rs": {
                "name": "binary_heap_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::binary_heap_c::_BinaryHeap;",
                    "pub use crate::src::binary_heap_c::binary_heap_new;",
                    "pub use crate::src::binary_heap_c::binary_heap_insert;",
                    "pub use crate::src::binary_heap_c::binary_heap_num_entries;",
                    "pub use crate::src::binary_heap_c::binary_heap_pop;",
                    "pub use crate::src::binary_heap_c::binary_heap_free;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef enum\n    {\n\n        BINARY_HEAP_TYPE_MIN,\n\n        BINARY_HEAP_TYPE_MAX\n    } BinaryHeapType;",
                        "rust_code": "pub type BinaryHeapType = i32;"
                    },
                    {
                        "c_code": "typedef void *BinaryHeapValue;",
                        "rust_code": "pub type BinaryHeapValue = i32;"
                    },
                    {
                        "c_code": "typedef int (*BinaryHeapCompareFunc)(BinaryHeapValue value1, BinaryHeapValue value2);",
                        "rust_code": "pub type BinaryHeapCompareFunc = i32;"
                    },
                    {
                        "c_code": "typedef struct _BinaryHeap BinaryHeap;",
                        "rust_code": "pub type BinaryHeap = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_BINARY_HEAP_H",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define BINARY_HEAP_NULL ((void *)0)",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "trie_h.rs": {
                "name": "trie_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::trie_c::trie_lookup;",
                    "pub use crate::src::trie_c::trie_insert;",
                    "pub use crate::src::trie_c::trie_remove_binary;",
                    "pub use crate::src::trie_c::trie_insert_binary;",
                    "pub use crate::src::trie_c::trie_new;",
                    "pub use crate::src::trie_c::_Trie;",
                    "pub use crate::src::trie_c::trie_num_entries;",
                    "pub use crate::src::trie_c::trie_free;",
                    "pub use crate::src::trie_c::trie_lookup_binary;",
                    "pub use crate::src::trie_c::trie_remove;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef struct _Trie Trie;",
                        "rust_code": "pub type Trie = i32;"
                    },
                    {
                        "c_code": "typedef void *TrieValue;",
                        "rust_code": "pub type TrieValue = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_TRIE_H",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define TRIE_NULL ((void *)0)",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "slist_h.rs": {
                "name": "slist_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::slist_c::slist_iter_has_more;",
                    "pub use crate::src::slist_c::slist_append;",
                    "pub use crate::src::slist_c::slist_remove_data;",
                    "pub use crate::src::slist_c::slist_data;",
                    "pub use crate::src::slist_c::slist_iter_next;",
                    "pub use crate::src::slist_c::slist_find_data;",
                    "pub use crate::src::slist_c::slist_to_array;",
                    "pub use crate::src::slist_c::slist_set_data;",
                    "pub use crate::src::slist_c::slist_next;",
                    "pub use crate::src::slist_c::slist_iterate;",
                    "pub use crate::src::slist_c::_SListEntry;",
                    "pub use crate::src::slist_c::slist_sort;",
                    "pub use crate::src::slist_c::slist_nth_data;",
                    "pub use crate::src::slist_c::slist_free;",
                    "pub use crate::src::slist_c::slist_iter_remove;",
                    "pub use crate::src::slist_c::slist_remove_entry;",
                    "pub use crate::src::slist_c::slist_nth_entry;",
                    "pub use crate::src::slist_c::slist_length;",
                    "pub use crate::src::slist_c::slist_prepend;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef struct _SListEntry SListEntry;",
                        "rust_code": "pub type SListEntry = i32;"
                    },
                    {
                        "c_code": "typedef struct _SListIterator SListIterator;",
                        "rust_code": "pub type SListIterator = i32;"
                    },
                    {
                        "c_code": "typedef void *SListValue;",
                        "rust_code": "pub type SListValue = i32;"
                    },
                    {
                        "c_code": "struct _SListIterator\n    {\n        SListEntry **prev_next;\n        SListEntry *current;\n    };",
                        "rust_code": "pub type _SListIterator = i32;"
                    },
                    {
                        "c_code": "typedef int (*SListCompareFunc)(SListValue value1, SListValue value2);",
                        "rust_code": "pub type SListCompareFunc = i32;"
                    },
                    {
                        "c_code": "typedef int (*SListEqualFunc)(SListValue value1, SListValue value2);",
                        "rust_code": "pub type SListEqualFunc = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_SLIST_H",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define SLIST_NULL ((void *)0)",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "avl_tree_h.rs": {
                "name": "avl_tree_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::avl_tree_c::avl_tree_remove;",
                    "pub use crate::src::avl_tree_c::avl_tree_num_entries;",
                    "pub use crate::src::avl_tree_c::avl_tree_root_node;",
                    "pub use crate::src::avl_tree_c::avl_tree_subtree_height;",
                    "pub use crate::src::avl_tree_c::avl_tree_free;",
                    "pub use crate::src::avl_tree_c::avl_tree_lookup;",
                    "pub use crate::src::avl_tree_c::avl_tree_insert;",
                    "pub use crate::src::avl_tree_c::avl_tree_lookup_node;",
                    "pub use crate::src::avl_tree_c::avl_tree_new;",
                    "pub use crate::src::avl_tree_c::avl_tree_node_parent;",
                    "pub use crate::src::avl_tree_c::_AVLTreeNode;",
                    "pub use crate::src::avl_tree_c::avl_tree_to_array;",
                    "pub use crate::src::avl_tree_c::_AVLTree;",
                    "pub use crate::src::avl_tree_c::avl_tree_node_value;",
                    "pub use crate::src::avl_tree_c::avl_tree_node_child;",
                    "pub use crate::src::avl_tree_c::avl_tree_remove_node;",
                    "pub use crate::src::avl_tree_c::avl_tree_node_key;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef struct _AVLTree AVLTree;",
                        "rust_code": "pub type AVLTree = i32;"
                    },
                    {
                        "c_code": "typedef void *AVLTreeKey;",
                        "rust_code": "pub type AVLTreeKey = i32;"
                    },
                    {
                        "c_code": "typedef void *AVLTreeValue;",
                        "rust_code": "pub type AVLTreeValue = i32;"
                    },
                    {
                        "c_code": "typedef struct _AVLTreeNode AVLTreeNode;",
                        "rust_code": "pub type AVLTreeNode = i32;"
                    },
                    {
                        "c_code": "typedef enum\n    {\n        AVL_TREE_NODE_LEFT = 0,\n        AVL_TREE_NODE_RIGHT = 1\n    } AVLTreeNodeSide;",
                        "rust_code": "pub type AVLTreeNodeSide = i32;"
                    },
                    {
                        "c_code": "typedef int (*AVLTreeCompareFunc)(AVLTreeValue value1, AVLTreeValue value2);",
                        "rust_code": "pub type AVLTreeCompareFunc = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_AVLTREE_H",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define AVL_TREE_NULL ((void *)0)",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "queue_c.rs": {
                "name": "queue_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::queue_h::*;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef struct _QueueEntry QueueEntry;",
                        "rust_code": "pub type QueueEntry = i32;"
                    },
                    {
                        "c_code": "struct _QueueEntry\n{\n    QueueValue data;\n    QueueEntry *prev;\n    QueueEntry *next;\n};",
                        "rust_code": "pub type _QueueEntry = i32;"
                    },
                    {
                        "c_code": "struct _Queue\n{\n    QueueEntry *head;\n    QueueEntry *tail;\n};",
                        "rust_code": "pub type _Queue = i32;"
                    }
                ],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "Queue *queue_new(void)\n{\n    Queue *queue;\n\n    queue = (Queue *)malloc(sizeof(Queue));\n\n    if (queue == NULL)\n    {\n        return NULL;\n    }\n\n    queue->head = NULL;\n    queue->tail = NULL;\n\n    return queue;\n}",
                        "rust_code": "pub fn queue_new() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void queue_free(Queue *queue)\n{\n\n    while (!queue_is_empty(queue))\n    {\n        queue_pop_head(queue);\n    }\n\n    free(queue);\n}",
                        "rust_code": "pub fn queue_free() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int queue_push_head(Queue *queue, QueueValue data)\n{\n    QueueEntry *new_entry;\n\n    new_entry = malloc(sizeof(QueueEntry));\n\n    if (new_entry == NULL)\n    {\n        return 0;\n    }\n\n    new_entry->data = data;\n    new_entry->prev = NULL;\n    new_entry->next = queue->head;\n\n    if (queue->head == NULL)\n    {\n\n        queue->head = new_entry;\n        queue->tail = new_entry;\n    }\n    else\n    {\n\n        queue->head->prev = new_entry;\n\n        queue->head = new_entry;\n    }\n\n    return 1;\n}",
                        "rust_code": "pub fn queue_push_head() { unimplemented!(); }"
                    },
                    {
                        "c_code": "QueueValue queue_pop_head(Queue *queue)\n{\n    QueueEntry *entry;\n    QueueValue result;\n\n    if (queue_is_empty(queue))\n    {\n        return QUEUE_NULL;\n    }\n\n    entry = queue->head;\n    queue->head = entry->next;\n    result = entry->data;\n\n    if (queue->head == NULL)\n    {\n\n        queue->tail = NULL;\n    }\n    else\n    {\n\n        queue->head->prev = NULL;\n    }\n\n    free(entry);\n\n    return result;\n}",
                        "rust_code": "pub fn queue_pop_head() { unimplemented!(); }"
                    },
                    {
                        "c_code": "QueueValue queue_peek_head(Queue *queue)\n{\n    if (queue_is_empty(queue))\n    {\n        return QUEUE_NULL;\n    }\n    else\n    {\n        return queue->head->data;\n    }\n}",
                        "rust_code": "pub fn queue_peek_head() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int queue_push_tail(Queue *queue, QueueValue data)\n{\n    QueueEntry *new_entry;\n\n    new_entry = malloc(sizeof(QueueEntry));\n\n    if (new_entry == NULL)\n    {\n        return 0;\n    }\n\n    new_entry->data = data;\n    new_entry->prev = queue->tail;\n    new_entry->next = NULL;\n\n    if (queue->tail == NULL)\n    {\n\n        queue->head = new_entry;\n        queue->tail = new_entry;\n    }\n    else\n    {\n\n        queue->tail->next = new_entry;\n\n        queue->tail = new_entry;\n    }\n\n    return 1;\n}",
                        "rust_code": "pub fn queue_push_tail() { unimplemented!(); }"
                    },
                    {
                        "c_code": "QueueValue queue_pop_tail(Queue *queue)\n{\n    QueueEntry *entry;\n    QueueValue result;\n\n    if (queue_is_empty(queue))\n    {\n        return QUEUE_NULL;\n    }\n\n    entry = queue->tail;\n    queue->tail = entry->prev;\n    result = entry->data;\n\n    if (queue->tail == NULL)\n    {\n\n        queue->head = NULL;\n    }\n    else\n    {\n\n        queue->tail->next = NULL;\n    }\n\n    free(entry);\n\n    return result;\n}",
                        "rust_code": "pub fn queue_pop_tail() { unimplemented!(); }"
                    },
                    {
                        "c_code": "QueueValue queue_peek_tail(Queue *queue)\n{\n    if (queue_is_empty(queue))\n    {\n        return QUEUE_NULL;\n    }\n    else\n    {\n        return queue->tail->data;\n    }\n}",
                        "rust_code": "pub fn queue_peek_tail() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int queue_is_empty(Queue *queue)\n{\n    return queue->head == NULL;\n}",
                        "rust_code": "pub fn queue_is_empty() { unimplemented!(); }"
                    }
                ]
            },
            "arraylist_h.rs": {
                "name": "arraylist_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::arraylist_c::arraylist_insert;",
                    "pub use crate::src::arraylist_c::arraylist_index_of;",
                    "pub use crate::src::arraylist_c::arraylist_remove;",
                    "pub use crate::src::arraylist_c::arraylist_append;",
                    "pub use crate::src::arraylist_c::arraylist_prepend;",
                    "pub use crate::src::arraylist_c::arraylist_clear;",
                    "pub use crate::src::arraylist_c::arraylist_free;",
                    "pub use crate::src::arraylist_c::arraylist_remove_range;",
                    "pub use crate::src::arraylist_c::arraylist_new;",
                    "pub use crate::src::arraylist_c::arraylist_sort;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef void *ArrayListValue;",
                        "rust_code": "pub type ArrayListValue = i32;"
                    },
                    {
                        "c_code": "typedef struct _ArrayList ArrayList;",
                        "rust_code": "pub type ArrayList = i32;"
                    },
                    {
                        "c_code": "struct _ArrayList\n    {\n\n        ArrayListValue *data;\n\n        unsigned int length;\n\n        unsigned int _alloced;\n    };",
                        "rust_code": "pub type _ArrayList = i32;"
                    },
                    {
                        "c_code": "typedef int (*ArrayListEqualFunc)(ArrayListValue value1, ArrayListValue value2);",
                        "rust_code": "pub type ArrayListEqualFunc = i32;"
                    },
                    {
                        "c_code": "typedef int (*ArrayListCompareFunc)(ArrayListValue value1, ArrayListValue value2);",
                        "rust_code": "pub type ArrayListCompareFunc = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_ARRAYLIST_H",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "compare_int_h.rs": {
                "name": "compare_int_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::compare_int_c::int_equal;",
                    "pub use crate::src::compare_int_c::int_compare;"
                ],
                "definitions": [],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_COMPARE_INT_H",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "hash_table_h.rs": {
                "name": "hash_table_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::hash_table_c::_HashTableEntry;",
                    "pub use crate::src::hash_table_c::hash_table_lookup;",
                    "pub use crate::src::hash_table_c::hash_table_iterate;",
                    "pub use crate::src::hash_table_c::hash_table_register_free_functions;",
                    "pub use crate::src::hash_table_c::hash_table_remove;",
                    "pub use crate::src::hash_table_c::hash_table_iter_has_more;",
                    "pub use crate::src::hash_table_c::hash_table_num_entries;",
                    "pub use crate::src::hash_table_c::hash_table_insert;",
                    "pub use crate::src::hash_table_c::hash_table_new;",
                    "pub use crate::src::hash_table_c::hash_table_iter_next;",
                    "pub use crate::src::hash_table_c::hash_table_free;",
                    "pub use crate::src::hash_table_c::_HashTable;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef struct _HashTable HashTable;",
                        "rust_code": "pub type HashTable = i32;"
                    },
                    {
                        "c_code": "typedef struct _HashTableIterator HashTableIterator;",
                        "rust_code": "pub type HashTableIterator = i32;"
                    },
                    {
                        "c_code": "typedef struct _HashTableEntry HashTableEntry;",
                        "rust_code": "pub type HashTableEntry = i32;"
                    },
                    {
                        "c_code": "typedef void *HashTableKey;",
                        "rust_code": "pub type HashTableKey = i32;"
                    },
                    {
                        "c_code": "typedef void *HashTableValue;",
                        "rust_code": "pub type HashTableValue = i32;"
                    },
                    {
                        "c_code": "typedef struct _HashTablePair\n    {\n        HashTableKey key;\n        HashTableValue value;\n    } HashTablePair;",
                        "rust_code": "pub type HashTablePair = i32;"
                    },
                    {
                        "c_code": "struct _HashTableIterator\n    {\n        HashTable *hash_table;\n        HashTableEntry *next_entry;\n        unsigned int next_chain;\n    };",
                        "rust_code": "pub type _HashTableIterator = i32;"
                    },
                    {
                        "c_code": "typedef unsigned int (*HashTableHashFunc)(HashTableKey value);",
                        "rust_code": "pub type HashTableHashFunc = i32;"
                    },
                    {
                        "c_code": "typedef int (*HashTableEqualFunc)(HashTableKey value1, HashTableKey value2);",
                        "rust_code": "pub type HashTableEqualFunc = i32;"
                    },
                    {
                        "c_code": "typedef void (*HashTableKeyFreeFunc)(HashTableKey value);",
                        "rust_code": "pub type HashTableKeyFreeFunc = i32;"
                    },
                    {
                        "c_code": "typedef void (*HashTableValueFreeFunc)(HashTableValue value);",
                        "rust_code": "pub type HashTableValueFreeFunc = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_HASH_TABLE_H",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define HASH_TABLE_NULL ((void *)0)",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "list_h.rs": {
                "name": "list_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::list_c::list_sort;",
                    "pub use crate::src::list_c::list_nth_data;",
                    "pub use crate::src::list_c::list_prepend;",
                    "pub use crate::src::list_c::list_iterate;",
                    "pub use crate::src::list_c::list_prev;",
                    "pub use crate::src::list_c::list_next;",
                    "pub use crate::src::list_c::list_iter_remove;",
                    "pub use crate::src::list_c::list_set_data;",
                    "pub use crate::src::list_c::list_remove_data;",
                    "pub use crate::src::list_c::_ListEntry;",
                    "pub use crate::src::list_c::list_length;",
                    "pub use crate::src::list_c::list_iter_next;",
                    "pub use crate::src::list_c::list_data;",
                    "pub use crate::src::list_c::list_find_data;",
                    "pub use crate::src::list_c::list_to_array;",
                    "pub use crate::src::list_c::list_free;",
                    "pub use crate::src::list_c::list_iter_has_more;",
                    "pub use crate::src::list_c::list_remove_entry;",
                    "pub use crate::src::list_c::list_nth_entry;",
                    "pub use crate::src::list_c::list_append;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef struct _ListEntry ListEntry;",
                        "rust_code": "pub type ListEntry = i32;"
                    },
                    {
                        "c_code": "typedef struct _ListIterator ListIterator;",
                        "rust_code": "pub type ListIterator = i32;"
                    },
                    {
                        "c_code": "typedef void *ListValue;",
                        "rust_code": "pub type ListValue = i32;"
                    },
                    {
                        "c_code": "struct _ListIterator\n    {\n        ListEntry **prev_next;\n        ListEntry *current;\n    };",
                        "rust_code": "pub type _ListIterator = i32;"
                    },
                    {
                        "c_code": "typedef int (*ListCompareFunc)(ListValue value1, ListValue value2);",
                        "rust_code": "pub type ListCompareFunc = i32;"
                    },
                    {
                        "c_code": "typedef int (*ListEqualFunc)(ListValue value1, ListValue value2);",
                        "rust_code": "pub type ListEqualFunc = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_LIST_H",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define LIST_NULL ((void *)0)",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "compare_int_c.rs": {
                "name": "compare_int_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::compare_int_h::*;"
                ],
                "definitions": [],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "int int_equal(void *vlocation1, void *vlocation2)\n{\n    int *location1;\n    int *location2;\n\n    location1 = (int *)vlocation1;\n    location2 = (int *)vlocation2;\n\n    return *location1 == *location2;\n}",
                        "rust_code": "pub fn int_equal() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int int_compare(void *vlocation1, void *vlocation2)\n{\n    int *location1;\n    int *location2;\n\n    location1 = (int *)vlocation1;\n    location2 = (int *)vlocation2;\n\n    if (*location1 < *location2)\n    {\n        return -1;\n    }\n    else if (*location1 > *location2)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}",
                        "rust_code": "pub fn int_compare() { unimplemented!(); }"
                    }
                ]
            },
            "rb_tree_h.rs": {
                "name": "rb_tree_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::rb_tree_c::rb_tree_lookup;",
                    "pub use crate::src::rb_tree_c::rb_tree_root_node;",
                    "pub use crate::src::rb_tree_c::_RBTreeNode;",
                    "pub use crate::src::rb_tree_c::rb_tree_insert;",
                    "pub use crate::src::rb_tree_c::rb_tree_node_parent;",
                    "pub use crate::src::rb_tree_c::rb_tree_num_entries;",
                    "pub use crate::src::rb_tree_c::rb_tree_node_child;",
                    "pub use crate::src::rb_tree_c::_RBTree;",
                    "pub use crate::src::rb_tree_c::rb_tree_new;",
                    "pub use crate::src::rb_tree_c::rb_tree_remove_node;",
                    "pub use crate::src::rb_tree_c::rb_tree_lookup_node;",
                    "pub use crate::src::rb_tree_c::rb_tree_node_value;",
                    "pub use crate::src::rb_tree_c::rb_tree_to_array;",
                    "pub use crate::src::rb_tree_c::rb_tree_remove;",
                    "pub use crate::src::rb_tree_c::rb_tree_free;",
                    "pub use crate::src::rb_tree_c::rb_tree_node_key;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef struct _RBTree RBTree;",
                        "rust_code": "pub type RBTree = i32;"
                    },
                    {
                        "c_code": "typedef void *RBTreeKey;",
                        "rust_code": "pub type RBTreeKey = i32;"
                    },
                    {
                        "c_code": "typedef void *RBTreeValue;",
                        "rust_code": "pub type RBTreeValue = i32;"
                    },
                    {
                        "c_code": "typedef struct _RBTreeNode RBTreeNode;",
                        "rust_code": "pub type RBTreeNode = i32;"
                    },
                    {
                        "c_code": "typedef int (*RBTreeCompareFunc)(RBTreeValue data1, RBTreeValue data2);",
                        "rust_code": "pub type RBTreeCompareFunc = i32;"
                    },
                    {
                        "c_code": "typedef enum\n    {\n        RB_TREE_NODE_RED,\n        RB_TREE_NODE_BLACK,\n    } RBTreeNodeColor;",
                        "rust_code": "pub type RBTreeNodeColor = i32;"
                    },
                    {
                        "c_code": "typedef enum\n    {\n        RB_TREE_NODE_LEFT = 0,\n        RB_TREE_NODE_RIGHT = 1\n    } RBTreeNodeSide;",
                        "rust_code": "pub type RBTreeNodeSide = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_RB_TREE_H",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define RB_TREE_NULL ((void *)0)",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "binary_heap_c.rs": {
                "name": "binary_heap_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::binary_heap_h::*;"
                ],
                "definitions": [
                    {
                        "c_code": "struct _BinaryHeap\n{\n    BinaryHeapType heap_type;\n    BinaryHeapValue *values;\n    unsigned int num_values;\n    unsigned int alloced_size;\n    BinaryHeapCompareFunc compare_func;\n};",
                        "rust_code": "pub type _BinaryHeap = i32;"
                    }
                ],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "static int binary_heap_cmp(BinaryHeap *heap, BinaryHeapValue data1, BinaryHeapValue data2)\n{\n    if (heap->heap_type == BINARY_HEAP_TYPE_MIN)\n    {\n        return heap->compare_func(data1, data2);\n    }\n    else\n    {\n        return -heap->compare_func(data1, data2);\n    }\n}",
                        "rust_code": "pub fn binary_heap_cmp() { unimplemented!(); }"
                    },
                    {
                        "c_code": "BinaryHeap *binary_heap_new(BinaryHeapType heap_type, BinaryHeapCompareFunc compare_func)\n{\n    BinaryHeap *heap;\n\n    heap = malloc(sizeof(BinaryHeap));\n\n    if (heap == NULL)\n    {\n        return NULL;\n    }\n\n    heap->heap_type = heap_type;\n    heap->num_values = 0;\n    heap->compare_func = compare_func;\n\n    heap->alloced_size = 16;\n    heap->values = malloc(sizeof(BinaryHeapValue) * heap->alloced_size);\n\n    if (heap->values == NULL)\n    {\n        free(heap);\n        return NULL;\n    }\n\n    return heap;\n}",
                        "rust_code": "pub fn binary_heap_new() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void binary_heap_free(BinaryHeap *heap)\n{\n    free(heap->values);\n    free(heap);\n}",
                        "rust_code": "pub fn binary_heap_free() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int binary_heap_insert(BinaryHeap *heap, BinaryHeapValue value)\n{\n    BinaryHeapValue *new_values;\n    unsigned int index;\n    unsigned int new_size;\n    unsigned int parent;\n\n    if (heap->num_values >= heap->alloced_size)\n    {\n\n        new_size = heap->alloced_size * 2;\n        new_values = realloc(heap->values, sizeof(BinaryHeapValue) * new_size);\n\n        if (new_values == NULL)\n        {\n            return 0;\n        }\n\n        heap->alloced_size = new_size;\n        heap->values = new_values;\n    }\n\n    index = heap->num_values;\n    ++heap->num_values;\n\n    while (index > 0)\n    {\n\n        parent = (index - 1) / 2;\n\n        if (binary_heap_cmp(heap, heap->values[parent], value) < 0)\n        {\n\n            break;\n        }\n        else\n        {\n\n            heap->values[index] = heap->values[parent];\n\n            index = parent;\n        }\n    }\n\n    heap->values[index] = value;\n\n    return 1;\n}",
                        "rust_code": "pub fn binary_heap_insert() { unimplemented!(); }"
                    },
                    {
                        "c_code": "BinaryHeapValue binary_heap_pop(BinaryHeap *heap)\n{\n    BinaryHeapValue result;\n    BinaryHeapValue new_value;\n    unsigned int index;\n    unsigned int next_index;\n    unsigned int child1, child2;\n\n    if (heap->num_values == 0)\n    {\n        return BINARY_HEAP_NULL;\n    }\n\n    result = heap->values[0];\n\n    new_value = heap->values[heap->num_values - 1];\n    --heap->num_values;\n\n    index = 0;\n\n    for (;;)\n    {\n\n        child1 = index * 2 + 1;\n        child2 = index * 2 + 2;\n\n        if (child1 < heap->num_values && binary_heap_cmp(heap, new_value, heap->values[child1]) > 0)\n        {\n\n            if (child2 < heap->num_values && binary_heap_cmp(heap, heap->values[child1], heap->values[child2]) > 0)\n            {\n                next_index = child2;\n            }\n            else\n            {\n                next_index = child1;\n            }\n        }\n        else if (child2 < heap->num_values && binary_heap_cmp(heap, new_value, heap->values[child2]) > 0)\n        {\n\n            next_index = child2;\n        }\n        else\n        {\n\n            heap->values[index] = new_value;\n            break;\n        }\n\n        heap->values[index] = heap->values[next_index];\n\n        index = next_index;\n    }\n\n    return result;\n}",
                        "rust_code": "pub fn binary_heap_pop() { unimplemented!(); }"
                    },
                    {
                        "c_code": "unsigned int binary_heap_num_entries(BinaryHeap *heap)\n{\n    return heap->num_values;\n}",
                        "rust_code": "pub fn binary_heap_num_entries() { unimplemented!(); }"
                    }
                ]
            },
            "binomial_heap_h.rs": {
                "name": "binomial_heap_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::binomial_heap_c::binomial_heap_insert;",
                    "pub use crate::src::binomial_heap_c::binomial_heap_num_entries;",
                    "pub use crate::src::binomial_heap_c::_BinomialHeap;",
                    "pub use crate::src::binomial_heap_c::binomial_heap_free;",
                    "pub use crate::src::binomial_heap_c::binomial_heap_pop;",
                    "pub use crate::src::binomial_heap_c::binomial_heap_new;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef enum\n    {\n\n        BINOMIAL_HEAP_TYPE_MIN,\n\n        BINOMIAL_HEAP_TYPE_MAX\n    } BinomialHeapType;",
                        "rust_code": "pub type BinomialHeapType = i32;"
                    },
                    {
                        "c_code": "typedef void *BinomialHeapValue;",
                        "rust_code": "pub type BinomialHeapValue = i32;"
                    },
                    {
                        "c_code": "typedef int (*BinomialHeapCompareFunc)(BinomialHeapValue value1, BinomialHeapValue value2);",
                        "rust_code": "pub type BinomialHeapCompareFunc = i32;"
                    },
                    {
                        "c_code": "typedef struct _BinomialHeap BinomialHeap;",
                        "rust_code": "pub type BinomialHeap = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_BINOMIAL_HEAP_H",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define BINOMIAL_HEAP_NULL ((void *)0)",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "sortedarray_h.rs": {
                "name": "sortedarray_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::sortedarray_c::sortedarray_remove_range;",
                    "pub use crate::src::sortedarray_c::sortedarray_clear;",
                    "pub use crate::src::sortedarray_c::sortedarray_remove;",
                    "pub use crate::src::sortedarray_c::sortedarray_index_of;",
                    "pub use crate::src::sortedarray_c::sortedarray_insert;",
                    "pub use crate::src::sortedarray_c::sortedarray_length;",
                    "pub use crate::src::sortedarray_c::_SortedArray;",
                    "pub use crate::src::sortedarray_c::sortedarray_free;",
                    "pub use crate::src::sortedarray_c::sortedarray_get;",
                    "pub use crate::src::sortedarray_c::sortedarray_new;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef void *SortedArrayValue;",
                        "rust_code": "pub type SortedArrayValue = i32;"
                    },
                    {
                        "c_code": "typedef struct _SortedArray SortedArray;",
                        "rust_code": "pub type SortedArray = i32;"
                    },
                    {
                        "c_code": "typedef int (*SortedArrayEqualFunc)(SortedArrayValue value1, SortedArrayValue value2);",
                        "rust_code": "pub type SortedArrayEqualFunc = i32;"
                    },
                    {
                        "c_code": "typedef int (*SortedArrayCompareFunc)(SortedArrayValue value1, SortedArrayValue value2);",
                        "rust_code": "pub type SortedArrayCompareFunc = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_SORTEDARRAY_H",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "queue_h.rs": {
                "name": "queue_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::queue_c::_Queue;",
                    "pub use crate::src::queue_c::queue_peek_tail;",
                    "pub use crate::src::queue_c::queue_pop_tail;",
                    "pub use crate::src::queue_c::queue_push_head;",
                    "pub use crate::src::queue_c::queue_push_tail;",
                    "pub use crate::src::queue_c::queue_new;",
                    "pub use crate::src::queue_c::queue_pop_head;",
                    "pub use crate::src::queue_c::queue_is_empty;",
                    "pub use crate::src::queue_c::queue_free;",
                    "pub use crate::src::queue_c::queue_peek_head;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef struct _Queue Queue;",
                        "rust_code": "pub type Queue = i32;"
                    },
                    {
                        "c_code": "typedef void *QueueValue;",
                        "rust_code": "pub type QueueValue = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_QUEUE_H",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define QUEUE_NULL ((void *)0)",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "hash_pointer_c.rs": {
                "name": "hash_pointer_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::hash_pointer_h::*;"
                ],
                "definitions": [],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "unsigned int pointer_hash(void *location)\n{\n    return (unsigned int)(unsigned long)location;\n}",
                        "rust_code": "pub fn pointer_hash() { unimplemented!(); }"
                    }
                ]
            },
            "trie_c.rs": {
                "name": "trie_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::trie_h::*;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef struct _TrieNode TrieNode;",
                        "rust_code": "pub type TrieNode = i32;"
                    },
                    {
                        "c_code": "struct _TrieNode\n{\n    TrieValue data;\n    unsigned int use_count;\n    TrieNode *next[256];\n};",
                        "rust_code": "pub type _TrieNode = i32;"
                    },
                    {
                        "c_code": "struct _Trie\n{\n    TrieNode *root_node;\n};",
                        "rust_code": "pub type _Trie = i32;"
                    }
                ],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "Trie *trie_new(void)\n{\n    Trie *new_trie;\n\n    new_trie = (Trie *)malloc(sizeof(Trie));\n\n    if (new_trie == NULL)\n    {\n        return NULL;\n    }\n\n    new_trie->root_node = NULL;\n\n    return new_trie;\n}",
                        "rust_code": "pub fn trie_new() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void trie_free_list_push(TrieNode **list, TrieNode *node)\n{\n    node->data = *list;\n    *list = node;\n}",
                        "rust_code": "pub fn trie_free_list_push() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static TrieNode *trie_free_list_pop(TrieNode **list)\n{\n    TrieNode *result;\n\n    result = *list;\n    *list = result->data;\n\n    return result;\n}",
                        "rust_code": "pub fn trie_free_list_pop() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void trie_free(Trie *trie)\n{\n    TrieNode *free_list;\n    TrieNode *node;\n    int i;\n\n    free_list = NULL;\n\n    if (trie->root_node != NULL)\n    {\n        trie_free_list_push(&free_list, trie->root_node);\n    }\n\n    while (free_list != NULL)\n    {\n        node = trie_free_list_pop(&free_list);\n\n        for (i = 0; i < 256; ++i)\n        {\n            if (node->next[i] != NULL)\n            {\n                trie_free_list_push(&free_list, node->next[i]);\n            }\n        }\n\n        free(node);\n    }\n\n    free(trie);\n}",
                        "rust_code": "pub fn trie_free() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static TrieNode *trie_find_end(Trie *trie, char *key)\n{\n    TrieNode *node;\n    char *p;\n\n    node = trie->root_node;\n\n    for (p = key; *p != '\\0'; ++p)\n    {\n\n        if (node == NULL)\n        {\n\n            return NULL;\n        }\n\n        node = node->next[(unsigned char)*p];\n    }\n\n    return node;\n}",
                        "rust_code": "pub fn trie_find_end() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static TrieNode *trie_find_end_binary(Trie *trie, unsigned char *key, int key_length)\n{\n    TrieNode *node;\n    int j;\n    int c;\n\n    node = trie->root_node;\n\n    for (j = 0; j < key_length; j++)\n    {\n\n        if (node == NULL)\n        {\n\n            return NULL;\n        }\n\n        c = (unsigned char)key[j];\n\n        node = node->next[c];\n    }\n\n    return node;\n}",
                        "rust_code": "pub fn trie_find_end_binary() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void trie_insert_rollback(Trie *trie, unsigned char *key)\n{\n    TrieNode *node;\n    TrieNode **prev_ptr;\n    TrieNode *next_node;\n    TrieNode **next_prev_ptr;\n    unsigned char *p;\n\n    node = trie->root_node;\n    prev_ptr = &trie->root_node;\n    p = key;\n\n    while (node != NULL)\n    {\n\n        next_prev_ptr = &node->next[(unsigned char)*p];\n        next_node = *next_prev_ptr;\n        ++p;\n\n        --node->use_count;\n\n        if (node->use_count == 0)\n        {\n            free(node);\n\n            if (prev_ptr != NULL)\n            {\n                *prev_ptr = NULL;\n            }\n\n            next_prev_ptr = NULL;\n        }\n\n        node = next_node;\n        prev_ptr = next_prev_ptr;\n    }\n}",
                        "rust_code": "pub fn trie_insert_rollback() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int trie_insert(Trie *trie, char *key, TrieValue value)\n{\n    TrieNode **rover;\n    TrieNode *node;\n    char *p;\n    int c;\n\n    if (value == TRIE_NULL)\n    {\n        return 0;\n    }\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = value;\n        return 1;\n    }\n\n    rover = &trie->root_node;\n    p = key;\n\n    for (;;)\n    {\n\n        node = *rover;\n\n        if (node == NULL)\n        {\n\n            node = (TrieNode *)calloc(1, sizeof(TrieNode));\n\n            if (node == NULL)\n            {\n\n                trie_insert_rollback(trie, (unsigned char *)key);\n\n                return 0;\n            }\n\n            node->data = TRIE_NULL;\n\n            *rover = node;\n        }\n\n        ++node->use_count;\n\n        c = (unsigned char)*p;\n\n        if (c == '\\0')\n        {\n\n            node->data = value;\n\n            break;\n        }\n\n        rover = &node->next[c];\n        ++p;\n    }\n\n    return 1;\n}",
                        "rust_code": "pub fn trie_insert() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int trie_insert_binary(Trie *trie, unsigned char *key, int key_length, TrieValue value)\n{\n    TrieNode **rover;\n    TrieNode *node;\n    int p, c;\n\n    if (value == TRIE_NULL)\n    {\n        return 0;\n    }\n\n    node = trie_find_end_binary(trie, key, key_length);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = value;\n        return 1;\n    }\n\n    rover = &trie->root_node;\n    p = 0;\n\n    for (;;)\n    {\n\n        node = *rover;\n\n        if (node == NULL)\n        {\n\n            node = (TrieNode *)calloc(1, sizeof(TrieNode));\n\n            if (node == NULL)\n            {\n\n                trie_insert_rollback(trie, key);\n\n                return 0;\n            }\n\n            node->data = TRIE_NULL;\n\n            *rover = node;\n        }\n\n        ++node->use_count;\n\n        c = (unsigned char)key[p];\n\n        if (p == key_length)\n        {\n\n            node->data = value;\n\n            break;\n        }\n\n        rover = &node->next[c];\n        ++p;\n    }\n\n    return 1;\n}",
                        "rust_code": "pub fn trie_insert_binary() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int trie_remove_binary(Trie *trie, unsigned char *key, int key_length)\n{\n    TrieNode *node;\n    TrieNode *next;\n    TrieNode **last_next_ptr;\n    int p, c;\n\n    node = trie_find_end_binary(trie, key, key_length);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = TRIE_NULL;\n    }\n    else\n    {\n        return 0;\n    }\n\n    node = trie->root_node;\n    last_next_ptr = &trie->root_node;\n    p = 0;\n\n    for (;;)\n    {\n\n        c = (unsigned char)key[p];\n        next = node->next[c];\n\n        --node->use_count;\n\n        if (node->use_count <= 0)\n        {\n            free(node);\n\n            if (last_next_ptr != NULL)\n            {\n                *last_next_ptr = NULL;\n                last_next_ptr = NULL;\n            }\n        }\n\n        if (p == key_length)\n        {\n            break;\n        }\n        else\n        {\n            ++p;\n        }\n\n        if (last_next_ptr != NULL)\n        {\n            last_next_ptr = &node->next[c];\n        }\n\n        node = next;\n    }\n\n    return 1;\n}",
                        "rust_code": "pub fn trie_remove_binary() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int trie_remove(Trie *trie, char *key)\n{\n    TrieNode *node;\n    TrieNode *next;\n    TrieNode **last_next_ptr;\n    char *p;\n    int c;\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL && node->data != TRIE_NULL)\n    {\n        node->data = TRIE_NULL;\n    }\n    else\n    {\n        return 0;\n    }\n\n    node = trie->root_node;\n    last_next_ptr = &trie->root_node;\n    p = key;\n\n    for (;;)\n    {\n\n        c = (unsigned char)*p;\n        next = node->next[c];\n\n        --node->use_count;\n\n        if (node->use_count <= 0)\n        {\n            free(node);\n\n            if (last_next_ptr != NULL)\n            {\n                *last_next_ptr = NULL;\n                last_next_ptr = NULL;\n            }\n        }\n\n        if (c == '\\0')\n        {\n            break;\n        }\n        else\n        {\n            ++p;\n        }\n\n        if (last_next_ptr != NULL)\n        {\n            last_next_ptr = &node->next[c];\n        }\n\n        node = next;\n    }\n\n    return 1;\n}",
                        "rust_code": "pub fn trie_remove() { unimplemented!(); }"
                    },
                    {
                        "c_code": "TrieValue trie_lookup(Trie *trie, char *key)\n{\n    TrieNode *node;\n\n    node = trie_find_end(trie, key);\n\n    if (node != NULL)\n    {\n        return node->data;\n    }\n    else\n    {\n        return TRIE_NULL;\n    }\n}",
                        "rust_code": "pub fn trie_lookup() { unimplemented!(); }"
                    },
                    {
                        "c_code": "TrieValue trie_lookup_binary(Trie *trie, unsigned char *key, int key_length)\n{\n    TrieNode *node;\n\n    node = trie_find_end_binary(trie, key, key_length);\n\n    if (node != NULL)\n    {\n        return node->data;\n    }\n    else\n    {\n        return TRIE_NULL;\n    }\n}",
                        "rust_code": "pub fn trie_lookup_binary() { unimplemented!(); }"
                    },
                    {
                        "c_code": "unsigned int trie_num_entries(Trie *trie)\n{\n\n    if (trie->root_node == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        return trie->root_node->use_count;\n    }\n}",
                        "rust_code": "pub fn trie_num_entries() { unimplemented!(); }"
                    }
                ]
            },
            "arraylist_c.rs": {
                "name": "arraylist_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::arraylist_h::*;"
                ],
                "definitions": [],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "ArrayList *arraylist_new(unsigned int length)\n{\n    ArrayList *new_arraylist;\n\n    if (length <= 0)\n    {\n        length = 16;\n    }\n\n    new_arraylist = (ArrayList *)malloc(sizeof(ArrayList));\n\n    if (new_arraylist == NULL)\n    {\n        return NULL;\n    }\n\n    new_arraylist->_alloced = length;\n    new_arraylist->length = 0;\n\n    new_arraylist->data = malloc(length * sizeof(ArrayListValue));\n\n    if (new_arraylist->data == NULL)\n    {\n        free(new_arraylist);\n        return NULL;\n    }\n\n    return new_arraylist;\n}",
                        "rust_code": "pub fn arraylist_new() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void arraylist_free(ArrayList *arraylist)\n{\n\n    if (arraylist != NULL)\n    {\n        free(arraylist->data);\n        free(arraylist);\n    }\n}",
                        "rust_code": "pub fn arraylist_free() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static int arraylist_enlarge(ArrayList *arraylist)\n{\n    ArrayListValue *data;\n    unsigned int newsize;\n\n    newsize = arraylist->_alloced * 2;\n\n    data = realloc(arraylist->data, sizeof(ArrayListValue) * newsize);\n\n    if (data == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        arraylist->data = data;\n        arraylist->_alloced = newsize;\n\n        return 1;\n    }\n}",
                        "rust_code": "pub fn arraylist_enlarge() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int arraylist_insert(ArrayList *arraylist, unsigned int index, ArrayListValue data)\n{\n\n    if (index > arraylist->length)\n    {\n        return 0;\n    }\n\n    if (arraylist->length + 1 > arraylist->_alloced)\n    {\n        if (!arraylist_enlarge(arraylist))\n        {\n            return 0;\n        }\n    }\n\n    memmove(&arraylist->data[index + 1], &arraylist->data[index], (arraylist->length - index) * sizeof(ArrayListValue));\n\n    arraylist->data[index] = data;\n    ++arraylist->length;\n\n    return 1;\n}",
                        "rust_code": "pub fn arraylist_insert() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int arraylist_append(ArrayList *arraylist, ArrayListValue data)\n{\n    return arraylist_insert(arraylist, arraylist->length, data);\n}",
                        "rust_code": "pub fn arraylist_append() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int arraylist_prepend(ArrayList *arraylist, ArrayListValue data)\n{\n    return arraylist_insert(arraylist, 0, data);\n}",
                        "rust_code": "pub fn arraylist_prepend() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void arraylist_remove_range(ArrayList *arraylist, unsigned int index, unsigned int length)\n{\n\n    if (index > arraylist->length || index + length > arraylist->length)\n    {\n        return;\n    }\n\n    memmove(&arraylist->data[index], &arraylist->data[index + length],\n            (arraylist->length - (index + length)) * sizeof(ArrayListValue));\n\n    arraylist->length -= length;\n}",
                        "rust_code": "pub fn arraylist_remove_range() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void arraylist_remove(ArrayList *arraylist, unsigned int index)\n{\n    arraylist_remove_range(arraylist, index, 1);\n}",
                        "rust_code": "pub fn arraylist_remove() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int arraylist_index_of(ArrayList *arraylist, ArrayListEqualFunc callback, ArrayListValue data)\n{\n    unsigned int i;\n\n    for (i = 0; i < arraylist->length; ++i)\n    {\n        if (callback(arraylist->data[i], data) != 0)\n            return (int)i;\n    }\n\n    return -1;\n}",
                        "rust_code": "pub fn arraylist_index_of() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void arraylist_clear(ArrayList *arraylist)\n{\n\n    arraylist->length = 0;\n}",
                        "rust_code": "pub fn arraylist_clear() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void arraylist_sort_internal(ArrayListValue *list_data, unsigned int list_length,\n                                    ArrayListCompareFunc compare_func)\n{\n    ArrayListValue pivot;\n    ArrayListValue tmp;\n    unsigned int i;\n    unsigned int list1_length;\n    unsigned int list2_length;\n\n    if (list_length <= 1)\n    {\n        return;\n    }\n\n    pivot = list_data[list_length - 1];\n# 221 \".tmp/tmp_files/src/arraylist.c\"\n    list1_length = 0;\n\n    for (i = 0; i < list_length - 1; ++i)\n    {\n\n        if (compare_func(list_data[i], pivot) < 0)\n        {\n\n            tmp = list_data[i];\n            list_data[i] = list_data[list1_length];\n            list_data[list1_length] = tmp;\n\n            ++list1_length;\n        }\n        else\n        {\n        }\n    }\n\n    list2_length = list_length - list1_length - 1;\n# 255 \".tmp/tmp_files/src/arraylist.c\"\n    list_data[list_length - 1] = list_data[list1_length];\n    list_data[list1_length] = pivot;\n\n    arraylist_sort_internal(list_data, list1_length, compare_func);\n\n    arraylist_sort_internal(&list_data[list1_length + 1], list2_length, compare_func);\n}",
                        "rust_code": "pub fn arraylist_sort_internal() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void arraylist_sort(ArrayList *arraylist, ArrayListCompareFunc compare_func)\n{\n\n    arraylist_sort_internal(arraylist->data, arraylist->length, compare_func);\n}",
                        "rust_code": "pub fn arraylist_sort() { unimplemented!(); }"
                    }
                ]
            },
            "compare_string_h.rs": {
                "name": "compare_string_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::compare_string_c::string_equal;",
                    "pub use crate::src::compare_string_c::string_nocase_compare;",
                    "pub use crate::src::compare_string_c::string_nocase_equal;",
                    "pub use crate::src::compare_string_c::string_compare;"
                ],
                "definitions": [],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_COMPARE_STRING_H",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "set_h.rs": {
                "name": "set_h.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::set_c::set_remove;",
                    "pub use crate::src::set_c::set_intersection;",
                    "pub use crate::src::set_c::set_free;",
                    "pub use crate::src::set_c::set_insert;",
                    "pub use crate::src::set_c::set_iter_next;",
                    "pub use crate::src::set_c::set_to_array;",
                    "pub use crate::src::set_c::set_new;",
                    "pub use crate::src::set_c::set_iter_has_more;",
                    "pub use crate::src::set_c::_SetEntry;",
                    "pub use crate::src::set_c::set_union;",
                    "pub use crate::src::set_c::set_iterate;",
                    "pub use crate::src::set_c::set_register_free_function;",
                    "pub use crate::src::set_c::set_num_entries;",
                    "pub use crate::src::set_c::_Set;",
                    "pub use crate::src::set_c::set_query;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef struct _Set Set;",
                        "rust_code": "pub type Set = i32;"
                    },
                    {
                        "c_code": "typedef struct _SetIterator SetIterator;",
                        "rust_code": "pub type SetIterator = i32;"
                    },
                    {
                        "c_code": "typedef struct _SetEntry SetEntry;",
                        "rust_code": "pub type SetEntry = i32;"
                    },
                    {
                        "c_code": "typedef void *SetValue;",
                        "rust_code": "pub type SetValue = i32;"
                    },
                    {
                        "c_code": "struct _SetIterator\n    {\n        Set *set;\n        SetEntry *next_entry;\n        unsigned int next_chain;\n    };",
                        "rust_code": "pub type _SetIterator = i32;"
                    },
                    {
                        "c_code": "typedef unsigned int (*SetHashFunc)(SetValue value);",
                        "rust_code": "pub type SetHashFunc = i32;"
                    },
                    {
                        "c_code": "typedef int (*SetEqualFunc)(SetValue value1, SetValue value2);",
                        "rust_code": "pub type SetEqualFunc = i32;"
                    },
                    {
                        "c_code": "typedef void (*SetFreeFunc)(SetValue value);",
                        "rust_code": "pub type SetFreeFunc = i32;"
                    }
                ],
                "macros": [
                    {
                        "c_code": "#define ALGORITHM_SET_H",
                        "rust_code": ""
                    },
                    {
                        "c_code": "#define SET_NULL ((void *)0)",
                        "rust_code": ""
                    }
                ],
                "macro_functions": [],
                "functions": []
            },
            "binomial_heap_c.rs": {
                "name": "binomial_heap_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::binomial_heap_h::*;"
                ],
                "definitions": [
                    {
                        "c_code": "typedef struct _BinomialTree BinomialTree;",
                        "rust_code": "pub type BinomialTree = i32;"
                    },
                    {
                        "c_code": "struct _BinomialTree\n{\n    BinomialHeapValue value;\n    unsigned short order;\n    unsigned short refcount;\n    BinomialTree **subtrees;\n};",
                        "rust_code": "pub type _BinomialTree = i32;"
                    },
                    {
                        "c_code": "struct _BinomialHeap\n{\n    BinomialHeapType heap_type;\n    BinomialHeapCompareFunc compare_func;\n    unsigned int num_values;\n    BinomialTree **roots;\n    unsigned int roots_length;\n};",
                        "rust_code": "pub type _BinomialHeap = i32;"
                    }
                ],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "static int binomial_heap_cmp(BinomialHeap *heap, BinomialHeapValue data1, BinomialHeapValue data2)\n{\n    if (heap->heap_type == BINOMIAL_HEAP_TYPE_MIN)\n    {\n        return heap->compare_func(data1, data2);\n    }\n    else\n    {\n        return -(heap->compare_func(data1, data2));\n    }\n}",
                        "rust_code": "pub fn binomial_heap_cmp() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void binomial_tree_ref(BinomialTree *tree)\n{\n    if (tree != NULL)\n    {\n        ++tree->refcount;\n    }\n}",
                        "rust_code": "pub fn binomial_tree_ref() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void binomial_tree_unref(BinomialTree *tree)\n{\n    int i;\n\n    if (tree == NULL)\n    {\n        return;\n    }\n\n    --tree->refcount;\n\n    if (tree->refcount == 0)\n    {\n\n        for (i = 0; i < tree->order; ++i)\n        {\n            binomial_tree_unref(tree->subtrees[i]);\n        }\n\n        free(tree->subtrees);\n        free(tree);\n    }\n}",
                        "rust_code": "pub fn binomial_tree_unref() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static BinomialTree *binomial_tree_merge(BinomialHeap *heap, BinomialTree *tree1, BinomialTree *tree2)\n{\n    BinomialTree *new_tree;\n    BinomialTree *tmp;\n    int i;\n\n    if (binomial_heap_cmp(heap, tree1->value, tree2->value) > 0)\n    {\n\n        tmp = tree1;\n        tree1 = tree2;\n        tree2 = tmp;\n    }\n\n    new_tree = malloc(sizeof(BinomialTree));\n\n    if (new_tree == NULL)\n    {\n        return NULL;\n    }\n\n    new_tree->refcount = 0;\n    new_tree->order = (unsigned short)(tree1->order + 1);\n\n    new_tree->value = tree1->value;\n\n    new_tree->subtrees = malloc(sizeof(BinomialTree *) * new_tree->order);\n\n    if (new_tree->subtrees == NULL)\n    {\n        free(new_tree);\n        return NULL;\n    }\n\n    memcpy(new_tree->subtrees, tree1->subtrees, sizeof(BinomialTree *) * tree1->order);\n    new_tree->subtrees[new_tree->order - 1] = tree2;\n\n    for (i = 0; i < new_tree->order; ++i)\n    {\n        binomial_tree_ref(new_tree->subtrees[i]);\n    }\n\n    return new_tree;\n}",
                        "rust_code": "pub fn binomial_tree_merge() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void binomial_heap_merge_undo(BinomialTree **new_roots, unsigned int count)\n{\n    unsigned int i;\n\n    for (i = 0; i <= count; ++i)\n    {\n        binomial_tree_unref(new_roots[i]);\n    }\n\n    free(new_roots);\n}",
                        "rust_code": "pub fn binomial_heap_merge_undo() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static int binomial_heap_merge(BinomialHeap *heap, BinomialHeap *other)\n{\n    BinomialTree **new_roots;\n    unsigned int new_roots_length;\n    BinomialTree *vals[3];\n    int num_vals;\n    BinomialTree *carry;\n    BinomialTree *new_carry;\n    unsigned int max;\n    unsigned int i;\n\n    if (heap->roots_length > other->roots_length)\n    {\n        max = heap->roots_length + 1;\n    }\n    else\n    {\n        max = other->roots_length + 1;\n    }\n\n    new_roots = malloc(sizeof(BinomialTree *) * max);\n\n    if (new_roots == NULL)\n    {\n        return 0;\n    }\n\n    new_roots_length = 0;\n    carry = NULL;\n\n    for (i = 0; i < max; ++i)\n    {\n\n        num_vals = 0;\n\n        if (i < heap->roots_length && heap->roots[i] != NULL)\n        {\n            vals[num_vals] = heap->roots[i];\n            ++num_vals;\n        }\n\n        if (i < other->roots_length && other->roots[i] != NULL)\n        {\n            vals[num_vals] = other->roots[i];\n            ++num_vals;\n        }\n\n        if (carry != NULL)\n        {\n            vals[num_vals] = carry;\n            ++num_vals;\n        }\n\n        if ((num_vals & 1) != 0)\n        {\n\n            new_roots[i] = vals[num_vals - 1];\n            binomial_tree_ref(new_roots[i]);\n            new_roots_length = i + 1;\n        }\n        else\n        {\n\n            new_roots[i] = NULL;\n        }\n\n        if ((num_vals & 2) != 0)\n        {\n\n            new_carry = binomial_tree_merge(heap, vals[0], vals[1]);\n\n            if (new_carry == NULL)\n            {\n\n                binomial_heap_merge_undo(new_roots, i);\n\n                binomial_tree_unref(carry);\n\n                return 0;\n            }\n        }\n        else\n        {\n\n            new_carry = NULL;\n        }\n\n        binomial_tree_unref(carry);\n\n        carry = new_carry;\n\n        binomial_tree_ref(carry);\n    }\n\n    for (i = 0; i < heap->roots_length; ++i)\n    {\n        if (heap->roots[i] != NULL)\n        {\n            binomial_tree_unref(heap->roots[i]);\n        }\n    }\n\n    free(heap->roots);\n    heap->roots = new_roots;\n    heap->roots_length = new_roots_length;\n\n    return 1;\n}",
                        "rust_code": "pub fn binomial_heap_merge() { unimplemented!(); }"
                    },
                    {
                        "c_code": "BinomialHeap *binomial_heap_new(BinomialHeapType heap_type, BinomialHeapCompareFunc compare_func)\n{\n    BinomialHeap *new_heap;\n\n    new_heap = calloc(1, sizeof(BinomialHeap));\n\n    if (new_heap == NULL)\n    {\n        return NULL;\n    }\n\n    new_heap->heap_type = heap_type;\n    new_heap->compare_func = compare_func;\n\n    return new_heap;\n}",
                        "rust_code": "pub fn binomial_heap_new() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void binomial_heap_free(BinomialHeap *heap)\n{\n    unsigned int i;\n\n    for (i = 0; i < heap->roots_length; ++i)\n    {\n        binomial_tree_unref(heap->roots[i]);\n    }\n\n    free(heap->roots);\n    free(heap);\n}",
                        "rust_code": "pub fn binomial_heap_free() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int binomial_heap_insert(BinomialHeap *heap, BinomialHeapValue value)\n{\n    BinomialHeap fake_heap;\n    BinomialTree *new_tree;\n    int result;\n\n    new_tree = malloc(sizeof(BinomialTree));\n\n    if (new_tree == NULL)\n    {\n        return 0;\n    }\n\n    new_tree->value = value;\n    new_tree->order = 0;\n    new_tree->refcount = 1;\n    new_tree->subtrees = NULL;\n\n    fake_heap.heap_type = heap->heap_type;\n    fake_heap.compare_func = heap->compare_func;\n    fake_heap.num_values = 1;\n    fake_heap.roots = &new_tree;\n    fake_heap.roots_length = 1;\n\n    result = binomial_heap_merge(heap, &fake_heap);\n\n    if (result != 0)\n    {\n        ++heap->num_values;\n    }\n\n    binomial_tree_unref(new_tree);\n\n    return result;\n}",
                        "rust_code": "pub fn binomial_heap_insert() { unimplemented!(); }"
                    },
                    {
                        "c_code": "BinomialHeapValue binomial_heap_pop(BinomialHeap *heap)\n{\n    BinomialTree *least_tree;\n    BinomialHeap fake_heap;\n    BinomialHeapValue result;\n    unsigned int i;\n    unsigned int least_index;\n\n    if (heap->num_values == 0)\n    {\n        return BINOMIAL_HEAP_NULL;\n    }\n\n    least_index = UINT_MAX;\n\n    for (i = 0; i < heap->roots_length; ++i)\n    {\n\n        if (heap->roots[i] == NULL)\n        {\n            continue;\n        }\n\n        if (least_index == UINT_MAX ||\n            binomial_heap_cmp(heap, heap->roots[i]->value, heap->roots[least_index]->value) < 0)\n        {\n            least_index = i;\n        }\n    }\n\n    least_tree = heap->roots[least_index];\n    heap->roots[least_index] = NULL;\n\n    fake_heap.heap_type = heap->heap_type;\n    fake_heap.compare_func = heap->compare_func;\n    fake_heap.roots = least_tree->subtrees;\n    fake_heap.roots_length = least_tree->order;\n\n    if (binomial_heap_merge(heap, &fake_heap))\n    {\n\n        result = least_tree->value;\n        binomial_tree_unref(least_tree);\n\n        --heap->num_values;\n\n        return result;\n    }\n    else\n    {\n\n        heap->roots[least_index] = least_tree;\n\n        return BINOMIAL_HEAP_NULL;\n    }\n}",
                        "rust_code": "pub fn binomial_heap_pop() { unimplemented!(); }"
                    },
                    {
                        "c_code": "unsigned int binomial_heap_num_entries(BinomialHeap *heap)\n{\n    return heap->num_values;\n}",
                        "rust_code": "pub fn binomial_heap_num_entries() { unimplemented!(); }"
                    }
                ]
            },
            "slist_c.rs": {
                "name": "slist_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::slist_h::*;"
                ],
                "definitions": [
                    {
                        "c_code": "struct _SListEntry\n{\n    SListValue data;\n    SListEntry *next;\n};",
                        "rust_code": "pub type _SListEntry = i32;"
                    }
                ],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "void slist_free(SListEntry *list)\n{\n    SListEntry *entry;\n\n    entry = list;\n\n    while (entry != NULL)\n    {\n        SListEntry *next;\n\n        next = entry->next;\n\n        free(entry);\n\n        entry = next;\n    }\n}",
                        "rust_code": "pub fn slist_free() { unimplemented!(); }"
                    },
                    {
                        "c_code": "SListEntry *slist_prepend(SListEntry **list, SListValue data)\n{\n    SListEntry *newentry;\n\n    newentry = malloc(sizeof(SListEntry));\n\n    if (newentry == NULL)\n    {\n        return NULL;\n    }\n\n    newentry->data = data;\n\n    newentry->next = *list;\n    *list = newentry;\n\n    return newentry;\n}",
                        "rust_code": "pub fn slist_prepend() { unimplemented!(); }"
                    },
                    {
                        "c_code": "SListEntry *slist_append(SListEntry **list, SListValue data)\n{\n    SListEntry *rover;\n    SListEntry *newentry;\n\n    newentry = malloc(sizeof(SListEntry));\n\n    if (newentry == NULL)\n    {\n        return NULL;\n    }\n\n    newentry->data = data;\n    newentry->next = NULL;\n\n    if (*list == NULL)\n    {\n\n        *list = newentry;\n    }\n    else\n    {\n\n        for (rover = *list; rover->next != NULL; rover = rover->next)\n            ;\n\n        rover->next = newentry;\n    }\n\n    return newentry;\n}",
                        "rust_code": "pub fn slist_append() { unimplemented!(); }"
                    },
                    {
                        "c_code": "SListValue slist_data(SListEntry *listentry)\n{\n    return listentry->data;\n}",
                        "rust_code": "pub fn slist_data() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void slist_set_data(SListEntry *listentry, SListValue data)\n{\n    if (listentry != NULL)\n    {\n        listentry->data = data;\n    }\n}",
                        "rust_code": "pub fn slist_set_data() { unimplemented!(); }"
                    },
                    {
                        "c_code": "SListEntry *slist_next(SListEntry *listentry)\n{\n    return listentry->next;\n}",
                        "rust_code": "pub fn slist_next() { unimplemented!(); }"
                    },
                    {
                        "c_code": "SListEntry *slist_nth_entry(SListEntry *list, unsigned int n)\n{\n    SListEntry *entry;\n    unsigned int i;\n\n    entry = list;\n\n    for (i = 0; i < n; ++i)\n    {\n\n        if (entry == NULL)\n        {\n            return NULL;\n        }\n        entry = entry->next;\n    }\n\n    return entry;\n}",
                        "rust_code": "pub fn slist_nth_entry() { unimplemented!(); }"
                    },
                    {
                        "c_code": "SListValue slist_nth_data(SListEntry *list, unsigned int n)\n{\n    SListEntry *entry;\n\n    entry = slist_nth_entry(list, n);\n\n    if (entry == NULL)\n    {\n        return SLIST_NULL;\n    }\n    else\n    {\n        return entry->data;\n    }\n}",
                        "rust_code": "pub fn slist_nth_data() { unimplemented!(); }"
                    },
                    {
                        "c_code": "unsigned int slist_length(SListEntry *list)\n{\n    SListEntry *entry;\n    unsigned int length;\n\n    length = 0;\n    entry = list;\n\n    while (entry != NULL)\n    {\n\n        ++length;\n\n        entry = entry->next;\n    }\n\n    return length;\n}",
                        "rust_code": "pub fn slist_length() { unimplemented!(); }"
                    },
                    {
                        "c_code": "SListValue *slist_to_array(SListEntry *list)\n{\n    SListEntry *rover;\n    SListValue *array;\n    unsigned int length;\n    unsigned int i;\n\n    length = slist_length(list);\n\n    array = malloc(sizeof(SListValue) * length);\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    rover = list;\n\n    for (i = 0; i < length; ++i)\n    {\n\n        array[i] = rover->data;\n\n        rover = rover->next;\n    }\n\n    return array;\n}",
                        "rust_code": "pub fn slist_to_array() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int slist_remove_entry(SListEntry **list, SListEntry *entry)\n{\n    SListEntry *rover;\n\n    if (*list == NULL || entry == NULL)\n    {\n        return 0;\n    }\n\n    if (*list == entry)\n    {\n\n        *list = entry->next;\n    }\n    else\n    {\n\n        rover = *list;\n\n        while (rover != NULL && rover->next != entry)\n        {\n            rover = rover->next;\n        }\n\n        if (rover == NULL)\n        {\n\n            return 0;\n        }\n        else\n        {\n\n            rover->next = entry->next;\n        }\n    }\n\n    free(entry);\n\n    return 1;\n}",
                        "rust_code": "pub fn slist_remove_entry() { unimplemented!(); }"
                    },
                    {
                        "c_code": "unsigned int slist_remove_data(SListEntry **list, SListEqualFunc callback, SListValue data)\n{\n    SListEntry **rover;\n    SListEntry *next;\n    unsigned int entries_removed;\n\n    entries_removed = 0;\n\n    rover = list;\n\n    while (*rover != NULL)\n    {\n\n        if (callback((*rover)->data, data) != 0)\n        {\n\n            next = (*rover)->next;\n            free(*rover);\n            *rover = next;\n\n            ++entries_removed;\n        }\n        else\n        {\n\n            rover = &((*rover)->next);\n        }\n    }\n\n    return entries_removed;\n}",
                        "rust_code": "pub fn slist_remove_data() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static SListEntry *slist_sort_internal(SListEntry **list, SListCompareFunc compare_func)\n{\n    SListEntry *pivot;\n    SListEntry *rover;\n    SListEntry *less_list, *more_list;\n    SListEntry *less_list_end, *more_list_end;\n\n    if (*list == NULL || (*list)->next == NULL)\n    {\n        return *list;\n    }\n\n    pivot = *list;\n\n    less_list = NULL;\n    more_list = NULL;\n    rover = (*list)->next;\n\n    while (rover != NULL)\n    {\n        SListEntry *next = rover->next;\n\n        if (compare_func(rover->data, pivot->data) < 0)\n        {\n\n            rover->next = less_list;\n            less_list = rover;\n        }\n        else\n        {\n\n            rover->next = more_list;\n            more_list = rover;\n        }\n\n        rover = next;\n    }\n\n    less_list_end = slist_sort_internal(&less_list, compare_func);\n    more_list_end = slist_sort_internal(&more_list, compare_func);\n\n    *list = less_list;\n\n    if (less_list == NULL)\n    {\n        *list = pivot;\n    }\n    else\n    {\n        less_list_end->next = pivot;\n    }\n\n    pivot->next = more_list;\n\n    if (more_list == NULL)\n    {\n        return pivot;\n    }\n    else\n    {\n        return more_list_end;\n    }\n}",
                        "rust_code": "pub fn slist_sort_internal() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void slist_sort(SListEntry **list, SListCompareFunc compare_func)\n{\n    slist_sort_internal(list, compare_func);\n}",
                        "rust_code": "pub fn slist_sort() { unimplemented!(); }"
                    },
                    {
                        "c_code": "SListEntry *slist_find_data(SListEntry *list, SListEqualFunc callback, SListValue data)\n{\n    SListEntry *rover;\n\n    for (rover = list; rover != NULL; rover = rover->next)\n    {\n        if (callback(rover->data, data) != 0)\n        {\n            return rover;\n        }\n    }\n\n    return NULL;\n}",
                        "rust_code": "pub fn slist_find_data() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void slist_iterate(SListEntry **list, SListIterator *iter)\n{\n\n    iter->prev_next = list;\n\n    iter->current = NULL;\n}",
                        "rust_code": "pub fn slist_iterate() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int slist_iter_has_more(SListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n\n        return *iter->prev_next != NULL;\n    }\n    else\n    {\n\n        return iter->current->next != NULL;\n    }\n}",
                        "rust_code": "pub fn slist_iter_has_more() { unimplemented!(); }"
                    },
                    {
                        "c_code": "SListValue slist_iter_next(SListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n\n        iter->current = *iter->prev_next;\n    }\n    else\n    {\n\n        iter->prev_next = &iter->current->next;\n        iter->current = iter->current->next;\n    }\n\n    if (iter->current == NULL)\n    {\n        return SLIST_NULL;\n    }\n    else\n    {\n        return iter->current->data;\n    }\n}",
                        "rust_code": "pub fn slist_iter_next() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void slist_iter_remove(SListIterator *iter)\n{\n    if (iter->current == NULL || iter->current != *iter->prev_next)\n    {\n    }\n    else\n    {\n\n        *iter->prev_next = iter->current->next;\n        free(iter->current);\n        iter->current = NULL;\n    }\n}",
                        "rust_code": "pub fn slist_iter_remove() { unimplemented!(); }"
                    }
                ]
            },
            "hash_string_c.rs": {
                "name": "hash_string_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::hash_string_h::*;"
                ],
                "definitions": [],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "unsigned int string_hash(void *string)\n{\n\n    unsigned int result = 5381;\n    unsigned char *p;\n\n    p = (unsigned char *)string;\n\n    while (*p != '\\0')\n    {\n        result = (result << 5) + result + *p;\n        ++p;\n    }\n\n    return result;\n}",
                        "rust_code": "pub fn string_hash() { unimplemented!(); }"
                    },
                    {
                        "c_code": "unsigned int string_nocase_hash(void *string)\n{\n    unsigned int result = 5381;\n    unsigned char *p;\n\n    p = (unsigned char *)string;\n\n    while (*p != '\\0')\n    {\n        result = (result << 5) + result + (unsigned int)tolower(*p);\n        ++p;\n    }\n\n    return result;\n}",
                        "rust_code": "pub fn string_nocase_hash() { unimplemented!(); }"
                    }
                ]
            },
            "rb_tree_c.rs": {
                "name": "rb_tree_c.rs",
                "type": "file",
                "declarations": [
                    "use crate::translation_utils::*;",
                    "pub use crate::src::rb_tree_h::*;"
                ],
                "definitions": [
                    {
                        "c_code": "struct _RBTreeNode\n{\n    RBTreeNodeColor color;\n    RBTreeKey key;\n    RBTreeValue value;\n    RBTreeNode *parent;\n    RBTreeNode *children[2];\n};",
                        "rust_code": "pub type _RBTreeNode = i32;"
                    },
                    {
                        "c_code": "struct _RBTree\n{\n    RBTreeNode *root_node;\n    RBTreeCompareFunc compare_func;\n    int num_nodes;\n};",
                        "rust_code": "pub type _RBTree = i32;"
                    }
                ],
                "macros": [],
                "macro_functions": [],
                "functions": [
                    {
                        "c_code": "static RBTreeNodeSide rb_tree_node_side(RBTreeNode *node)\n{\n    if (node->parent->children[RB_TREE_NODE_LEFT] == node)\n    {\n        return RB_TREE_NODE_LEFT;\n    }\n    else\n    {\n        return RB_TREE_NODE_RIGHT;\n    }\n}",
                        "rust_code": "pub fn rb_tree_node_side() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static RBTreeNode *rb_tree_node_sibling(RBTreeNode *node)\n{\n    RBTreeNodeSide side;\n\n    side = rb_tree_node_side(node);\n\n    return node->parent->children[1 - side];\n}",
                        "rust_code": "pub fn rb_tree_node_sibling() { unimplemented!(); }"
                    },
                    {
                        "c_code": "RBTreeNode *rb_tree_node_uncle(RBTreeNode *node)\n{\n    return rb_tree_node_sibling(node->parent);\n}",
                        "rust_code": "pub fn rb_tree_node_uncle() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void rb_tree_node_replace(RBTree *tree, RBTreeNode *node1, RBTreeNode *node2)\n{\n    int side;\n\n    if (node2 != NULL)\n    {\n        node2->parent = node1->parent;\n    }\n\n    if (node1->parent == NULL)\n    {\n        tree->root_node = node2;\n    }\n    else\n    {\n        side = rb_tree_node_side(node1);\n        node1->parent->children[side] = node2;\n    }\n}",
                        "rust_code": "pub fn rb_tree_node_replace() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static RBTreeNode *rb_tree_rotate(RBTree *tree, RBTreeNode *node, RBTreeNodeSide direction)\n{\n    RBTreeNode *new_root;\n\n    new_root = node->children[1 - direction];\n\n    rb_tree_node_replace(tree, node, new_root);\n\n    node->children[1 - direction] = new_root->children[direction];\n    new_root->children[direction] = node;\n\n    node->parent = new_root;\n\n    if (node->children[1 - direction] != NULL)\n    {\n        node->children[1 - direction]->parent = node;\n    }\n\n    return new_root;\n}",
                        "rust_code": "pub fn rb_tree_rotate() { unimplemented!(); }"
                    },
                    {
                        "c_code": "RBTree *rb_tree_new(RBTreeCompareFunc compare_func)\n{\n    RBTree *new_tree;\n\n    new_tree = malloc(sizeof(RBTree));\n\n    if (new_tree == NULL)\n    {\n        return NULL;\n    }\n\n    new_tree->root_node = NULL;\n    new_tree->num_nodes = 0;\n    new_tree->compare_func = compare_func;\n\n    return new_tree;\n}",
                        "rust_code": "pub fn rb_tree_new() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void rb_tree_free_subtree(RBTreeNode *node)\n{\n    if (node != NULL)\n    {\n\n        rb_tree_free_subtree(node->children[RB_TREE_NODE_LEFT]);\n        rb_tree_free_subtree(node->children[RB_TREE_NODE_RIGHT]);\n\n        free(node);\n    }\n}",
                        "rust_code": "pub fn rb_tree_free_subtree() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void rb_tree_free(RBTree *tree)\n{\n\n    rb_tree_free_subtree(tree->root_node);\n\n    free(tree);\n}",
                        "rust_code": "pub fn rb_tree_free() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void rb_tree_insert_case1(RBTree *tree, RBTreeNode *node)\n{\n    if (node->parent == NULL)\n    {\n\n        node->color = RB_TREE_NODE_BLACK;\n    }\n    else\n    {\n\n        rb_tree_insert_case2(tree, node);\n    }\n}",
                        "rust_code": "pub fn rb_tree_insert_case1() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void rb_tree_insert_case2(RBTree *tree, RBTreeNode *node)\n{\n\n    if (node->parent->color != RB_TREE_NODE_BLACK)\n    {\n        rb_tree_insert_case3(tree, node);\n    }\n}",
                        "rust_code": "pub fn rb_tree_insert_case2() { unimplemented!(); }"
                    },
                    {
                        "c_code": "static void rb_tree_insert_case3(RBTree *tree, RBTreeNode *node)\n{\n    RBTreeNode *grandparent;\n    RBTreeNode *uncle;\n\n    grandparent = node->parent->parent;\n    uncle = rb_tree_node_uncle(node);\n\n    if (uncle != NULL && uncle->color == RB_TREE_NODE_RED)\n    {\n\n        node->parent->color = RB_TREE_NODE_BLACK;\n        uncle->color = RB_TREE_NODE_BLACK;\n        grandparent->color = RB_TREE_NODE_RED;\n\n        rb_tree_insert_case1(tree, grandparent);\n    }\n    else\n    {\n        rb_tree_insert_case4(tree, node);\n    }\n}",
                        "rust_code": "pub fn rb_tree_insert_case3() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void rb_tree_insert_case4(RBTree *tree, RBTreeNode *node)\n{\n    RBTreeNode *next_node;\n    RBTreeNodeSide side;\n\n    side = rb_tree_node_side(node);\n\n    if (side != rb_tree_node_side(node->parent))\n    {\n\n        next_node = node->parent;\n\n        rb_tree_rotate(tree, node->parent, 1 - side);\n    }\n    else\n    {\n        next_node = node;\n    }\n\n    rb_tree_insert_case5(tree, next_node);\n}",
                        "rust_code": "pub fn rb_tree_insert_case4() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void rb_tree_insert_case5(RBTree *tree, RBTreeNode *node)\n{\n    RBTreeNode *parent;\n    RBTreeNode *grandparent;\n    RBTreeNodeSide side;\n\n    parent = node->parent;\n    grandparent = parent->parent;\n\n    side = rb_tree_node_side(node);\n\n    rb_tree_rotate(tree, grandparent, 1 - side);\n\n    parent->color = RB_TREE_NODE_BLACK;\n    grandparent->color = RB_TREE_NODE_RED;\n}",
                        "rust_code": "pub fn rb_tree_insert_case5() { unimplemented!(); }"
                    },
                    {
                        "c_code": "RBTreeNode *rb_tree_insert(RBTree *tree, RBTreeKey key, RBTreeValue value)\n{\n    RBTreeNode *node;\n    RBTreeNode **rover;\n    RBTreeNode *parent;\n    RBTreeNodeSide side;\n\n    node = malloc(sizeof(RBTreeNode));\n\n    if (node == NULL)\n    {\n        return NULL;\n    }\n\n    node->key = key;\n    node->value = value;\n    node->color = RB_TREE_NODE_RED;\n    node->children[RB_TREE_NODE_LEFT] = NULL;\n    node->children[RB_TREE_NODE_RIGHT] = NULL;\n\n    parent = NULL;\n    rover = &tree->root_node;\n\n    while (*rover != NULL)\n    {\n\n        parent = *rover;\n\n        if (tree->compare_func(value, (*rover)->value) < 0)\n        {\n            side = RB_TREE_NODE_LEFT;\n        }\n        else\n        {\n            side = RB_TREE_NODE_RIGHT;\n        }\n\n        rover = &(*rover)->children[side];\n    }\n\n    *rover = node;\n    node->parent = parent;\n\n    rb_tree_insert_case1(tree, node);\n\n    ++tree->num_nodes;\n\n    return node;\n}",
                        "rust_code": "pub fn rb_tree_insert() { unimplemented!(); }"
                    },
                    {
                        "c_code": "RBTreeNode *rb_tree_lookup_node(RBTree *tree, RBTreeKey key)\n{\n    RBTreeNode *node;\n    RBTreeNodeSide side;\n    int diff;\n\n    node = tree->root_node;\n\n    while (node != NULL)\n    {\n        diff = tree->compare_func(key, node->key);\n\n        if (diff == 0)\n        {\n            return node;\n        }\n        else if (diff < 0)\n        {\n            side = RB_TREE_NODE_LEFT;\n        }\n        else\n        {\n            side = RB_TREE_NODE_RIGHT;\n        }\n\n        node = node->children[side];\n    }\n\n    return NULL;\n}",
                        "rust_code": "pub fn rb_tree_lookup_node() { unimplemented!(); }"
                    },
                    {
                        "c_code": "RBTreeValue rb_tree_lookup(RBTree *tree, RBTreeKey key)\n{\n    RBTreeNode *node;\n\n    node = rb_tree_lookup_node(tree, key);\n\n    if (node == NULL)\n    {\n        return RB_TREE_NULL;\n    }\n    else\n    {\n        return node->value;\n    }\n}",
                        "rust_code": "pub fn rb_tree_lookup() { unimplemented!(); }"
                    },
                    {
                        "c_code": "void rb_tree_remove_node(RBTree *tree, RBTreeNode *node)\n{\n}",
                        "rust_code": "pub fn rb_tree_remove_node() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int rb_tree_remove(RBTree *tree, RBTreeKey key)\n{\n    RBTreeNode *node;\n\n    node = rb_tree_lookup_node(tree, key);\n\n    if (node == NULL)\n    {\n        return 0;\n    }\n\n    rb_tree_remove_node(tree, node);\n\n    return 1;\n}",
                        "rust_code": "pub fn rb_tree_remove() { unimplemented!(); }"
                    },
                    {
                        "c_code": "RBTreeNode *rb_tree_root_node(RBTree *tree)\n{\n    return tree->root_node;\n}",
                        "rust_code": "pub fn rb_tree_root_node() { unimplemented!(); }"
                    },
                    {
                        "c_code": "RBTreeKey rb_tree_node_key(RBTreeNode *node)\n{\n    return node->key;\n}",
                        "rust_code": "pub fn rb_tree_node_key() { unimplemented!(); }"
                    },
                    {
                        "c_code": "RBTreeValue rb_tree_node_value(RBTreeNode *node)\n{\n    return node->value;\n}",
                        "rust_code": "pub fn rb_tree_node_value() { unimplemented!(); }"
                    },
                    {
                        "c_code": "RBTreeNode *rb_tree_node_child(RBTreeNode *node, RBTreeNodeSide side)\n{\n    if (side == RB_TREE_NODE_LEFT || side == RB_TREE_NODE_RIGHT)\n    {\n        return node->children[side];\n    }\n    else\n    {\n        return NULL;\n    }\n}",
                        "rust_code": "pub fn rb_tree_node_child() { unimplemented!(); }"
                    },
                    {
                        "c_code": "RBTreeNode *rb_tree_node_parent(RBTreeNode *node)\n{\n    return node->parent;\n}",
                        "rust_code": "pub fn rb_tree_node_parent() { unimplemented!(); }"
                    },
                    {
                        "c_code": "RBTreeValue *rb_tree_to_array(RBTree *tree)\n{\n\n    return NULL;\n}",
                        "rust_code": "pub fn rb_tree_to_array() { unimplemented!(); }"
                    },
                    {
                        "c_code": "int rb_tree_num_entries(RBTree *tree)\n{\n    return tree->num_nodes;\n}",
                        "rust_code": "pub fn rb_tree_num_entries() { unimplemented!(); }"
                    }
                ]
            },
            "mod.rs": {
                "name": "mod.rs",
                "type": "file",
                "declarations": [
                    "pub mod list_c;",
                    "pub mod sortedarray_c;",
                    "pub mod avl_tree_c;",
                    "pub mod bloom_filter_c;",
                    "pub mod compare_string_c;",
                    "pub mod hash_pointer_h;",
                    "pub mod compare_pointer_c;",
                    "pub mod hash_table_c;",
                    "pub mod compare_pointer_h;",
                    "pub mod set_c;",
                    "pub mod hash_int_h;",
                    "pub mod hash_string_h;",
                    "pub mod hash_int_c;",
                    "pub mod bloom_filter_h;",
                    "pub mod binary_heap_h;",
                    "pub mod trie_h;",
                    "pub mod slist_h;",
                    "pub mod avl_tree_h;",
                    "pub mod queue_c;",
                    "pub mod arraylist_h;",
                    "pub mod compare_int_h;",
                    "pub mod hash_table_h;",
                    "pub mod list_h;",
                    "pub mod compare_int_c;",
                    "pub mod rb_tree_h;",
                    "pub mod binary_heap_c;",
                    "pub mod binomial_heap_h;",
                    "pub mod sortedarray_h;",
                    "pub mod queue_h;",
                    "pub mod hash_pointer_c;",
                    "pub mod trie_c;",
                    "pub mod arraylist_c;",
                    "pub mod compare_string_h;",
                    "pub mod set_h;",
                    "pub mod binomial_heap_c;",
                    "pub mod slist_c;",
                    "pub mod hash_string_c;",
                    "pub mod rb_tree_c;"
                ],
                "definitions": [],
                "macros": [],
                "macro_functions": [],
                "functions": []
            }
        }
    },
    "lib.rs": {
        "name": "lib.rs",
        "type": "file",
        "declarations": [
            "pub(crate) mod translation_utils;",
            "pub(crate) mod src;"
        ],
        "definitions": [],
        "macros": [],
        "macro_functions": [],
        "functions": []
    }
}